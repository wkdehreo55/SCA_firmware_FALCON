   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"sign.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.fpr_ursh,"ax",%progbits
  16              		.align	1
  17              		.arch armv7e-m
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	fpr_ursh:
  24              	.LFB1:
  25              		.file 1 "fpr.h"
   1:fpr.h         **** /*
   2:fpr.h         ****  * Floating-point operations.
   3:fpr.h         ****  *
   4:fpr.h         ****  * ==========================(LICENSE BEGIN)============================
   5:fpr.h         ****  *
   6:fpr.h         ****  * Copyright (c) 2017-2019  Falcon Project
   7:fpr.h         ****  *
   8:fpr.h         ****  * Permission is hereby granted, free of charge, to any person obtaining
   9:fpr.h         ****  * a copy of this software and associated documentation files (the
  10:fpr.h         ****  * "Software"), to deal in the Software without restriction, including
  11:fpr.h         ****  * without limitation the rights to use, copy, modify, merge, publish,
  12:fpr.h         ****  * distribute, sublicense, and/or sell copies of the Software, and to
  13:fpr.h         ****  * permit persons to whom the Software is furnished to do so, subject to
  14:fpr.h         ****  * the following conditions:
  15:fpr.h         ****  *
  16:fpr.h         ****  * The above copyright notice and this permission notice shall be
  17:fpr.h         ****  * included in all copies or substantial portions of the Software.
  18:fpr.h         ****  *
  19:fpr.h         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  20:fpr.h         ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  21:fpr.h         ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  22:fpr.h         ****  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  23:fpr.h         ****  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  24:fpr.h         ****  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  25:fpr.h         ****  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  26:fpr.h         ****  *
  27:fpr.h         ****  * ===========================(LICENSE END)=============================
  28:fpr.h         ****  *
  29:fpr.h         ****  * @author   Thomas Pornin <thomas.pornin@nccgroup.com>
  30:fpr.h         ****  */
  31:fpr.h         **** 
  32:fpr.h         **** 
  33:fpr.h         **** /* ====================================================================== */
  34:fpr.h         **** /*
  35:fpr.h         ****  * Custom floating-point implementation with integer arithmetics. We
  36:fpr.h         ****  * use IEEE-754 "binary64" format, with some simplifications:
  37:fpr.h         ****  *
  38:fpr.h         ****  *   - Top bit is s = 1 for negative, 0 for positive.
  39:fpr.h         ****  *
  40:fpr.h         ****  *   - Exponent e uses the next 11 bits (bits 52 to 62, inclusive).
  41:fpr.h         ****  *
  42:fpr.h         ****  *   - Mantissa m uses the 52 low bits.
  43:fpr.h         ****  *
  44:fpr.h         ****  * Encoded value is, in general: (-1)^s * 2^(e-1023) * (1 + m*2^(-52))
  45:fpr.h         ****  * i.e. the mantissa really is a 53-bit number (less than 2.0, but not
  46:fpr.h         ****  * less than 1.0), but the top bit (equal to 1 by definition) is omitted
  47:fpr.h         ****  * in the encoding.
  48:fpr.h         ****  *
  49:fpr.h         ****  * In IEEE-754, there are some special values:
  50:fpr.h         ****  *
  51:fpr.h         ****  *   - If e = 2047, then the value is either an infinite (m = 0) or
  52:fpr.h         ****  *     a NaN (m != 0).
  53:fpr.h         ****  *
  54:fpr.h         ****  *   - If e = 0, then the value is either a zero (m = 0) or a subnormal,
  55:fpr.h         ****  *     aka "denormalized number" (m != 0).
  56:fpr.h         ****  *
  57:fpr.h         ****  * Of these, we only need the zeros. The caller is responsible for not
  58:fpr.h         ****  * providing operands that would lead to infinites, NaNs or subnormals.
  59:fpr.h         ****  * If inputs are such that values go out of range, then indeterminate
  60:fpr.h         ****  * values are returned (it would still be deterministic, but no specific
  61:fpr.h         ****  * value may be relied upon).
  62:fpr.h         ****  *
  63:fpr.h         ****  * At the C level, the three parts are stored in a 64-bit unsigned
  64:fpr.h         ****  * word.
  65:fpr.h         ****  *
  66:fpr.h         ****  * One may note that a property of the IEEE-754 format is that order
  67:fpr.h         ****  * is preserved for positive values: if two positive floating-point
  68:fpr.h         ****  * values x and y are such that x < y, then their respective encodings
  69:fpr.h         ****  * as _signed_ 64-bit integers i64(x) and i64(y) will be such that
  70:fpr.h         ****  * i64(x) < i64(y). For negative values, order is reversed: if x < 0,
  71:fpr.h         ****  * y < 0, and x < y, then ia64(x) > ia64(y).
  72:fpr.h         ****  *
  73:fpr.h         ****  * IMPORTANT ASSUMPTIONS:
  74:fpr.h         ****  * ======================
  75:fpr.h         ****  *
  76:fpr.h         ****  * For proper computations, and constant-time behaviour, we assume the
  77:fpr.h         ****  * following:
  78:fpr.h         ****  *
  79:fpr.h         ****  *   - 32x32->64 multiplication (unsigned) has an execution time that
  80:fpr.h         ****  *     is independent of its operands. This is true of most modern
  81:fpr.h         ****  *     x86 and ARM cores. Notable exceptions are the ARM Cortex M0, M0+
  82:fpr.h         ****  *     and M3 (in the M0 and M0+, this is done in software, so it depends
  83:fpr.h         ****  *     on that routine), and the PowerPC cores from the G3/G4 lines.
  84:fpr.h         ****  *     For more info, see: https://www.bearssl.org/ctmul.html
  85:fpr.h         ****  *
  86:fpr.h         ****  *   - Left-shifts and right-shifts of 32-bit values have an execution
  87:fpr.h         ****  *     time which does not depend on the shifted value nor on the
  88:fpr.h         ****  *     shift count. An historical exception is the Pentium IV, but most
  89:fpr.h         ****  *     modern CPU have barrel shifters. Some small microcontrollers
  90:fpr.h         ****  *     might have varying-time shifts (not the ARM Cortex M*, though).
  91:fpr.h         ****  *
  92:fpr.h         ****  *   - Right-shift of a signed negative value performs a sign extension.
  93:fpr.h         ****  *     As per the C standard, this operation returns an
  94:fpr.h         ****  *     implementation-defined result (this is NOT an "undefined
  95:fpr.h         ****  *     behaviour"). On most/all systems, an arithmetic shift is
  96:fpr.h         ****  *     performed, because this is what makes most sense.
  97:fpr.h         ****  */
  98:fpr.h         **** 
  99:fpr.h         **** /*
 100:fpr.h         ****  * Normally we should declare the 'fpr' type to be a struct or union
 101:fpr.h         ****  * around the internal 64-bit value; however, we want to use the
 102:fpr.h         ****  * direct 64-bit integer type to enable a lighter call convention on
 103:fpr.h         ****  * ARM platforms. This means that direct (invalid) use of operators
 104:fpr.h         ****  * such as '*' or '+' will not be caught by the compiler. We rely on
 105:fpr.h         ****  * the "normal" (non-emulated) code to detect such instances.
 106:fpr.h         ****  */
 107:fpr.h         **** typedef uint64_t fpr;
 108:fpr.h         **** 
 109:fpr.h         **** /*
 110:fpr.h         ****  * For computations, we split values into an integral mantissa in the
 111:fpr.h         ****  * 2^54..2^55 range, and an (adjusted) exponent. The lowest bit is
 112:fpr.h         ****  * "sticky" (it is set to 1 if any of the bits below it is 1); when
 113:fpr.h         ****  * re-encoding, the low two bits are dropped, but may induce an
 114:fpr.h         ****  * increment in the value for proper rounding.
 115:fpr.h         ****  */
 116:fpr.h         **** 
 117:fpr.h         **** /*
 118:fpr.h         ****  * Right-shift a 64-bit unsigned value by a possibly secret shift count.
 119:fpr.h         ****  * We assumed that the underlying architecture had a barrel shifter for
 120:fpr.h         ****  * 32-bit shifts, but for 64-bit shifts on a 32-bit system, this will
 121:fpr.h         ****  * typically invoke a software routine that is not necessarily
 122:fpr.h         ****  * constant-time; hence the function below.
 123:fpr.h         ****  *
 124:fpr.h         ****  * Shift count n MUST be in the 0..63 range.
 125:fpr.h         ****  */
 126:fpr.h         **** static inline uint64_t
 127:fpr.h         **** fpr_ursh(uint64_t x, int n)
 128:fpr.h         **** {
  26              		.loc 1 128 1
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 40
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 2DE9B00F 		push	{r4, r5, r7, r8, r9, r10, fp}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 28
  34              		.cfi_offset 4, -28
  35              		.cfi_offset 5, -24
  36              		.cfi_offset 7, -20
  37              		.cfi_offset 8, -16
  38              		.cfi_offset 9, -12
  39              		.cfi_offset 10, -8
  40              		.cfi_offset 11, -4
  41 0004 8BB0     		sub	sp, sp, #44
  42              	.LCFI1:
  43              		.cfi_def_cfa_offset 72
  44 0006 00AF     		add	r7, sp, #0
  45              	.LCFI2:
  46              		.cfi_def_cfa_register 7
  47 0008 C7E90801 		strd	r0, [r7, #32]
  48 000c FA61     		str	r2, [r7, #28]
 129:fpr.h         **** 	x ^= (x ^ (x >> 32)) & -(uint64_t)(n >> 5);
  49              		.loc 1 129 15
  50 000e D7E90823 		ldrd	r2, [r7, #32]
  51 0012 4FF00000 		mov	r0, #0
  52 0016 4FF00001 		mov	r1, #0
  53 001a 1800     		movs	r0, r3
  54 001c 0021     		movs	r1, #0
  55              		.loc 1 129 10
  56 001e D7E90823 		ldrd	r2, [r7, #32]
  57 0022 80EA020C 		eor	ip, r0, r2
  58 0026 C7F810C0 		str	ip, [r7, #16]
  59 002a 4B40     		eors	r3, r3, r1
  60 002c 7B61     		str	r3, [r7, #20]
  61              		.loc 1 129 39
  62 002e FB69     		ldr	r3, [r7, #28]
  63 0030 5B11     		asrs	r3, r3, #5
  64              		.loc 1 129 26
  65 0032 DA17     		asrs	r2, r3, #31
  66 0034 BB60     		str	r3, [r7, #8]
  67 0036 FA60     		str	r2, [r7, #12]
  68              		.loc 1 129 25
  69 0038 0023     		movs	r3, #0
  70 003a D7E90212 		ldrd	r1, [r7, #8]
  71 003e 0846     		mov	r0, r1
  72 0040 D0F1000A 		rsbs	r10, r0, #0
  73 0044 63EB020B 		sbc	fp, r3, r2
  74              		.loc 1 129 23
  75 0048 D7E90423 		ldrd	r2, [r7, #16]
  76 004c 1146     		mov	r1, r2
  77 004e 01EA0A04 		and	r4, r1, r10
  78 0052 03EA0B05 		and	r5, r3, fp
  79              		.loc 1 129 4
  80 0056 D7E90823 		ldrd	r2, [r7, #32]
  81 005a 82EA0401 		eor	r1, r2, r4
  82 005e 3960     		str	r1, [r7]
  83 0060 6B40     		eors	r3, r3, r5
  84 0062 7B60     		str	r3, [r7, #4]
  85 0064 D7E90034 		ldrd	r3, [r7]
  86 0068 C7E90834 		strd	r3, [r7, #32]
 130:fpr.h         **** 	return x >> (n & 31);
  87              		.loc 1 130 17
  88 006c FB69     		ldr	r3, [r7, #28]
  89 006e 03F01F01 		and	r1, r3, #31
  90              		.loc 1 130 11
  91 0072 D7E90823 		ldrd	r2, [r7, #32]
  92 0076 C1F12004 		rsb	r4, r1, #32
  93 007a A1F12000 		sub	r0, r1, #32
  94 007e 22FA01F8 		lsr	r8, r2, r1
  95 0082 03FA04F4 		lsl	r4, r3, r4
  96 0086 48EA0408 		orr	r8, r8, r4
  97 008a 23FA00F0 		lsr	r0, r3, r0
  98 008e 48EA0008 		orr	r8, r8, r0
  99 0092 23FA01F9 		lsr	r9, r3, r1
 100 0096 4246     		mov	r2, r8
 101 0098 4B46     		mov	r3, r9
 131:fpr.h         **** }
 102              		.loc 1 131 1
 103 009a 1046     		mov	r0, r2
 104 009c 1946     		mov	r1, r3
 105 009e 2C37     		adds	r7, r7, #44
 106              	.LCFI3:
 107              		.cfi_def_cfa_offset 28
 108 00a0 BD46     		mov	sp, r7
 109              	.LCFI4:
 110              		.cfi_def_cfa_register 13
 111              		@ sp needed
 112 00a2 BDE8B00F 		pop	{r4, r5, r7, r8, r9, r10, fp}
 113              	.LCFI5:
 114              		.cfi_restore 11
 115              		.cfi_restore 10
 116              		.cfi_restore 9
 117              		.cfi_restore 8
 118              		.cfi_restore 7
 119              		.cfi_restore 5
 120              		.cfi_restore 4
 121              		.cfi_def_cfa_offset 0
 122 00a6 7047     		bx	lr
 123              		.cfi_endproc
 124              	.LFE1:
 126              		.section	.text.fpr_irsh,"ax",%progbits
 127              		.align	1
 128              		.syntax unified
 129              		.thumb
 130              		.thumb_func
 131              		.fpu softvfp
 133              	fpr_irsh:
 134              	.LFB2:
 132:fpr.h         **** 
 133:fpr.h         **** /*
 134:fpr.h         ****  * Right-shift a 64-bit signed value by a possibly secret shift count
 135:fpr.h         ****  * (see fpr_ursh() for the rationale).
 136:fpr.h         ****  *
 137:fpr.h         ****  * Shift count n MUST be in the 0..63 range.
 138:fpr.h         ****  */
 139:fpr.h         **** static inline int64_t
 140:fpr.h         **** fpr_irsh(int64_t x, int n)
 141:fpr.h         **** {
 135              		.loc 1 141 1
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 40
 138              		@ frame_needed = 1, uses_anonymous_args = 0
 139              		@ link register save eliminated.
 140 0000 2DE9B00F 		push	{r4, r5, r7, r8, r9, r10, fp}
 141              	.LCFI6:
 142              		.cfi_def_cfa_offset 28
 143              		.cfi_offset 4, -28
 144              		.cfi_offset 5, -24
 145              		.cfi_offset 7, -20
 146              		.cfi_offset 8, -16
 147              		.cfi_offset 9, -12
 148              		.cfi_offset 10, -8
 149              		.cfi_offset 11, -4
 150 0004 8BB0     		sub	sp, sp, #44
 151              	.LCFI7:
 152              		.cfi_def_cfa_offset 72
 153 0006 00AF     		add	r7, sp, #0
 154              	.LCFI8:
 155              		.cfi_def_cfa_register 7
 156 0008 C7E90801 		strd	r0, [r7, #32]
 157 000c FA61     		str	r2, [r7, #28]
 142:fpr.h         **** 	x ^= (x ^ (x >> 32)) & -(int64_t)(n >> 5);
 158              		.loc 1 142 15
 159 000e D7E90823 		ldrd	r2, [r7, #32]
 160 0012 4FF00000 		mov	r0, #0
 161 0016 4FF00001 		mov	r1, #0
 162 001a 1800     		movs	r0, r3
 163 001c D917     		asrs	r1, r3, #31
 164              		.loc 1 142 10
 165 001e D7E90823 		ldrd	r2, [r7, #32]
 166 0022 80EA020C 		eor	ip, r0, r2
 167 0026 C7F810C0 		str	ip, [r7, #16]
 168 002a 4B40     		eors	r3, r3, r1
 169 002c 7B61     		str	r3, [r7, #20]
 170              		.loc 1 142 38
 171 002e FB69     		ldr	r3, [r7, #28]
 172 0030 5B11     		asrs	r3, r3, #5
 173              		.loc 1 142 26
 174 0032 DA17     		asrs	r2, r3, #31
 175 0034 BB60     		str	r3, [r7, #8]
 176 0036 FA60     		str	r2, [r7, #12]
 177              		.loc 1 142 25
 178 0038 0023     		movs	r3, #0
 179 003a D7E90212 		ldrd	r1, [r7, #8]
 180 003e 0846     		mov	r0, r1
 181 0040 D0F1000A 		rsbs	r10, r0, #0
 182 0044 63EB020B 		sbc	fp, r3, r2
 183              		.loc 1 142 23
 184 0048 D7E90423 		ldrd	r2, [r7, #16]
 185 004c 1146     		mov	r1, r2
 186 004e 01EA0A04 		and	r4, r1, r10
 187 0052 03EA0B05 		and	r5, r3, fp
 188              		.loc 1 142 4
 189 0056 D7E90823 		ldrd	r2, [r7, #32]
 190 005a 82EA0401 		eor	r1, r2, r4
 191 005e 3960     		str	r1, [r7]
 192 0060 6B40     		eors	r3, r3, r5
 193 0062 7B60     		str	r3, [r7, #4]
 194 0064 D7E90034 		ldrd	r3, [r7]
 195 0068 C7E90834 		strd	r3, [r7, #32]
 143:fpr.h         **** 	return x >> (n & 31);
 196              		.loc 1 143 17
 197 006c FB69     		ldr	r3, [r7, #28]
 198 006e 03F01F01 		and	r1, r3, #31
 199              		.loc 1 143 11
 200 0072 D7E90823 		ldrd	r2, [r7, #32]
 201 0076 C1F12004 		rsb	r4, r1, #32
 202 007a B1F12000 		subs	r0, r1, #32
 203 007e 22FA01F8 		lsr	r8, r2, r1
 204 0082 03FA04F4 		lsl	r4, r3, r4
 205 0086 48EA0408 		orr	r8, r8, r4
 206 008a 03D4     		bmi	.L4
 207 008c 43FA00F0 		asr	r0, r3, r0
 208 0090 48EA0008 		orr	r8, r8, r0
 209              	.L4:
 210 0094 43FA01F9 		asr	r9, r3, r1
 211 0098 4246     		mov	r2, r8
 212 009a 4B46     		mov	r3, r9
 144:fpr.h         **** }
 213              		.loc 1 144 1
 214 009c 1046     		mov	r0, r2
 215 009e 1946     		mov	r1, r3
 216 00a0 2C37     		adds	r7, r7, #44
 217              	.LCFI9:
 218              		.cfi_def_cfa_offset 28
 219 00a2 BD46     		mov	sp, r7
 220              	.LCFI10:
 221              		.cfi_def_cfa_register 13
 222              		@ sp needed
 223 00a4 BDE8B00F 		pop	{r4, r5, r7, r8, r9, r10, fp}
 224              	.LCFI11:
 225              		.cfi_restore 11
 226              		.cfi_restore 10
 227              		.cfi_restore 9
 228              		.cfi_restore 8
 229              		.cfi_restore 7
 230              		.cfi_restore 5
 231              		.cfi_restore 4
 232              		.cfi_def_cfa_offset 0
 233 00a8 7047     		bx	lr
 234              		.cfi_endproc
 235              	.LFE2:
 237              		.section	.text.fpr_ulsh,"ax",%progbits
 238              		.align	1
 239              		.syntax unified
 240              		.thumb
 241              		.thumb_func
 242              		.fpu softvfp
 244              	fpr_ulsh:
 245              	.LFB3:
 145:fpr.h         **** 
 146:fpr.h         **** /*
 147:fpr.h         ****  * Left-shift a 64-bit unsigned value by a possibly secret shift count
 148:fpr.h         ****  * (see fpr_ursh() for the rationale).
 149:fpr.h         ****  *
 150:fpr.h         ****  * Shift count n MUST be in the 0..63 range.
 151:fpr.h         ****  */
 152:fpr.h         **** static inline uint64_t
 153:fpr.h         **** fpr_ulsh(uint64_t x, int n)
 154:fpr.h         **** {
 246              		.loc 1 154 1
 247              		.cfi_startproc
 248              		@ args = 0, pretend = 0, frame = 40
 249              		@ frame_needed = 1, uses_anonymous_args = 0
 250              		@ link register save eliminated.
 251 0000 2DE9B00F 		push	{r4, r5, r7, r8, r9, r10, fp}
 252              	.LCFI12:
 253              		.cfi_def_cfa_offset 28
 254              		.cfi_offset 4, -28
 255              		.cfi_offset 5, -24
 256              		.cfi_offset 7, -20
 257              		.cfi_offset 8, -16
 258              		.cfi_offset 9, -12
 259              		.cfi_offset 10, -8
 260              		.cfi_offset 11, -4
 261 0004 8BB0     		sub	sp, sp, #44
 262              	.LCFI13:
 263              		.cfi_def_cfa_offset 72
 264 0006 00AF     		add	r7, sp, #0
 265              	.LCFI14:
 266              		.cfi_def_cfa_register 7
 267 0008 C7E90801 		strd	r0, [r7, #32]
 268 000c FA61     		str	r2, [r7, #28]
 155:fpr.h         **** 	x ^= (x ^ (x << 32)) & -(uint64_t)(n >> 5);
 269              		.loc 1 155 15
 270 000e D7E90823 		ldrd	r2, [r7, #32]
 271 0012 4FF00000 		mov	r0, #0
 272 0016 4FF00001 		mov	r1, #0
 273 001a 1100     		movs	r1, r2
 274 001c 0020     		movs	r0, #0
 275              		.loc 1 155 10
 276 001e D7E90823 		ldrd	r2, [r7, #32]
 277 0022 80EA020C 		eor	ip, r0, r2
 278 0026 C7F810C0 		str	ip, [r7, #16]
 279 002a 4B40     		eors	r3, r3, r1
 280 002c 7B61     		str	r3, [r7, #20]
 281              		.loc 1 155 39
 282 002e FB69     		ldr	r3, [r7, #28]
 283 0030 5B11     		asrs	r3, r3, #5
 284              		.loc 1 155 26
 285 0032 DA17     		asrs	r2, r3, #31
 286 0034 BB60     		str	r3, [r7, #8]
 287 0036 FA60     		str	r2, [r7, #12]
 288              		.loc 1 155 25
 289 0038 0023     		movs	r3, #0
 290 003a D7E90212 		ldrd	r1, [r7, #8]
 291 003e 0846     		mov	r0, r1
 292 0040 D0F1000A 		rsbs	r10, r0, #0
 293 0044 63EB020B 		sbc	fp, r3, r2
 294              		.loc 1 155 23
 295 0048 D7E90423 		ldrd	r2, [r7, #16]
 296 004c 1146     		mov	r1, r2
 297 004e 01EA0A04 		and	r4, r1, r10
 298 0052 03EA0B05 		and	r5, r3, fp
 299              		.loc 1 155 4
 300 0056 D7E90823 		ldrd	r2, [r7, #32]
 301 005a 82EA0401 		eor	r1, r2, r4
 302 005e 3960     		str	r1, [r7]
 303 0060 6B40     		eors	r3, r3, r5
 304 0062 7B60     		str	r3, [r7, #4]
 305 0064 D7E90034 		ldrd	r3, [r7]
 306 0068 C7E90834 		strd	r3, [r7, #32]
 156:fpr.h         **** 	return x << (n & 31);
 307              		.loc 1 156 17
 308 006c FB69     		ldr	r3, [r7, #28]
 309 006e 03F01F01 		and	r1, r3, #31
 310              		.loc 1 156 11
 311 0072 D7E90823 		ldrd	r2, [r7, #32]
 312 0076 A1F12004 		sub	r4, r1, #32
 313 007a C1F12000 		rsb	r0, r1, #32
 314 007e 03FA01F9 		lsl	r9, r3, r1
 315 0082 02FA04F4 		lsl	r4, r2, r4
 316 0086 49EA0409 		orr	r9, r9, r4
 317 008a 22FA00F0 		lsr	r0, r2, r0
 318 008e 49EA0009 		orr	r9, r9, r0
 319 0092 02FA01F8 		lsl	r8, r2, r1
 320 0096 4246     		mov	r2, r8
 321 0098 4B46     		mov	r3, r9
 157:fpr.h         **** }
 322              		.loc 1 157 1
 323 009a 1046     		mov	r0, r2
 324 009c 1946     		mov	r1, r3
 325 009e 2C37     		adds	r7, r7, #44
 326              	.LCFI15:
 327              		.cfi_def_cfa_offset 28
 328 00a0 BD46     		mov	sp, r7
 329              	.LCFI16:
 330              		.cfi_def_cfa_register 13
 331              		@ sp needed
 332 00a2 BDE8B00F 		pop	{r4, r5, r7, r8, r9, r10, fp}
 333              	.LCFI17:
 334              		.cfi_restore 11
 335              		.cfi_restore 10
 336              		.cfi_restore 9
 337              		.cfi_restore 8
 338              		.cfi_restore 7
 339              		.cfi_restore 5
 340              		.cfi_restore 4
 341              		.cfi_def_cfa_offset 0
 342 00a6 7047     		bx	lr
 343              		.cfi_endproc
 344              	.LFE3:
 346              		.section	.text.fpr_of,"ax",%progbits
 347              		.align	1
 348              		.syntax unified
 349              		.thumb
 350              		.thumb_func
 351              		.fpu softvfp
 353              	fpr_of:
 354              	.LFB5:
 158:fpr.h         **** 
 159:fpr.h         **** /*
 160:fpr.h         ****  * Expectations:
 161:fpr.h         ****  *   s = 0 or 1
 162:fpr.h         ****  *   exponent e is "arbitrary" and unbiased
 163:fpr.h         ****  *   2^54 <= m < 2^55
 164:fpr.h         ****  * Numerical value is (-1)^2 * m * 2^e
 165:fpr.h         ****  *
 166:fpr.h         ****  * Exponents which are too low lead to value zero. If the exponent is
 167:fpr.h         ****  * too large, the returned value is indeterminate.
 168:fpr.h         ****  *
 169:fpr.h         ****  * If m = 0, then a zero is returned (using the provided sign).
 170:fpr.h         ****  * If e < -1076, then a zero is returned (regardless of the value of m).
 171:fpr.h         ****  * If e >= -1076 and e != 0, m must be within the expected range
 172:fpr.h         ****  * (2^54 to 2^55-1).
 173:fpr.h         ****  */
 174:fpr.h         **** 
 175:fpr.h         **** static inline fpr
 176:fpr.h         **** FPR(int s, int e, uint64_t m)
 177:fpr.h         **** {
 178:fpr.h         **** 	fpr x;
 179:fpr.h         **** 	uint32_t t;
 180:fpr.h         **** 	unsigned f;
 181:fpr.h         **** 
 182:fpr.h         **** 	/*
 183:fpr.h         **** 	 * If e >= -1076, then the value is "normal"; otherwise, it
 184:fpr.h         **** 	 * should be a subnormal, which we clamp down to zero.
 185:fpr.h         **** 	 */
 186:fpr.h         **** 	e += 1076;
 187:fpr.h         **** 	t = (uint32_t)e >> 31;
 188:fpr.h         **** 	m &= (uint64_t)t - 1;
 189:fpr.h         **** 
 190:fpr.h         **** 	/*
 191:fpr.h         **** 	 * If m = 0 then we want a zero; make e = 0 too, but conserve
 192:fpr.h         **** 	 * the sign.
 193:fpr.h         **** 	 */
 194:fpr.h         **** 	t = (uint32_t)(m >> 54);
 195:fpr.h         **** 	e &= -(int)t;
 196:fpr.h         **** 
 197:fpr.h         **** 	/*
 198:fpr.h         **** 	 * The 52 mantissa bits come from m. Value m has its top bit set
 199:fpr.h         **** 	 * (unless it is a zero); we leave it "as is": the top bit will
 200:fpr.h         **** 	 * increment the exponent by 1, except when m = 0, which is
 201:fpr.h         **** 	 * exactly what we want.
 202:fpr.h         **** 	 */
 203:fpr.h         **** 	x = (((uint64_t)s << 63) | (m >> 2)) + ((uint64_t)(uint32_t)e << 52);
 204:fpr.h         **** 
 205:fpr.h         **** 	/*
 206:fpr.h         **** 	 * Rounding: if the low three bits of m are 011, 110 or 111,
 207:fpr.h         **** 	 * then the value should be incremented to get the next
 208:fpr.h         **** 	 * representable value. This implements the usual
 209:fpr.h         **** 	 * round-to-nearest rule (with preference to even values in case
 210:fpr.h         **** 	 * of a tie). Note that the increment may make a carry spill
 211:fpr.h         **** 	 * into the exponent field, which is again exactly what we want
 212:fpr.h         **** 	 * in that case.
 213:fpr.h         **** 	 */
 214:fpr.h         **** 	f = (unsigned)m & 7U;
 215:fpr.h         **** 	x += (0xC8U >> f) & 1;
 216:fpr.h         **** 	return x;
 217:fpr.h         **** }
 218:fpr.h         **** 
 219:fpr.h         **** #define fpr_scaled   Zf(fpr_scaled)
 220:fpr.h         **** fpr fpr_scaled(int64_t i, int sc);
 221:fpr.h         **** 
 222:fpr.h         **** static inline fpr
 223:fpr.h         **** fpr_of(int64_t i)
 224:fpr.h         **** {
 355              		.loc 1 224 1
 356              		.cfi_startproc
 357              		@ args = 0, pretend = 0, frame = 8
 358              		@ frame_needed = 1, uses_anonymous_args = 0
 359 0000 80B5     		push	{r7, lr}
 360              	.LCFI18:
 361              		.cfi_def_cfa_offset 8
 362              		.cfi_offset 7, -8
 363              		.cfi_offset 14, -4
 364 0002 82B0     		sub	sp, sp, #8
 365              	.LCFI19:
 366              		.cfi_def_cfa_offset 16
 367 0004 00AF     		add	r7, sp, #0
 368              	.LCFI20:
 369              		.cfi_def_cfa_register 7
 370 0006 C7E90001 		strd	r0, [r7]
 225:fpr.h         **** 	return fpr_scaled(i, 0);
 371              		.loc 1 225 9
 372 000a 0022     		movs	r2, #0
 373 000c D7E90001 		ldrd	r0, [r7]
 374 0010 FFF7FEFF 		bl	falcon_inner_fpr_scaled
 375 0014 0246     		mov	r2, r0
 376 0016 0B46     		mov	r3, r1
 226:fpr.h         **** }
 377              		.loc 1 226 1
 378 0018 1046     		mov	r0, r2
 379 001a 1946     		mov	r1, r3
 380 001c 0837     		adds	r7, r7, #8
 381              	.LCFI21:
 382              		.cfi_def_cfa_offset 8
 383 001e BD46     		mov	sp, r7
 384              	.LCFI22:
 385              		.cfi_def_cfa_register 13
 386              		@ sp needed
 387 0020 80BD     		pop	{r7, pc}
 388              		.cfi_endproc
 389              	.LFE5:
 391              		.section	.rodata
 392              		.align	3
 395              	fpr_q:
 396 0000 00000000 		.word	0
 397 0004 8000C840 		.word	1086849152
 398              		.align	3
 401              	fpr_inverse_of_q:
 402 0008 82A79790 		.word	-1869109374
 403 000c E354153F 		.word	1058362595
 404              		.align	3
 407              	fpr_inv_2sqrsigma0:
 408 0010 C2BB83C1 		.word	-1048331326
 409 0014 8B4FC33F 		.word	1069764491
 410              		.align	3
 413              	fpr_inv_sigma:
 414 0018 00000000 		.word	0
 415 001c 00000000 		.word	0
 416 0020 9A16247E 		.word	2116294298
 417 0024 EB487C3F 		.word	1065109739
 418 0028 D9AE8C54 		.word	1418505945
 419 002c 0AE57B3F 		.word	1065084170
 420 0030 2C769EE0 		.word	-526485972
 421 0034 2E857B3F 		.word	1065059630
 422 0038 36DACAD3 		.word	-741680586
 423 003c 5EFC7A3F 		.word	1065024606
 424 0040 EDB37609 		.word	158774253
 425 0044 3B7B7A3F 		.word	1064991547
 426 0048 989CCA82 		.word	-2100650856
 427 004c 12017A3F 		.word	1064960274
 428 0050 36275FCE 		.word	-832624842
 429 0054 498D793F 		.word	1064930633
 430 0058 EED96EC5 		.word	-982590994
 431 005c 571F793F 		.word	1064902487
 432 0060 CAC764DE 		.word	-563820598
 433 0064 C2B6783F 		.word	1064875714
 434 0068 E31A31F6 		.word	-164554013
 435 006c 1E53783F 		.word	1064850206
 436              		.align	3
 439              	fpr_sigma_min:
 440 0070 00000000 		.word	0
 441 0074 00000000 		.word	0
 442 0078 8B564406 		.word	105141899
 443 007c 38DDF13F 		.word	1072815416
 444 0080 2686ADDC 		.word	-592607706
 445 0084 2E1DF23F 		.word	1072831790
 446 0088 7A7CAAE1 		.word	-508920710
 447 008c 465CF23F 		.word	1072847942
 448 0090 25FB4A57 		.word	1464531749
 449 0094 5CB9F23F 		.word	1072871772
 450 0098 B622FEC7 		.word	-939646282
 451 009c AB14F33F 		.word	1072895147
 452 00a0 C3D77534 		.word	880138179
 453 00a4 4E6EF33F 		.word	1072918094
 454 00a8 24C2A166 		.word	1721877028
 455 00ac 5AC6F33F 		.word	1072940634
 456 00b0 A0B38C35 		.word	898413472
 457 00b4 E51CF43F 		.word	1072962789
 458 00b8 757A1FBF 		.word	-1088456075
 459 00bc 0172F43F 		.word	1072984577
 460 00c0 64C79099 		.word	-1718565020
 461 00c4 C1C5F43F 		.word	1073006017
 462              		.align	3
 465              	fpr_log2:
 466 00c8 EF39FAFE 		.word	-17155601
 467 00cc 422EE63F 		.word	1072049730
 468              		.align	3
 471              	fpr_inv_log2:
 472 00d0 FE822B65 		.word	1697350398
 473 00d4 4715F73F 		.word	1073157447
 474              		.align	3
 477              	fpr_bnorm_max:
 478 00d8 ACADD85F 		.word	1608035756
 479 00dc 9A6DD040 		.word	1087401370
 480              		.align	3
 483              	fpr_zero:
 484 00e0 00000000 		.space	8
 484      00000000 
 485              		.align	3
 488              	fpr_one:
 489 00e8 00000000 		.word	0
 490 00ec 0000F03F 		.word	1072693248
 491              		.align	3
 494              	fpr_two:
 495 00f0 00000000 		.word	0
 496 00f4 00000040 		.word	1073741824
 497              		.align	3
 500              	fpr_onehalf:
 501 00f8 00000000 		.word	0
 502 00fc 0000E03F 		.word	1071644672
 503              		.align	3
 506              	fpr_invsqrt2:
 507 0100 CD3B7F66 		.word	1719614413
 508 0104 9EA0E63F 		.word	1072079006
 509              		.align	3
 512              	fpr_invsqrt8:
 513 0108 CD3B7F66 		.word	1719614413
 514 010c 9EA0D63F 		.word	1071030430
 515              		.align	3
 518              	fpr_ptwo31:
 519 0110 00000000 		.word	0
 520 0114 0000E041 		.word	1105199104
 521              		.align	3
 524              	fpr_ptwo31m1:
 525 0118 0000C0FF 		.word	-4194304
 526 011c FFFFDF41 		.word	1105199103
 527              		.align	3
 530              	fpr_mtwo31m1:
 531 0120 0000C0FF 		.word	-4194304
 532 0124 FFFFDFC1 		.word	-1042284545
 533              		.align	3
 536              	fpr_ptwo63m1:
 537 0128 00000000 		.word	0
 538 012c 0000E043 		.word	1138753536
 539              		.align	3
 542              	fpr_mtwo63m1:
 543 0130 00000000 		.word	0
 544 0134 0000E0C3 		.word	-1008730112
 545              		.align	3
 548              	fpr_ptwo63:
 549 0138 00000000 		.word	0
 550 013c 0000E043 		.word	1138753536
 551              		.section	.text.fpr_rint,"ax",%progbits
 552              		.align	1
 553              		.syntax unified
 554              		.thumb
 555              		.thumb_func
 556              		.fpu softvfp
 558              	fpr_rint:
 559              	.LFB6:
 227:fpr.h         **** 
 228:fpr.h         **** static const fpr fpr_q = 4667981563525332992;
 229:fpr.h         **** static const fpr fpr_inverse_of_q = 4545632735260551042;
 230:fpr.h         **** static const fpr fpr_inv_2sqrsigma0 = 4594603506513722306;
 231:fpr.h         **** static const fpr fpr_inv_sigma[] = {
 232:fpr.h         **** 	0,  /* unused */
 233:fpr.h         **** 	4574611497772390042,
 234:fpr.h         **** 	4574501679055810265,
 235:fpr.h         **** 	4574396282908341804,
 236:fpr.h         **** 	4574245855758572086,
 237:fpr.h         **** 	4574103865040221165,
 238:fpr.h         **** 	4573969550563515544,
 239:fpr.h         **** 	4573842244705920822,
 240:fpr.h         **** 	4573721358406441454,
 241:fpr.h         **** 	4573606369665796042,
 242:fpr.h         **** 	4573496814039276259
 243:fpr.h         **** };
 244:fpr.h         **** static const fpr fpr_sigma_min[] = {
 245:fpr.h         **** 	0,  /* unused */
 246:fpr.h         **** 	4607707126469777035,
 247:fpr.h         **** 	4607777455861499430,
 248:fpr.h         **** 	4607846828256951418,
 249:fpr.h         **** 	4607949175006100261,
 250:fpr.h         **** 	4608049571757433526,
 251:fpr.h         **** 	4608148125896792003,
 252:fpr.h         **** 	4608244935301382692,
 253:fpr.h         **** 	4608340089478362016,
 254:fpr.h         **** 	4608433670533905013,
 255:fpr.h         **** 	4608525754002622308
 256:fpr.h         **** };
 257:fpr.h         **** static const fpr fpr_log2 = 4604418534313441775;
 258:fpr.h         **** static const fpr fpr_inv_log2 = 4609176140021203710;
 259:fpr.h         **** static const fpr fpr_bnorm_max = 4670353323383631276;
 260:fpr.h         **** static const fpr fpr_zero = 0;
 261:fpr.h         **** static const fpr fpr_one = 4607182418800017408;
 262:fpr.h         **** static const fpr fpr_two = 4611686018427387904;
 263:fpr.h         **** static const fpr fpr_onehalf = 4602678819172646912;
 264:fpr.h         **** static const fpr fpr_invsqrt2 = 4604544271217802189;
 265:fpr.h         **** static const fpr fpr_invsqrt8 = 4600040671590431693;
 266:fpr.h         **** static const fpr fpr_ptwo31 = 4746794007248502784;
 267:fpr.h         **** static const fpr fpr_ptwo31m1 = 4746794007244308480;
 268:fpr.h         **** static const fpr fpr_mtwo31m1 = 13970166044099084288U;
 269:fpr.h         **** static const fpr fpr_ptwo63m1 = 4890909195324358656;
 270:fpr.h         **** static const fpr fpr_mtwo63m1 = 14114281232179134464U;
 271:fpr.h         **** static const fpr fpr_ptwo63 = 4890909195324358656;
 272:fpr.h         **** 
 273:fpr.h         **** static inline int64_t
 274:fpr.h         **** fpr_rint(fpr x)
 275:fpr.h         **** {
 560              		.loc 1 275 1
 561              		.cfi_startproc
 562              		@ args = 0, pretend = 0, frame = 128
 563              		@ frame_needed = 1, uses_anonymous_args = 0
 564 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 565              	.LCFI23:
 566              		.cfi_def_cfa_offset 32
 567              		.cfi_offset 4, -32
 568              		.cfi_offset 5, -28
 569              		.cfi_offset 7, -24
 570              		.cfi_offset 8, -20
 571              		.cfi_offset 9, -16
 572              		.cfi_offset 10, -12
 573              		.cfi_offset 11, -8
 574              		.cfi_offset 14, -4
 575 0004 A0B0     		sub	sp, sp, #128
 576              	.LCFI24:
 577              		.cfi_def_cfa_offset 160
 578 0006 00AF     		add	r7, sp, #0
 579              	.LCFI25:
 580              		.cfi_def_cfa_register 7
 581 0008 C7E91401 		strd	r0, [r7, #80]
 276:fpr.h         **** 	uint64_t m, d;
 277:fpr.h         **** 	int e;
 278:fpr.h         **** 	uint32_t s, dd, f;
 279:fpr.h         **** 
 280:fpr.h         **** 	/*
 281:fpr.h         **** 	 * We assume that the value fits in -(2^63-1)..+(2^63-1). We can
 282:fpr.h         **** 	 * thus extract the mantissa as a 63-bit integer, then right-shift
 283:fpr.h         **** 	 * it as needed.
 284:fpr.h         **** 	 */
 285:fpr.h         **** 	m = ((x << 10) | ((uint64_t)1 << 62)) & (((uint64_t)1 << 63) - 1);
 582              		.loc 1 285 10
 583 000c D7E91423 		ldrd	r2, [r7, #80]
 584 0010 4FF00000 		mov	r0, #0
 585 0014 4FF00001 		mov	r1, #0
 586 0018 9902     		lsls	r1, r3, #10
 587 001a 41EA9251 		orr	r1, r1, r2, lsr #22
 588 001e 9002     		lsls	r0, r2, #10
 589              		.loc 1 285 40
 590 0020 0446     		mov	r4, r0
 591 0022 21F04045 		bic	r5, r1, #-1073741824
 592              		.loc 1 285 4
 593 0026 A246     		mov	r10, r4
 594 0028 45F0804B 		orr	fp, r5, #1073741824
 595 002c C7E91EAB 		strd	r10, [r7, #120]
 286:fpr.h         **** 	e = 1085 - ((int)(x >> 52) & 0x7FF);
 596              		.loc 1 286 22
 597 0030 D7E91423 		ldrd	r2, [r7, #80]
 598 0034 4FF00000 		mov	r0, #0
 599 0038 4FF00001 		mov	r1, #0
 600 003c 180D     		lsrs	r0, r3, #20
 601 003e 0021     		movs	r1, #0
 602              		.loc 1 286 14
 603 0040 0346     		mov	r3, r0
 604              		.loc 1 286 29
 605 0042 C3F30A03 		ubfx	r3, r3, #0, #11
 606              		.loc 1 286 4
 607 0046 C3F58763 		rsb	r3, r3, #1080
 608 004a 0533     		adds	r3, r3, #5
 609 004c 7B67     		str	r3, [r7, #116]
 287:fpr.h         **** 
 288:fpr.h         **** 	/*
 289:fpr.h         **** 	 * If a shift of more than 63 bits is needed, then simply set m
 290:fpr.h         **** 	 * to zero. This also covers the case of an input operand equal
 291:fpr.h         **** 	 * to zero.
 292:fpr.h         **** 	 */
 293:fpr.h         **** 	m &= -(uint64_t)((uint32_t)(e - 64) >> 31);
 610              		.loc 1 293 32
 611 004e 7B6F     		ldr	r3, [r7, #116]
 612 0050 403B     		subs	r3, r3, #64
 613              		.loc 1 293 38
 614 0052 DB0F     		lsrs	r3, r3, #31
 615              		.loc 1 293 8
 616 0054 0022     		movs	r2, #0
 617 0056 BB64     		str	r3, [r7, #72]
 618 0058 FA64     		str	r2, [r7, #76]
 619              		.loc 1 293 7
 620 005a 0023     		movs	r3, #0
 621 005c D7E91212 		ldrd	r1, [r7, #72]
 622 0060 0846     		mov	r0, r1
 623 0062 D0F10008 		rsbs	r8, r0, #0
 624 0066 63EB0209 		sbc	r9, r3, r2
 625              		.loc 1 293 4
 626 006a D7E91E23 		ldrd	r2, [r7, #120]
 627 006e 02EA0801 		and	r1, r2, r8
 628 0072 B960     		str	r1, [r7, #8]
 629 0074 03EA0903 		and	r3, r3, r9
 630 0078 FB60     		str	r3, [r7, #12]
 631 007a D7E90234 		ldrd	r3, [r7, #8]
 632 007e C7E91E34 		strd	r3, [r7, #120]
 294:fpr.h         **** 	e &= 63;
 633              		.loc 1 294 4
 634 0082 7B6F     		ldr	r3, [r7, #116]
 635 0084 03F03F03 		and	r3, r3, #63
 636 0088 7B67     		str	r3, [r7, #116]
 295:fpr.h         **** 
 296:fpr.h         **** 	/*
 297:fpr.h         **** 	 * Right-shift m as needed. Shift count is e. Proper rounding
 298:fpr.h         **** 	 * mandates that:
 299:fpr.h         **** 	 *   - If the highest dropped bit is zero, then round low.
 300:fpr.h         **** 	 *   - If the highest dropped bit is one, and at least one of the
 301:fpr.h         **** 	 *     other dropped bits is one, then round up.
 302:fpr.h         **** 	 *   - If the highest dropped bit is one, and all other dropped
 303:fpr.h         **** 	 *     bits are zero, then round up if the lowest kept bit is 1,
 304:fpr.h         **** 	 *     or low otherwise (i.e. ties are broken by "rounding to even").
 305:fpr.h         **** 	 *
 306:fpr.h         **** 	 * We thus first extract a word consisting of all the dropped bit
 307:fpr.h         **** 	 * AND the lowest kept bit; then we shrink it down to three bits,
 308:fpr.h         **** 	 * the lowest being "sticky".
 309:fpr.h         **** 	 */
 310:fpr.h         **** 	d = fpr_ulsh(m, 63 - e);
 637              		.loc 1 310 6
 638 008a 7B6F     		ldr	r3, [r7, #116]
 639 008c C3F13F03 		rsb	r3, r3, #63
 640 0090 1A46     		mov	r2, r3
 641 0092 D7E91E01 		ldrd	r0, [r7, #120]
 642 0096 FFF7FEFF 		bl	fpr_ulsh
 643 009a C7E91A01 		strd	r0, [r7, #104]
 311:fpr.h         **** 	dd = (uint32_t)d | ((uint32_t)(d >> 32) & 0x1FFFFFFF);
 644              		.loc 1 311 7
 645 009e BC6E     		ldr	r4, [r7, #104]
 646              		.loc 1 311 35
 647 00a0 D7E91A23 		ldrd	r2, [r7, #104]
 648 00a4 4FF00000 		mov	r0, #0
 649 00a8 4FF00001 		mov	r1, #0
 650 00ac 1800     		movs	r0, r3
 651 00ae 0021     		movs	r1, #0
 652              		.loc 1 311 22
 653 00b0 0346     		mov	r3, r0
 654              		.loc 1 311 42
 655 00b2 23F06043 		bic	r3, r3, #-536870912
 656              		.loc 1 311 5
 657 00b6 2343     		orrs	r3, r3, r4
 658 00b8 7B66     		str	r3, [r7, #100]
 312:fpr.h         **** 	f = (uint32_t)(d >> 61) | ((dd | -dd) >> 31);
 659              		.loc 1 312 19
 660 00ba D7E91A23 		ldrd	r2, [r7, #104]
 661 00be 4FF00000 		mov	r0, #0
 662 00c2 4FF00001 		mov	r1, #0
 663 00c6 580F     		lsrs	r0, r3, #29
 664 00c8 0021     		movs	r1, #0
 665              		.loc 1 312 6
 666 00ca 0146     		mov	r1, r0
 667              		.loc 1 312 35
 668 00cc 7B6E     		ldr	r3, [r7, #100]
 669 00ce 5A42     		rsbs	r2, r3, #0
 670              		.loc 1 312 33
 671 00d0 7B6E     		ldr	r3, [r7, #100]
 672 00d2 1343     		orrs	r3, r3, r2
 673              		.loc 1 312 40
 674 00d4 DB0F     		lsrs	r3, r3, #31
 675              		.loc 1 312 4
 676 00d6 0B43     		orrs	r3, r3, r1
 677 00d8 3B66     		str	r3, [r7, #96]
 313:fpr.h         **** 	m = fpr_ursh(m, e) + (uint64_t)((0xC8U >> f) & 1U);
 678              		.loc 1 313 6
 679 00da 7A6F     		ldr	r2, [r7, #116]
 680 00dc D7E91E01 		ldrd	r0, [r7, #120]
 681 00e0 FFF7FEFF 		bl	fpr_ursh
 682              		.loc 1 313 41
 683 00e4 C822     		movs	r2, #200
 684 00e6 3B6E     		ldr	r3, [r7, #96]
 685 00e8 22FA03F3 		lsr	r3, r2, r3
 686              		.loc 1 313 47
 687 00ec 0022     		movs	r2, #0
 688 00ee 3B64     		str	r3, [r7, #64]
 689 00f0 7A64     		str	r2, [r7, #68]
 690              		.loc 1 313 23
 691 00f2 3B6C     		ldr	r3, [r7, #64]
 692 00f4 03F00103 		and	r3, r3, #1
 693 00f8 BB63     		str	r3, [r7, #56]
 694 00fa 0023     		movs	r3, #0
 695 00fc FB63     		str	r3, [r7, #60]
 696              		.loc 1 313 4
 697 00fe D7E90E45 		ldrd	r4, [r7, #56]
 698 0102 2346     		mov	r3, r4
 699 0104 C318     		adds	r3, r0, r3
 700 0106 3B60     		str	r3, [r7]
 701 0108 2B46     		mov	r3, r5
 702 010a 41EB0303 		adc	r3, r1, r3
 703 010e 7B60     		str	r3, [r7, #4]
 704 0110 D7E90034 		ldrd	r3, [r7]
 705 0114 C7E91E34 		strd	r3, [r7, #120]
 314:fpr.h         **** 
 315:fpr.h         **** 	/*
 316:fpr.h         **** 	 * Apply the sign bit.
 317:fpr.h         **** 	 */
 318:fpr.h         **** 	s = (uint32_t)(x >> 63);
 706              		.loc 1 318 19
 707 0118 D7E91401 		ldrd	r0, [r7, #80]
 708 011c 4FF00002 		mov	r2, #0
 709 0120 4FF00003 		mov	r3, #0
 710 0124 CA0F     		lsrs	r2, r1, #31
 711 0126 0023     		movs	r3, #0
 712              		.loc 1 318 4
 713 0128 1346     		mov	r3, r2
 714 012a FB65     		str	r3, [r7, #92]
 319:fpr.h         **** 	return ((int64_t)m ^ -(int64_t)s) + (int64_t)s;
 715              		.loc 1 319 24
 716 012c FB6D     		ldr	r3, [r7, #92]
 717 012e 0022     		movs	r2, #0
 718 0130 3B63     		str	r3, [r7, #48]
 719 0132 7A63     		str	r2, [r7, #52]
 720              		.loc 1 319 23
 721 0134 0023     		movs	r3, #0
 722 0136 D7E90C01 		ldrd	r0, [r7, #48]
 723 013a 0246     		mov	r2, r0
 724 013c 5242     		negs	r2, r2
 725 013e BA62     		str	r2, [r7, #40]
 726 0140 0A46     		mov	r2, r1
 727 0142 63EB0203 		sbc	r3, r3, r2
 728 0146 FB62     		str	r3, [r7, #44]
 729              		.loc 1 319 10
 730 0148 D7E91E23 		ldrd	r2, [r7, #120]
 731              		.loc 1 319 21
 732 014c D7E90A01 		ldrd	r0, [r7, #40]
 733 0150 0446     		mov	r4, r0
 734 0152 5440     		eors	r4, r4, r2
 735 0154 3C62     		str	r4, [r7, #32]
 736 0156 5940     		eors	r1, r1, r3
 737 0158 7962     		str	r1, [r7, #36]
 738              		.loc 1 319 38
 739 015a FB6D     		ldr	r3, [r7, #92]
 740 015c 0022     		movs	r2, #0
 741 015e BB61     		str	r3, [r7, #24]
 742 0160 FA61     		str	r2, [r7, #28]
 743              		.loc 1 319 36
 744 0162 D7E90845 		ldrd	r4, [r7, #32]
 745 0166 2346     		mov	r3, r4
 746 0168 D7E90601 		ldrd	r0, [r7, #24]
 747 016c 0246     		mov	r2, r0
 748 016e 9B18     		adds	r3, r3, r2
 749 0170 3B61     		str	r3, [r7, #16]
 750 0172 0B46     		mov	r3, r1
 751 0174 2A46     		mov	r2, r5
 752 0176 42EB0303 		adc	r3, r2, r3
 753 017a 7B61     		str	r3, [r7, #20]
 754 017c D7E90423 		ldrd	r2, [r7, #16]
 320:fpr.h         **** }
 755              		.loc 1 320 1
 756 0180 1046     		mov	r0, r2
 757 0182 1946     		mov	r1, r3
 758 0184 8037     		adds	r7, r7, #128
 759              	.LCFI26:
 760              		.cfi_def_cfa_offset 32
 761 0186 BD46     		mov	sp, r7
 762              	.LCFI27:
 763              		.cfi_def_cfa_register 13
 764              		@ sp needed
 765 0188 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 766              		.cfi_endproc
 767              	.LFE6:
 769              		.section	.text.fpr_floor,"ax",%progbits
 770              		.align	1
 771              		.syntax unified
 772              		.thumb
 773              		.thumb_func
 774              		.fpu softvfp
 776              	fpr_floor:
 777              	.LFB7:
 321:fpr.h         **** 
 322:fpr.h         **** static inline int64_t
 323:fpr.h         **** fpr_floor(fpr x)
 324:fpr.h         **** {
 778              		.loc 1 324 1
 779              		.cfi_startproc
 780              		@ args = 0, pretend = 0, frame = 104
 781              		@ frame_needed = 1, uses_anonymous_args = 0
 782 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 783              	.LCFI28:
 784              		.cfi_def_cfa_offset 32
 785              		.cfi_offset 4, -32
 786              		.cfi_offset 5, -28
 787              		.cfi_offset 7, -24
 788              		.cfi_offset 8, -20
 789              		.cfi_offset 9, -16
 790              		.cfi_offset 10, -12
 791              		.cfi_offset 11, -8
 792              		.cfi_offset 14, -4
 793 0004 9AB0     		sub	sp, sp, #104
 794              	.LCFI29:
 795              		.cfi_def_cfa_offset 136
 796 0006 00AF     		add	r7, sp, #0
 797              	.LCFI30:
 798              		.cfi_def_cfa_register 7
 799 0008 C7E91001 		strd	r0, [r7, #64]
 325:fpr.h         **** 	uint64_t t;
 326:fpr.h         **** 	int64_t xi;
 327:fpr.h         **** 	int e, cc;
 328:fpr.h         **** 
 329:fpr.h         **** 	/*
 330:fpr.h         **** 	 * We extract the integer as a _signed_ 64-bit integer with
 331:fpr.h         **** 	 * a scaling factor. Since we assume that the value fits
 332:fpr.h         **** 	 * in the -(2^63-1)..+(2^63-1) range, we can left-shift the
 333:fpr.h         **** 	 * absolute value to make it in the 2^62..2^63-1 range: we
 334:fpr.h         **** 	 * will only need a right-shift afterwards.
 335:fpr.h         **** 	 */
 336:fpr.h         **** 	e = (int)(x >> 52) & 0x7FF;
 800              		.loc 1 336 14
 801 000c D7E91023 		ldrd	r2, [r7, #64]
 802 0010 4FF00000 		mov	r0, #0
 803 0014 4FF00001 		mov	r1, #0
 804 0018 180D     		lsrs	r0, r3, #20
 805 001a 0021     		movs	r1, #0
 806              		.loc 1 336 6
 807 001c 0346     		mov	r3, r0
 808              		.loc 1 336 4
 809 001e C3F30A03 		ubfx	r3, r3, #0, #11
 810 0022 7B66     		str	r3, [r7, #100]
 337:fpr.h         **** 	t = x >> 63;
 811              		.loc 1 337 4
 812 0024 D7E91023 		ldrd	r2, [r7, #64]
 813 0028 4FF00000 		mov	r0, #0
 814 002c 4FF00001 		mov	r1, #0
 815 0030 D80F     		lsrs	r0, r3, #31
 816 0032 0021     		movs	r1, #0
 817 0034 C7E91601 		strd	r0, [r7, #88]
 338:fpr.h         **** 	xi = (int64_t)(((x << 10) | ((uint64_t)1 << 62))
 818              		.loc 1 338 21
 819 0038 D7E91023 		ldrd	r2, [r7, #64]
 820 003c 4FF00000 		mov	r0, #0
 821 0040 4FF00001 		mov	r1, #0
 822 0044 9902     		lsls	r1, r3, #10
 823 0046 41EA9251 		orr	r1, r1, r2, lsr #22
 824 004a 9002     		lsls	r0, r2, #10
 825              		.loc 1 338 28
 826 004c B863     		str	r0, [r7, #56]
 827 004e 41F08043 		orr	r3, r1, #1073741824
 828 0052 FB63     		str	r3, [r7, #60]
 339:fpr.h         **** 		& (((uint64_t)1 << 63) - 1));
 829              		.loc 1 339 3
 830 0054 D7E90E23 		ldrd	r2, [r7, #56]
 338:fpr.h         **** 	xi = (int64_t)(((x << 10) | ((uint64_t)1 << 62))
 831              		.loc 1 338 5
 832 0058 3A61     		str	r2, [r7, #16]
 833 005a 23F00043 		bic	r3, r3, #-2147483648
 834 005e 7B61     		str	r3, [r7, #20]
 835 0060 D7E90423 		ldrd	r2, [r7, #16]
 836 0064 C7E91423 		strd	r2, [r7, #80]
 340:fpr.h         **** 	xi = (xi ^ -(int64_t)t) + (int64_t)t;
 837              		.loc 1 340 14
 838 0068 D7E91623 		ldrd	r2, [r7, #88]
 839              		.loc 1 340 13
 840 006c 0021     		movs	r1, #0
 841 006e 5442     		negs	r4, r2
 842 0070 61EB0305 		sbc	r5, r1, r3
 843              		.loc 1 340 11
 844 0074 D7E91423 		ldrd	r2, [r7, #80]
 845 0078 84EA0208 		eor	r8, r4, r2
 846 007c 85EA0309 		eor	r9, r5, r3
 847              		.loc 1 340 28
 848 0080 D7E91623 		ldrd	r2, [r7, #88]
 849              		.loc 1 340 5
 850 0084 18EB0201 		adds	r1, r8, r2
 851 0088 B960     		str	r1, [r7, #8]
 852 008a 49EB0303 		adc	r3, r9, r3
 853 008e FB60     		str	r3, [r7, #12]
 854 0090 D7E90234 		ldrd	r3, [r7, #8]
 855 0094 C7E91434 		strd	r3, [r7, #80]
 341:fpr.h         **** 	cc = 1085 - e;
 856              		.loc 1 341 5
 857 0098 7B6E     		ldr	r3, [r7, #100]
 858 009a C3F58763 		rsb	r3, r3, #1080
 859 009e 0533     		adds	r3, r3, #5
 860 00a0 FB64     		str	r3, [r7, #76]
 342:fpr.h         **** 
 343:fpr.h         **** 	/*
 344:fpr.h         **** 	 * We perform an arithmetic right-shift on the value. This
 345:fpr.h         **** 	 * applies floor() semantics on both positive and negative values
 346:fpr.h         **** 	 * (rounding toward minus infinity).
 347:fpr.h         **** 	 */
 348:fpr.h         **** 	xi = fpr_irsh(xi, cc & 63);
 861              		.loc 1 348 7
 862 00a2 FB6C     		ldr	r3, [r7, #76]
 863 00a4 03F03F03 		and	r3, r3, #63
 864 00a8 1A46     		mov	r2, r3
 865 00aa D7E91401 		ldrd	r0, [r7, #80]
 866 00ae FFF7FEFF 		bl	fpr_irsh
 867 00b2 C7E91401 		strd	r0, [r7, #80]
 349:fpr.h         **** 
 350:fpr.h         **** 	/*
 351:fpr.h         **** 	 * If the true shift count was 64 or more, then we should instead
 352:fpr.h         **** 	 * replace xi with 0 (if nonnegative) or -1 (if negative). Edge
 353:fpr.h         **** 	 * case: -0 will be floored to -1, not 0 (whether this is correct
 354:fpr.h         **** 	 * is debatable; in any case, the other functions normalize zero
 355:fpr.h         **** 	 * to +0).
 356:fpr.h         **** 	 *
 357:fpr.h         **** 	 * For an input of zero, the non-shifted xi was incorrect (we used
 358:fpr.h         **** 	 * a top implicit bit of value 1, not 0), but this does not matter
 359:fpr.h         **** 	 * since this operation will clamp it down.
 360:fpr.h         **** 	 */
 361:fpr.h         **** 	xi ^= (xi ^ -(int64_t)t) & -(int64_t)((uint32_t)(63 - cc) >> 31);
 868              		.loc 1 361 15
 869 00b6 D7E91623 		ldrd	r2, [r7, #88]
 870              		.loc 1 361 14
 871 00ba 0021     		movs	r1, #0
 872 00bc 5042     		negs	r0, r2
 873 00be 3863     		str	r0, [r7, #48]
 874 00c0 61EB0303 		sbc	r3, r1, r3
 875 00c4 7B63     		str	r3, [r7, #52]
 876              		.loc 1 361 12
 877 00c6 D7E91423 		ldrd	r2, [r7, #80]
 878 00ca D7E90C01 		ldrd	r0, [r7, #48]
 879 00ce 0446     		mov	r4, r0
 880 00d0 5440     		eors	r4, r4, r2
 881 00d2 BC62     		str	r4, [r7, #40]
 882 00d4 5940     		eors	r1, r1, r3
 883 00d6 F962     		str	r1, [r7, #44]
 884              		.loc 1 361 54
 885 00d8 FB6C     		ldr	r3, [r7, #76]
 886 00da C3F13F03 		rsb	r3, r3, #63
 887              		.loc 1 361 60
 888 00de DB0F     		lsrs	r3, r3, #31
 889              		.loc 1 361 30
 890 00e0 0022     		movs	r2, #0
 891 00e2 3B62     		str	r3, [r7, #32]
 892 00e4 7A62     		str	r2, [r7, #36]
 893              		.loc 1 361 29
 894 00e6 0023     		movs	r3, #0
 895 00e8 D7E90801 		ldrd	r0, [r7, #32]
 896 00ec 0246     		mov	r2, r0
 897 00ee 5242     		negs	r2, r2
 898 00f0 BA61     		str	r2, [r7, #24]
 899 00f2 0A46     		mov	r2, r1
 900 00f4 63EB0203 		sbc	r3, r3, r2
 901 00f8 FB61     		str	r3, [r7, #28]
 902              		.loc 1 361 27
 903 00fa D7E90A12 		ldrd	r1, [r7, #40]
 904 00fe 0846     		mov	r0, r1
 905 0100 D7E90634 		ldrd	r3, [r7, #24]
 906 0104 1D46     		mov	r5, r3
 907 0106 00EA050A 		and	r10, r0, r5
 908 010a 2346     		mov	r3, r4
 909 010c 02EA030B 		and	fp, r2, r3
 910              		.loc 1 361 5
 911 0110 D7E91423 		ldrd	r2, [r7, #80]
 912 0114 82EA0A01 		eor	r1, r2, r10
 913 0118 3960     		str	r1, [r7]
 914 011a 83EA0B03 		eor	r3, r3, fp
 915 011e 7B60     		str	r3, [r7, #4]
 916 0120 D7E90034 		ldrd	r3, [r7]
 917 0124 C7E91434 		strd	r3, [r7, #80]
 362:fpr.h         **** 	return xi;
 918              		.loc 1 362 9
 919 0128 D7E91423 		ldrd	r2, [r7, #80]
 363:fpr.h         **** }
 920              		.loc 1 363 1
 921 012c 1046     		mov	r0, r2
 922 012e 1946     		mov	r1, r3
 923 0130 6837     		adds	r7, r7, #104
 924              	.LCFI31:
 925              		.cfi_def_cfa_offset 32
 926 0132 BD46     		mov	sp, r7
 927              	.LCFI32:
 928              		.cfi_def_cfa_register 13
 929              		@ sp needed
 930 0134 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 931              		.cfi_endproc
 932              	.LFE7:
 934              		.section	.text.fpr_trunc,"ax",%progbits
 935              		.align	1
 936              		.syntax unified
 937              		.thumb
 938              		.thumb_func
 939              		.fpu softvfp
 941              	fpr_trunc:
 942              	.LFB8:
 364:fpr.h         **** 
 365:fpr.h         **** static inline int64_t
 366:fpr.h         **** fpr_trunc(fpr x)
 367:fpr.h         **** {
 943              		.loc 1 367 1
 944              		.cfi_startproc
 945              		@ args = 0, pretend = 0, frame = 72
 946              		@ frame_needed = 1, uses_anonymous_args = 0
 947 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 948              	.LCFI33:
 949              		.cfi_def_cfa_offset 32
 950              		.cfi_offset 4, -32
 951              		.cfi_offset 5, -28
 952              		.cfi_offset 7, -24
 953              		.cfi_offset 8, -20
 954              		.cfi_offset 9, -16
 955              		.cfi_offset 10, -12
 956              		.cfi_offset 11, -8
 957              		.cfi_offset 14, -4
 958 0004 92B0     		sub	sp, sp, #72
 959              	.LCFI34:
 960              		.cfi_def_cfa_offset 104
 961 0006 00AF     		add	r7, sp, #0
 962              	.LCFI35:
 963              		.cfi_def_cfa_register 7
 964 0008 C7E90A01 		strd	r0, [r7, #40]
 368:fpr.h         **** 	uint64_t t, xu;
 369:fpr.h         **** 	int e, cc;
 370:fpr.h         **** 
 371:fpr.h         **** 	/*
 372:fpr.h         **** 	 * Extract the absolute value. Since we assume that the value
 373:fpr.h         **** 	 * fits in the -(2^63-1)..+(2^63-1) range, we can left-shift
 374:fpr.h         **** 	 * the absolute value into the 2^62..2^63-1 range, and then
 375:fpr.h         **** 	 * do a right shift afterwards.
 376:fpr.h         **** 	 */
 377:fpr.h         **** 	e = (int)(x >> 52) & 0x7FF;
 965              		.loc 1 377 14
 966 000c D7E90A23 		ldrd	r2, [r7, #40]
 967 0010 4FF00000 		mov	r0, #0
 968 0014 4FF00001 		mov	r1, #0
 969 0018 180D     		lsrs	r0, r3, #20
 970 001a 0021     		movs	r1, #0
 971              		.loc 1 377 6
 972 001c 0346     		mov	r3, r0
 973              		.loc 1 377 4
 974 001e C3F30A03 		ubfx	r3, r3, #0, #11
 975 0022 7B64     		str	r3, [r7, #68]
 378:fpr.h         **** 	xu = ((x << 10) | ((uint64_t)1 << 62)) & (((uint64_t)1 << 63) - 1);
 976              		.loc 1 378 11
 977 0024 D7E90A23 		ldrd	r2, [r7, #40]
 978 0028 4FF00000 		mov	r0, #0
 979 002c 4FF00001 		mov	r1, #0
 980 0030 9902     		lsls	r1, r3, #10
 981 0032 41EA9251 		orr	r1, r1, r2, lsr #22
 982 0036 9002     		lsls	r0, r2, #10
 983              		.loc 1 378 41
 984 0038 3862     		str	r0, [r7, #32]
 985 003a 21F04043 		bic	r3, r1, #-1073741824
 986 003e 7B62     		str	r3, [r7, #36]
 987 0040 D7E90823 		ldrd	r2, [r7, #32]
 988 0044 1146     		mov	r1, r2
 989 0046 B961     		str	r1, [r7, #24]
 990 0048 43F08043 		orr	r3, r3, #1073741824
 991 004c FB61     		str	r3, [r7, #28]
 992              		.loc 1 378 5
 993 004e D7E90623 		ldrd	r2, [r7, #24]
 994 0052 C7E90C23 		strd	r2, [r7, #48]
 379:fpr.h         **** 	cc = 1085 - e;
 995              		.loc 1 379 5
 996 0056 7B6C     		ldr	r3, [r7, #68]
 997 0058 C3F58763 		rsb	r3, r3, #1080
 998 005c 0533     		adds	r3, r3, #5
 999 005e 3B64     		str	r3, [r7, #64]
 380:fpr.h         **** 	xu = fpr_ursh(xu, cc & 63);
 1000              		.loc 1 380 7
 1001 0060 D7E90C01 		ldrd	r0, [r7, #48]
 1002 0064 3B6C     		ldr	r3, [r7, #64]
 1003 0066 03F03F03 		and	r3, r3, #63
 1004 006a 1A46     		mov	r2, r3
 1005 006c FFF7FEFF 		bl	fpr_ursh
 1006 0070 0246     		mov	r2, r0
 1007 0072 0B46     		mov	r3, r1
 1008              		.loc 1 380 5
 1009 0074 C7E90C23 		strd	r2, [r7, #48]
 381:fpr.h         **** 
 382:fpr.h         **** 	/*
 383:fpr.h         **** 	 * If the exponent is too low (cc > 63), then the shift was wrong
 384:fpr.h         **** 	 * and we must clamp the value to 0. This also covers the case
 385:fpr.h         **** 	 * of an input equal to zero.
 386:fpr.h         **** 	 */
 387:fpr.h         **** 	xu &= -(uint64_t)((uint32_t)(cc - 64) >> 31);
 1010              		.loc 1 387 34
 1011 0078 3B6C     		ldr	r3, [r7, #64]
 1012 007a 403B     		subs	r3, r3, #64
 1013              		.loc 1 387 40
 1014 007c DB0F     		lsrs	r3, r3, #31
 1015              		.loc 1 387 9
 1016 007e 0022     		movs	r2, #0
 1017 0080 3B61     		str	r3, [r7, #16]
 1018 0082 7A61     		str	r2, [r7, #20]
 1019              		.loc 1 387 8
 1020 0084 0023     		movs	r3, #0
 1021 0086 D7E90412 		ldrd	r1, [r7, #16]
 1022 008a 0846     		mov	r0, r1
 1023 008c D0F1000A 		rsbs	r10, r0, #0
 1024 0090 63EB020B 		sbc	fp, r3, r2
 1025              		.loc 1 387 5
 1026 0094 D7E90C23 		ldrd	r2, [r7, #48]
 1027 0098 0AEA0201 		and	r1, r10, r2
 1028 009c B960     		str	r1, [r7, #8]
 1029 009e 0BEA0303 		and	r3, fp, r3
 1030 00a2 FB60     		str	r3, [r7, #12]
 1031 00a4 D7E90223 		ldrd	r2, [r7, #8]
 1032 00a8 C7E90C23 		strd	r2, [r7, #48]
 388:fpr.h         **** 
 389:fpr.h         **** 	/*
 390:fpr.h         **** 	 * Apply back the sign, if the source value is negative.
 391:fpr.h         **** 	 */
 392:fpr.h         **** 	t = x >> 63;
 1033              		.loc 1 392 4
 1034 00ac D7E90A01 		ldrd	r0, [r7, #40]
 1035 00b0 4FF00002 		mov	r2, #0
 1036 00b4 4FF00003 		mov	r3, #0
 1037 00b8 CA0F     		lsrs	r2, r1, #31
 1038 00ba 0023     		movs	r3, #0
 1039 00bc C7E90E23 		strd	r2, [r7, #56]
 393:fpr.h         **** 	xu = (xu ^ -t) + t;
 1040              		.loc 1 393 13
 1041 00c0 D7E90E23 		ldrd	r2, [r7, #56]
 1042 00c4 0021     		movs	r1, #0
 1043 00c6 D2F10008 		rsbs	r8, r2, #0
 1044 00ca 61EB0309 		sbc	r9, r1, r3
 1045              		.loc 1 393 11
 1046 00ce D7E90C23 		ldrd	r2, [r7, #48]
 1047 00d2 88EA0204 		eor	r4, r8, r2
 1048 00d6 89EA0305 		eor	r5, r9, r3
 1049              		.loc 1 393 17
 1050 00da D7E90E23 		ldrd	r2, [r7, #56]
 1051 00de A118     		adds	r1, r4, r2
 1052 00e0 3960     		str	r1, [r7]
 1053 00e2 45EB0303 		adc	r3, r5, r3
 1054 00e6 7B60     		str	r3, [r7, #4]
 1055              		.loc 1 393 5
 1056 00e8 D7E90034 		ldrd	r3, [r7]
 1057 00ec C7E90C34 		strd	r3, [r7, #48]
 394:fpr.h         **** 	return *(int64_t *)&xu;
 1058              		.loc 1 394 21
 1059 00f0 07F13003 		add	r3, r7, #48
 1060              		.loc 1 394 9
 1061 00f4 D3E90023 		ldrd	r2, [r3]
 395:fpr.h         **** }
 1062              		.loc 1 395 1
 1063 00f8 1046     		mov	r0, r2
 1064 00fa 1946     		mov	r1, r3
 1065 00fc 4837     		adds	r7, r7, #72
 1066              	.LCFI36:
 1067              		.cfi_def_cfa_offset 32
 1068 00fe BD46     		mov	sp, r7
 1069              	.LCFI37:
 1070              		.cfi_def_cfa_register 13
 1071              		@ sp needed
 1072 0100 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 1073              		.cfi_endproc
 1074              	.LFE8:
 1076              		.section	.text.fpr_sub,"ax",%progbits
 1077              		.align	1
 1078              		.syntax unified
 1079              		.thumb
 1080              		.thumb_func
 1081              		.fpu softvfp
 1083              	fpr_sub:
 1084              	.LFB9:
 396:fpr.h         **** 
 397:fpr.h         **** #define fpr_add   Zf(fpr_add)
 398:fpr.h         **** fpr fpr_add(fpr x, fpr y);
 399:fpr.h         **** 
 400:fpr.h         **** static inline fpr
 401:fpr.h         **** fpr_sub(fpr x, fpr y)
 402:fpr.h         **** {
 1085              		.loc 1 402 1
 1086              		.cfi_startproc
 1087              		@ args = 0, pretend = 0, frame = 16
 1088              		@ frame_needed = 1, uses_anonymous_args = 0
 1089 0000 B0B5     		push	{r4, r5, r7, lr}
 1090              	.LCFI38:
 1091              		.cfi_def_cfa_offset 16
 1092              		.cfi_offset 4, -16
 1093              		.cfi_offset 5, -12
 1094              		.cfi_offset 7, -8
 1095              		.cfi_offset 14, -4
 1096 0002 84B0     		sub	sp, sp, #16
 1097              	.LCFI39:
 1098              		.cfi_def_cfa_offset 32
 1099 0004 00AF     		add	r7, sp, #0
 1100              	.LCFI40:
 1101              		.cfi_def_cfa_register 7
 1102 0006 C7E90201 		strd	r0, [r7, #8]
 1103 000a C7E90023 		strd	r2, [r7]
 403:fpr.h         **** 	y ^= (uint64_t)1 << 63;
 1104              		.loc 1 403 4
 1105 000e D7E90023 		ldrd	r2, [r7]
 1106 0012 1446     		mov	r4, r2
 1107 0014 03F10045 		add	r5, r3, #-2147483648
 1108 0018 C7E90045 		strd	r4, [r7]
 404:fpr.h         **** 	return fpr_add(x, y);
 1109              		.loc 1 404 9
 1110 001c D7E90023 		ldrd	r2, [r7]
 1111 0020 D7E90201 		ldrd	r0, [r7, #8]
 1112 0024 FFF7FEFF 		bl	falcon_inner_fpr_add
 1113 0028 0246     		mov	r2, r0
 1114 002a 0B46     		mov	r3, r1
 405:fpr.h         **** }
 1115              		.loc 1 405 1
 1116 002c 1046     		mov	r0, r2
 1117 002e 1946     		mov	r1, r3
 1118 0030 1037     		adds	r7, r7, #16
 1119              	.LCFI41:
 1120              		.cfi_def_cfa_offset 16
 1121 0032 BD46     		mov	sp, r7
 1122              	.LCFI42:
 1123              		.cfi_def_cfa_register 13
 1124              		@ sp needed
 1125 0034 B0BD     		pop	{r4, r5, r7, pc}
 1126              		.cfi_endproc
 1127              	.LFE9:
 1129              		.section	.text.fpr_neg,"ax",%progbits
 1130              		.align	1
 1131              		.syntax unified
 1132              		.thumb
 1133              		.thumb_func
 1134              		.fpu softvfp
 1136              	fpr_neg:
 1137              	.LFB10:
 406:fpr.h         **** 
 407:fpr.h         **** static inline fpr
 408:fpr.h         **** fpr_neg(fpr x)
 409:fpr.h         **** {
 1138              		.loc 1 409 1
 1139              		.cfi_startproc
 1140              		@ args = 0, pretend = 0, frame = 8
 1141              		@ frame_needed = 1, uses_anonymous_args = 0
 1142              		@ link register save eliminated.
 1143 0000 80B4     		push	{r7}
 1144              	.LCFI43:
 1145              		.cfi_def_cfa_offset 4
 1146              		.cfi_offset 7, -4
 1147 0002 83B0     		sub	sp, sp, #12
 1148              	.LCFI44:
 1149              		.cfi_def_cfa_offset 16
 1150 0004 00AF     		add	r7, sp, #0
 1151              	.LCFI45:
 1152              		.cfi_def_cfa_register 7
 1153 0006 C7E90001 		strd	r0, [r7]
 410:fpr.h         **** 	x ^= (uint64_t)1 << 63;
 1154              		.loc 1 410 4
 1155 000a D7E90001 		ldrd	r0, [r7]
 1156 000e 0246     		mov	r2, r0
 1157 0010 01F10043 		add	r3, r1, #-2147483648
 1158 0014 C7E90023 		strd	r2, [r7]
 411:fpr.h         **** 	return x;
 1159              		.loc 1 411 9
 1160 0018 D7E90023 		ldrd	r2, [r7]
 412:fpr.h         **** }
 1161              		.loc 1 412 1
 1162 001c 1046     		mov	r0, r2
 1163 001e 1946     		mov	r1, r3
 1164 0020 0C37     		adds	r7, r7, #12
 1165              	.LCFI46:
 1166              		.cfi_def_cfa_offset 4
 1167 0022 BD46     		mov	sp, r7
 1168              	.LCFI47:
 1169              		.cfi_def_cfa_register 13
 1170              		@ sp needed
 1171 0024 80BC     		pop	{r7}
 1172              	.LCFI48:
 1173              		.cfi_restore 7
 1174              		.cfi_def_cfa_offset 0
 1175 0026 7047     		bx	lr
 1176              		.cfi_endproc
 1177              	.LFE10:
 1179              		.section	.text.fpr_half,"ax",%progbits
 1180              		.align	1
 1181              		.syntax unified
 1182              		.thumb
 1183              		.thumb_func
 1184              		.fpu softvfp
 1186              	fpr_half:
 1187              	.LFB11:
 413:fpr.h         **** 
 414:fpr.h         **** static inline fpr
 415:fpr.h         **** fpr_half(fpr x)
 416:fpr.h         **** {
 1188              		.loc 1 416 1
 1189              		.cfi_startproc
 1190              		@ args = 0, pretend = 0, frame = 16
 1191              		@ frame_needed = 1, uses_anonymous_args = 0
 1192              		@ link register save eliminated.
 1193 0000 2DE9B00F 		push	{r4, r5, r7, r8, r9, r10, fp}
 1194              	.LCFI49:
 1195              		.cfi_def_cfa_offset 28
 1196              		.cfi_offset 4, -28
 1197              		.cfi_offset 5, -24
 1198              		.cfi_offset 7, -20
 1199              		.cfi_offset 8, -16
 1200              		.cfi_offset 9, -12
 1201              		.cfi_offset 10, -8
 1202              		.cfi_offset 11, -4
 1203 0004 85B0     		sub	sp, sp, #20
 1204              	.LCFI50:
 1205              		.cfi_def_cfa_offset 48
 1206 0006 00AF     		add	r7, sp, #0
 1207              	.LCFI51:
 1208              		.cfi_def_cfa_register 7
 1209 0008 C7E90001 		strd	r0, [r7]
 417:fpr.h         **** 	/*
 418:fpr.h         **** 	 * To divide a value by 2, we just have to subtract 1 from its
 419:fpr.h         **** 	 * exponent, but we have to take care of zero.
 420:fpr.h         **** 	 */
 421:fpr.h         **** 	uint32_t t;
 422:fpr.h         **** 
 423:fpr.h         **** 	x -= (uint64_t)1 << 52;
 1210              		.loc 1 423 4
 1211 000c D7E90001 		ldrd	r0, [r7]
 1212 0010 A1F5801B 		sub	fp, r1, #1048576
 1213 0014 8246     		mov	r10, r0
 1214 0016 C7E900AB 		strd	r10, [r7]
 424:fpr.h         **** 	t = (((uint32_t)(x >> 52) & 0x7FF) + 1) >> 11;
 1215              		.loc 1 424 21
 1216 001a D7E900AB 		ldrd	r10, [r7]
 1217 001e 4FF00000 		mov	r0, #0
 1218 0022 4FF00001 		mov	r1, #0
 1219 0026 4FEA1B50 		lsr	r0, fp, #20
 1220 002a 0021     		movs	r1, #0
 1221              		.loc 1 424 8
 1222 002c 0146     		mov	r1, r0
 1223              		.loc 1 424 28
 1224 002e C1F30A01 		ubfx	r1, r1, #0, #11
 1225              		.loc 1 424 37
 1226 0032 0131     		adds	r1, r1, #1
 1227              		.loc 1 424 4
 1228 0034 C90A     		lsrs	r1, r1, #11
 1229 0036 F960     		str	r1, [r7, #12]
 425:fpr.h         **** 	x &= (uint64_t)t - 1;
 1230              		.loc 1 425 7
 1231 0038 F968     		ldr	r1, [r7, #12]
 1232 003a 0020     		movs	r0, #0
 1233 003c 0C46     		mov	r4, r1
 1234 003e 0546     		mov	r5, r0
 1235              		.loc 1 425 19
 1236 0040 621E     		subs	r2, r4, #1
 1237 0042 45F1FF33 		adc	r3, r5, #-1
 1238              		.loc 1 425 4
 1239 0046 D7E90001 		ldrd	r0, [r7]
 1240 004a 00EA0208 		and	r8, r0, r2
 1241 004e 01EA0309 		and	r9, r1, r3
 1242 0052 C7E90089 		strd	r8, [r7]
 426:fpr.h         **** 	return x;
 1243              		.loc 1 426 9
 1244 0056 D7E90023 		ldrd	r2, [r7]
 427:fpr.h         **** }
 1245              		.loc 1 427 1
 1246 005a 1046     		mov	r0, r2
 1247 005c 1946     		mov	r1, r3
 1248 005e 1437     		adds	r7, r7, #20
 1249              	.LCFI52:
 1250              		.cfi_def_cfa_offset 28
 1251 0060 BD46     		mov	sp, r7
 1252              	.LCFI53:
 1253              		.cfi_def_cfa_register 13
 1254              		@ sp needed
 1255 0062 BDE8B00F 		pop	{r4, r5, r7, r8, r9, r10, fp}
 1256              	.LCFI54:
 1257              		.cfi_restore 11
 1258              		.cfi_restore 10
 1259              		.cfi_restore 9
 1260              		.cfi_restore 8
 1261              		.cfi_restore 7
 1262              		.cfi_restore 5
 1263              		.cfi_restore 4
 1264              		.cfi_def_cfa_offset 0
 1265 0066 7047     		bx	lr
 1266              		.cfi_endproc
 1267              	.LFE11:
 1269              		.section	.text.fpr_sqr,"ax",%progbits
 1270              		.align	1
 1271              		.syntax unified
 1272              		.thumb
 1273              		.thumb_func
 1274              		.fpu softvfp
 1276              	fpr_sqr:
 1277              	.LFB13:
 428:fpr.h         **** 
 429:fpr.h         **** static inline fpr
 430:fpr.h         **** fpr_double(fpr x)
 431:fpr.h         **** {
 432:fpr.h         **** 	/*
 433:fpr.h         **** 	 * To double a value, we just increment by one the exponent. We
 434:fpr.h         **** 	 * don't care about infinites or NaNs; however, 0 is a
 435:fpr.h         **** 	 * special case.
 436:fpr.h         **** 	 */
 437:fpr.h         **** 	x += (uint64_t)((((unsigned)(x >> 52) & 0x7FFU) + 0x7FFU) >> 11) << 52;
 438:fpr.h         **** 	return x;
 439:fpr.h         **** }
 440:fpr.h         **** 
 441:fpr.h         **** #define fpr_mul   Zf(fpr_mul)
 442:fpr.h         **** fpr fpr_mul(fpr x, fpr y);
 443:fpr.h         **** 
 444:fpr.h         **** static inline fpr
 445:fpr.h         **** fpr_sqr(fpr x)
 446:fpr.h         **** {
 1278              		.loc 1 446 1
 1279              		.cfi_startproc
 1280              		@ args = 0, pretend = 0, frame = 8
 1281              		@ frame_needed = 1, uses_anonymous_args = 0
 1282 0000 80B5     		push	{r7, lr}
 1283              	.LCFI55:
 1284              		.cfi_def_cfa_offset 8
 1285              		.cfi_offset 7, -8
 1286              		.cfi_offset 14, -4
 1287 0002 82B0     		sub	sp, sp, #8
 1288              	.LCFI56:
 1289              		.cfi_def_cfa_offset 16
 1290 0004 00AF     		add	r7, sp, #0
 1291              	.LCFI57:
 1292              		.cfi_def_cfa_register 7
 1293 0006 C7E90001 		strd	r0, [r7]
 447:fpr.h         **** 	return fpr_mul(x, x);
 1294              		.loc 1 447 9
 1295 000a D7E90023 		ldrd	r2, [r7]
 1296 000e D7E90001 		ldrd	r0, [r7]
 1297 0012 FFF7FEFF 		bl	falcon_inner_fpr_mul
 1298 0016 0246     		mov	r2, r0
 1299 0018 0B46     		mov	r3, r1
 448:fpr.h         **** }
 1300              		.loc 1 448 1
 1301 001a 1046     		mov	r0, r2
 1302 001c 1946     		mov	r1, r3
 1303 001e 0837     		adds	r7, r7, #8
 1304              	.LCFI58:
 1305              		.cfi_def_cfa_offset 8
 1306 0020 BD46     		mov	sp, r7
 1307              	.LCFI59:
 1308              		.cfi_def_cfa_register 13
 1309              		@ sp needed
 1310 0022 80BD     		pop	{r7, pc}
 1311              		.cfi_endproc
 1312              	.LFE13:
 1314              		.section	.text.prng_get_u64,"ax",%progbits
 1315              		.align	1
 1316              		.syntax unified
 1317              		.thumb
 1318              		.thumb_func
 1319              		.fpu softvfp
 1321              	prng_get_u64:
 1322              	.LFB16:
 1323              		.file 2 "inner.h"
   1:inner.h       **** #ifndef FALCON_INNER_H__
   2:inner.h       **** #define FALCON_INNER_H__
   3:inner.h       **** 
   4:inner.h       **** /*
   5:inner.h       ****  * Internal functions for Falcon. This is not the API intended to be
   6:inner.h       ****  * used by applications; instead, this internal API provides all the
   7:inner.h       ****  * primitives on which wrappers build to provide external APIs.
   8:inner.h       ****  *
   9:inner.h       ****  * ==========================(LICENSE BEGIN)============================
  10:inner.h       ****  *
  11:inner.h       ****  * Copyright (c) 2017-2019  Falcon Project
  12:inner.h       ****  *
  13:inner.h       ****  * Permission is hereby granted, free of charge, to any person obtaining
  14:inner.h       ****  * a copy of this software and associated documentation files (the
  15:inner.h       ****  * "Software"), to deal in the Software without restriction, including
  16:inner.h       ****  * without limitation the rights to use, copy, modify, merge, publish,
  17:inner.h       ****  * distribute, sublicense, and/or sell copies of the Software, and to
  18:inner.h       ****  * permit persons to whom the Software is furnished to do so, subject to
  19:inner.h       ****  * the following conditions:
  20:inner.h       ****  *
  21:inner.h       ****  * The above copyright notice and this permission notice shall be
  22:inner.h       ****  * included in all copies or substantial portions of the Software.
  23:inner.h       ****  *
  24:inner.h       ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  25:inner.h       ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  26:inner.h       ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  27:inner.h       ****  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  28:inner.h       ****  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  29:inner.h       ****  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  30:inner.h       ****  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  31:inner.h       ****  *
  32:inner.h       ****  * ===========================(LICENSE END)=============================
  33:inner.h       ****  *
  34:inner.h       ****  * @author   Thomas Pornin <thomas.pornin@nccgroup.com>
  35:inner.h       ****  */
  36:inner.h       **** 
  37:inner.h       **** /*
  38:inner.h       ****  * IMPORTANT API RULES
  39:inner.h       ****  * -------------------
  40:inner.h       ****  *
  41:inner.h       ****  * This API has some non-trivial usage rules:
  42:inner.h       ****  *
  43:inner.h       ****  *
  44:inner.h       ****  *  - All public functions (i.e. the non-static ones) must be referenced
  45:inner.h       ****  *    with the Zf() macro (e.g. Zf(verify_raw) for the verify_raw()
  46:inner.h       ****  *    function). That macro adds a prefix to the name, which is
  47:inner.h       ****  *    configurable with the FALCON_PREFIX macro. This allows compiling
  48:inner.h       ****  *    the code into a specific "namespace" and potentially including
  49:inner.h       ****  *    several versions of this code into a single application (e.g. to
  50:inner.h       ****  *    have an AVX2 and a non-AVX2 variants and select the one to use at
  51:inner.h       ****  *    runtime based on availability of AVX2 opcodes).
  52:inner.h       ****  *
  53:inner.h       ****  *  - Functions that need temporary buffers expects them as a final
  54:inner.h       ****  *    tmp[] array of type uint8_t*, with a size which is documented for
  55:inner.h       ****  *    each function. However, most have some alignment requirements,
  56:inner.h       ****  *    because they will use the array to store 16-bit, 32-bit or 64-bit
  57:inner.h       ****  *    values (e.g. uint64_t or double). The caller must ensure proper
  58:inner.h       ****  *    alignment. What happens on unaligned access depends on the
  59:inner.h       ****  *    underlying architecture, ranging from a slight time penalty
  60:inner.h       ****  *    to immediate termination of the process.
  61:inner.h       ****  *
  62:inner.h       ****  *  - Some functions rely on specific rounding rules and precision for
  63:inner.h       ****  *    floating-point numbers. On some systems (in particular 32-bit x86
  64:inner.h       ****  *    with the 387 FPU), this requires setting an hardware control
  65:inner.h       ****  *    word. The caller MUST use set_fpu_cw() to ensure proper precision:
  66:inner.h       ****  *
  67:inner.h       ****  *      oldcw = set_fpu_cw(2);
  68:inner.h       ****  *      Zf(sign_dyn)(...);
  69:inner.h       ****  *      set_fpu_cw(oldcw);
  70:inner.h       ****  *
  71:inner.h       ****  *    On systems where the native floating-point precision is already
  72:inner.h       ****  *    proper, or integer-based emulation is used, the set_fpu_cw()
  73:inner.h       ****  *    function does nothing, so it can be called systematically.
  74:inner.h       ****  */
  75:inner.h       **** 
  76:inner.h       **** 
  77:inner.h       **** #include <stdint.h>
  78:inner.h       **** #include <stdlib.h>
  79:inner.h       **** #include <string.h>
  80:inner.h       **** 
  81:inner.h       **** 
  82:inner.h       **** 
  83:inner.h       **** /*
  84:inner.h       ****  * "Naming" macro used to apply a consistent prefix over all global
  85:inner.h       ****  * symbols.
  86:inner.h       ****  */
  87:inner.h       **** #ifndef FALCON_PREFIX
  88:inner.h       **** #define FALCON_PREFIX   falcon_inner
  89:inner.h       **** #endif
  90:inner.h       **** #define Zf(name)             Zf_(FALCON_PREFIX, name)
  91:inner.h       **** #define Zf_(prefix, name)    Zf__(prefix, name)
  92:inner.h       **** #define Zf__(prefix, name)   prefix ## _ ## name  
  93:inner.h       **** 
  94:inner.h       **** 
  95:inner.h       **** /*
  96:inner.h       ****  * Some computations with floating-point elements, in particular
  97:inner.h       ****  * rounding to the nearest integer, rely on operations using _exactly_
  98:inner.h       ****  * the precision of IEEE-754 binary64 type (i.e. 52 bits). On 32-bit
  99:inner.h       ****  * x86, the 387 FPU may be used (depending on the target OS) and, in
 100:inner.h       ****  * that case, may use more precision bits (i.e. 64 bits, for an 80-bit
 101:inner.h       ****  * total type length); to prevent miscomputations, we define an explicit
 102:inner.h       ****  * function that modifies the precision in the FPU control word.
 103:inner.h       ****  *
 104:inner.h       ****  * set_fpu_cw() sets the precision to the provided value, and returns
 105:inner.h       ****  * the previously set precision; callers are supposed to restore the
 106:inner.h       ****  * previous precision on exit. The correct (52-bit) precision is
 107:inner.h       ****  * configured with the value "2". On unsupported compilers, or on
 108:inner.h       ****  * targets other than 32-bit x86, or when the native 'double' type is
 109:inner.h       ****  * not used, the set_fpu_cw() function does nothing at all.
 110:inner.h       ****  */
 111:inner.h       **** static inline unsigned
 112:inner.h       **** set_fpu_cw(unsigned x)
 113:inner.h       **** {
 114:inner.h       **** 	return x;
 115:inner.h       **** }
 116:inner.h       **** 
 117:inner.h       **** 
 118:inner.h       **** 
 119:inner.h       **** /*
 120:inner.h       ****  * MSVC 2015 does not know the C99 keyword 'restrict'.
 121:inner.h       ****  */
 122:inner.h       **** #if defined _MSC_VER && _MSC_VER
 123:inner.h       **** #ifndef restrict
 124:inner.h       **** #define restrict   __restrict
 125:inner.h       **** #endif
 126:inner.h       **** #endif
 127:inner.h       **** 
 128:inner.h       **** /* ==================================================================== */
 129:inner.h       **** /*
 130:inner.h       ****  * SHAKE256 implementation (shake.c).
 131:inner.h       ****  *
 132:inner.h       ****  * API is defined to be easily replaced with the fips202.h API defined
 133:inner.h       ****  * as part of PQClean.
 134:inner.h       ****  */
 135:inner.h       **** 
 136:inner.h       **** typedef struct {
 137:inner.h       **** 	union {
 138:inner.h       **** 		uint64_t A[25];
 139:inner.h       **** 		uint8_t dbuf[200];
 140:inner.h       **** 	} st;
 141:inner.h       **** 	uint64_t dptr;
 142:inner.h       **** } inner_shake256_context;
 143:inner.h       **** 
 144:inner.h       **** #define inner_shake256_init      Zf(i_shake256_init)
 145:inner.h       **** #define inner_shake256_inject    Zf(i_shake256_inject)
 146:inner.h       **** #define inner_shake256_flip      Zf(i_shake256_flip)
 147:inner.h       **** #define inner_shake256_extract   Zf(i_shake256_extract)
 148:inner.h       **** 
 149:inner.h       **** void Zf(i_shake256_init)(
 150:inner.h       **** 	inner_shake256_context *sc);
 151:inner.h       **** void Zf(i_shake256_inject)(
 152:inner.h       **** 	inner_shake256_context *sc, const uint8_t *in, size_t len);
 153:inner.h       **** void Zf(i_shake256_flip)(
 154:inner.h       **** 	inner_shake256_context *sc);
 155:inner.h       **** void Zf(i_shake256_extract)(
 156:inner.h       **** 	inner_shake256_context *sc, uint8_t *out, size_t len);
 157:inner.h       **** 
 158:inner.h       **** /*
 159:inner.h       ****  */
 160:inner.h       **** 
 161:inner.h       **** /* ==================================================================== */
 162:inner.h       **** /*
 163:inner.h       ****  * Encoding/decoding functions (codec.c).
 164:inner.h       ****  *
 165:inner.h       ****  * Encoding functions take as parameters an output buffer (out) with
 166:inner.h       ****  * a given maximum length (max_out_len); returned value is the actual
 167:inner.h       ****  * number of bytes which have been written. If the output buffer is
 168:inner.h       ****  * not large enough, then 0 is returned (some bytes may have been
 169:inner.h       ****  * written to the buffer). If 'out' is NULL, then 'max_out_len' is
 170:inner.h       ****  * ignored; instead, the function computes and returns the actual
 171:inner.h       ****  * required output length (in bytes).
 172:inner.h       ****  *
 173:inner.h       ****  * Decoding functions take as parameters an input buffer (in) with
 174:inner.h       ****  * its maximum length (max_in_len); returned value is the actual number
 175:inner.h       ****  * of bytes that have been read from the buffer. If the provided length
 176:inner.h       ****  * is too short, then 0 is returned.
 177:inner.h       ****  *
 178:inner.h       ****  * Values to encode or decode are vectors of integers, with N = 2^logn
 179:inner.h       ****  * elements.
 180:inner.h       ****  *
 181:inner.h       ****  * Three encoding formats are defined:
 182:inner.h       ****  *
 183:inner.h       ****  *   - modq: sequence of values modulo 12289, each encoded over exactly
 184:inner.h       ****  *     14 bits. The encoder and decoder verify that integers are within
 185:inner.h       ****  *     the valid range (0..12288). Values are arrays of uint16.
 186:inner.h       ****  *
 187:inner.h       ****  *   - trim: sequence of signed integers, a specified number of bits
 188:inner.h       ****  *     each. The number of bits is provided as parameter and includes
 189:inner.h       ****  *     the sign bit. Each integer x must be such that |x| < 2^(bits-1)
 190:inner.h       ****  *     (which means that the -2^(bits-1) value is forbidden); encode and
 191:inner.h       ****  *     decode functions check that property. Values are arrays of
 192:inner.h       ****  *     int16_t or int8_t, corresponding to names 'trim_i16' and
 193:inner.h       ****  *     'trim_i8', respectively.
 194:inner.h       ****  *
 195:inner.h       ****  *   - comp: variable-length encoding for signed integers; each integer
 196:inner.h       ****  *     uses a minimum of 9 bits, possibly more. This is normally used
 197:inner.h       ****  *     only for signatures.
 198:inner.h       ****  *
 199:inner.h       ****  */
 200:inner.h       **** 
 201:inner.h       **** size_t Zf(modq_encode)(void *out, size_t max_out_len,
 202:inner.h       **** 	const uint16_t *x, unsigned logn);
 203:inner.h       **** size_t Zf(trim_i16_encode)(void *out, size_t max_out_len,
 204:inner.h       **** 	const int16_t *x, unsigned logn, unsigned bits);
 205:inner.h       **** size_t Zf(trim_i8_encode)(void *out, size_t max_out_len,
 206:inner.h       **** 	const int8_t *x, unsigned logn, unsigned bits);
 207:inner.h       **** size_t Zf(comp_encode)(void *out, size_t max_out_len,
 208:inner.h       **** 	const int16_t *x, unsigned logn);
 209:inner.h       **** 
 210:inner.h       **** size_t Zf(modq_decode)(uint16_t *x, unsigned logn,
 211:inner.h       **** 	const void *in, size_t max_in_len);
 212:inner.h       **** size_t Zf(trim_i16_decode)(int16_t *x, unsigned logn, unsigned bits,
 213:inner.h       **** 	const void *in, size_t max_in_len);
 214:inner.h       **** size_t Zf(trim_i8_decode)(int8_t *x, unsigned logn, unsigned bits,
 215:inner.h       **** 	const void *in, size_t max_in_len);
 216:inner.h       **** size_t Zf(comp_decode)(int16_t *x, unsigned logn,
 217:inner.h       **** 	const void *in, size_t max_in_len);
 218:inner.h       **** 
 219:inner.h       **** /*
 220:inner.h       ****  * Number of bits for key elements, indexed by logn (1 to 10). This
 221:inner.h       ****  * is at most 8 bits for all degrees, but some degrees may have shorter
 222:inner.h       ****  * elements.
 223:inner.h       ****  */
 224:inner.h       **** extern const uint8_t Zf(max_fg_bits)[];
 225:inner.h       **** extern const uint8_t Zf(max_FG_bits)[];
 226:inner.h       **** 
 227:inner.h       **** /*
 228:inner.h       ****  * Maximum size, in bits, of elements in a signature, indexed by logn
 229:inner.h       ****  * (1 to 10). The size includes the sign bit.
 230:inner.h       ****  */
 231:inner.h       **** extern const uint8_t Zf(max_sig_bits)[];
 232:inner.h       **** 
 233:inner.h       **** /* ==================================================================== */
 234:inner.h       **** /*
 235:inner.h       ****  * Support functions used for both signature generation and signature
 236:inner.h       ****  * verification (common.c).
 237:inner.h       ****  */
 238:inner.h       **** 
 239:inner.h       **** /*
 240:inner.h       ****  * From a SHAKE256 context (must be already flipped), produce a new
 241:inner.h       ****  * point. This is the non-constant-time version, which may leak enough
 242:inner.h       ****  * information to serve as a stop condition on a brute force attack on
 243:inner.h       ****  * the hashed message (provided that the nonce value is known).
 244:inner.h       ****  */
 245:inner.h       **** void Zf(hash_to_point_vartime)(inner_shake256_context *sc,
 246:inner.h       **** 	uint16_t *x, unsigned logn);
 247:inner.h       **** 
 248:inner.h       **** /*
 249:inner.h       ****  * From a SHAKE256 context (must be already flipped), produce a new
 250:inner.h       ****  * point. The temporary buffer (tmp) must have room for 2*2^logn bytes.
 251:inner.h       ****  * This function is constant-time but is typically more expensive than
 252:inner.h       ****  * Zf(hash_to_point_vartime)().
 253:inner.h       ****  *
 254:inner.h       ****  * tmp[] must have 16-bit alignment.
 255:inner.h       ****  */
 256:inner.h       **** void Zf(hash_to_point_ct)(inner_shake256_context *sc,
 257:inner.h       **** 	uint16_t *x, unsigned logn, uint8_t *tmp);
 258:inner.h       **** 
 259:inner.h       **** /*
 260:inner.h       ****  * Tell whether a given vector (2N coordinates, in two halves) is
 261:inner.h       ****  * acceptable as a signature. This compares the appropriate norm of the
 262:inner.h       ****  * vector with the acceptance bound. Returned value is 1 on success
 263:inner.h       ****  * (vector is short enough to be acceptable), 0 otherwise.
 264:inner.h       ****  */
 265:inner.h       **** int Zf(is_short)(const int16_t *s1, const int16_t *s2, unsigned logn);
 266:inner.h       **** 
 267:inner.h       **** /*
 268:inner.h       ****  * Tell whether a given vector (2N coordinates, in two halves) is
 269:inner.h       ****  * acceptable as a signature. Instead of the first half s1, this
 270:inner.h       ****  * function receives the "saturated squared norm" of s1, i.e. the
 271:inner.h       ****  * sum of the squares of the coordinates of s1 (saturated at 2^32-1
 272:inner.h       ****  * if the sum exceeds 2^31-1).
 273:inner.h       ****  *
 274:inner.h       ****  * Returned value is 1 on success (vector is short enough to be
 275:inner.h       ****  * acceptable), 0 otherwise.
 276:inner.h       ****  */
 277:inner.h       **** int Zf(is_short_half)(uint32_t sqn, const int16_t *s2, unsigned logn);
 278:inner.h       **** 
 279:inner.h       **** /* ==================================================================== */
 280:inner.h       **** /*
 281:inner.h       ****  * Signature verification functions (vrfy.c).
 282:inner.h       ****  */
 283:inner.h       **** 
 284:inner.h       **** /*
 285:inner.h       ****  * Convert a public key to NTT + Montgomery format. Conversion is done
 286:inner.h       ****  * in place.
 287:inner.h       ****  */
 288:inner.h       **** void Zf(to_ntt_monty)(uint16_t *h, unsigned logn);
 289:inner.h       **** 
 290:inner.h       **** /*
 291:inner.h       ****  * Internal signature verification code:
 292:inner.h       ****  *   c0[]      contains the hashed nonce+message
 293:inner.h       ****  *   s2[]      is the decoded signature
 294:inner.h       ****  *   h[]       contains the public key, in NTT + Montgomery format
 295:inner.h       ****  *   logn      is the degree log
 296:inner.h       ****  *   tmp[]     temporary, must have at least 2*2^logn bytes
 297:inner.h       ****  * Returned value is 1 on success, 0 on error.
 298:inner.h       ****  *
 299:inner.h       ****  * tmp[] must have 16-bit alignment.
 300:inner.h       ****  */
 301:inner.h       **** int Zf(verify_raw)(const uint16_t *c0, const int16_t *s2,
 302:inner.h       **** 	const uint16_t *h, unsigned logn, uint8_t *tmp);
 303:inner.h       **** 
 304:inner.h       **** /*
 305:inner.h       ****  * Compute the public key h[], given the private key elements f[] and
 306:inner.h       ****  * g[]. This computes h = g/f mod phi mod q, where phi is the polynomial
 307:inner.h       ****  * modulus. This function returns 1 on success, 0 on error (an error is
 308:inner.h       ****  * reported if f is not invertible mod phi mod q).
 309:inner.h       ****  *
 310:inner.h       ****  * The tmp[] array must have room for at least 2*2^logn elements.
 311:inner.h       ****  * tmp[] must have 16-bit alignment.
 312:inner.h       ****  */
 313:inner.h       **** int Zf(compute_public)(uint16_t *h,
 314:inner.h       **** 	const int8_t *f, const int8_t *g, unsigned logn, uint8_t *tmp);
 315:inner.h       **** 
 316:inner.h       **** /*
 317:inner.h       ****  * Recompute the fourth private key element. Private key consists in
 318:inner.h       ****  * four polynomials with small coefficients f, g, F and G, which are
 319:inner.h       ****  * such that fG - gF = q mod phi; furthermore, f is invertible modulo
 320:inner.h       ****  * phi and modulo q. This function recomputes G from f, g and F.
 321:inner.h       ****  *
 322:inner.h       ****  * The tmp[] array must have room for at least 4*2^logn bytes.
 323:inner.h       ****  *
 324:inner.h       ****  * Returned value is 1 in success, 0 on error (f not invertible).
 325:inner.h       ****  * tmp[] must have 16-bit alignment.
 326:inner.h       ****  */
 327:inner.h       **** int Zf(complete_private)(int8_t *G,
 328:inner.h       **** 	const int8_t *f, const int8_t *g, const int8_t *F,
 329:inner.h       **** 	unsigned logn, uint8_t *tmp);
 330:inner.h       **** 
 331:inner.h       **** /*
 332:inner.h       ****  * Test whether a given polynomial is invertible modulo phi and q.
 333:inner.h       ****  * Polynomial coefficients are small integers.
 334:inner.h       ****  *
 335:inner.h       ****  * tmp[] must have 16-bit alignment.
 336:inner.h       ****  */
 337:inner.h       **** int Zf(is_invertible)(
 338:inner.h       **** 	const int16_t *s2, unsigned logn, uint8_t *tmp);
 339:inner.h       **** 
 340:inner.h       **** /*
 341:inner.h       ****  * Count the number of elements of value zero in the NTT representation
 342:inner.h       ****  * of the given polynomial: this is the number of primitive 2n-th roots
 343:inner.h       ****  * of unity (modulo q = 12289) that are roots of the provided polynomial
 344:inner.h       ****  * (taken modulo q).
 345:inner.h       ****  *
 346:inner.h       ****  * tmp[] must have 16-bit alignment.
 347:inner.h       ****  */
 348:inner.h       **** int Zf(count_nttzero)(const int16_t *sig, unsigned logn, uint8_t *tmp);
 349:inner.h       **** 
 350:inner.h       **** /*
 351:inner.h       ****  * Internal signature verification with public key recovery:
 352:inner.h       ****  *   h[]       receives the public key (NOT in NTT/Montgomery format)
 353:inner.h       ****  *   c0[]      contains the hashed nonce+message
 354:inner.h       ****  *   s1[]      is the first signature half
 355:inner.h       ****  *   s2[]      is the second signature half
 356:inner.h       ****  *   logn      is the degree log
 357:inner.h       ****  *   tmp[]     temporary, must have at least 2*2^logn bytes
 358:inner.h       ****  * Returned value is 1 on success, 0 on error. Success is returned if
 359:inner.h       ****  * the signature is a short enough vector; in that case, the public
 360:inner.h       ****  * key has been written to h[]. However, the caller must still
 361:inner.h       ****  * verify that h[] is the correct value (e.g. with regards to a known
 362:inner.h       ****  * hash of the public key).
 363:inner.h       ****  *
 364:inner.h       ****  * h[] may not overlap with any of the other arrays.
 365:inner.h       ****  *
 366:inner.h       ****  * tmp[] must have 16-bit alignment.
 367:inner.h       ****  */
 368:inner.h       **** int Zf(verify_recover)(uint16_t *h,
 369:inner.h       **** 	const uint16_t *c0, const int16_t *s1, const int16_t *s2,
 370:inner.h       **** 	unsigned logn, uint8_t *tmp);
 371:inner.h       **** 
 372:inner.h       **** /* ==================================================================== */
 373:inner.h       **** /*
 374:inner.h       ****  * Implementation of floating-point real numbers (fpr.h, fpr.c).
 375:inner.h       ****  */
 376:inner.h       **** 
 377:inner.h       **** /*
 378:inner.h       ****  * Real numbers are implemented by an extra header file, included below.
 379:inner.h       ****  * This is meant to support pluggable implementations. The default
 380:inner.h       ****  * implementation relies on the C type 'double'.
 381:inner.h       ****  *
 382:inner.h       ****  * The included file must define the following types, functions and
 383:inner.h       ****  * constants:
 384:inner.h       ****  *
 385:inner.h       ****  *   fpr
 386:inner.h       ****  *         type for a real number
 387:inner.h       ****  *
 388:inner.h       ****  *   fpr fpr_of(int64_t i)
 389:inner.h       ****  *         cast an integer into a real number; source must be in the
 390:inner.h       ****  *         -(2^63-1)..+(2^63-1) range
 391:inner.h       ****  *
 392:inner.h       ****  *   fpr fpr_scaled(int64_t i, int sc)
 393:inner.h       ****  *         compute i*2^sc as a real number; source 'i' must be in the
 394:inner.h       ****  *         -(2^63-1)..+(2^63-1) range
 395:inner.h       ****  *
 396:inner.h       ****  *   fpr fpr_ldexp(fpr x, int e)
 397:inner.h       ****  *         compute x*2^e
 398:inner.h       ****  *
 399:inner.h       ****  *   int64_t fpr_rint(fpr x)
 400:inner.h       ****  *         round x to the nearest integer; x must be in the -(2^63-1)
 401:inner.h       ****  *         to +(2^63-1) range
 402:inner.h       ****  *
 403:inner.h       ****  *   int64_t fpr_trunc(fpr x)
 404:inner.h       ****  *         round to an integer; this rounds towards zero; value must
 405:inner.h       ****  *         be in the -(2^63-1) to +(2^63-1) range
 406:inner.h       ****  *
 407:inner.h       ****  *   fpr fpr_add(fpr x, fpr y)
 408:inner.h       ****  *         compute x + y
 409:inner.h       ****  *
 410:inner.h       ****  *   fpr fpr_sub(fpr x, fpr y)
 411:inner.h       ****  *         compute x - y
 412:inner.h       ****  *
 413:inner.h       ****  *   fpr fpr_neg(fpr x)
 414:inner.h       ****  *         compute -x
 415:inner.h       ****  *
 416:inner.h       ****  *   fpr fpr_half(fpr x)
 417:inner.h       ****  *         compute x/2
 418:inner.h       ****  *
 419:inner.h       ****  *   fpr fpr_double(fpr x)
 420:inner.h       ****  *         compute x*2
 421:inner.h       ****  *
 422:inner.h       ****  *   fpr fpr_mul(fpr x, fpr y)
 423:inner.h       ****  *         compute x * y
 424:inner.h       ****  *
 425:inner.h       ****  *   fpr fpr_sqr(fpr x)
 426:inner.h       ****  *         compute x * x
 427:inner.h       ****  *
 428:inner.h       ****  *   fpr fpr_inv(fpr x)
 429:inner.h       ****  *         compute 1/x
 430:inner.h       ****  *
 431:inner.h       ****  *   fpr fpr_div(fpr x, fpr y)
 432:inner.h       ****  *         compute x/y
 433:inner.h       ****  *
 434:inner.h       ****  *   fpr fpr_sqrt(fpr x)
 435:inner.h       ****  *         compute the square root of x
 436:inner.h       ****  *
 437:inner.h       ****  *   int fpr_lt(fpr x, fpr y)
 438:inner.h       ****  *         return 1 if x < y, 0 otherwise
 439:inner.h       ****  *
 440:inner.h       ****  *   uint64_t fpr_expm_p63(fpr x)
 441:inner.h       ****  *         return exp(x), assuming that 0 <= x < log(2). Returned value
 442:inner.h       ****  *         is scaled to 63 bits (i.e. it really returns 2^63*exp(-x),
 443:inner.h       ****  *         rounded to the nearest integer). Computation should have a
 444:inner.h       ****  *         precision of at least 45 bits.
 445:inner.h       ****  *
 446:inner.h       ****  *   const fpr fpr_gm_tab[]
 447:inner.h       ****  *         array of constants for FFT / iFFT
 448:inner.h       ****  *
 449:inner.h       ****  *   const fpr fpr_p2_tab[]
 450:inner.h       ****  *         precomputed powers of 2 (by index, 0 to 10)
 451:inner.h       ****  *
 452:inner.h       ****  * Constants of type 'fpr':
 453:inner.h       ****  *
 454:inner.h       ****  *   fpr fpr_q                 12289
 455:inner.h       ****  *   fpr fpr_inverse_of_q      1/12289
 456:inner.h       ****  *   fpr fpr_inv_2sqrsigma0    1/(2*(1.8205^2))
 457:inner.h       ****  *   fpr fpr_inv_sigma[]       1/sigma (indexed by logn, 1 to 10)
 458:inner.h       ****  *   fpr fpr_sigma_min[]       1/sigma_min (indexed by logn, 1 to 10)
 459:inner.h       ****  *   fpr fpr_log2              log(2)
 460:inner.h       ****  *   fpr fpr_inv_log2          1/log(2)
 461:inner.h       ****  *   fpr fpr_bnorm_max         16822.4121
 462:inner.h       ****  *   fpr fpr_zero              0
 463:inner.h       ****  *   fpr fpr_one               1
 464:inner.h       ****  *   fpr fpr_two               2
 465:inner.h       ****  *   fpr fpr_onehalf           0.5
 466:inner.h       ****  *   fpr fpr_ptwo31            2^31
 467:inner.h       ****  *   fpr fpr_ptwo31m1          2^31-1
 468:inner.h       ****  *   fpr fpr_mtwo31m1          -(2^31-1)
 469:inner.h       ****  *   fpr fpr_ptwo63m1          2^63-1
 470:inner.h       ****  *   fpr fpr_mtwo63m1          -(2^63-1)
 471:inner.h       ****  *   fpr fpr_ptwo63            2^63
 472:inner.h       ****  */
 473:inner.h       **** #include "fpr.h"
 474:inner.h       **** 
 475:inner.h       **** /* ==================================================================== */
 476:inner.h       **** /*
 477:inner.h       ****  * RNG (rng.c).
 478:inner.h       ****  *
 479:inner.h       ****  * A PRNG based on ChaCha20 is implemented; it is seeded from a SHAKE256
 480:inner.h       ****  * context (flipped) and is used for bulk pseudorandom generation.
 481:inner.h       ****  * A system-dependent seed generator is also provided.
 482:inner.h       ****  */
 483:inner.h       **** 
 484:inner.h       **** /*
 485:inner.h       ****  * Obtain a random seed from the system RNG.
 486:inner.h       ****  *
 487:inner.h       ****  * Returned value is 1 on success, 0 on error.
 488:inner.h       ****  */
 489:inner.h       **** int Zf(get_seed)(void *seed, size_t seed_len);
 490:inner.h       **** 
 491:inner.h       **** /*
 492:inner.h       ****  * Structure for a PRNG. This includes a large buffer so that values
 493:inner.h       ****  * get generated in advance. The 'state' is used to keep the current
 494:inner.h       ****  * PRNG algorithm state (contents depend on the selected algorithm).
 495:inner.h       ****  *
 496:inner.h       ****  * The unions with 'dummy_u64' are there to ensure proper alignment for
 497:inner.h       ****  * 64-bit direct access.
 498:inner.h       ****  */
 499:inner.h       **** typedef struct {
 500:inner.h       **** 	union {
 501:inner.h       **** 		uint8_t d[512]; /* MUST be 512, exactly */
 502:inner.h       **** 		uint64_t dummy_u64;
 503:inner.h       **** 	} buf;
 504:inner.h       **** 	size_t ptr;
 505:inner.h       **** 	union {
 506:inner.h       **** 		uint8_t d[256];
 507:inner.h       **** 		uint64_t dummy_u64;
 508:inner.h       **** 	} state;
 509:inner.h       **** 	int type;
 510:inner.h       **** } prng;
 511:inner.h       **** 
 512:inner.h       **** /*
 513:inner.h       ****  * Instantiate a PRNG. That PRNG will feed over the provided SHAKE256
 514:inner.h       ****  * context (in "flipped" state) to obtain its initial state.
 515:inner.h       ****  */
 516:inner.h       **** void Zf(prng_init)(prng *p, inner_shake256_context *src);
 517:inner.h       **** 
 518:inner.h       **** /*
 519:inner.h       ****  * Refill the PRNG buffer. This is normally invoked automatically, and
 520:inner.h       ****  * is declared here only so that prng_get_u64() may be inlined.
 521:inner.h       ****  */
 522:inner.h       **** void Zf(prng_refill)(prng *p);
 523:inner.h       **** 
 524:inner.h       **** /*
 525:inner.h       ****  * Get some bytes from a PRNG.
 526:inner.h       ****  */
 527:inner.h       **** void Zf(prng_get_bytes)(prng *p, void *dst, size_t len);
 528:inner.h       **** 
 529:inner.h       **** /*
 530:inner.h       ****  * Get a 64-bit random value from a PRNG.
 531:inner.h       ****  */
 532:inner.h       **** static inline uint64_t
 533:inner.h       **** prng_get_u64(prng *p)
 534:inner.h       **** {
 1324              		.loc 2 534 1
 1325              		.cfi_startproc
 1326              		@ args = 0, pretend = 0, frame = 120
 1327              		@ frame_needed = 1, uses_anonymous_args = 0
 1328 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 1329              	.LCFI60:
 1330              		.cfi_def_cfa_offset 32
 1331              		.cfi_offset 4, -32
 1332              		.cfi_offset 5, -28
 1333              		.cfi_offset 7, -24
 1334              		.cfi_offset 8, -20
 1335              		.cfi_offset 9, -16
 1336              		.cfi_offset 10, -12
 1337              		.cfi_offset 11, -8
 1338              		.cfi_offset 14, -4
 1339 0004 9EB0     		sub	sp, sp, #120
 1340              	.LCFI61:
 1341              		.cfi_def_cfa_offset 152
 1342 0006 00AF     		add	r7, sp, #0
 1343              	.LCFI62:
 1344              		.cfi_def_cfa_register 7
 1345 0008 F866     		str	r0, [r7, #108]
 535:inner.h       **** 	size_t u;
 536:inner.h       **** 
 537:inner.h       **** 	/*
 538:inner.h       **** 	 * If there are less than 9 bytes in the buffer, we refill it.
 539:inner.h       **** 	 * This means that we may drop the last few bytes, but this allows
 540:inner.h       **** 	 * for faster extraction code. Also, it means that we never leave
 541:inner.h       **** 	 * an empty buffer.
 542:inner.h       **** 	 */
 543:inner.h       **** 	u = p->ptr;
 1346              		.loc 2 543 4
 1347 000a FB6E     		ldr	r3, [r7, #108]
 1348 000c D3F80032 		ldr	r3, [r3, #512]
 1349 0010 7B67     		str	r3, [r7, #116]
 544:inner.h       **** 	if (u >= (sizeof p->buf.d) - 9) {
 1350              		.loc 2 544 5
 1351 0012 7B6F     		ldr	r3, [r7, #116]
 1352 0014 B3F5FB7F 		cmp	r3, #502
 1353 0018 04D9     		bls	.L25
 545:inner.h       **** 		Zf(prng_refill)(p);
 1354              		.loc 2 545 3
 1355 001a F86E     		ldr	r0, [r7, #108]
 1356 001c FFF7FEFF 		bl	falcon_inner_prng_refill
 546:inner.h       **** 		u = 0;
 1357              		.loc 2 546 5
 1358 0020 0023     		movs	r3, #0
 1359 0022 7B67     		str	r3, [r7, #116]
 1360              	.L25:
 547:inner.h       **** 	}
 548:inner.h       **** 	p->ptr = u + 8;
 1361              		.loc 2 548 13
 1362 0024 7B6F     		ldr	r3, [r7, #116]
 1363 0026 03F10802 		add	r2, r3, #8
 1364              		.loc 2 548 9
 1365 002a FB6E     		ldr	r3, [r7, #108]
 1366 002c C3F80022 		str	r2, [r3, #512]
 549:inner.h       **** 
 550:inner.h       **** 	/*
 551:inner.h       **** 	 * On systems that use little-endian encoding and allow
 552:inner.h       **** 	 * unaligned accesses, we can simply read the data where it is.
 553:inner.h       **** 	 */
 554:inner.h       **** 	return (uint64_t)p->buf.d[u + 0]
 1367              		.loc 2 554 27
 1368 0030 FA6E     		ldr	r2, [r7, #108]
 1369 0032 7B6F     		ldr	r3, [r7, #116]
 1370 0034 1344     		add	r3, r3, r2
 1371 0036 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1372              		.loc 2 554 9
 1373 0038 DBB2     		uxtb	r3, r3
 1374 003a 0022     		movs	r2, #0
 1375 003c 3B66     		str	r3, [r7, #96]
 1376 003e 7A66     		str	r2, [r7, #100]
 555:inner.h       **** 		| ((uint64_t)p->buf.d[u + 1] << 8)
 1377              		.loc 2 555 27
 1378 0040 7B6F     		ldr	r3, [r7, #116]
 1379 0042 5A1C     		adds	r2, r3, #1
 1380              		.loc 2 555 24
 1381 0044 FB6E     		ldr	r3, [r7, #108]
 1382 0046 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 1383              		.loc 2 555 6
 1384 0048 DBB2     		uxtb	r3, r3
 1385 004a 0022     		movs	r2, #0
 1386 004c 1C46     		mov	r4, r3
 1387 004e 1546     		mov	r5, r2
 1388              		.loc 2 555 32
 1389 0050 4FF00002 		mov	r2, #0
 1390 0054 4FF00003 		mov	r3, #0
 1391 0058 2B02     		lsls	r3, r5, #8
 1392 005a 43EA1463 		orr	r3, r3, r4, lsr #24
 1393 005e 2202     		lsls	r2, r4, #8
 1394              		.loc 2 555 3
 1395 0060 D7E91801 		ldrd	r0, [r7, #96]
 1396 0064 0446     		mov	r4, r0
 1397 0066 44EA020A 		orr	r10, r4, r2
 1398 006a 41EA030B 		orr	fp, r1, r3
 556:inner.h       **** 		| ((uint64_t)p->buf.d[u + 2] << 16)
 1399              		.loc 2 556 27
 1400 006e 7B6F     		ldr	r3, [r7, #116]
 1401 0070 9A1C     		adds	r2, r3, #2
 1402              		.loc 2 556 24
 1403 0072 FB6E     		ldr	r3, [r7, #108]
 1404 0074 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 1405              		.loc 2 556 6
 1406 0076 DBB2     		uxtb	r3, r3
 1407 0078 0022     		movs	r2, #0
 1408 007a BB65     		str	r3, [r7, #88]
 1409 007c FA65     		str	r2, [r7, #92]
 1410              		.loc 2 556 32
 1411 007e 4FF00002 		mov	r2, #0
 1412 0082 4FF00003 		mov	r3, #0
 1413 0086 D7E91645 		ldrd	r4, [r7, #88]
 1414 008a 2946     		mov	r1, r5
 1415 008c 0B04     		lsls	r3, r1, #16
 1416 008e 2046     		mov	r0, r4
 1417 0090 2946     		mov	r1, r5
 1418 0092 0446     		mov	r4, r0
 1419 0094 43EA1443 		orr	r3, r3, r4, lsr #16
 1420 0098 0146     		mov	r1, r0
 1421 009a 0A04     		lsls	r2, r1, #16
 1422              		.loc 2 556 3
 1423 009c 4AEA0201 		orr	r1, r10, r2
 1424 00a0 3965     		str	r1, [r7, #80]
 1425 00a2 4BEA0303 		orr	r3, fp, r3
 1426 00a6 7B65     		str	r3, [r7, #84]
 557:inner.h       **** 		| ((uint64_t)p->buf.d[u + 3] << 24)
 1427              		.loc 2 557 27
 1428 00a8 7B6F     		ldr	r3, [r7, #116]
 1429 00aa DA1C     		adds	r2, r3, #3
 1430              		.loc 2 557 24
 1431 00ac FB6E     		ldr	r3, [r7, #108]
 1432 00ae 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 1433              		.loc 2 557 6
 1434 00b0 DBB2     		uxtb	r3, r3
 1435 00b2 0022     		movs	r2, #0
 1436 00b4 BB64     		str	r3, [r7, #72]
 1437 00b6 FA64     		str	r2, [r7, #76]
 1438              		.loc 2 557 32
 1439 00b8 D7E91234 		ldrd	r3, [r7, #72]
 1440 00bc 1A46     		mov	r2, r3
 1441 00be 4FEA1229 		lsr	r9, r2, #8
 1442 00c2 4FEA0368 		lsl	r8, r3, #24
 1443              		.loc 2 557 3
 1444 00c6 D7E91434 		ldrd	r3, [r7, #80]
 1445 00ca 1A46     		mov	r2, r3
 1446 00cc 42EA0802 		orr	r2, r2, r8
 1447 00d0 3A64     		str	r2, [r7, #64]
 1448 00d2 2346     		mov	r3, r4
 1449 00d4 43EA0903 		orr	r3, r3, r9
 1450 00d8 7B64     		str	r3, [r7, #68]
 558:inner.h       **** 		| ((uint64_t)p->buf.d[u + 4] << 32)
 1451              		.loc 2 558 27
 1452 00da 7B6F     		ldr	r3, [r7, #116]
 1453 00dc 1A1D     		adds	r2, r3, #4
 1454              		.loc 2 558 24
 1455 00de FB6E     		ldr	r3, [r7, #108]
 1456 00e0 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 1457              		.loc 2 558 6
 1458 00e2 DBB2     		uxtb	r3, r3
 1459 00e4 0022     		movs	r2, #0
 1460 00e6 BB63     		str	r3, [r7, #56]
 1461 00e8 FA63     		str	r2, [r7, #60]
 1462              		.loc 2 558 32
 1463 00ea 4FF00002 		mov	r2, #0
 1464 00ee 4FF00003 		mov	r3, #0
 1465 00f2 B96B     		ldr	r1, [r7, #56]
 1466 00f4 0B00     		movs	r3, r1
 1467 00f6 0022     		movs	r2, #0
 1468              		.loc 2 558 3
 1469 00f8 D7E91001 		ldrd	r0, [r7, #64]
 1470 00fc 0446     		mov	r4, r0
 1471 00fe 1443     		orrs	r4, r4, r2
 1472 0100 3C63     		str	r4, [r7, #48]
 1473 0102 1943     		orrs	r1, r1, r3
 1474 0104 7963     		str	r1, [r7, #52]
 559:inner.h       **** 		| ((uint64_t)p->buf.d[u + 5] << 40)
 1475              		.loc 2 559 27
 1476 0106 7B6F     		ldr	r3, [r7, #116]
 1477 0108 5A1D     		adds	r2, r3, #5
 1478              		.loc 2 559 24
 1479 010a FB6E     		ldr	r3, [r7, #108]
 1480 010c 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 1481              		.loc 2 559 6
 1482 010e DBB2     		uxtb	r3, r3
 1483 0110 0022     		movs	r2, #0
 1484 0112 BB62     		str	r3, [r7, #40]
 1485 0114 FA62     		str	r2, [r7, #44]
 1486              		.loc 2 559 32
 1487 0116 4FF00002 		mov	r2, #0
 1488 011a 4FF00003 		mov	r3, #0
 1489 011e B96A     		ldr	r1, [r7, #40]
 1490 0120 0B02     		lsls	r3, r1, #8
 1491 0122 0022     		movs	r2, #0
 1492              		.loc 2 559 3
 1493 0124 D7E90C01 		ldrd	r0, [r7, #48]
 1494 0128 0446     		mov	r4, r0
 1495 012a 1443     		orrs	r4, r4, r2
 1496 012c 3C62     		str	r4, [r7, #32]
 1497 012e 1943     		orrs	r1, r1, r3
 1498 0130 7962     		str	r1, [r7, #36]
 560:inner.h       **** 		| ((uint64_t)p->buf.d[u + 6] << 48)
 1499              		.loc 2 560 27
 1500 0132 7B6F     		ldr	r3, [r7, #116]
 1501 0134 0633     		adds	r3, r3, #6
 1502              		.loc 2 560 24
 1503 0136 FA6E     		ldr	r2, [r7, #108]
 1504 0138 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 1505              		.loc 2 560 6
 1506 013a DBB2     		uxtb	r3, r3
 1507 013c 0022     		movs	r2, #0
 1508 013e BB61     		str	r3, [r7, #24]
 1509 0140 FA61     		str	r2, [r7, #28]
 1510              		.loc 2 560 32
 1511 0142 4FF00002 		mov	r2, #0
 1512 0146 4FF00003 		mov	r3, #0
 1513 014a B969     		ldr	r1, [r7, #24]
 1514 014c 0B04     		lsls	r3, r1, #16
 1515 014e 0022     		movs	r2, #0
 1516              		.loc 2 560 3
 1517 0150 D7E90801 		ldrd	r0, [r7, #32]
 1518 0154 0446     		mov	r4, r0
 1519 0156 1443     		orrs	r4, r4, r2
 1520 0158 3C61     		str	r4, [r7, #16]
 1521 015a 1943     		orrs	r1, r1, r3
 1522 015c 7961     		str	r1, [r7, #20]
 561:inner.h       **** 		| ((uint64_t)p->buf.d[u + 7] << 56);
 1523              		.loc 2 561 27
 1524 015e 7B6F     		ldr	r3, [r7, #116]
 1525 0160 0733     		adds	r3, r3, #7
 1526              		.loc 2 561 24
 1527 0162 FA6E     		ldr	r2, [r7, #108]
 1528 0164 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 1529              		.loc 2 561 6
 1530 0166 DBB2     		uxtb	r3, r3
 1531 0168 0022     		movs	r2, #0
 1532 016a BB60     		str	r3, [r7, #8]
 1533 016c FA60     		str	r2, [r7, #12]
 1534              		.loc 2 561 32
 1535 016e 4FF00002 		mov	r2, #0
 1536 0172 4FF00003 		mov	r3, #0
 1537 0176 B968     		ldr	r1, [r7, #8]
 1538 0178 0B06     		lsls	r3, r1, #24
 1539 017a 0022     		movs	r2, #0
 1540              		.loc 2 561 3
 1541 017c D7E90401 		ldrd	r0, [r7, #16]
 1542 0180 0446     		mov	r4, r0
 1543 0182 1443     		orrs	r4, r4, r2
 1544 0184 3C60     		str	r4, [r7]
 1545 0186 1943     		orrs	r1, r1, r3
 1546 0188 7960     		str	r1, [r7, #4]
 1547 018a D7E90023 		ldrd	r2, [r7]
 562:inner.h       **** }
 1548              		.loc 2 562 1
 1549 018e 1046     		mov	r0, r2
 1550 0190 1946     		mov	r1, r3
 1551 0192 7837     		adds	r7, r7, #120
 1552              	.LCFI63:
 1553              		.cfi_def_cfa_offset 32
 1554 0194 BD46     		mov	sp, r7
 1555              	.LCFI64:
 1556              		.cfi_def_cfa_register 13
 1557              		@ sp needed
 1558 0196 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 1559              		.cfi_endproc
 1560              	.LFE16:
 1562              		.section	.text.prng_get_u8,"ax",%progbits
 1563              		.align	1
 1564              		.syntax unified
 1565              		.thumb
 1566              		.thumb_func
 1567              		.fpu softvfp
 1569              	prng_get_u8:
 1570              	.LFB17:
 563:inner.h       **** 
 564:inner.h       **** /*
 565:inner.h       ****  * Get an 8-bit random value from a PRNG.
 566:inner.h       ****  */
 567:inner.h       **** static inline unsigned
 568:inner.h       **** prng_get_u8(prng *p)
 569:inner.h       **** {
 1571              		.loc 2 569 1
 1572              		.cfi_startproc
 1573              		@ args = 0, pretend = 0, frame = 16
 1574              		@ frame_needed = 1, uses_anonymous_args = 0
 1575 0000 80B5     		push	{r7, lr}
 1576              	.LCFI65:
 1577              		.cfi_def_cfa_offset 8
 1578              		.cfi_offset 7, -8
 1579              		.cfi_offset 14, -4
 1580 0002 84B0     		sub	sp, sp, #16
 1581              	.LCFI66:
 1582              		.cfi_def_cfa_offset 24
 1583 0004 00AF     		add	r7, sp, #0
 1584              	.LCFI67:
 1585              		.cfi_def_cfa_register 7
 1586 0006 7860     		str	r0, [r7, #4]
 570:inner.h       **** 	unsigned v;
 571:inner.h       **** 
 572:inner.h       **** 	v = p->buf.d[p->ptr ++];
 1587              		.loc 2 572 16
 1588 0008 7B68     		ldr	r3, [r7, #4]
 1589 000a D3F80032 		ldr	r3, [r3, #512]
 1590              		.loc 2 572 22
 1591 000e 591C     		adds	r1, r3, #1
 1592 0010 7A68     		ldr	r2, [r7, #4]
 1593 0012 C2F80012 		str	r1, [r2, #512]
 1594              		.loc 2 572 14
 1595 0016 7A68     		ldr	r2, [r7, #4]
 1596 0018 D35C     		ldrb	r3, [r2, r3]	@ zero_extendqisi2
 1597              		.loc 2 572 4
 1598 001a FB60     		str	r3, [r7, #12]
 573:inner.h       **** 	if (p->ptr == sizeof p->buf.d) {
 1599              		.loc 2 573 7
 1600 001c 7B68     		ldr	r3, [r7, #4]
 1601 001e D3F80032 		ldr	r3, [r3, #512]
 1602              		.loc 2 573 5
 1603 0022 B3F5007F 		cmp	r3, #512
 1604 0026 02D1     		bne	.L28
 574:inner.h       **** 		Zf(prng_refill)(p);
 1605              		.loc 2 574 3
 1606 0028 7868     		ldr	r0, [r7, #4]
 1607 002a FFF7FEFF 		bl	falcon_inner_prng_refill
 1608              	.L28:
 575:inner.h       **** 	}
 576:inner.h       **** 	return v;
 1609              		.loc 2 576 9
 1610 002e FB68     		ldr	r3, [r7, #12]
 577:inner.h       **** }
 1611              		.loc 2 577 1
 1612 0030 1846     		mov	r0, r3
 1613 0032 1037     		adds	r7, r7, #16
 1614              	.LCFI68:
 1615              		.cfi_def_cfa_offset 8
 1616 0034 BD46     		mov	sp, r7
 1617              	.LCFI69:
 1618              		.cfi_def_cfa_register 13
 1619              		@ sp needed
 1620 0036 80BD     		pop	{r7, pc}
 1621              		.cfi_endproc
 1622              	.LFE17:
 1624              		.section	.text.ffLDL_treesize,"ax",%progbits
 1625              		.align	1
 1626              		.syntax unified
 1627              		.thumb
 1628              		.thumb_func
 1629              		.fpu softvfp
 1631              	ffLDL_treesize:
 1632              	.LFB18:
 1633              		.file 3 "sign.c"
   1:sign.c        **** /*
   2:sign.c        ****  * Falcon signature generation.
   3:sign.c        ****  *
   4:sign.c        ****  * ==========================(LICENSE BEGIN)============================
   5:sign.c        ****  *
   6:sign.c        ****  * Copyright (c) 2017-2019  Falcon Project
   7:sign.c        ****  *
   8:sign.c        ****  * Permission is hereby granted, free of charge, to any person obtaining
   9:sign.c        ****  * a copy of this software and associated documentation files (the
  10:sign.c        ****  * "Software"), to deal in the Software without restriction, including
  11:sign.c        ****  * without limitation the rights to use, copy, modify, merge, publish,
  12:sign.c        ****  * distribute, sublicense, and/or sell copies of the Software, and to
  13:sign.c        ****  * permit persons to whom the Software is furnished to do so, subject to
  14:sign.c        ****  * the following conditions:
  15:sign.c        ****  *
  16:sign.c        ****  * The above copyright notice and this permission notice shall be
  17:sign.c        ****  * included in all copies or substantial portions of the Software.
  18:sign.c        ****  *
  19:sign.c        ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  20:sign.c        ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  21:sign.c        ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  22:sign.c        ****  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  23:sign.c        ****  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  24:sign.c        ****  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  25:sign.c        ****  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  26:sign.c        ****  *
  27:sign.c        ****  * ===========================(LICENSE END)=============================
  28:sign.c        ****  *
  29:sign.c        ****  * @author   Thomas Pornin <thomas.pornin@nccgroup.com>
  30:sign.c        ****  */
  31:sign.c        **** 
  32:sign.c        **** #include "inner.h"
  33:sign.c        **** #include "hal.h"
  34:sign.c        **** #include "simpleserial.h"
  35:sign.c        **** /* =================================================================== */
  36:sign.c        **** 
  37:sign.c        **** /*
  38:sign.c        ****  * Compute degree N from logarithm 'logn'.
  39:sign.c        ****  */
  40:sign.c        **** #define MKN(logn)   ((size_t)1 << (logn))
  41:sign.c        **** 
  42:sign.c        **** /* =================================================================== */
  43:sign.c        **** /*
  44:sign.c        ****  * Binary case:
  45:sign.c        ****  *   N = 2^logn
  46:sign.c        ****  *   phi = X^N+1
  47:sign.c        ****  */
  48:sign.c        **** 
  49:sign.c        **** /*
  50:sign.c        ****  * Get the size of the LDL tree for an input with polynomials of size
  51:sign.c        ****  * 2^logn. The size is expressed in the number of elements.
  52:sign.c        ****  */
  53:sign.c        **** static inline unsigned
  54:sign.c        **** ffLDL_treesize(unsigned logn)
  55:sign.c        **** {
 1634              		.loc 3 55 1
 1635              		.cfi_startproc
 1636              		@ args = 0, pretend = 0, frame = 8
 1637              		@ frame_needed = 1, uses_anonymous_args = 0
 1638              		@ link register save eliminated.
 1639 0000 80B4     		push	{r7}
 1640              	.LCFI70:
 1641              		.cfi_def_cfa_offset 4
 1642              		.cfi_offset 7, -4
 1643 0002 83B0     		sub	sp, sp, #12
 1644              	.LCFI71:
 1645              		.cfi_def_cfa_offset 16
 1646 0004 00AF     		add	r7, sp, #0
 1647              	.LCFI72:
 1648              		.cfi_def_cfa_register 7
 1649 0006 7860     		str	r0, [r7, #4]
  56:sign.c        **** 	/*
  57:sign.c        **** 	 * For logn = 0 (polynomials are constant), the "tree" is a
  58:sign.c        **** 	 * single element. Otherwise, the tree node has size 2^logn, and
  59:sign.c        **** 	 * has two child trees for size logn-1 each. Thus, treesize s()
  60:sign.c        **** 	 * must fulfill these two relations:
  61:sign.c        **** 	 *
  62:sign.c        **** 	 *   s(0) = 1
  63:sign.c        **** 	 *   s(logn) = (2^logn) + 2*s(logn-1)
  64:sign.c        **** 	 */
  65:sign.c        **** 	return (logn + 1) << logn;
 1650              		.loc 3 65 15
 1651 0008 7B68     		ldr	r3, [r7, #4]
 1652 000a 5A1C     		adds	r2, r3, #1
 1653              		.loc 3 65 20
 1654 000c 7B68     		ldr	r3, [r7, #4]
 1655 000e 02FA03F3 		lsl	r3, r2, r3
  66:sign.c        **** }
 1656              		.loc 3 66 1
 1657 0012 1846     		mov	r0, r3
 1658 0014 0C37     		adds	r7, r7, #12
 1659              	.LCFI73:
 1660              		.cfi_def_cfa_offset 4
 1661 0016 BD46     		mov	sp, r7
 1662              	.LCFI74:
 1663              		.cfi_def_cfa_register 13
 1664              		@ sp needed
 1665 0018 80BC     		pop	{r7}
 1666              	.LCFI75:
 1667              		.cfi_restore 7
 1668              		.cfi_def_cfa_offset 0
 1669 001a 7047     		bx	lr
 1670              		.cfi_endproc
 1671              	.LFE18:
 1673              		.section	.text.ffLDL_fft_inner,"ax",%progbits
 1674              		.align	1
 1675              		.syntax unified
 1676              		.thumb
 1677              		.thumb_func
 1678              		.fpu softvfp
 1680              	ffLDL_fft_inner:
 1681              	.LFB19:
  67:sign.c        **** 
  68:sign.c        **** /*
  69:sign.c        ****  * Inner function for ffLDL_fft(). It expects the matrix to be both
  70:sign.c        ****  * auto-adjoint and quasicyclic; also, it uses the source operands
  71:sign.c        ****  * as modifiable temporaries.
  72:sign.c        ****  *
  73:sign.c        ****  * tmp[] must have room for at least one polynomial.
  74:sign.c        ****  */
  75:sign.c        **** static void
  76:sign.c        **** ffLDL_fft_inner(fpr *restrict tree,
  77:sign.c        **** 	fpr *restrict g0, fpr *restrict g1, unsigned logn, fpr *restrict tmp)
  78:sign.c        **** {
 1682              		.loc 3 78 1
 1683              		.cfi_startproc
 1684              		@ args = 4, pretend = 0, frame = 24
 1685              		@ frame_needed = 1, uses_anonymous_args = 0
 1686 0000 80B5     		push	{r7, lr}
 1687              	.LCFI76:
 1688              		.cfi_def_cfa_offset 8
 1689              		.cfi_offset 7, -8
 1690              		.cfi_offset 14, -4
 1691 0002 88B0     		sub	sp, sp, #32
 1692              	.LCFI77:
 1693              		.cfi_def_cfa_offset 40
 1694 0004 02AF     		add	r7, sp, #8
 1695              	.LCFI78:
 1696              		.cfi_def_cfa 7, 32
 1697 0006 F860     		str	r0, [r7, #12]
 1698 0008 B960     		str	r1, [r7, #8]
 1699 000a 7A60     		str	r2, [r7, #4]
 1700 000c 3B60     		str	r3, [r7]
  79:sign.c        **** 	size_t n, hn;
  80:sign.c        **** 
  81:sign.c        **** 	n = MKN(logn);
 1701              		.loc 3 81 4
 1702 000e 0122     		movs	r2, #1
 1703 0010 3B68     		ldr	r3, [r7]
 1704 0012 02FA03F3 		lsl	r3, r2, r3
 1705 0016 7B61     		str	r3, [r7, #20]
  82:sign.c        **** 	if (n == 1) {
 1706              		.loc 3 82 5
 1707 0018 7B69     		ldr	r3, [r7, #20]
 1708 001a 012B     		cmp	r3, #1
 1709 001c 06D1     		bne	.L33
  83:sign.c        **** 		tree[0] = g0[0];
 1710              		.loc 3 83 15
 1711 001e BB68     		ldr	r3, [r7, #8]
 1712 0020 D3E90023 		ldrd	r2, [r3]
 1713              		.loc 3 83 11
 1714 0024 F968     		ldr	r1, [r7, #12]
 1715 0026 C1E90023 		strd	r2, [r1]
  84:sign.c        **** 		return;
 1716              		.loc 3 84 3
 1717 002a 45E0     		b	.L32
 1718              	.L33:
  85:sign.c        **** 	}
  86:sign.c        **** 	hn = n >> 1;
 1719              		.loc 3 86 5
 1720 002c 7B69     		ldr	r3, [r7, #20]
 1721 002e 5B08     		lsrs	r3, r3, #1
 1722 0030 3B61     		str	r3, [r7, #16]
  87:sign.c        **** 
  88:sign.c        **** 	/*
  89:sign.c        **** 	 * The LDL decomposition yields L (which is written in the tree)
  90:sign.c        **** 	 * and the diagonal of D. Since d00 = g0, we just write d11
  91:sign.c        **** 	 * into tmp.
  92:sign.c        **** 	 */
  93:sign.c        **** 	Zf(poly_LDLmv_fft)(tmp, tree, g0, g1, g0, logn);
 1723              		.loc 3 93 2
 1724 0032 3B68     		ldr	r3, [r7]
 1725 0034 0193     		str	r3, [sp, #4]
 1726 0036 BB68     		ldr	r3, [r7, #8]
 1727 0038 0093     		str	r3, [sp]
 1728 003a 7B68     		ldr	r3, [r7, #4]
 1729 003c BA68     		ldr	r2, [r7, #8]
 1730 003e F968     		ldr	r1, [r7, #12]
 1731 0040 386A     		ldr	r0, [r7, #32]
 1732 0042 FFF7FEFF 		bl	falcon_inner_poly_LDLmv_fft
  94:sign.c        **** 
  95:sign.c        **** 	/*
  96:sign.c        **** 	 * Split d00 (currently in g0) and d11 (currently in tmp). We
  97:sign.c        **** 	 * reuse g0 and g1 as temporary storage spaces:
  98:sign.c        **** 	 *   d00 splits into g1, g1+hn
  99:sign.c        **** 	 *   d11 splits into g0, g0+hn
 100:sign.c        **** 	 */
 101:sign.c        **** 	Zf(poly_split_fft)(g1, g1 + hn, g0, logn);
 1733              		.loc 3 101 28
 1734 0046 3B69     		ldr	r3, [r7, #16]
 1735 0048 DB00     		lsls	r3, r3, #3
 1736              		.loc 3 101 2
 1737 004a 7A68     		ldr	r2, [r7, #4]
 1738 004c D118     		adds	r1, r2, r3
 1739 004e 3B68     		ldr	r3, [r7]
 1740 0050 BA68     		ldr	r2, [r7, #8]
 1741 0052 7868     		ldr	r0, [r7, #4]
 1742 0054 FFF7FEFF 		bl	falcon_inner_poly_split_fft
 102:sign.c        **** 	Zf(poly_split_fft)(g0, g0 + hn, tmp, logn);
 1743              		.loc 3 102 28
 1744 0058 3B69     		ldr	r3, [r7, #16]
 1745 005a DB00     		lsls	r3, r3, #3
 1746              		.loc 3 102 2
 1747 005c BA68     		ldr	r2, [r7, #8]
 1748 005e D118     		adds	r1, r2, r3
 1749 0060 3B68     		ldr	r3, [r7]
 1750 0062 3A6A     		ldr	r2, [r7, #32]
 1751 0064 B868     		ldr	r0, [r7, #8]
 1752 0066 FFF7FEFF 		bl	falcon_inner_poly_split_fft
 103:sign.c        **** 
 104:sign.c        **** 	/*
 105:sign.c        **** 	 * Each split result is the first row of a new auto-adjoint
 106:sign.c        **** 	 * quasicyclic matrix for the next recursive step.
 107:sign.c        **** 	 */
 108:sign.c        **** 	ffLDL_fft_inner(tree + n,
 1753              		.loc 3 108 23
 1754 006a 7B69     		ldr	r3, [r7, #20]
 1755 006c DB00     		lsls	r3, r3, #3
 1756              		.loc 3 108 2
 1757 006e FA68     		ldr	r2, [r7, #12]
 1758 0070 D018     		adds	r0, r2, r3
 109:sign.c        **** 		g1, g1 + hn, logn - 1, tmp);
 1759              		.loc 3 109 10
 1760 0072 3B69     		ldr	r3, [r7, #16]
 1761 0074 DB00     		lsls	r3, r3, #3
 108:sign.c        **** 		g1, g1 + hn, logn - 1, tmp);
 1762              		.loc 3 108 2
 1763 0076 7A68     		ldr	r2, [r7, #4]
 1764 0078 1A44     		add	r2, r2, r3
 1765 007a 3B68     		ldr	r3, [r7]
 1766 007c 591E     		subs	r1, r3, #1
 1767 007e 3B6A     		ldr	r3, [r7, #32]
 1768 0080 0093     		str	r3, [sp]
 1769 0082 0B46     		mov	r3, r1
 1770 0084 7968     		ldr	r1, [r7, #4]
 1771 0086 FFF7BBFF 		bl	ffLDL_fft_inner
 110:sign.c        **** 	ffLDL_fft_inner(tree + n + ffLDL_treesize(logn - 1),
 1772              		.loc 3 110 29
 1773 008a 3B68     		ldr	r3, [r7]
 1774 008c 013B     		subs	r3, r3, #1
 1775 008e 1846     		mov	r0, r3
 1776 0090 FFF7FEFF 		bl	ffLDL_treesize
 1777 0094 0246     		mov	r2, r0
 1778              		.loc 3 110 27
 1779 0096 7B69     		ldr	r3, [r7, #20]
 1780 0098 1344     		add	r3, r3, r2
 1781 009a DB00     		lsls	r3, r3, #3
 1782              		.loc 3 110 2
 1783 009c FA68     		ldr	r2, [r7, #12]
 1784 009e D018     		adds	r0, r2, r3
 111:sign.c        **** 		g0, g0 + hn, logn - 1, tmp);
 1785              		.loc 3 111 10
 1786 00a0 3B69     		ldr	r3, [r7, #16]
 1787 00a2 DB00     		lsls	r3, r3, #3
 110:sign.c        **** 	ffLDL_fft_inner(tree + n + ffLDL_treesize(logn - 1),
 1788              		.loc 3 110 2
 1789 00a4 BA68     		ldr	r2, [r7, #8]
 1790 00a6 1A44     		add	r2, r2, r3
 1791 00a8 3B68     		ldr	r3, [r7]
 1792 00aa 591E     		subs	r1, r3, #1
 1793 00ac 3B6A     		ldr	r3, [r7, #32]
 1794 00ae 0093     		str	r3, [sp]
 1795 00b0 0B46     		mov	r3, r1
 1796 00b2 B968     		ldr	r1, [r7, #8]
 1797 00b4 FFF7A4FF 		bl	ffLDL_fft_inner
 1798              	.L32:
 112:sign.c        **** }
 1799              		.loc 3 112 1
 1800 00b8 1837     		adds	r7, r7, #24
 1801              	.LCFI79:
 1802              		.cfi_def_cfa_offset 8
 1803 00ba BD46     		mov	sp, r7
 1804              	.LCFI80:
 1805              		.cfi_def_cfa_register 13
 1806              		@ sp needed
 1807 00bc 80BD     		pop	{r7, pc}
 1808              		.cfi_endproc
 1809              	.LFE19:
 1811              		.section	.text.ffLDL_fft,"ax",%progbits
 1812              		.align	1
 1813              		.syntax unified
 1814              		.thumb
 1815              		.thumb_func
 1816              		.fpu softvfp
 1818              	ffLDL_fft:
 1819              	.LFB20:
 113:sign.c        **** 
 114:sign.c        **** /*
 115:sign.c        ****  * Compute the ffLDL tree of an auto-adjoint matrix G. The matrix
 116:sign.c        ****  * is provided as three polynomials (FFT representation).
 117:sign.c        ****  *
 118:sign.c        ****  * The "tree" array is filled with the computed tree, of size
 119:sign.c        ****  * (logn+1)*(2^logn) elements (see ffLDL_treesize()).
 120:sign.c        ****  *
 121:sign.c        ****  * Input arrays MUST NOT overlap, except possibly the three unmodified
 122:sign.c        ****  * arrays g00, g01 and g11. tmp[] should have room for at least three
 123:sign.c        ****  * polynomials of 2^logn elements each.
 124:sign.c        ****  */
 125:sign.c        **** static void
 126:sign.c        **** ffLDL_fft(fpr *restrict tree, const fpr *restrict g00,
 127:sign.c        **** 	const fpr *restrict g01, const fpr *restrict g11,
 128:sign.c        **** 	unsigned logn, fpr *restrict tmp)
 129:sign.c        **** {
 1820              		.loc 3 129 1
 1821              		.cfi_startproc
 1822              		@ args = 8, pretend = 0, frame = 32
 1823              		@ frame_needed = 1, uses_anonymous_args = 0
 1824 0000 80B5     		push	{r7, lr}
 1825              	.LCFI81:
 1826              		.cfi_def_cfa_offset 8
 1827              		.cfi_offset 7, -8
 1828              		.cfi_offset 14, -4
 1829 0002 8AB0     		sub	sp, sp, #40
 1830              	.LCFI82:
 1831              		.cfi_def_cfa_offset 48
 1832 0004 02AF     		add	r7, sp, #8
 1833              	.LCFI83:
 1834              		.cfi_def_cfa 7, 40
 1835 0006 F860     		str	r0, [r7, #12]
 1836 0008 B960     		str	r1, [r7, #8]
 1837 000a 7A60     		str	r2, [r7, #4]
 1838 000c 3B60     		str	r3, [r7]
 130:sign.c        **** 	size_t n, hn;
 131:sign.c        **** 	fpr *d00, *d11;
 132:sign.c        **** 
 133:sign.c        **** 	n = MKN(logn);
 1839              		.loc 3 133 4
 1840 000e 0122     		movs	r2, #1
 1841 0010 BB6A     		ldr	r3, [r7, #40]
 1842 0012 02FA03F3 		lsl	r3, r2, r3
 1843 0016 FB61     		str	r3, [r7, #28]
 134:sign.c        **** 	if (n == 1) {
 1844              		.loc 3 134 5
 1845 0018 FB69     		ldr	r3, [r7, #28]
 1846 001a 012B     		cmp	r3, #1
 1847 001c 06D1     		bne	.L36
 135:sign.c        **** 		tree[0] = g00[0];
 1848              		.loc 3 135 16
 1849 001e BB68     		ldr	r3, [r7, #8]
 1850 0020 D3E90023 		ldrd	r2, [r3]
 1851              		.loc 3 135 11
 1852 0024 F968     		ldr	r1, [r7, #12]
 1853 0026 C1E90023 		strd	r2, [r1]
 136:sign.c        **** 		return;
 1854              		.loc 3 136 3
 1855 002a 5FE0     		b	.L35
 1856              	.L36:
 137:sign.c        **** 	}
 138:sign.c        **** 	hn = n >> 1;
 1857              		.loc 3 138 5
 1858 002c FB69     		ldr	r3, [r7, #28]
 1859 002e 5B08     		lsrs	r3, r3, #1
 1860 0030 BB61     		str	r3, [r7, #24]
 139:sign.c        **** 	d00 = tmp;
 1861              		.loc 3 139 6
 1862 0032 FB6A     		ldr	r3, [r7, #44]
 1863 0034 7B61     		str	r3, [r7, #20]
 140:sign.c        **** 	d11 = tmp + n;
 1864              		.loc 3 140 12
 1865 0036 FB69     		ldr	r3, [r7, #28]
 1866 0038 DB00     		lsls	r3, r3, #3
 1867              		.loc 3 140 6
 1868 003a FA6A     		ldr	r2, [r7, #44]
 1869 003c 1344     		add	r3, r3, r2
 1870 003e 3B61     		str	r3, [r7, #16]
 141:sign.c        **** 	tmp += n << 1;
 1871              		.loc 3 141 6
 1872 0040 FB69     		ldr	r3, [r7, #28]
 1873 0042 1B01     		lsls	r3, r3, #4
 1874 0044 FA6A     		ldr	r2, [r7, #44]
 1875 0046 1344     		add	r3, r3, r2
 1876 0048 FB62     		str	r3, [r7, #44]
 142:sign.c        **** 
 143:sign.c        **** 	memcpy(d00, g00, n * sizeof *g00);
 1877              		.loc 3 143 2
 1878 004a FB69     		ldr	r3, [r7, #28]
 1879 004c DB00     		lsls	r3, r3, #3
 1880 004e 1A46     		mov	r2, r3
 1881 0050 B968     		ldr	r1, [r7, #8]
 1882 0052 7869     		ldr	r0, [r7, #20]
 1883 0054 FFF7FEFF 		bl	memcpy
 144:sign.c        **** 	Zf(poly_LDLmv_fft)(d11, tree, g00, g01, g11, logn);
 1884              		.loc 3 144 2
 1885 0058 BB6A     		ldr	r3, [r7, #40]
 1886 005a 0193     		str	r3, [sp, #4]
 1887 005c 3B68     		ldr	r3, [r7]
 1888 005e 0093     		str	r3, [sp]
 1889 0060 7B68     		ldr	r3, [r7, #4]
 1890 0062 BA68     		ldr	r2, [r7, #8]
 1891 0064 F968     		ldr	r1, [r7, #12]
 1892 0066 3869     		ldr	r0, [r7, #16]
 1893 0068 FFF7FEFF 		bl	falcon_inner_poly_LDLmv_fft
 145:sign.c        **** 
 146:sign.c        **** 	Zf(poly_split_fft)(tmp, tmp + hn, d00, logn);
 1894              		.loc 3 146 30
 1895 006c BB69     		ldr	r3, [r7, #24]
 1896 006e DB00     		lsls	r3, r3, #3
 1897              		.loc 3 146 2
 1898 0070 FA6A     		ldr	r2, [r7, #44]
 1899 0072 D118     		adds	r1, r2, r3
 1900 0074 BB6A     		ldr	r3, [r7, #40]
 1901 0076 7A69     		ldr	r2, [r7, #20]
 1902 0078 F86A     		ldr	r0, [r7, #44]
 1903 007a FFF7FEFF 		bl	falcon_inner_poly_split_fft
 147:sign.c        **** 	Zf(poly_split_fft)(d00, d00 + hn, d11, logn);
 1904              		.loc 3 147 30
 1905 007e BB69     		ldr	r3, [r7, #24]
 1906 0080 DB00     		lsls	r3, r3, #3
 1907              		.loc 3 147 2
 1908 0082 7A69     		ldr	r2, [r7, #20]
 1909 0084 D118     		adds	r1, r2, r3
 1910 0086 BB6A     		ldr	r3, [r7, #40]
 1911 0088 3A69     		ldr	r2, [r7, #16]
 1912 008a 7869     		ldr	r0, [r7, #20]
 1913 008c FFF7FEFF 		bl	falcon_inner_poly_split_fft
 148:sign.c        **** 	memcpy(d11, tmp, n * sizeof *tmp);
 1914              		.loc 3 148 2
 1915 0090 FB69     		ldr	r3, [r7, #28]
 1916 0092 DB00     		lsls	r3, r3, #3
 1917 0094 1A46     		mov	r2, r3
 1918 0096 F96A     		ldr	r1, [r7, #44]
 1919 0098 3869     		ldr	r0, [r7, #16]
 1920 009a FFF7FEFF 		bl	memcpy
 149:sign.c        **** 	ffLDL_fft_inner(tree + n,
 1921              		.loc 3 149 23
 1922 009e FB69     		ldr	r3, [r7, #28]
 1923 00a0 DB00     		lsls	r3, r3, #3
 1924              		.loc 3 149 2
 1925 00a2 FA68     		ldr	r2, [r7, #12]
 1926 00a4 D018     		adds	r0, r2, r3
 150:sign.c        **** 		d11, d11 + hn, logn - 1, tmp);
 1927              		.loc 3 150 12
 1928 00a6 BB69     		ldr	r3, [r7, #24]
 1929 00a8 DB00     		lsls	r3, r3, #3
 149:sign.c        **** 	ffLDL_fft_inner(tree + n,
 1930              		.loc 3 149 2
 1931 00aa 3A69     		ldr	r2, [r7, #16]
 1932 00ac 1A44     		add	r2, r2, r3
 1933 00ae BB6A     		ldr	r3, [r7, #40]
 1934 00b0 591E     		subs	r1, r3, #1
 1935 00b2 FB6A     		ldr	r3, [r7, #44]
 1936 00b4 0093     		str	r3, [sp]
 1937 00b6 0B46     		mov	r3, r1
 1938 00b8 3969     		ldr	r1, [r7, #16]
 1939 00ba FFF7FEFF 		bl	ffLDL_fft_inner
 151:sign.c        **** 	ffLDL_fft_inner(tree + n + ffLDL_treesize(logn - 1),
 1940              		.loc 3 151 29
 1941 00be BB6A     		ldr	r3, [r7, #40]
 1942 00c0 013B     		subs	r3, r3, #1
 1943 00c2 1846     		mov	r0, r3
 1944 00c4 FFF7FEFF 		bl	ffLDL_treesize
 1945 00c8 0246     		mov	r2, r0
 1946              		.loc 3 151 27
 1947 00ca FB69     		ldr	r3, [r7, #28]
 1948 00cc 1344     		add	r3, r3, r2
 1949 00ce DB00     		lsls	r3, r3, #3
 1950              		.loc 3 151 2
 1951 00d0 FA68     		ldr	r2, [r7, #12]
 1952 00d2 D018     		adds	r0, r2, r3
 152:sign.c        **** 		d00, d00 + hn, logn - 1, tmp);
 1953              		.loc 3 152 12
 1954 00d4 BB69     		ldr	r3, [r7, #24]
 1955 00d6 DB00     		lsls	r3, r3, #3
 151:sign.c        **** 	ffLDL_fft_inner(tree + n + ffLDL_treesize(logn - 1),
 1956              		.loc 3 151 2
 1957 00d8 7A69     		ldr	r2, [r7, #20]
 1958 00da 1A44     		add	r2, r2, r3
 1959 00dc BB6A     		ldr	r3, [r7, #40]
 1960 00de 591E     		subs	r1, r3, #1
 1961 00e0 FB6A     		ldr	r3, [r7, #44]
 1962 00e2 0093     		str	r3, [sp]
 1963 00e4 0B46     		mov	r3, r1
 1964 00e6 7969     		ldr	r1, [r7, #20]
 1965 00e8 FFF7FEFF 		bl	ffLDL_fft_inner
 1966              	.L35:
 153:sign.c        **** }
 1967              		.loc 3 153 1
 1968 00ec 2037     		adds	r7, r7, #32
 1969              	.LCFI84:
 1970              		.cfi_def_cfa_offset 8
 1971 00ee BD46     		mov	sp, r7
 1972              	.LCFI85:
 1973              		.cfi_def_cfa_register 13
 1974              		@ sp needed
 1975 00f0 80BD     		pop	{r7, pc}
 1976              		.cfi_endproc
 1977              	.LFE20:
 1979              		.section	.text.ffLDL_binary_normalize,"ax",%progbits
 1980              		.align	1
 1981              		.syntax unified
 1982              		.thumb
 1983              		.thumb_func
 1984              		.fpu softvfp
 1986              	ffLDL_binary_normalize:
 1987              	.LFB21:
 154:sign.c        **** 
 155:sign.c        **** /*
 156:sign.c        ****  * Normalize an ffLDL tree: each leaf of value x is replaced with
 157:sign.c        ****  * sigma / sqrt(x).
 158:sign.c        ****  */
 159:sign.c        **** static void
 160:sign.c        **** ffLDL_binary_normalize(fpr *tree, unsigned orig_logn, unsigned logn)
 161:sign.c        **** {
 1988              		.loc 3 161 1
 1989              		.cfi_startproc
 1990              		@ args = 0, pretend = 0, frame = 24
 1991              		@ frame_needed = 1, uses_anonymous_args = 0
 1992 0000 80B5     		push	{r7, lr}
 1993              	.LCFI86:
 1994              		.cfi_def_cfa_offset 8
 1995              		.cfi_offset 7, -8
 1996              		.cfi_offset 14, -4
 1997 0002 86B0     		sub	sp, sp, #24
 1998              	.LCFI87:
 1999              		.cfi_def_cfa_offset 32
 2000 0004 00AF     		add	r7, sp, #0
 2001              	.LCFI88:
 2002              		.cfi_def_cfa_register 7
 2003 0006 F860     		str	r0, [r7, #12]
 2004 0008 B960     		str	r1, [r7, #8]
 2005 000a 7A60     		str	r2, [r7, #4]
 162:sign.c        **** 	/*
 163:sign.c        **** 	 * TODO: make an iterative version.
 164:sign.c        **** 	 */
 165:sign.c        **** 	size_t n;
 166:sign.c        **** 
 167:sign.c        **** 	n = MKN(logn);
 2006              		.loc 3 167 4
 2007 000c 0122     		movs	r2, #1
 2008 000e 7B68     		ldr	r3, [r7, #4]
 2009 0010 02FA03F3 		lsl	r3, r2, r3
 2010 0014 7B61     		str	r3, [r7, #20]
 168:sign.c        **** 	if (n == 1) {
 2011              		.loc 3 168 5
 2012 0016 7B69     		ldr	r3, [r7, #20]
 2013 0018 012B     		cmp	r3, #1
 2014 001a 14D1     		bne	.L39
 169:sign.c        **** 		/*
 170:sign.c        **** 		 * We actually store in the tree leaf the inverse of
 171:sign.c        **** 		 * the value mandated by the specification: this
 172:sign.c        **** 		 * saves a division both here and in the sampler.
 173:sign.c        **** 		 */
 174:sign.c        **** 		tree[0] = fpr_mul(fpr_sqrt(tree[0]), fpr_inv_sigma[orig_logn]);
 2015              		.loc 3 174 13
 2016 001c FB68     		ldr	r3, [r7, #12]
 2017 001e D3E90023 		ldrd	r2, [r3]
 2018 0022 1046     		mov	r0, r2
 2019 0024 1946     		mov	r1, r3
 2020 0026 FFF7FEFF 		bl	falcon_inner_fpr_sqrt
 2021 002a 164A     		ldr	r2, .L42
 2022 002c BB68     		ldr	r3, [r7, #8]
 2023 002e DB00     		lsls	r3, r3, #3
 2024 0030 1344     		add	r3, r3, r2
 2025 0032 D3E90023 		ldrd	r2, [r3]
 2026 0036 FFF7FEFF 		bl	falcon_inner_fpr_mul
 2027 003a 0246     		mov	r2, r0
 2028 003c 0B46     		mov	r3, r1
 2029              		.loc 3 174 11
 2030 003e F968     		ldr	r1, [r7, #12]
 2031 0040 C1E90023 		strd	r2, [r1]
 175:sign.c        **** 	} else {
 176:sign.c        **** 		ffLDL_binary_normalize(tree + n, orig_logn, logn - 1);
 177:sign.c        **** 		ffLDL_binary_normalize(tree + n + ffLDL_treesize(logn - 1),
 178:sign.c        **** 			orig_logn, logn - 1);
 179:sign.c        **** 	}
 180:sign.c        **** }
 2032              		.loc 3 180 1
 2033 0044 1AE0     		b	.L41
 2034              	.L39:
 176:sign.c        **** 		ffLDL_binary_normalize(tree + n + ffLDL_treesize(logn - 1),
 2035              		.loc 3 176 31
 2036 0046 7B69     		ldr	r3, [r7, #20]
 2037 0048 DB00     		lsls	r3, r3, #3
 176:sign.c        **** 		ffLDL_binary_normalize(tree + n + ffLDL_treesize(logn - 1),
 2038              		.loc 3 176 3
 2039 004a FA68     		ldr	r2, [r7, #12]
 2040 004c D018     		adds	r0, r2, r3
 2041 004e 7B68     		ldr	r3, [r7, #4]
 2042 0050 013B     		subs	r3, r3, #1
 2043 0052 1A46     		mov	r2, r3
 2044 0054 B968     		ldr	r1, [r7, #8]
 2045 0056 FFF7D3FF 		bl	ffLDL_binary_normalize
 177:sign.c        **** 			orig_logn, logn - 1);
 2046              		.loc 3 177 37
 2047 005a 7B68     		ldr	r3, [r7, #4]
 2048 005c 013B     		subs	r3, r3, #1
 2049 005e 1846     		mov	r0, r3
 2050 0060 FFF7FEFF 		bl	ffLDL_treesize
 2051 0064 0246     		mov	r2, r0
 177:sign.c        **** 			orig_logn, logn - 1);
 2052              		.loc 3 177 35
 2053 0066 7B69     		ldr	r3, [r7, #20]
 2054 0068 1344     		add	r3, r3, r2
 2055 006a DB00     		lsls	r3, r3, #3
 177:sign.c        **** 			orig_logn, logn - 1);
 2056              		.loc 3 177 3
 2057 006c FA68     		ldr	r2, [r7, #12]
 2058 006e D018     		adds	r0, r2, r3
 2059 0070 7B68     		ldr	r3, [r7, #4]
 2060 0072 013B     		subs	r3, r3, #1
 2061 0074 1A46     		mov	r2, r3
 2062 0076 B968     		ldr	r1, [r7, #8]
 2063 0078 FFF7C2FF 		bl	ffLDL_binary_normalize
 2064              	.L41:
 2065              		.loc 3 180 1
 2066 007c 00BF     		nop
 2067 007e 1837     		adds	r7, r7, #24
 2068              	.LCFI89:
 2069              		.cfi_def_cfa_offset 8
 2070 0080 BD46     		mov	sp, r7
 2071              	.LCFI90:
 2072              		.cfi_def_cfa_register 13
 2073              		@ sp needed
 2074 0082 80BD     		pop	{r7, pc}
 2075              	.L43:
 2076              		.align	2
 2077              	.L42:
 2078 0084 18000000 		.word	fpr_inv_sigma
 2079              		.cfi_endproc
 2080              	.LFE21:
 2082              		.section	.text.smallints_to_fpr,"ax",%progbits
 2083              		.align	1
 2084              		.syntax unified
 2085              		.thumb
 2086              		.thumb_func
 2087              		.fpu softvfp
 2089              	smallints_to_fpr:
 2090              	.LFB22:
 181:sign.c        **** 
 182:sign.c        **** /* =================================================================== */
 183:sign.c        **** 
 184:sign.c        **** /*
 185:sign.c        ****  * Convert an integer polynomial (with small values) into the
 186:sign.c        ****  * representation with complex numbers.
 187:sign.c        ****  */
 188:sign.c        **** static void
 189:sign.c        **** smallints_to_fpr(fpr *r, const int8_t *t, unsigned logn)
 190:sign.c        **** {
 2091              		.loc 3 190 1
 2092              		.cfi_startproc
 2093              		@ args = 0, pretend = 0, frame = 24
 2094              		@ frame_needed = 1, uses_anonymous_args = 0
 2095 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 2096              	.LCFI91:
 2097              		.cfi_def_cfa_offset 20
 2098              		.cfi_offset 4, -20
 2099              		.cfi_offset 5, -16
 2100              		.cfi_offset 6, -12
 2101              		.cfi_offset 7, -8
 2102              		.cfi_offset 14, -4
 2103 0002 87B0     		sub	sp, sp, #28
 2104              	.LCFI92:
 2105              		.cfi_def_cfa_offset 48
 2106 0004 00AF     		add	r7, sp, #0
 2107              	.LCFI93:
 2108              		.cfi_def_cfa_register 7
 2109 0006 F860     		str	r0, [r7, #12]
 2110 0008 B960     		str	r1, [r7, #8]
 2111 000a 7A60     		str	r2, [r7, #4]
 191:sign.c        **** 	size_t n, u;
 192:sign.c        **** 
 193:sign.c        **** 	n = MKN(logn);
 2112              		.loc 3 193 4
 2113 000c 0122     		movs	r2, #1
 2114 000e 7B68     		ldr	r3, [r7, #4]
 2115 0010 02FA03F3 		lsl	r3, r2, r3
 2116 0014 3B61     		str	r3, [r7, #16]
 194:sign.c        **** 	for (u = 0; u < n; u ++) {
 2117              		.loc 3 194 9
 2118 0016 0023     		movs	r3, #0
 2119 0018 7B61     		str	r3, [r7, #20]
 2120              		.loc 3 194 2
 2121 001a 17E0     		b	.L45
 2122              	.L46:
 195:sign.c        **** 		r[u] = fpr_of(t[u]);
 2123              		.loc 3 195 18 discriminator 3
 2124 001c BA68     		ldr	r2, [r7, #8]
 2125 001e 7B69     		ldr	r3, [r7, #20]
 2126 0020 1344     		add	r3, r3, r2
 2127 0022 93F90030 		ldrsb	r3, [r3]
 2128              		.loc 3 195 10 discriminator 3
 2129 0026 5BB2     		sxtb	r3, r3
 2130 0028 DA17     		asrs	r2, r3, #31
 2131 002a 1C46     		mov	r4, r3
 2132 002c 1546     		mov	r5, r2
 2133              		.loc 3 195 4 discriminator 3
 2134 002e 7B69     		ldr	r3, [r7, #20]
 2135 0030 DB00     		lsls	r3, r3, #3
 2136 0032 FA68     		ldr	r2, [r7, #12]
 2137 0034 D618     		adds	r6, r2, r3
 2138              		.loc 3 195 10 discriminator 3
 2139 0036 2046     		mov	r0, r4
 2140 0038 2946     		mov	r1, r5
 2141 003a FFF7FEFF 		bl	fpr_of
 2142 003e 0246     		mov	r2, r0
 2143 0040 0B46     		mov	r3, r1
 2144              		.loc 3 195 8 discriminator 3
 2145 0042 C6E90023 		strd	r2, [r6]
 194:sign.c        **** 	for (u = 0; u < n; u ++) {
 2146              		.loc 3 194 23 discriminator 3
 2147 0046 7B69     		ldr	r3, [r7, #20]
 2148 0048 0133     		adds	r3, r3, #1
 2149 004a 7B61     		str	r3, [r7, #20]
 2150              	.L45:
 194:sign.c        **** 	for (u = 0; u < n; u ++) {
 2151              		.loc 3 194 2 discriminator 1
 2152 004c 7A69     		ldr	r2, [r7, #20]
 2153 004e 3B69     		ldr	r3, [r7, #16]
 2154 0050 9A42     		cmp	r2, r3
 2155 0052 E3D3     		bcc	.L46
 196:sign.c        **** 	}
 197:sign.c        **** }
 2156              		.loc 3 197 1
 2157 0054 00BF     		nop
 2158 0056 00BF     		nop
 2159 0058 1C37     		adds	r7, r7, #28
 2160              	.LCFI94:
 2161              		.cfi_def_cfa_offset 20
 2162 005a BD46     		mov	sp, r7
 2163              	.LCFI95:
 2164              		.cfi_def_cfa_register 13
 2165              		@ sp needed
 2166 005c F0BD     		pop	{r4, r5, r6, r7, pc}
 2167              		.cfi_endproc
 2168              	.LFE22:
 2170              		.section	.text.skoff_b00,"ax",%progbits
 2171              		.align	1
 2172              		.syntax unified
 2173              		.thumb
 2174              		.thumb_func
 2175              		.fpu softvfp
 2177              	skoff_b00:
 2178              	.LFB23:
 198:sign.c        **** 
 199:sign.c        **** /*
 200:sign.c        ****  * The expanded private key contains:
 201:sign.c        ****  *  - The B0 matrix (four elements)
 202:sign.c        ****  *  - The ffLDL tree
 203:sign.c        ****  */
 204:sign.c        **** 
 205:sign.c        **** static inline size_t
 206:sign.c        **** skoff_b00(unsigned logn)
 207:sign.c        **** {
 2179              		.loc 3 207 1
 2180              		.cfi_startproc
 2181              		@ args = 0, pretend = 0, frame = 8
 2182              		@ frame_needed = 1, uses_anonymous_args = 0
 2183              		@ link register save eliminated.
 2184 0000 80B4     		push	{r7}
 2185              	.LCFI96:
 2186              		.cfi_def_cfa_offset 4
 2187              		.cfi_offset 7, -4
 2188 0002 83B0     		sub	sp, sp, #12
 2189              	.LCFI97:
 2190              		.cfi_def_cfa_offset 16
 2191 0004 00AF     		add	r7, sp, #0
 2192              	.LCFI98:
 2193              		.cfi_def_cfa_register 7
 2194 0006 7860     		str	r0, [r7, #4]
 208:sign.c        **** 	(void)logn;
 209:sign.c        **** 	return 0;
 2195              		.loc 3 209 9
 2196 0008 0023     		movs	r3, #0
 210:sign.c        **** }
 2197              		.loc 3 210 1
 2198 000a 1846     		mov	r0, r3
 2199 000c 0C37     		adds	r7, r7, #12
 2200              	.LCFI99:
 2201              		.cfi_def_cfa_offset 4
 2202 000e BD46     		mov	sp, r7
 2203              	.LCFI100:
 2204              		.cfi_def_cfa_register 13
 2205              		@ sp needed
 2206 0010 80BC     		pop	{r7}
 2207              	.LCFI101:
 2208              		.cfi_restore 7
 2209              		.cfi_def_cfa_offset 0
 2210 0012 7047     		bx	lr
 2211              		.cfi_endproc
 2212              	.LFE23:
 2214              		.section	.text.skoff_b01,"ax",%progbits
 2215              		.align	1
 2216              		.syntax unified
 2217              		.thumb
 2218              		.thumb_func
 2219              		.fpu softvfp
 2221              	skoff_b01:
 2222              	.LFB24:
 211:sign.c        **** 
 212:sign.c        **** static inline size_t
 213:sign.c        **** skoff_b01(unsigned logn)
 214:sign.c        **** {
 2223              		.loc 3 214 1
 2224              		.cfi_startproc
 2225              		@ args = 0, pretend = 0, frame = 8
 2226              		@ frame_needed = 1, uses_anonymous_args = 0
 2227              		@ link register save eliminated.
 2228 0000 80B4     		push	{r7}
 2229              	.LCFI102:
 2230              		.cfi_def_cfa_offset 4
 2231              		.cfi_offset 7, -4
 2232 0002 83B0     		sub	sp, sp, #12
 2233              	.LCFI103:
 2234              		.cfi_def_cfa_offset 16
 2235 0004 00AF     		add	r7, sp, #0
 2236              	.LCFI104:
 2237              		.cfi_def_cfa_register 7
 2238 0006 7860     		str	r0, [r7, #4]
 215:sign.c        **** 	return MKN(logn);
 2239              		.loc 3 215 9
 2240 0008 0122     		movs	r2, #1
 2241 000a 7B68     		ldr	r3, [r7, #4]
 2242 000c 02FA03F3 		lsl	r3, r2, r3
 216:sign.c        **** }
 2243              		.loc 3 216 1
 2244 0010 1846     		mov	r0, r3
 2245 0012 0C37     		adds	r7, r7, #12
 2246              	.LCFI105:
 2247              		.cfi_def_cfa_offset 4
 2248 0014 BD46     		mov	sp, r7
 2249              	.LCFI106:
 2250              		.cfi_def_cfa_register 13
 2251              		@ sp needed
 2252 0016 80BC     		pop	{r7}
 2253              	.LCFI107:
 2254              		.cfi_restore 7
 2255              		.cfi_def_cfa_offset 0
 2256 0018 7047     		bx	lr
 2257              		.cfi_endproc
 2258              	.LFE24:
 2260              		.section	.text.skoff_b10,"ax",%progbits
 2261              		.align	1
 2262              		.syntax unified
 2263              		.thumb
 2264              		.thumb_func
 2265              		.fpu softvfp
 2267              	skoff_b10:
 2268              	.LFB25:
 217:sign.c        **** 
 218:sign.c        **** static inline size_t
 219:sign.c        **** skoff_b10(unsigned logn)
 220:sign.c        **** {
 2269              		.loc 3 220 1
 2270              		.cfi_startproc
 2271              		@ args = 0, pretend = 0, frame = 8
 2272              		@ frame_needed = 1, uses_anonymous_args = 0
 2273              		@ link register save eliminated.
 2274 0000 80B4     		push	{r7}
 2275              	.LCFI108:
 2276              		.cfi_def_cfa_offset 4
 2277              		.cfi_offset 7, -4
 2278 0002 83B0     		sub	sp, sp, #12
 2279              	.LCFI109:
 2280              		.cfi_def_cfa_offset 16
 2281 0004 00AF     		add	r7, sp, #0
 2282              	.LCFI110:
 2283              		.cfi_def_cfa_register 7
 2284 0006 7860     		str	r0, [r7, #4]
 221:sign.c        **** 	return 2 * MKN(logn);
 2285              		.loc 3 221 11
 2286 0008 0222     		movs	r2, #2
 2287 000a 7B68     		ldr	r3, [r7, #4]
 2288 000c 02FA03F3 		lsl	r3, r2, r3
 222:sign.c        **** }
 2289              		.loc 3 222 1
 2290 0010 1846     		mov	r0, r3
 2291 0012 0C37     		adds	r7, r7, #12
 2292              	.LCFI111:
 2293              		.cfi_def_cfa_offset 4
 2294 0014 BD46     		mov	sp, r7
 2295              	.LCFI112:
 2296              		.cfi_def_cfa_register 13
 2297              		@ sp needed
 2298 0016 80BC     		pop	{r7}
 2299              	.LCFI113:
 2300              		.cfi_restore 7
 2301              		.cfi_def_cfa_offset 0
 2302 0018 7047     		bx	lr
 2303              		.cfi_endproc
 2304              	.LFE25:
 2306              		.section	.text.skoff_b11,"ax",%progbits
 2307              		.align	1
 2308              		.syntax unified
 2309              		.thumb
 2310              		.thumb_func
 2311              		.fpu softvfp
 2313              	skoff_b11:
 2314              	.LFB26:
 223:sign.c        **** 
 224:sign.c        **** static inline size_t
 225:sign.c        **** skoff_b11(unsigned logn)
 226:sign.c        **** {
 2315              		.loc 3 226 1
 2316              		.cfi_startproc
 2317              		@ args = 0, pretend = 0, frame = 8
 2318              		@ frame_needed = 1, uses_anonymous_args = 0
 2319              		@ link register save eliminated.
 2320 0000 80B4     		push	{r7}
 2321              	.LCFI114:
 2322              		.cfi_def_cfa_offset 4
 2323              		.cfi_offset 7, -4
 2324 0002 83B0     		sub	sp, sp, #12
 2325              	.LCFI115:
 2326              		.cfi_def_cfa_offset 16
 2327 0004 00AF     		add	r7, sp, #0
 2328              	.LCFI116:
 2329              		.cfi_def_cfa_register 7
 2330 0006 7860     		str	r0, [r7, #4]
 227:sign.c        **** 	return 3 * MKN(logn);
 2331              		.loc 3 227 11
 2332 0008 0322     		movs	r2, #3
 2333 000a 7B68     		ldr	r3, [r7, #4]
 2334 000c 02FA03F3 		lsl	r3, r2, r3
 228:sign.c        **** }
 2335              		.loc 3 228 1
 2336 0010 1846     		mov	r0, r3
 2337 0012 0C37     		adds	r7, r7, #12
 2338              	.LCFI117:
 2339              		.cfi_def_cfa_offset 4
 2340 0014 BD46     		mov	sp, r7
 2341              	.LCFI118:
 2342              		.cfi_def_cfa_register 13
 2343              		@ sp needed
 2344 0016 80BC     		pop	{r7}
 2345              	.LCFI119:
 2346              		.cfi_restore 7
 2347              		.cfi_def_cfa_offset 0
 2348 0018 7047     		bx	lr
 2349              		.cfi_endproc
 2350              	.LFE26:
 2352              		.section	.text.skoff_tree,"ax",%progbits
 2353              		.align	1
 2354              		.syntax unified
 2355              		.thumb
 2356              		.thumb_func
 2357              		.fpu softvfp
 2359              	skoff_tree:
 2360              	.LFB27:
 229:sign.c        **** 
 230:sign.c        **** static inline size_t
 231:sign.c        **** skoff_tree(unsigned logn)
 232:sign.c        **** {
 2361              		.loc 3 232 1
 2362              		.cfi_startproc
 2363              		@ args = 0, pretend = 0, frame = 8
 2364              		@ frame_needed = 1, uses_anonymous_args = 0
 2365              		@ link register save eliminated.
 2366 0000 80B4     		push	{r7}
 2367              	.LCFI120:
 2368              		.cfi_def_cfa_offset 4
 2369              		.cfi_offset 7, -4
 2370 0002 83B0     		sub	sp, sp, #12
 2371              	.LCFI121:
 2372              		.cfi_def_cfa_offset 16
 2373 0004 00AF     		add	r7, sp, #0
 2374              	.LCFI122:
 2375              		.cfi_def_cfa_register 7
 2376 0006 7860     		str	r0, [r7, #4]
 233:sign.c        **** 	return 4 * MKN(logn);
 2377              		.loc 3 233 11
 2378 0008 0422     		movs	r2, #4
 2379 000a 7B68     		ldr	r3, [r7, #4]
 2380 000c 02FA03F3 		lsl	r3, r2, r3
 234:sign.c        **** }
 2381              		.loc 3 234 1
 2382 0010 1846     		mov	r0, r3
 2383 0012 0C37     		adds	r7, r7, #12
 2384              	.LCFI123:
 2385              		.cfi_def_cfa_offset 4
 2386 0014 BD46     		mov	sp, r7
 2387              	.LCFI124:
 2388              		.cfi_def_cfa_register 13
 2389              		@ sp needed
 2390 0016 80BC     		pop	{r7}
 2391              	.LCFI125:
 2392              		.cfi_restore 7
 2393              		.cfi_def_cfa_offset 0
 2394 0018 7047     		bx	lr
 2395              		.cfi_endproc
 2396              	.LFE27:
 2398              		.section	.text.falcon_inner_expand_privkey,"ax",%progbits
 2399              		.align	1
 2400              		.global	falcon_inner_expand_privkey
 2401              		.syntax unified
 2402              		.thumb
 2403              		.thumb_func
 2404              		.fpu softvfp
 2406              	falcon_inner_expand_privkey:
 2407              	.LFB28:
 235:sign.c        **** 
 236:sign.c        **** /* see inner.h */
 237:sign.c        **** void
 238:sign.c        **** Zf(expand_privkey)(fpr *restrict expanded_key,
 239:sign.c        **** 	const int8_t *f, const int8_t *g,
 240:sign.c        **** 	const int8_t *F, const int8_t *G,
 241:sign.c        **** 	unsigned logn, uint8_t *restrict tmp)
 242:sign.c        **** {
 2408              		.loc 3 242 1
 2409              		.cfi_startproc
 2410              		@ args = 12, pretend = 0, frame = 72
 2411              		@ frame_needed = 1, uses_anonymous_args = 0
 2412 0000 80B5     		push	{r7, lr}
 2413              	.LCFI126:
 2414              		.cfi_def_cfa_offset 8
 2415              		.cfi_offset 7, -8
 2416              		.cfi_offset 14, -4
 2417 0002 94B0     		sub	sp, sp, #80
 2418              	.LCFI127:
 2419              		.cfi_def_cfa_offset 88
 2420 0004 02AF     		add	r7, sp, #8
 2421              	.LCFI128:
 2422              		.cfi_def_cfa 7, 80
 2423 0006 F860     		str	r0, [r7, #12]
 2424 0008 B960     		str	r1, [r7, #8]
 2425 000a 7A60     		str	r2, [r7, #4]
 2426 000c 3B60     		str	r3, [r7]
 243:sign.c        **** 	size_t n;
 244:sign.c        **** 	fpr *rf, *rg, *rF, *rG;
 245:sign.c        **** 	fpr *b00, *b01, *b10, *b11;
 246:sign.c        **** 	fpr *g00, *g01, *g11, *gxx;
 247:sign.c        **** 	fpr *tree;
 248:sign.c        **** 
 249:sign.c        **** 	n = MKN(logn);
 2427              		.loc 3 249 4
 2428 000e 0122     		movs	r2, #1
 2429 0010 7B6D     		ldr	r3, [r7, #84]
 2430 0012 02FA03F3 		lsl	r3, r2, r3
 2431 0016 7B64     		str	r3, [r7, #68]
 250:sign.c        **** 	b00 = expanded_key + skoff_b00(logn);
 2432              		.loc 3 250 23
 2433 0018 786D     		ldr	r0, [r7, #84]
 2434 001a FFF7FEFF 		bl	skoff_b00
 2435 001e 0346     		mov	r3, r0
 2436              		.loc 3 250 21
 2437 0020 DB00     		lsls	r3, r3, #3
 2438              		.loc 3 250 6
 2439 0022 FA68     		ldr	r2, [r7, #12]
 2440 0024 1344     		add	r3, r3, r2
 2441 0026 3B64     		str	r3, [r7, #64]
 251:sign.c        **** 	b01 = expanded_key + skoff_b01(logn);
 2442              		.loc 3 251 23
 2443 0028 786D     		ldr	r0, [r7, #84]
 2444 002a FFF7FEFF 		bl	skoff_b01
 2445 002e 0346     		mov	r3, r0
 2446              		.loc 3 251 21
 2447 0030 DB00     		lsls	r3, r3, #3
 2448              		.loc 3 251 6
 2449 0032 FA68     		ldr	r2, [r7, #12]
 2450 0034 1344     		add	r3, r3, r2
 2451 0036 FB63     		str	r3, [r7, #60]
 252:sign.c        **** 	b10 = expanded_key + skoff_b10(logn);
 2452              		.loc 3 252 23
 2453 0038 786D     		ldr	r0, [r7, #84]
 2454 003a FFF7FEFF 		bl	skoff_b10
 2455 003e 0346     		mov	r3, r0
 2456              		.loc 3 252 21
 2457 0040 DB00     		lsls	r3, r3, #3
 2458              		.loc 3 252 6
 2459 0042 FA68     		ldr	r2, [r7, #12]
 2460 0044 1344     		add	r3, r3, r2
 2461 0046 BB63     		str	r3, [r7, #56]
 253:sign.c        **** 	b11 = expanded_key + skoff_b11(logn);
 2462              		.loc 3 253 23
 2463 0048 786D     		ldr	r0, [r7, #84]
 2464 004a FFF7FEFF 		bl	skoff_b11
 2465 004e 0346     		mov	r3, r0
 2466              		.loc 3 253 21
 2467 0050 DB00     		lsls	r3, r3, #3
 2468              		.loc 3 253 6
 2469 0052 FA68     		ldr	r2, [r7, #12]
 2470 0054 1344     		add	r3, r3, r2
 2471 0056 7B63     		str	r3, [r7, #52]
 254:sign.c        **** 	tree = expanded_key + skoff_tree(logn);
 2472              		.loc 3 254 24
 2473 0058 786D     		ldr	r0, [r7, #84]
 2474 005a FFF7FEFF 		bl	skoff_tree
 2475 005e 0346     		mov	r3, r0
 2476              		.loc 3 254 22
 2477 0060 DB00     		lsls	r3, r3, #3
 2478              		.loc 3 254 7
 2479 0062 FA68     		ldr	r2, [r7, #12]
 2480 0064 1344     		add	r3, r3, r2
 2481 0066 3B63     		str	r3, [r7, #48]
 255:sign.c        **** 
 256:sign.c        **** 	/*
 257:sign.c        **** 	 * We load the private key elements directly into the B0 matrix,
 258:sign.c        **** 	 * since B0 = [[g, -f], [G, -F]].
 259:sign.c        **** 	 */
 260:sign.c        **** 	rf = b01;
 2482              		.loc 3 260 5
 2483 0068 FB6B     		ldr	r3, [r7, #60]
 2484 006a FB62     		str	r3, [r7, #44]
 261:sign.c        **** 	rg = b00;
 2485              		.loc 3 261 5
 2486 006c 3B6C     		ldr	r3, [r7, #64]
 2487 006e BB62     		str	r3, [r7, #40]
 262:sign.c        **** 	rF = b11;
 2488              		.loc 3 262 5
 2489 0070 7B6B     		ldr	r3, [r7, #52]
 2490 0072 7B62     		str	r3, [r7, #36]
 263:sign.c        **** 	rG = b10;
 2491              		.loc 3 263 5
 2492 0074 BB6B     		ldr	r3, [r7, #56]
 2493 0076 3B62     		str	r3, [r7, #32]
 264:sign.c        **** 
 265:sign.c        **** 	smallints_to_fpr(rf, f, logn);
 2494              		.loc 3 265 2
 2495 0078 7A6D     		ldr	r2, [r7, #84]
 2496 007a B968     		ldr	r1, [r7, #8]
 2497 007c F86A     		ldr	r0, [r7, #44]
 2498 007e FFF7FEFF 		bl	smallints_to_fpr
 266:sign.c        **** 	smallints_to_fpr(rg, g, logn);
 2499              		.loc 3 266 2
 2500 0082 7A6D     		ldr	r2, [r7, #84]
 2501 0084 7968     		ldr	r1, [r7, #4]
 2502 0086 B86A     		ldr	r0, [r7, #40]
 2503 0088 FFF7FEFF 		bl	smallints_to_fpr
 267:sign.c        **** 	smallints_to_fpr(rF, F, logn);
 2504              		.loc 3 267 2
 2505 008c 7A6D     		ldr	r2, [r7, #84]
 2506 008e 3968     		ldr	r1, [r7]
 2507 0090 786A     		ldr	r0, [r7, #36]
 2508 0092 FFF7FEFF 		bl	smallints_to_fpr
 268:sign.c        **** 	smallints_to_fpr(rG, G, logn);
 2509              		.loc 3 268 2
 2510 0096 7A6D     		ldr	r2, [r7, #84]
 2511 0098 396D     		ldr	r1, [r7, #80]
 2512 009a 386A     		ldr	r0, [r7, #32]
 2513 009c FFF7FEFF 		bl	smallints_to_fpr
 269:sign.c        **** 
 270:sign.c        **** 	/*
 271:sign.c        **** 	 * Compute the FFT for the key elements, and negate f and F.
 272:sign.c        **** 	 */
 273:sign.c        **** 	Zf(FFT)(rf, logn);
 2514              		.loc 3 273 2
 2515 00a0 796D     		ldr	r1, [r7, #84]
 2516 00a2 F86A     		ldr	r0, [r7, #44]
 2517 00a4 FFF7FEFF 		bl	falcon_inner_FFT
 274:sign.c        **** 	Zf(FFT)(rg, logn);
 2518              		.loc 3 274 2
 2519 00a8 796D     		ldr	r1, [r7, #84]
 2520 00aa B86A     		ldr	r0, [r7, #40]
 2521 00ac FFF7FEFF 		bl	falcon_inner_FFT
 275:sign.c        **** 	Zf(FFT)(rF, logn);
 2522              		.loc 3 275 2
 2523 00b0 796D     		ldr	r1, [r7, #84]
 2524 00b2 786A     		ldr	r0, [r7, #36]
 2525 00b4 FFF7FEFF 		bl	falcon_inner_FFT
 276:sign.c        **** 	Zf(FFT)(rG, logn);
 2526              		.loc 3 276 2
 2527 00b8 796D     		ldr	r1, [r7, #84]
 2528 00ba 386A     		ldr	r0, [r7, #32]
 2529 00bc FFF7FEFF 		bl	falcon_inner_FFT
 277:sign.c        **** 	Zf(poly_neg)(rf, logn);
 2530              		.loc 3 277 2
 2531 00c0 796D     		ldr	r1, [r7, #84]
 2532 00c2 F86A     		ldr	r0, [r7, #44]
 2533 00c4 FFF7FEFF 		bl	falcon_inner_poly_neg
 278:sign.c        **** 	Zf(poly_neg)(rF, logn);
 2534              		.loc 3 278 2
 2535 00c8 796D     		ldr	r1, [r7, #84]
 2536 00ca 786A     		ldr	r0, [r7, #36]
 2537 00cc FFF7FEFF 		bl	falcon_inner_poly_neg
 279:sign.c        **** 
 280:sign.c        **** 	/*
 281:sign.c        **** 	 * The Gram matrix is G = B·B*. Formulas are:
 282:sign.c        **** 	 *   g00 = b00*adj(b00) + b01*adj(b01)
 283:sign.c        **** 	 *   g01 = b00*adj(b10) + b01*adj(b11)
 284:sign.c        **** 	 *   g10 = b10*adj(b00) + b11*adj(b01)
 285:sign.c        **** 	 *   g11 = b10*adj(b10) + b11*adj(b11)
 286:sign.c        **** 	 *
 287:sign.c        **** 	 * For historical reasons, this implementation uses
 288:sign.c        **** 	 * g00, g01 and g11 (upper triangle).
 289:sign.c        **** 	 */
 290:sign.c        **** 	g00 = (fpr *)tmp;
 2538              		.loc 3 290 6
 2539 00d0 BB6D     		ldr	r3, [r7, #88]
 2540 00d2 FB61     		str	r3, [r7, #28]
 291:sign.c        **** 	g01 = g00 + n;
 2541              		.loc 3 291 12
 2542 00d4 7B6C     		ldr	r3, [r7, #68]
 2543 00d6 DB00     		lsls	r3, r3, #3
 2544              		.loc 3 291 6
 2545 00d8 FA69     		ldr	r2, [r7, #28]
 2546 00da 1344     		add	r3, r3, r2
 2547 00dc BB61     		str	r3, [r7, #24]
 292:sign.c        **** 	g11 = g01 + n;
 2548              		.loc 3 292 12
 2549 00de 7B6C     		ldr	r3, [r7, #68]
 2550 00e0 DB00     		lsls	r3, r3, #3
 2551              		.loc 3 292 6
 2552 00e2 BA69     		ldr	r2, [r7, #24]
 2553 00e4 1344     		add	r3, r3, r2
 2554 00e6 7B61     		str	r3, [r7, #20]
 293:sign.c        **** 	gxx = g11 + n;
 2555              		.loc 3 293 12
 2556 00e8 7B6C     		ldr	r3, [r7, #68]
 2557 00ea DB00     		lsls	r3, r3, #3
 2558              		.loc 3 293 6
 2559 00ec 7A69     		ldr	r2, [r7, #20]
 2560 00ee 1344     		add	r3, r3, r2
 2561 00f0 3B61     		str	r3, [r7, #16]
 294:sign.c        **** 
 295:sign.c        **** 	memcpy(g00, b00, n * sizeof *b00);
 2562              		.loc 3 295 2
 2563 00f2 7B6C     		ldr	r3, [r7, #68]
 2564 00f4 DB00     		lsls	r3, r3, #3
 2565 00f6 1A46     		mov	r2, r3
 2566 00f8 396C     		ldr	r1, [r7, #64]
 2567 00fa F869     		ldr	r0, [r7, #28]
 2568 00fc FFF7FEFF 		bl	memcpy
 296:sign.c        **** 	Zf(poly_mulselfadj_fft)(g00, logn);
 2569              		.loc 3 296 2
 2570 0100 796D     		ldr	r1, [r7, #84]
 2571 0102 F869     		ldr	r0, [r7, #28]
 2572 0104 FFF7FEFF 		bl	falcon_inner_poly_mulselfadj_fft
 297:sign.c        **** 	memcpy(gxx, b01, n * sizeof *b01);
 2573              		.loc 3 297 2
 2574 0108 7B6C     		ldr	r3, [r7, #68]
 2575 010a DB00     		lsls	r3, r3, #3
 2576 010c 1A46     		mov	r2, r3
 2577 010e F96B     		ldr	r1, [r7, #60]
 2578 0110 3869     		ldr	r0, [r7, #16]
 2579 0112 FFF7FEFF 		bl	memcpy
 298:sign.c        **** 	Zf(poly_mulselfadj_fft)(gxx, logn);
 2580              		.loc 3 298 2
 2581 0116 796D     		ldr	r1, [r7, #84]
 2582 0118 3869     		ldr	r0, [r7, #16]
 2583 011a FFF7FEFF 		bl	falcon_inner_poly_mulselfadj_fft
 299:sign.c        **** 	Zf(poly_add)(g00, gxx, logn);
 2584              		.loc 3 299 2
 2585 011e 7A6D     		ldr	r2, [r7, #84]
 2586 0120 3969     		ldr	r1, [r7, #16]
 2587 0122 F869     		ldr	r0, [r7, #28]
 2588 0124 FFF7FEFF 		bl	falcon_inner_poly_add
 300:sign.c        **** 
 301:sign.c        **** 	memcpy(g01, b00, n * sizeof *b00);
 2589              		.loc 3 301 2
 2590 0128 7B6C     		ldr	r3, [r7, #68]
 2591 012a DB00     		lsls	r3, r3, #3
 2592 012c 1A46     		mov	r2, r3
 2593 012e 396C     		ldr	r1, [r7, #64]
 2594 0130 B869     		ldr	r0, [r7, #24]
 2595 0132 FFF7FEFF 		bl	memcpy
 302:sign.c        **** 	Zf(poly_muladj_fft)(g01, b10, logn);
 2596              		.loc 3 302 2
 2597 0136 7A6D     		ldr	r2, [r7, #84]
 2598 0138 B96B     		ldr	r1, [r7, #56]
 2599 013a B869     		ldr	r0, [r7, #24]
 2600 013c FFF7FEFF 		bl	falcon_inner_poly_muladj_fft
 303:sign.c        **** 	memcpy(gxx, b01, n * sizeof *b01);
 2601              		.loc 3 303 2
 2602 0140 7B6C     		ldr	r3, [r7, #68]
 2603 0142 DB00     		lsls	r3, r3, #3
 2604 0144 1A46     		mov	r2, r3
 2605 0146 F96B     		ldr	r1, [r7, #60]
 2606 0148 3869     		ldr	r0, [r7, #16]
 2607 014a FFF7FEFF 		bl	memcpy
 304:sign.c        **** 	Zf(poly_muladj_fft)(gxx, b11, logn);
 2608              		.loc 3 304 2
 2609 014e 7A6D     		ldr	r2, [r7, #84]
 2610 0150 796B     		ldr	r1, [r7, #52]
 2611 0152 3869     		ldr	r0, [r7, #16]
 2612 0154 FFF7FEFF 		bl	falcon_inner_poly_muladj_fft
 305:sign.c        **** 	Zf(poly_add)(g01, gxx, logn);
 2613              		.loc 3 305 2
 2614 0158 7A6D     		ldr	r2, [r7, #84]
 2615 015a 3969     		ldr	r1, [r7, #16]
 2616 015c B869     		ldr	r0, [r7, #24]
 2617 015e FFF7FEFF 		bl	falcon_inner_poly_add
 306:sign.c        **** 
 307:sign.c        **** 	memcpy(g11, b10, n * sizeof *b10);
 2618              		.loc 3 307 2
 2619 0162 7B6C     		ldr	r3, [r7, #68]
 2620 0164 DB00     		lsls	r3, r3, #3
 2621 0166 1A46     		mov	r2, r3
 2622 0168 B96B     		ldr	r1, [r7, #56]
 2623 016a 7869     		ldr	r0, [r7, #20]
 2624 016c FFF7FEFF 		bl	memcpy
 308:sign.c        **** 	Zf(poly_mulselfadj_fft)(g11, logn);
 2625              		.loc 3 308 2
 2626 0170 796D     		ldr	r1, [r7, #84]
 2627 0172 7869     		ldr	r0, [r7, #20]
 2628 0174 FFF7FEFF 		bl	falcon_inner_poly_mulselfadj_fft
 309:sign.c        **** 	memcpy(gxx, b11, n * sizeof *b11);
 2629              		.loc 3 309 2
 2630 0178 7B6C     		ldr	r3, [r7, #68]
 2631 017a DB00     		lsls	r3, r3, #3
 2632 017c 1A46     		mov	r2, r3
 2633 017e 796B     		ldr	r1, [r7, #52]
 2634 0180 3869     		ldr	r0, [r7, #16]
 2635 0182 FFF7FEFF 		bl	memcpy
 310:sign.c        **** 	Zf(poly_mulselfadj_fft)(gxx, logn);
 2636              		.loc 3 310 2
 2637 0186 796D     		ldr	r1, [r7, #84]
 2638 0188 3869     		ldr	r0, [r7, #16]
 2639 018a FFF7FEFF 		bl	falcon_inner_poly_mulselfadj_fft
 311:sign.c        **** 	Zf(poly_add)(g11, gxx, logn);
 2640              		.loc 3 311 2
 2641 018e 7A6D     		ldr	r2, [r7, #84]
 2642 0190 3969     		ldr	r1, [r7, #16]
 2643 0192 7869     		ldr	r0, [r7, #20]
 2644 0194 FFF7FEFF 		bl	falcon_inner_poly_add
 312:sign.c        **** 
 313:sign.c        **** 	/*
 314:sign.c        **** 	 * Compute the Falcon tree.
 315:sign.c        **** 	 */
 316:sign.c        **** 	ffLDL_fft(tree, g00, g01, g11, logn, gxx);
 2645              		.loc 3 316 2
 2646 0198 3B69     		ldr	r3, [r7, #16]
 2647 019a 0193     		str	r3, [sp, #4]
 2648 019c 7B6D     		ldr	r3, [r7, #84]
 2649 019e 0093     		str	r3, [sp]
 2650 01a0 7B69     		ldr	r3, [r7, #20]
 2651 01a2 BA69     		ldr	r2, [r7, #24]
 2652 01a4 F969     		ldr	r1, [r7, #28]
 2653 01a6 386B     		ldr	r0, [r7, #48]
 2654 01a8 FFF7FEFF 		bl	ffLDL_fft
 317:sign.c        **** 
 318:sign.c        **** 	/*
 319:sign.c        **** 	 * Normalize tree.
 320:sign.c        **** 	 */
 321:sign.c        **** 	ffLDL_binary_normalize(tree, logn, logn);
 2655              		.loc 3 321 2
 2656 01ac 7A6D     		ldr	r2, [r7, #84]
 2657 01ae 796D     		ldr	r1, [r7, #84]
 2658 01b0 386B     		ldr	r0, [r7, #48]
 2659 01b2 FFF7FEFF 		bl	ffLDL_binary_normalize
 322:sign.c        **** }
 2660              		.loc 3 322 1
 2661 01b6 00BF     		nop
 2662 01b8 4837     		adds	r7, r7, #72
 2663              	.LCFI129:
 2664              		.cfi_def_cfa_offset 8
 2665 01ba BD46     		mov	sp, r7
 2666              	.LCFI130:
 2667              		.cfi_def_cfa_register 13
 2668              		@ sp needed
 2669 01bc 80BD     		pop	{r7, pc}
 2670              		.cfi_endproc
 2671              	.LFE28:
 2673              		.section	.text.ffSampling_fft_dyntree,"ax",%progbits
 2674              		.align	1
 2675              		.syntax unified
 2676              		.thumb
 2677              		.thumb_func
 2678              		.fpu softvfp
 2680              	ffSampling_fft_dyntree:
 2681              	.LFB29:
 323:sign.c        **** 
 324:sign.c        **** typedef int (*samplerZ)(void *ctx, fpr mu, fpr sigma);
 325:sign.c        **** 
 326:sign.c        **** /*
 327:sign.c        ****  * Perform Fast Fourier Sampling for target vector t. The Gram matrix
 328:sign.c        ****  * is provided (G = [[g00, g01], [adj(g01), g11]]). The sampled vector
 329:sign.c        ****  * is written over (t0,t1). The Gram matrix is modified as well. The
 330:sign.c        ****  * tmp[] buffer must have room for four polynomials.
 331:sign.c        ****  */
 332:sign.c        **** static void
 333:sign.c        **** ffSampling_fft_dyntree(samplerZ samp, void *samp_ctx,
 334:sign.c        **** 	fpr *restrict t0, fpr *restrict t1,
 335:sign.c        **** 	fpr *restrict g00, fpr *restrict g01, fpr *restrict g11,
 336:sign.c        **** 	unsigned orig_logn, unsigned logn, fpr *restrict tmp)
 337:sign.c        **** {
 2682              		.loc 3 337 1
 2683              		.cfi_startproc
 2684              		@ args = 24, pretend = 0, frame = 40
 2685              		@ frame_needed = 1, uses_anonymous_args = 0
 2686 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 2687              	.LCFI131:
 2688              		.cfi_def_cfa_offset 28
 2689              		.cfi_offset 4, -28
 2690              		.cfi_offset 5, -24
 2691              		.cfi_offset 6, -20
 2692              		.cfi_offset 7, -16
 2693              		.cfi_offset 8, -12
 2694              		.cfi_offset 9, -8
 2695              		.cfi_offset 14, -4
 2696 0004 91B0     		sub	sp, sp, #68
 2697              	.LCFI132:
 2698              		.cfi_def_cfa_offset 96
 2699 0006 06AF     		add	r7, sp, #24
 2700              	.LCFI133:
 2701              		.cfi_def_cfa 7, 72
 2702 0008 F860     		str	r0, [r7, #12]
 2703 000a B960     		str	r1, [r7, #8]
 2704 000c 7A60     		str	r2, [r7, #4]
 2705 000e 3B60     		str	r3, [r7]
 338:sign.c        **** 	size_t n, hn;
 339:sign.c        **** 	fpr *z0, *z1;
 340:sign.c        **** 
 341:sign.c        **** 	/*
 342:sign.c        **** 	 * Deepest level: the LDL tree leaf value is just g00 (the
 343:sign.c        **** 	 * array has length only 1 at this point); we normalize it
 344:sign.c        **** 	 * with regards to sigma, then use it for sampling.
 345:sign.c        **** 	 */
 346:sign.c        **** 	if (logn == 0) {
 2706              		.loc 3 346 5
 2707 0010 BB6D     		ldr	r3, [r7, #88]
 2708 0012 002B     		cmp	r3, #0
 2709 0014 45D1     		bne	.L59
 2710              	.LBB2:
 347:sign.c        **** 		fpr leaf;
 348:sign.c        **** 
 349:sign.c        **** 		leaf = g00[0];
 2711              		.loc 3 349 8
 2712 0016 BB6C     		ldr	r3, [r7, #72]
 2713 0018 D3E90023 		ldrd	r2, [r3]
 2714 001c C7E90423 		strd	r2, [r7, #16]
 350:sign.c        **** 		leaf = fpr_mul(fpr_sqrt(leaf), fpr_inv_sigma[orig_logn]);
 2715              		.loc 3 350 10
 2716 0020 D7E90401 		ldrd	r0, [r7, #16]
 2717 0024 FFF7FEFF 		bl	falcon_inner_fpr_sqrt
 2718 0028 8A4A     		ldr	r2, .L61
 2719 002a 7B6D     		ldr	r3, [r7, #84]
 2720 002c DB00     		lsls	r3, r3, #3
 2721 002e 1344     		add	r3, r3, r2
 2722 0030 D3E90023 		ldrd	r2, [r3]
 2723 0034 FFF7FEFF 		bl	falcon_inner_fpr_mul
 2724 0038 C7E90401 		strd	r0, [r7, #16]
 351:sign.c        **** 		t0[0] = fpr_of(samp(samp_ctx, t0[0], leaf));
 2725              		.loc 3 351 18
 2726 003c 7B68     		ldr	r3, [r7, #4]
 2727 003e D3E90001 		ldrd	r0, [r3]
 2728 0042 D7E90423 		ldrd	r2, [r7, #16]
 2729 0046 CDE90023 		strd	r2, [sp]
 2730 004a FE68     		ldr	r6, [r7, #12]
 2731 004c 0246     		mov	r2, r0
 2732 004e 0B46     		mov	r3, r1
 2733 0050 B868     		ldr	r0, [r7, #8]
 2734 0052 B047     		blx	r6
 2735              	.LVL0:
 2736 0054 0346     		mov	r3, r0
 2737              		.loc 3 351 11
 2738 0056 DA17     		asrs	r2, r3, #31
 2739 0058 9846     		mov	r8, r3
 2740 005a 9146     		mov	r9, r2
 2741 005c 4046     		mov	r0, r8
 2742 005e 4946     		mov	r1, r9
 2743 0060 FFF7FEFF 		bl	fpr_of
 2744 0064 0246     		mov	r2, r0
 2745 0066 0B46     		mov	r3, r1
 2746              		.loc 3 351 9
 2747 0068 7968     		ldr	r1, [r7, #4]
 2748 006a C1E90023 		strd	r2, [r1]
 352:sign.c        **** 		t1[0] = fpr_of(samp(samp_ctx, t1[0], leaf));
 2749              		.loc 3 352 18
 2750 006e 3B68     		ldr	r3, [r7]
 2751 0070 D3E90001 		ldrd	r0, [r3]
 2752 0074 D7E90423 		ldrd	r2, [r7, #16]
 2753 0078 CDE90023 		strd	r2, [sp]
 2754 007c FE68     		ldr	r6, [r7, #12]
 2755 007e 0246     		mov	r2, r0
 2756 0080 0B46     		mov	r3, r1
 2757 0082 B868     		ldr	r0, [r7, #8]
 2758 0084 B047     		blx	r6
 2759              	.LVL1:
 2760 0086 0346     		mov	r3, r0
 2761              		.loc 3 352 11
 2762 0088 DA17     		asrs	r2, r3, #31
 2763 008a 1C46     		mov	r4, r3
 2764 008c 1546     		mov	r5, r2
 2765 008e 2046     		mov	r0, r4
 2766 0090 2946     		mov	r1, r5
 2767 0092 FFF7FEFF 		bl	fpr_of
 2768 0096 0246     		mov	r2, r0
 2769 0098 0B46     		mov	r3, r1
 2770              		.loc 3 352 9
 2771 009a 3968     		ldr	r1, [r7]
 2772 009c C1E90023 		strd	r2, [r1]
 353:sign.c        **** 		return;
 2773              		.loc 3 353 3
 2774 00a0 D4E0     		b	.L58
 2775              	.L59:
 2776              	.LBE2:
 354:sign.c        **** 	}
 355:sign.c        **** 
 356:sign.c        **** 	n = (size_t)1 << logn;
 2777              		.loc 3 356 4
 2778 00a2 0122     		movs	r2, #1
 2779 00a4 BB6D     		ldr	r3, [r7, #88]
 2780 00a6 02FA03F3 		lsl	r3, r2, r3
 2781 00aa 7B62     		str	r3, [r7, #36]
 357:sign.c        **** 	hn = n >> 1;
 2782              		.loc 3 357 5
 2783 00ac 7B6A     		ldr	r3, [r7, #36]
 2784 00ae 5B08     		lsrs	r3, r3, #1
 2785 00b0 3B62     		str	r3, [r7, #32]
 358:sign.c        **** 
 359:sign.c        **** 	/*
 360:sign.c        **** 	 * Decompose G into LDL. We only need d00 (identical to g00),
 361:sign.c        **** 	 * d11, and l10; we do that in place.
 362:sign.c        **** 	 */
 363:sign.c        **** 	Zf(poly_LDL_fft)(g00, g01, g11, logn);
 2786              		.loc 3 363 2
 2787 00b2 BB6D     		ldr	r3, [r7, #88]
 2788 00b4 3A6D     		ldr	r2, [r7, #80]
 2789 00b6 F96C     		ldr	r1, [r7, #76]
 2790 00b8 B86C     		ldr	r0, [r7, #72]
 2791 00ba FFF7FEFF 		bl	falcon_inner_poly_LDL_fft
 364:sign.c        **** 
 365:sign.c        **** 	/*
 366:sign.c        **** 	 * Split d00 and d11 and expand them into half-size quasi-cyclic
 367:sign.c        **** 	 * Gram matrices. We also save l10 in tmp[].
 368:sign.c        **** 	 */
 369:sign.c        **** 	Zf(poly_split_fft)(tmp, tmp + hn, g00, logn);
 2792              		.loc 3 369 30
 2793 00be 3B6A     		ldr	r3, [r7, #32]
 2794 00c0 DB00     		lsls	r3, r3, #3
 2795              		.loc 3 369 2
 2796 00c2 FA6D     		ldr	r2, [r7, #92]
 2797 00c4 D118     		adds	r1, r2, r3
 2798 00c6 BB6D     		ldr	r3, [r7, #88]
 2799 00c8 BA6C     		ldr	r2, [r7, #72]
 2800 00ca F86D     		ldr	r0, [r7, #92]
 2801 00cc FFF7FEFF 		bl	falcon_inner_poly_split_fft
 370:sign.c        **** 	memcpy(g00, tmp, n * sizeof *tmp);
 2802              		.loc 3 370 2
 2803 00d0 7B6A     		ldr	r3, [r7, #36]
 2804 00d2 DB00     		lsls	r3, r3, #3
 2805 00d4 1A46     		mov	r2, r3
 2806 00d6 F96D     		ldr	r1, [r7, #92]
 2807 00d8 B86C     		ldr	r0, [r7, #72]
 2808 00da FFF7FEFF 		bl	memcpy
 371:sign.c        **** 	Zf(poly_split_fft)(tmp, tmp + hn, g11, logn);
 2809              		.loc 3 371 30
 2810 00de 3B6A     		ldr	r3, [r7, #32]
 2811 00e0 DB00     		lsls	r3, r3, #3
 2812              		.loc 3 371 2
 2813 00e2 FA6D     		ldr	r2, [r7, #92]
 2814 00e4 D118     		adds	r1, r2, r3
 2815 00e6 BB6D     		ldr	r3, [r7, #88]
 2816 00e8 3A6D     		ldr	r2, [r7, #80]
 2817 00ea F86D     		ldr	r0, [r7, #92]
 2818 00ec FFF7FEFF 		bl	falcon_inner_poly_split_fft
 372:sign.c        **** 	memcpy(g11, tmp, n * sizeof *tmp);
 2819              		.loc 3 372 2
 2820 00f0 7B6A     		ldr	r3, [r7, #36]
 2821 00f2 DB00     		lsls	r3, r3, #3
 2822 00f4 1A46     		mov	r2, r3
 2823 00f6 F96D     		ldr	r1, [r7, #92]
 2824 00f8 386D     		ldr	r0, [r7, #80]
 2825 00fa FFF7FEFF 		bl	memcpy
 373:sign.c        **** 	memcpy(tmp, g01, n * sizeof *g01);
 2826              		.loc 3 373 2
 2827 00fe 7B6A     		ldr	r3, [r7, #36]
 2828 0100 DB00     		lsls	r3, r3, #3
 2829 0102 1A46     		mov	r2, r3
 2830 0104 F96C     		ldr	r1, [r7, #76]
 2831 0106 F86D     		ldr	r0, [r7, #92]
 2832 0108 FFF7FEFF 		bl	memcpy
 374:sign.c        **** 	memcpy(g01, g00, hn * sizeof *g00);
 2833              		.loc 3 374 2
 2834 010c 3B6A     		ldr	r3, [r7, #32]
 2835 010e DB00     		lsls	r3, r3, #3
 2836 0110 1A46     		mov	r2, r3
 2837 0112 B96C     		ldr	r1, [r7, #72]
 2838 0114 F86C     		ldr	r0, [r7, #76]
 2839 0116 FFF7FEFF 		bl	memcpy
 375:sign.c        **** 	memcpy(g01 + hn, g11, hn * sizeof *g00);
 2840              		.loc 3 375 13
 2841 011a 3B6A     		ldr	r3, [r7, #32]
 2842 011c DB00     		lsls	r3, r3, #3
 2843 011e FA6C     		ldr	r2, [r7, #76]
 2844 0120 D018     		adds	r0, r2, r3
 2845              		.loc 3 375 2
 2846 0122 3B6A     		ldr	r3, [r7, #32]
 2847 0124 DB00     		lsls	r3, r3, #3
 2848 0126 1A46     		mov	r2, r3
 2849 0128 396D     		ldr	r1, [r7, #80]
 2850 012a FFF7FEFF 		bl	memcpy
 376:sign.c        **** 
 377:sign.c        **** 	/*
 378:sign.c        **** 	 * The half-size Gram matrices for the recursive LDL tree
 379:sign.c        **** 	 * building are now:
 380:sign.c        **** 	 *   - left sub-tree: g00, g00+hn, g01
 381:sign.c        **** 	 *   - right sub-tree: g11, g11+hn, g01+hn
 382:sign.c        **** 	 * l10 is in tmp[].
 383:sign.c        **** 	 */
 384:sign.c        **** 
 385:sign.c        **** 	/*
 386:sign.c        **** 	 * We split t1 and use the first recursive call on the two
 387:sign.c        **** 	 * halves, using the right sub-tree. The result is merged
 388:sign.c        **** 	 * back into tmp + 2*n.
 389:sign.c        **** 	 */
 390:sign.c        **** 	z1 = tmp + n;
 2851              		.loc 3 390 11
 2852 012e 7B6A     		ldr	r3, [r7, #36]
 2853 0130 DB00     		lsls	r3, r3, #3
 2854              		.loc 3 390 5
 2855 0132 FA6D     		ldr	r2, [r7, #92]
 2856 0134 1344     		add	r3, r3, r2
 2857 0136 FB61     		str	r3, [r7, #28]
 391:sign.c        **** 	Zf(poly_split_fft)(z1, z1 + hn, t1, logn);
 2858              		.loc 3 391 28
 2859 0138 3B6A     		ldr	r3, [r7, #32]
 2860 013a DB00     		lsls	r3, r3, #3
 2861              		.loc 3 391 2
 2862 013c FA69     		ldr	r2, [r7, #28]
 2863 013e D118     		adds	r1, r2, r3
 2864 0140 BB6D     		ldr	r3, [r7, #88]
 2865 0142 3A68     		ldr	r2, [r7]
 2866 0144 F869     		ldr	r0, [r7, #28]
 2867 0146 FFF7FEFF 		bl	falcon_inner_poly_split_fft
 392:sign.c        **** 	ffSampling_fft_dyntree(samp, samp_ctx, z1, z1 + hn,
 2868              		.loc 3 392 48
 2869 014a 3B6A     		ldr	r3, [r7, #32]
 2870 014c DB00     		lsls	r3, r3, #3
 2871              		.loc 3 392 2
 2872 014e FA69     		ldr	r2, [r7, #28]
 2873 0150 D518     		adds	r5, r2, r3
 393:sign.c        **** 		g11, g11 + hn, g01 + hn, orig_logn, logn - 1, z1 + n);
 2874              		.loc 3 393 12
 2875 0152 3B6A     		ldr	r3, [r7, #32]
 2876 0154 DB00     		lsls	r3, r3, #3
 392:sign.c        **** 	ffSampling_fft_dyntree(samp, samp_ctx, z1, z1 + hn,
 2877              		.loc 3 392 2
 2878 0156 3A6D     		ldr	r2, [r7, #80]
 2879 0158 1344     		add	r3, r3, r2
 2880              		.loc 3 393 22
 2881 015a 3A6A     		ldr	r2, [r7, #32]
 2882 015c D200     		lsls	r2, r2, #3
 392:sign.c        **** 	ffSampling_fft_dyntree(samp, samp_ctx, z1, z1 + hn,
 2883              		.loc 3 392 2
 2884 015e F96C     		ldr	r1, [r7, #76]
 2885 0160 0A44     		add	r2, r2, r1
 2886 0162 B96D     		ldr	r1, [r7, #88]
 2887 0164 0139     		subs	r1, r1, #1
 2888              		.loc 3 393 52
 2889 0166 786A     		ldr	r0, [r7, #36]
 2890 0168 C000     		lsls	r0, r0, #3
 392:sign.c        **** 	ffSampling_fft_dyntree(samp, samp_ctx, z1, z1 + hn,
 2891              		.loc 3 392 2
 2892 016a FC69     		ldr	r4, [r7, #28]
 2893 016c 2044     		add	r0, r0, r4
 2894 016e 0590     		str	r0, [sp, #20]
 2895 0170 0491     		str	r1, [sp, #16]
 2896 0172 796D     		ldr	r1, [r7, #84]
 2897 0174 0391     		str	r1, [sp, #12]
 2898 0176 0292     		str	r2, [sp, #8]
 2899 0178 0193     		str	r3, [sp, #4]
 2900 017a 3B6D     		ldr	r3, [r7, #80]
 2901 017c 0093     		str	r3, [sp]
 2902 017e 2B46     		mov	r3, r5
 2903 0180 FA69     		ldr	r2, [r7, #28]
 2904 0182 B968     		ldr	r1, [r7, #8]
 2905 0184 F868     		ldr	r0, [r7, #12]
 2906 0186 FFF73BFF 		bl	ffSampling_fft_dyntree
 394:sign.c        **** 	Zf(poly_merge_fft)(tmp + (n << 1), z1, z1 + hn, logn);
 2907              		.loc 3 394 2
 2908 018a 7B6A     		ldr	r3, [r7, #36]
 2909 018c 1B01     		lsls	r3, r3, #4
 2910 018e FA6D     		ldr	r2, [r7, #92]
 2911 0190 D018     		adds	r0, r2, r3
 2912              		.loc 3 394 44
 2913 0192 3B6A     		ldr	r3, [r7, #32]
 2914 0194 DB00     		lsls	r3, r3, #3
 2915 0196 FA69     		ldr	r2, [r7, #28]
 2916 0198 1A44     		add	r2, r2, r3
 2917              		.loc 3 394 2
 2918 019a BB6D     		ldr	r3, [r7, #88]
 2919 019c F969     		ldr	r1, [r7, #28]
 2920 019e FFF7FEFF 		bl	falcon_inner_poly_merge_fft
 395:sign.c        **** 
 396:sign.c        **** 	/*
 397:sign.c        **** 	 * Compute tb0 = t0 + (t1 - z1) * l10.
 398:sign.c        **** 	 * At that point, l10 is in tmp, t1 is unmodified, and z1 is
 399:sign.c        **** 	 * in tmp + (n << 1). The buffer in z1 is free.
 400:sign.c        **** 	 *
 401:sign.c        **** 	 * In the end, z1 is written over t1, and tb0 is in t0.
 402:sign.c        **** 	 */
 403:sign.c        **** 	memcpy(z1, t1, n * sizeof *t1);
 2921              		.loc 3 403 2
 2922 01a2 7B6A     		ldr	r3, [r7, #36]
 2923 01a4 DB00     		lsls	r3, r3, #3
 2924 01a6 1A46     		mov	r2, r3
 2925 01a8 3968     		ldr	r1, [r7]
 2926 01aa F869     		ldr	r0, [r7, #28]
 2927 01ac FFF7FEFF 		bl	memcpy
 404:sign.c        **** 	Zf(poly_sub)(z1, tmp + (n << 1), logn);
 2928              		.loc 3 404 2
 2929 01b0 7B6A     		ldr	r3, [r7, #36]
 2930 01b2 1B01     		lsls	r3, r3, #4
 2931              		.loc 3 404 23
 2932 01b4 FA6D     		ldr	r2, [r7, #92]
 2933 01b6 1344     		add	r3, r3, r2
 2934              		.loc 3 404 2
 2935 01b8 BA6D     		ldr	r2, [r7, #88]
 2936 01ba 1946     		mov	r1, r3
 2937 01bc F869     		ldr	r0, [r7, #28]
 2938 01be FFF7FEFF 		bl	falcon_inner_poly_sub
 405:sign.c        **** 	memcpy(t1, tmp + (n << 1), n * sizeof *tmp);
 2939              		.loc 3 405 2
 2940 01c2 7B6A     		ldr	r3, [r7, #36]
 2941 01c4 1B01     		lsls	r3, r3, #4
 2942              		.loc 3 405 17
 2943 01c6 FA6D     		ldr	r2, [r7, #92]
 2944 01c8 D118     		adds	r1, r2, r3
 2945              		.loc 3 405 2
 2946 01ca 7B6A     		ldr	r3, [r7, #36]
 2947 01cc DB00     		lsls	r3, r3, #3
 2948 01ce 1A46     		mov	r2, r3
 2949 01d0 3868     		ldr	r0, [r7]
 2950 01d2 FFF7FEFF 		bl	memcpy
 406:sign.c        **** 	Zf(poly_mul_fft)(tmp, z1, logn);
 2951              		.loc 3 406 2
 2952 01d6 BA6D     		ldr	r2, [r7, #88]
 2953 01d8 F969     		ldr	r1, [r7, #28]
 2954 01da F86D     		ldr	r0, [r7, #92]
 2955 01dc FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 407:sign.c        **** 	Zf(poly_add)(t0, tmp, logn);
 2956              		.loc 3 407 2
 2957 01e0 BA6D     		ldr	r2, [r7, #88]
 2958 01e2 F96D     		ldr	r1, [r7, #92]
 2959 01e4 7868     		ldr	r0, [r7, #4]
 2960 01e6 FFF7FEFF 		bl	falcon_inner_poly_add
 408:sign.c        **** 
 409:sign.c        **** 	/*
 410:sign.c        **** 	 * Second recursive invocation, on the split tb0 (currently in t0)
 411:sign.c        **** 	 * and the left sub-tree.
 412:sign.c        **** 	 */
 413:sign.c        **** 	z0 = tmp;
 2961              		.loc 3 413 5
 2962 01ea FB6D     		ldr	r3, [r7, #92]
 2963 01ec BB61     		str	r3, [r7, #24]
 414:sign.c        **** 	Zf(poly_split_fft)(z0, z0 + hn, t0, logn);
 2964              		.loc 3 414 28
 2965 01ee 3B6A     		ldr	r3, [r7, #32]
 2966 01f0 DB00     		lsls	r3, r3, #3
 2967              		.loc 3 414 2
 2968 01f2 BA69     		ldr	r2, [r7, #24]
 2969 01f4 D118     		adds	r1, r2, r3
 2970 01f6 BB6D     		ldr	r3, [r7, #88]
 2971 01f8 7A68     		ldr	r2, [r7, #4]
 2972 01fa B869     		ldr	r0, [r7, #24]
 2973 01fc FFF7FEFF 		bl	falcon_inner_poly_split_fft
 415:sign.c        **** 	ffSampling_fft_dyntree(samp, samp_ctx, z0, z0 + hn,
 2974              		.loc 3 415 48
 2975 0200 3B6A     		ldr	r3, [r7, #32]
 2976 0202 DB00     		lsls	r3, r3, #3
 2977              		.loc 3 415 2
 2978 0204 BA69     		ldr	r2, [r7, #24]
 2979 0206 D418     		adds	r4, r2, r3
 416:sign.c        **** 		g00, g00 + hn, g01, orig_logn, logn - 1, z0 + n);
 2980              		.loc 3 416 12
 2981 0208 3B6A     		ldr	r3, [r7, #32]
 2982 020a DB00     		lsls	r3, r3, #3
 415:sign.c        **** 	ffSampling_fft_dyntree(samp, samp_ctx, z0, z0 + hn,
 2983              		.loc 3 415 2
 2984 020c BA6C     		ldr	r2, [r7, #72]
 2985 020e 1344     		add	r3, r3, r2
 2986 0210 BA6D     		ldr	r2, [r7, #88]
 2987 0212 013A     		subs	r2, r2, #1
 2988              		.loc 3 416 47
 2989 0214 796A     		ldr	r1, [r7, #36]
 2990 0216 C900     		lsls	r1, r1, #3
 415:sign.c        **** 	ffSampling_fft_dyntree(samp, samp_ctx, z0, z0 + hn,
 2991              		.loc 3 415 2
 2992 0218 B869     		ldr	r0, [r7, #24]
 2993 021a 0144     		add	r1, r1, r0
 2994 021c 0591     		str	r1, [sp, #20]
 2995 021e 0492     		str	r2, [sp, #16]
 2996 0220 7A6D     		ldr	r2, [r7, #84]
 2997 0222 0392     		str	r2, [sp, #12]
 2998 0224 FA6C     		ldr	r2, [r7, #76]
 2999 0226 0292     		str	r2, [sp, #8]
 3000 0228 0193     		str	r3, [sp, #4]
 3001 022a BB6C     		ldr	r3, [r7, #72]
 3002 022c 0093     		str	r3, [sp]
 3003 022e 2346     		mov	r3, r4
 3004 0230 BA69     		ldr	r2, [r7, #24]
 3005 0232 B968     		ldr	r1, [r7, #8]
 3006 0234 F868     		ldr	r0, [r7, #12]
 3007 0236 FFF7E3FE 		bl	ffSampling_fft_dyntree
 417:sign.c        **** 	Zf(poly_merge_fft)(t0, z0, z0 + hn, logn);
 3008              		.loc 3 417 32
 3009 023a 3B6A     		ldr	r3, [r7, #32]
 3010 023c DB00     		lsls	r3, r3, #3
 3011 023e BA69     		ldr	r2, [r7, #24]
 3012 0240 1A44     		add	r2, r2, r3
 3013              		.loc 3 417 2
 3014 0242 BB6D     		ldr	r3, [r7, #88]
 3015 0244 B969     		ldr	r1, [r7, #24]
 3016 0246 7868     		ldr	r0, [r7, #4]
 3017 0248 FFF7FEFF 		bl	falcon_inner_poly_merge_fft
 3018              	.L58:
 418:sign.c        **** }
 3019              		.loc 3 418 1
 3020 024c 2C37     		adds	r7, r7, #44
 3021              	.LCFI134:
 3022              		.cfi_def_cfa_offset 28
 3023 024e BD46     		mov	sp, r7
 3024              	.LCFI135:
 3025              		.cfi_def_cfa_register 13
 3026              		@ sp needed
 3027 0250 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 3028              	.L62:
 3029              		.align	2
 3030              	.L61:
 3031 0254 18000000 		.word	fpr_inv_sigma
 3032              		.cfi_endproc
 3033              	.LFE29:
 3035              		.section	.text.ffSampling_fft,"ax",%progbits
 3036              		.align	1
 3037              		.syntax unified
 3038              		.thumb
 3039              		.thumb_func
 3040              		.fpu softvfp
 3042              	ffSampling_fft:
 3043              	.LFB30:
 419:sign.c        **** 
 420:sign.c        **** /*
 421:sign.c        ****  * Perform Fast Fourier Sampling for target vector t and LDL tree T.
 422:sign.c        ****  * tmp[] must have size for at least two polynomials of size 2^logn.
 423:sign.c        ****  */
 424:sign.c        **** static void
 425:sign.c        **** ffSampling_fft(samplerZ samp, void *samp_ctx,
 426:sign.c        **** 	fpr *restrict z0, fpr *restrict z1,
 427:sign.c        **** 	const fpr *restrict tree,
 428:sign.c        **** 	const fpr *restrict t0, const fpr *restrict t1, unsigned logn,
 429:sign.c        **** 	fpr *restrict tmp)
 430:sign.c        **** {
 3044              		.loc 3 430 1
 3045              		.cfi_startproc
 3046              		@ args = 20, pretend = 0, frame = 312
 3047              		@ frame_needed = 1, uses_anonymous_args = 0
 3048 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 3049              	.LCFI136:
 3050              		.cfi_def_cfa_offset 32
 3051              		.cfi_offset 4, -32
 3052              		.cfi_offset 5, -28
 3053              		.cfi_offset 7, -24
 3054              		.cfi_offset 8, -20
 3055              		.cfi_offset 9, -16
 3056              		.cfi_offset 10, -12
 3057              		.cfi_offset 11, -8
 3058              		.cfi_offset 14, -4
 3059 0004 D4B0     		sub	sp, sp, #336
 3060              	.LCFI137:
 3061              		.cfi_def_cfa_offset 368
 3062 0006 06AF     		add	r7, sp, #24
 3063              	.LCFI138:
 3064              		.cfi_def_cfa 7, 344
 3065 0008 7865     		str	r0, [r7, #84]
 3066 000a 3965     		str	r1, [r7, #80]
 3067 000c FA64     		str	r2, [r7, #76]
 3068 000e BB64     		str	r3, [r7, #72]
 431:sign.c        **** 	size_t n, hn;
 432:sign.c        **** 	const fpr *tree0, *tree1;
 433:sign.c        **** 
 434:sign.c        **** 	/*
 435:sign.c        **** 	 * When logn == 2, we inline the last two recursion levels.
 436:sign.c        **** 	 */
 437:sign.c        **** 	if (logn == 2) {
 3069              		.loc 3 437 5
 3070 0010 D7F86431 		ldr	r3, [r7, #356]
 3071 0014 022B     		cmp	r3, #2
 3072 0016 40F0D383 		bne	.L64
 3073              	.LBB3:
 438:sign.c        **** 		fpr x0, x1, y0, y1, w0, w1, w2, w3, sigma;
 439:sign.c        **** 		fpr a_re, a_im, b_re, b_im, c_re, c_im;
 440:sign.c        **** 
 441:sign.c        **** 		tree0 = tree + 4;
 3074              		.loc 3 441 9
 3075 001a D7F85831 		ldr	r3, [r7, #344]
 3076 001e 2033     		adds	r3, r3, #32
 3077 0020 C7F82C31 		str	r3, [r7, #300]
 442:sign.c        **** 		tree1 = tree + 8;
 3078              		.loc 3 442 9
 3079 0024 D7F85831 		ldr	r3, [r7, #344]
 3080 0028 4033     		adds	r3, r3, #64
 3081 002a C7F82831 		str	r3, [r7, #296]
 443:sign.c        **** 
 444:sign.c        **** 		/*
 445:sign.c        **** 		 * We split t1 into w*, then do the recursive invocation,
 446:sign.c        **** 		 * with output in w*. We finally merge back into z1.
 447:sign.c        **** 		 */
 448:sign.c        **** 		a_re = t1[0];
 3082              		.loc 3 448 8
 3083 002e D7F86031 		ldr	r3, [r7, #352]
 3084 0032 D3E90023 		ldrd	r2, [r3]
 3085 0036 C7E93223 		strd	r2, [r7, #200]
 449:sign.c        **** 		a_im = t1[2];
 3086              		.loc 3 449 8
 3087 003a D7F86031 		ldr	r3, [r7, #352]
 3088 003e D3E90423 		ldrd	r2, [r3, #16]
 3089 0042 C7E93023 		strd	r2, [r7, #192]
 450:sign.c        **** 		b_re = t1[1];
 3090              		.loc 3 450 8
 3091 0046 D7F86031 		ldr	r3, [r7, #352]
 3092 004a D3E90223 		ldrd	r2, [r3, #8]
 3093 004e C7E92E23 		strd	r2, [r7, #184]
 451:sign.c        **** 		b_im = t1[3];
 3094              		.loc 3 451 8
 3095 0052 D7F86031 		ldr	r3, [r7, #352]
 3096 0056 D3E90623 		ldrd	r2, [r3, #24]
 3097 005a C7E92C23 		strd	r2, [r7, #176]
 452:sign.c        **** 		c_re = fpr_add(a_re, b_re);
 3098              		.loc 3 452 10
 3099 005e D7E92E23 		ldrd	r2, [r7, #184]
 3100 0062 D7E93201 		ldrd	r0, [r7, #200]
 3101 0066 FFF7FEFF 		bl	falcon_inner_fpr_add
 3102 006a C7E92A01 		strd	r0, [r7, #168]
 453:sign.c        **** 		c_im = fpr_add(a_im, b_im);
 3103              		.loc 3 453 10
 3104 006e D7E92C23 		ldrd	r2, [r7, #176]
 3105 0072 D7E93001 		ldrd	r0, [r7, #192]
 3106 0076 FFF7FEFF 		bl	falcon_inner_fpr_add
 3107 007a C7E92801 		strd	r0, [r7, #160]
 454:sign.c        **** 		w0 = fpr_half(c_re);
 3108              		.loc 3 454 8
 3109 007e D7E92A01 		ldrd	r0, [r7, #168]
 3110 0082 FFF7FEFF 		bl	fpr_half
 3111 0086 C7E92601 		strd	r0, [r7, #152]
 455:sign.c        **** 		w1 = fpr_half(c_im);
 3112              		.loc 3 455 8
 3113 008a D7E92801 		ldrd	r0, [r7, #160]
 3114 008e FFF7FEFF 		bl	fpr_half
 3115 0092 C7E92401 		strd	r0, [r7, #144]
 456:sign.c        **** 		c_re = fpr_sub(a_re, b_re);
 3116              		.loc 3 456 10
 3117 0096 D7E92E23 		ldrd	r2, [r7, #184]
 3118 009a D7E93201 		ldrd	r0, [r7, #200]
 3119 009e FFF7FEFF 		bl	fpr_sub
 3120 00a2 C7E92A01 		strd	r0, [r7, #168]
 457:sign.c        **** 		c_im = fpr_sub(a_im, b_im);
 3121              		.loc 3 457 10
 3122 00a6 D7E92C23 		ldrd	r2, [r7, #176]
 3123 00aa D7E93001 		ldrd	r0, [r7, #192]
 3124 00ae FFF7FEFF 		bl	fpr_sub
 3125 00b2 C7E92801 		strd	r0, [r7, #160]
 458:sign.c        **** 		w2 = fpr_mul(fpr_add(c_re, c_im), fpr_invsqrt8);
 3126              		.loc 3 458 8
 3127 00b6 D7E92823 		ldrd	r2, [r7, #160]
 3128 00ba D7E92A01 		ldrd	r0, [r7, #168]
 3129 00be FFF7FEFF 		bl	falcon_inner_fpr_add
 3130 00c2 0FF6B403 		adr	r3, .L67
 3131 00c6 D3E90023 		ldrd	r2, [r3]
 3132 00ca FFF7FEFF 		bl	falcon_inner_fpr_mul
 3133 00ce C7E92201 		strd	r0, [r7, #136]
 459:sign.c        **** 		w3 = fpr_mul(fpr_sub(c_im, c_re), fpr_invsqrt8);
 3134              		.loc 3 459 8
 3135 00d2 D7E92A23 		ldrd	r2, [r7, #168]
 3136 00d6 D7E92801 		ldrd	r0, [r7, #160]
 3137 00da FFF7FEFF 		bl	fpr_sub
 3138 00de 0FF69803 		adr	r3, .L67
 3139 00e2 D3E90023 		ldrd	r2, [r3]
 3140 00e6 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3141 00ea C7E92001 		strd	r0, [r7, #128]
 460:sign.c        **** 
 461:sign.c        **** 		x0 = w2;
 3142              		.loc 3 461 6
 3143 00ee D7E92223 		ldrd	r2, [r7, #136]
 3144 00f2 C7E91E23 		strd	r2, [r7, #120]
 462:sign.c        **** 		x1 = w3;
 3145              		.loc 3 462 6
 3146 00f6 D7E92023 		ldrd	r2, [r7, #128]
 3147 00fa C7E91C23 		strd	r2, [r7, #112]
 463:sign.c        **** 		sigma = tree1[3];
 3148              		.loc 3 463 9
 3149 00fe D7F82831 		ldr	r3, [r7, #296]
 3150 0102 D3E90623 		ldrd	r2, [r3, #24]
 3151 0106 C7E91A23 		strd	r2, [r7, #104]
 464:sign.c        **** 		w2 = fpr_of(samp(samp_ctx, x0, sigma));
 3152              		.loc 3 464 15
 3153 010a D7E91A23 		ldrd	r2, [r7, #104]
 3154 010e CDE90023 		strd	r2, [sp]
 3155 0112 796D     		ldr	r1, [r7, #84]
 3156 0114 D7E91E23 		ldrd	r2, [r7, #120]
 3157 0118 386D     		ldr	r0, [r7, #80]
 3158 011a 8847     		blx	r1
 3159              	.LVL2:
 3160 011c 0346     		mov	r3, r0
 3161              		.loc 3 464 8
 3162 011e DA17     		asrs	r2, r3, #31
 3163 0120 3B64     		str	r3, [r7, #64]
 3164 0122 7A64     		str	r2, [r7, #68]
 3165 0124 D7E91001 		ldrd	r0, [r7, #64]
 3166 0128 FFF7FEFF 		bl	fpr_of
 3167 012c C7E92201 		strd	r0, [r7, #136]
 465:sign.c        **** 		w3 = fpr_of(samp(samp_ctx, x1, sigma));
 3168              		.loc 3 465 15
 3169 0130 D7E91A23 		ldrd	r2, [r7, #104]
 3170 0134 CDE90023 		strd	r2, [sp]
 3171 0138 796D     		ldr	r1, [r7, #84]
 3172 013a D7E91C23 		ldrd	r2, [r7, #112]
 3173 013e 386D     		ldr	r0, [r7, #80]
 3174 0140 8847     		blx	r1
 3175              	.LVL3:
 3176 0142 0346     		mov	r3, r0
 3177              		.loc 3 465 8
 3178 0144 DA17     		asrs	r2, r3, #31
 3179 0146 BB63     		str	r3, [r7, #56]
 3180 0148 FA63     		str	r2, [r7, #60]
 3181 014a D7E90E01 		ldrd	r0, [r7, #56]
 3182 014e FFF7FEFF 		bl	fpr_of
 3183 0152 C7E92001 		strd	r0, [r7, #128]
 466:sign.c        **** 		a_re = fpr_sub(x0, w2);
 3184              		.loc 3 466 10
 3185 0156 D7E92223 		ldrd	r2, [r7, #136]
 3186 015a D7E91E01 		ldrd	r0, [r7, #120]
 3187 015e FFF7FEFF 		bl	fpr_sub
 3188 0162 C7E93201 		strd	r0, [r7, #200]
 467:sign.c        **** 		a_im = fpr_sub(x1, w3);
 3189              		.loc 3 467 10
 3190 0166 D7E92023 		ldrd	r2, [r7, #128]
 3191 016a D7E91C01 		ldrd	r0, [r7, #112]
 3192 016e FFF7FEFF 		bl	fpr_sub
 3193 0172 C7E93001 		strd	r0, [r7, #192]
 468:sign.c        **** 		b_re = tree1[0];
 3194              		.loc 3 468 8
 3195 0176 D7F82831 		ldr	r3, [r7, #296]
 3196 017a D3E90023 		ldrd	r2, [r3]
 3197 017e C7E92E23 		strd	r2, [r7, #184]
 469:sign.c        **** 		b_im = tree1[1];
 3198              		.loc 3 469 8
 3199 0182 D7F82831 		ldr	r3, [r7, #296]
 3200 0186 D3E90223 		ldrd	r2, [r3, #8]
 3201 018a C7E92C23 		strd	r2, [r7, #176]
 470:sign.c        **** 		c_re = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
 3202              		.loc 3 470 10
 3203 018e D7E92E23 		ldrd	r2, [r7, #184]
 3204 0192 D7E93201 		ldrd	r0, [r7, #200]
 3205 0196 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3206 019a 0446     		mov	r4, r0
 3207 019c 0D46     		mov	r5, r1
 3208 019e D7E92C23 		ldrd	r2, [r7, #176]
 3209 01a2 D7E93001 		ldrd	r0, [r7, #192]
 3210 01a6 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3211 01aa 0246     		mov	r2, r0
 3212 01ac 0B46     		mov	r3, r1
 3213 01ae 2046     		mov	r0, r4
 3214 01b0 2946     		mov	r1, r5
 3215 01b2 FFF7FEFF 		bl	fpr_sub
 3216 01b6 C7E92A01 		strd	r0, [r7, #168]
 471:sign.c        **** 		c_im = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
 3217              		.loc 3 471 10
 3218 01ba D7E92C23 		ldrd	r2, [r7, #176]
 3219 01be D7E93201 		ldrd	r0, [r7, #200]
 3220 01c2 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3221 01c6 0446     		mov	r4, r0
 3222 01c8 0D46     		mov	r5, r1
 3223 01ca D7E92E23 		ldrd	r2, [r7, #184]
 3224 01ce D7E93001 		ldrd	r0, [r7, #192]
 3225 01d2 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3226 01d6 0246     		mov	r2, r0
 3227 01d8 0B46     		mov	r3, r1
 3228 01da 2046     		mov	r0, r4
 3229 01dc 2946     		mov	r1, r5
 3230 01de FFF7FEFF 		bl	falcon_inner_fpr_add
 3231 01e2 C7E92801 		strd	r0, [r7, #160]
 472:sign.c        **** 		x0 = fpr_add(c_re, w0);
 3232              		.loc 3 472 8
 3233 01e6 D7E92623 		ldrd	r2, [r7, #152]
 3234 01ea D7E92A01 		ldrd	r0, [r7, #168]
 3235 01ee FFF7FEFF 		bl	falcon_inner_fpr_add
 3236 01f2 C7E91E01 		strd	r0, [r7, #120]
 473:sign.c        **** 		x1 = fpr_add(c_im, w1);
 3237              		.loc 3 473 8
 3238 01f6 D7E92423 		ldrd	r2, [r7, #144]
 3239 01fa D7E92801 		ldrd	r0, [r7, #160]
 3240 01fe FFF7FEFF 		bl	falcon_inner_fpr_add
 3241 0202 C7E91C01 		strd	r0, [r7, #112]
 474:sign.c        **** 		sigma = tree1[2];
 3242              		.loc 3 474 9
 3243 0206 D7F82831 		ldr	r3, [r7, #296]
 3244 020a D3E90423 		ldrd	r2, [r3, #16]
 3245 020e C7E91A23 		strd	r2, [r7, #104]
 475:sign.c        **** 		w0 = fpr_of(samp(samp_ctx, x0, sigma));
 3246              		.loc 3 475 15
 3247 0212 D7E91A23 		ldrd	r2, [r7, #104]
 3248 0216 CDE90023 		strd	r2, [sp]
 3249 021a 796D     		ldr	r1, [r7, #84]
 3250 021c D7E91E23 		ldrd	r2, [r7, #120]
 3251 0220 386D     		ldr	r0, [r7, #80]
 3252 0222 8847     		blx	r1
 3253              	.LVL4:
 3254 0224 0346     		mov	r3, r0
 3255              		.loc 3 475 8
 3256 0226 DA17     		asrs	r2, r3, #31
 3257 0228 3B63     		str	r3, [r7, #48]
 3258 022a 7A63     		str	r2, [r7, #52]
 3259 022c D7E90C01 		ldrd	r0, [r7, #48]
 3260 0230 FFF7FEFF 		bl	fpr_of
 3261 0234 C7E92601 		strd	r0, [r7, #152]
 476:sign.c        **** 		w1 = fpr_of(samp(samp_ctx, x1, sigma));
 3262              		.loc 3 476 15
 3263 0238 D7E91A23 		ldrd	r2, [r7, #104]
 3264 023c CDE90023 		strd	r2, [sp]
 3265 0240 796D     		ldr	r1, [r7, #84]
 3266 0242 D7E91C23 		ldrd	r2, [r7, #112]
 3267 0246 386D     		ldr	r0, [r7, #80]
 3268 0248 8847     		blx	r1
 3269              	.LVL5:
 3270 024a 0346     		mov	r3, r0
 3271              		.loc 3 476 8
 3272 024c DA17     		asrs	r2, r3, #31
 3273 024e BB62     		str	r3, [r7, #40]
 3274 0250 FA62     		str	r2, [r7, #44]
 3275 0252 D7E90A01 		ldrd	r0, [r7, #40]
 3276 0256 FFF7FEFF 		bl	fpr_of
 3277 025a C7E92401 		strd	r0, [r7, #144]
 477:sign.c        **** 
 478:sign.c        **** 		a_re = w0;
 3278              		.loc 3 478 8
 3279 025e D7E92623 		ldrd	r2, [r7, #152]
 3280 0262 C7E93223 		strd	r2, [r7, #200]
 479:sign.c        **** 		a_im = w1;
 3281              		.loc 3 479 8
 3282 0266 D7E92423 		ldrd	r2, [r7, #144]
 3283 026a C7E93023 		strd	r2, [r7, #192]
 480:sign.c        **** 		b_re = w2;
 3284              		.loc 3 480 8
 3285 026e D7E92223 		ldrd	r2, [r7, #136]
 3286 0272 C7E92E23 		strd	r2, [r7, #184]
 481:sign.c        **** 		b_im = w3;
 3287              		.loc 3 481 8
 3288 0276 D7E92023 		ldrd	r2, [r7, #128]
 3289 027a C7E92C23 		strd	r2, [r7, #176]
 482:sign.c        **** 		c_re = fpr_mul(fpr_sub(b_re, b_im), fpr_invsqrt2);
 3290              		.loc 3 482 10
 3291 027e D7E92C23 		ldrd	r2, [r7, #176]
 3292 0282 D7E92E01 		ldrd	r0, [r7, #184]
 3293 0286 FFF7FEFF 		bl	fpr_sub
 3294 028a 0FF2F463 		adr	r3, .L67+8
 3295 028e D3E90023 		ldrd	r2, [r3]
 3296 0292 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3297 0296 C7E92A01 		strd	r0, [r7, #168]
 483:sign.c        **** 		c_im = fpr_mul(fpr_add(b_re, b_im), fpr_invsqrt2);
 3298              		.loc 3 483 10
 3299 029a D7E92C23 		ldrd	r2, [r7, #176]
 3300 029e D7E92E01 		ldrd	r0, [r7, #184]
 3301 02a2 FFF7FEFF 		bl	falcon_inner_fpr_add
 3302 02a6 0FF2D863 		adr	r3, .L67+8
 3303 02aa D3E90023 		ldrd	r2, [r3]
 3304 02ae FFF7FEFF 		bl	falcon_inner_fpr_mul
 3305 02b2 C7E92801 		strd	r0, [r7, #160]
 484:sign.c        **** 		z1[0] = w0 = fpr_add(a_re, c_re);
 3306              		.loc 3 484 16
 3307 02b6 D7E92A23 		ldrd	r2, [r7, #168]
 3308 02ba D7E93201 		ldrd	r0, [r7, #200]
 3309 02be FFF7FEFF 		bl	falcon_inner_fpr_add
 3310 02c2 C7E92601 		strd	r0, [r7, #152]
 3311              		.loc 3 484 9
 3312 02c6 B96C     		ldr	r1, [r7, #72]
 3313 02c8 D7E92623 		ldrd	r2, [r7, #152]
 3314 02cc C1E90023 		strd	r2, [r1]
 485:sign.c        **** 		z1[2] = w2 = fpr_add(a_im, c_im);
 3315              		.loc 3 485 16
 3316 02d0 D7E92823 		ldrd	r2, [r7, #160]
 3317 02d4 D7E93001 		ldrd	r0, [r7, #192]
 3318 02d8 FFF7FEFF 		bl	falcon_inner_fpr_add
 3319 02dc C7E92201 		strd	r0, [r7, #136]
 3320              		.loc 3 485 5
 3321 02e0 BB6C     		ldr	r3, [r7, #72]
 3322 02e2 03F11001 		add	r1, r3, #16
 3323              		.loc 3 485 9
 3324 02e6 D7E92223 		ldrd	r2, [r7, #136]
 3325 02ea C1E90023 		strd	r2, [r1]
 486:sign.c        **** 		z1[1] = w1 = fpr_sub(a_re, c_re);
 3326              		.loc 3 486 16
 3327 02ee D7E92A23 		ldrd	r2, [r7, #168]
 3328 02f2 D7E93201 		ldrd	r0, [r7, #200]
 3329 02f6 FFF7FEFF 		bl	fpr_sub
 3330 02fa C7E92401 		strd	r0, [r7, #144]
 3331              		.loc 3 486 5
 3332 02fe BB6C     		ldr	r3, [r7, #72]
 3333 0300 03F10801 		add	r1, r3, #8
 3334              		.loc 3 486 9
 3335 0304 D7E92423 		ldrd	r2, [r7, #144]
 3336 0308 C1E90023 		strd	r2, [r1]
 487:sign.c        **** 		z1[3] = w3 = fpr_sub(a_im, c_im);
 3337              		.loc 3 487 16
 3338 030c D7E92823 		ldrd	r2, [r7, #160]
 3339 0310 D7E93001 		ldrd	r0, [r7, #192]
 3340 0314 FFF7FEFF 		bl	fpr_sub
 3341 0318 C7E92001 		strd	r0, [r7, #128]
 3342              		.loc 3 487 5
 3343 031c BB6C     		ldr	r3, [r7, #72]
 3344 031e 03F11801 		add	r1, r3, #24
 3345              		.loc 3 487 9
 3346 0322 D7E92023 		ldrd	r2, [r7, #128]
 3347 0326 C1E90023 		strd	r2, [r1]
 488:sign.c        **** 
 489:sign.c        **** 		/*
 490:sign.c        **** 		 * Compute tb0 = t0 + (t1 - z1) * L. Value tb0 ends up in w*.
 491:sign.c        **** 		 */
 492:sign.c        **** 		w0 = fpr_sub(t1[0], w0);
 3348              		.loc 3 492 8
 3349 032a D7F86031 		ldr	r3, [r7, #352]
 3350 032e D3E90001 		ldrd	r0, [r3]
 3351 0332 D7E92623 		ldrd	r2, [r7, #152]
 3352 0336 FFF7FEFF 		bl	fpr_sub
 3353 033a C7E92601 		strd	r0, [r7, #152]
 493:sign.c        **** 		w1 = fpr_sub(t1[1], w1);
 3354              		.loc 3 493 18
 3355 033e D7F86031 		ldr	r3, [r7, #352]
 3356 0342 0833     		adds	r3, r3, #8
 3357              		.loc 3 493 8
 3358 0344 D3E90001 		ldrd	r0, [r3]
 3359 0348 D7E92423 		ldrd	r2, [r7, #144]
 3360 034c FFF7FEFF 		bl	fpr_sub
 3361 0350 C7E92401 		strd	r0, [r7, #144]
 494:sign.c        **** 		w2 = fpr_sub(t1[2], w2);
 3362              		.loc 3 494 18
 3363 0354 D7F86031 		ldr	r3, [r7, #352]
 3364 0358 1033     		adds	r3, r3, #16
 3365              		.loc 3 494 8
 3366 035a D3E90001 		ldrd	r0, [r3]
 3367 035e D7E92223 		ldrd	r2, [r7, #136]
 3368 0362 FFF7FEFF 		bl	fpr_sub
 3369 0366 C7E92201 		strd	r0, [r7, #136]
 495:sign.c        **** 		w3 = fpr_sub(t1[3], w3);
 3370              		.loc 3 495 18
 3371 036a D7F86031 		ldr	r3, [r7, #352]
 3372 036e 1833     		adds	r3, r3, #24
 3373              		.loc 3 495 8
 3374 0370 D3E90001 		ldrd	r0, [r3]
 3375 0374 D7E92023 		ldrd	r2, [r7, #128]
 3376 0378 FFF7FEFF 		bl	fpr_sub
 3377 037c C7E92001 		strd	r0, [r7, #128]
 496:sign.c        **** 
 497:sign.c        **** 		a_re = w0;
 3378              		.loc 3 497 8
 3379 0380 D7E92623 		ldrd	r2, [r7, #152]
 3380 0384 C7E93223 		strd	r2, [r7, #200]
 498:sign.c        **** 		a_im = w2;
 3381              		.loc 3 498 8
 3382 0388 D7E92223 		ldrd	r2, [r7, #136]
 3383 038c C7E93023 		strd	r2, [r7, #192]
 499:sign.c        **** 		b_re = tree[0];
 3384              		.loc 3 499 8
 3385 0390 D7F85831 		ldr	r3, [r7, #344]
 3386 0394 D3E90023 		ldrd	r2, [r3]
 3387 0398 C7E92E23 		strd	r2, [r7, #184]
 500:sign.c        **** 		b_im = tree[2];
 3388              		.loc 3 500 8
 3389 039c D7F85831 		ldr	r3, [r7, #344]
 3390 03a0 D3E90423 		ldrd	r2, [r3, #16]
 3391 03a4 C7E92C23 		strd	r2, [r7, #176]
 501:sign.c        **** 		w0 = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
 3392              		.loc 3 501 8
 3393 03a8 D7E92E23 		ldrd	r2, [r7, #184]
 3394 03ac D7E93201 		ldrd	r0, [r7, #200]
 3395 03b0 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3396 03b4 0446     		mov	r4, r0
 3397 03b6 0D46     		mov	r5, r1
 3398 03b8 D7E92C23 		ldrd	r2, [r7, #176]
 3399 03bc D7E93001 		ldrd	r0, [r7, #192]
 3400 03c0 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3401 03c4 0246     		mov	r2, r0
 3402 03c6 0B46     		mov	r3, r1
 3403 03c8 2046     		mov	r0, r4
 3404 03ca 2946     		mov	r1, r5
 3405 03cc FFF7FEFF 		bl	fpr_sub
 3406 03d0 C7E92601 		strd	r0, [r7, #152]
 502:sign.c        **** 		w2 = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
 3407              		.loc 3 502 8
 3408 03d4 D7E92C23 		ldrd	r2, [r7, #176]
 3409 03d8 D7E93201 		ldrd	r0, [r7, #200]
 3410 03dc FFF7FEFF 		bl	falcon_inner_fpr_mul
 3411 03e0 0446     		mov	r4, r0
 3412 03e2 0D46     		mov	r5, r1
 3413 03e4 D7E92E23 		ldrd	r2, [r7, #184]
 3414 03e8 D7E93001 		ldrd	r0, [r7, #192]
 3415 03ec FFF7FEFF 		bl	falcon_inner_fpr_mul
 3416 03f0 0246     		mov	r2, r0
 3417 03f2 0B46     		mov	r3, r1
 3418 03f4 2046     		mov	r0, r4
 3419 03f6 2946     		mov	r1, r5
 3420 03f8 FFF7FEFF 		bl	falcon_inner_fpr_add
 3421 03fc C7E92201 		strd	r0, [r7, #136]
 503:sign.c        **** 		a_re = w1;
 3422              		.loc 3 503 8
 3423 0400 D7E92423 		ldrd	r2, [r7, #144]
 3424 0404 C7E93223 		strd	r2, [r7, #200]
 504:sign.c        **** 		a_im = w3;
 3425              		.loc 3 504 8
 3426 0408 D7E92023 		ldrd	r2, [r7, #128]
 3427 040c C7E93023 		strd	r2, [r7, #192]
 505:sign.c        **** 		b_re = tree[1];
 3428              		.loc 3 505 8
 3429 0410 D7F85831 		ldr	r3, [r7, #344]
 3430 0414 D3E90223 		ldrd	r2, [r3, #8]
 3431 0418 C7E92E23 		strd	r2, [r7, #184]
 506:sign.c        **** 		b_im = tree[3];
 3432              		.loc 3 506 8
 3433 041c D7F85831 		ldr	r3, [r7, #344]
 3434 0420 D3E90623 		ldrd	r2, [r3, #24]
 3435 0424 C7E92C23 		strd	r2, [r7, #176]
 507:sign.c        **** 		w1 = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
 3436              		.loc 3 507 8
 3437 0428 D7E92E23 		ldrd	r2, [r7, #184]
 3438 042c D7E93201 		ldrd	r0, [r7, #200]
 3439 0430 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3440 0434 0446     		mov	r4, r0
 3441 0436 0D46     		mov	r5, r1
 3442 0438 D7E92C23 		ldrd	r2, [r7, #176]
 3443 043c D7E93001 		ldrd	r0, [r7, #192]
 3444 0440 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3445 0444 0246     		mov	r2, r0
 3446 0446 0B46     		mov	r3, r1
 3447 0448 2046     		mov	r0, r4
 3448 044a 2946     		mov	r1, r5
 3449 044c FFF7FEFF 		bl	fpr_sub
 3450 0450 C7E92401 		strd	r0, [r7, #144]
 508:sign.c        **** 		w3 = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
 3451              		.loc 3 508 8
 3452 0454 D7E92C23 		ldrd	r2, [r7, #176]
 3453 0458 D7E93201 		ldrd	r0, [r7, #200]
 3454 045c FFF7FEFF 		bl	falcon_inner_fpr_mul
 3455 0460 0446     		mov	r4, r0
 3456 0462 0D46     		mov	r5, r1
 3457 0464 D7E92E23 		ldrd	r2, [r7, #184]
 3458 0468 D7E93001 		ldrd	r0, [r7, #192]
 3459 046c FFF7FEFF 		bl	falcon_inner_fpr_mul
 3460 0470 0246     		mov	r2, r0
 3461 0472 0B46     		mov	r3, r1
 3462 0474 2046     		mov	r0, r4
 3463 0476 2946     		mov	r1, r5
 3464 0478 FFF7FEFF 		bl	falcon_inner_fpr_add
 3465 047c C7E92001 		strd	r0, [r7, #128]
 509:sign.c        **** 
 510:sign.c        **** 		w0 = fpr_add(w0, t0[0]);
 3466              		.loc 3 510 8
 3467 0480 D7F85C31 		ldr	r3, [r7, #348]
 3468 0484 D3E90023 		ldrd	r2, [r3]
 3469 0488 D7E92601 		ldrd	r0, [r7, #152]
 3470 048c FFF7FEFF 		bl	falcon_inner_fpr_add
 3471 0490 C7E92601 		strd	r0, [r7, #152]
 511:sign.c        **** 		w1 = fpr_add(w1, t0[1]);
 3472              		.loc 3 511 22
 3473 0494 D7F85C31 		ldr	r3, [r7, #348]
 3474 0498 0833     		adds	r3, r3, #8
 3475              		.loc 3 511 8
 3476 049a D3E90023 		ldrd	r2, [r3]
 3477 049e D7E92401 		ldrd	r0, [r7, #144]
 3478 04a2 FFF7FEFF 		bl	falcon_inner_fpr_add
 3479 04a6 C7E92401 		strd	r0, [r7, #144]
 512:sign.c        **** 		w2 = fpr_add(w2, t0[2]);
 3480              		.loc 3 512 22
 3481 04aa D7F85C31 		ldr	r3, [r7, #348]
 3482 04ae 1033     		adds	r3, r3, #16
 3483              		.loc 3 512 8
 3484 04b0 D3E90023 		ldrd	r2, [r3]
 3485 04b4 D7E92201 		ldrd	r0, [r7, #136]
 3486 04b8 FFF7FEFF 		bl	falcon_inner_fpr_add
 3487 04bc C7E92201 		strd	r0, [r7, #136]
 513:sign.c        **** 		w3 = fpr_add(w3, t0[3]);
 3488              		.loc 3 513 22
 3489 04c0 D7F85C31 		ldr	r3, [r7, #348]
 3490 04c4 1833     		adds	r3, r3, #24
 3491              		.loc 3 513 8
 3492 04c6 D3E90023 		ldrd	r2, [r3]
 3493 04ca D7E92001 		ldrd	r0, [r7, #128]
 3494 04ce FFF7FEFF 		bl	falcon_inner_fpr_add
 3495 04d2 C7E92001 		strd	r0, [r7, #128]
 514:sign.c        **** 
 515:sign.c        **** 		/*
 516:sign.c        **** 		 * Second recursive invocation.
 517:sign.c        **** 		 */
 518:sign.c        **** 		a_re = w0;
 3496              		.loc 3 518 8
 3497 04d6 D7E92623 		ldrd	r2, [r7, #152]
 3498 04da C7E93223 		strd	r2, [r7, #200]
 519:sign.c        **** 		a_im = w2;
 3499              		.loc 3 519 8
 3500 04de D7E92223 		ldrd	r2, [r7, #136]
 3501 04e2 C7E93023 		strd	r2, [r7, #192]
 520:sign.c        **** 		b_re = w1;
 3502              		.loc 3 520 8
 3503 04e6 D7E92423 		ldrd	r2, [r7, #144]
 3504 04ea C7E92E23 		strd	r2, [r7, #184]
 521:sign.c        **** 		b_im = w3;
 3505              		.loc 3 521 8
 3506 04ee D7E92023 		ldrd	r2, [r7, #128]
 3507 04f2 C7E92C23 		strd	r2, [r7, #176]
 522:sign.c        **** 		c_re = fpr_add(a_re, b_re);
 3508              		.loc 3 522 10
 3509 04f6 D7E92E23 		ldrd	r2, [r7, #184]
 3510 04fa D7E93201 		ldrd	r0, [r7, #200]
 3511 04fe FFF7FEFF 		bl	falcon_inner_fpr_add
 3512 0502 C7E92A01 		strd	r0, [r7, #168]
 523:sign.c        **** 		c_im = fpr_add(a_im, b_im);
 3513              		.loc 3 523 10
 3514 0506 D7E92C23 		ldrd	r2, [r7, #176]
 3515 050a D7E93001 		ldrd	r0, [r7, #192]
 3516 050e FFF7FEFF 		bl	falcon_inner_fpr_add
 3517 0512 C7E92801 		strd	r0, [r7, #160]
 524:sign.c        **** 		w0 = fpr_half(c_re);
 3518              		.loc 3 524 8
 3519 0516 D7E92A01 		ldrd	r0, [r7, #168]
 3520 051a FFF7FEFF 		bl	fpr_half
 3521 051e C7E92601 		strd	r0, [r7, #152]
 525:sign.c        **** 		w1 = fpr_half(c_im);
 3522              		.loc 3 525 8
 3523 0522 D7E92801 		ldrd	r0, [r7, #160]
 3524 0526 FFF7FEFF 		bl	fpr_half
 3525 052a C7E92401 		strd	r0, [r7, #144]
 526:sign.c        **** 		c_re = fpr_sub(a_re, b_re);
 3526              		.loc 3 526 10
 3527 052e D7E92E23 		ldrd	r2, [r7, #184]
 3528 0532 D7E93201 		ldrd	r0, [r7, #200]
 3529 0536 FFF7FEFF 		bl	fpr_sub
 3530 053a C7E92A01 		strd	r0, [r7, #168]
 527:sign.c        **** 		c_im = fpr_sub(a_im, b_im);
 3531              		.loc 3 527 10
 3532 053e D7E92C23 		ldrd	r2, [r7, #176]
 3533 0542 D7E93001 		ldrd	r0, [r7, #192]
 3534 0546 FFF7FEFF 		bl	fpr_sub
 3535 054a C7E92801 		strd	r0, [r7, #160]
 528:sign.c        **** 		w2 = fpr_mul(fpr_add(c_re, c_im), fpr_invsqrt8);
 3536              		.loc 3 528 8
 3537 054e D7E92823 		ldrd	r2, [r7, #160]
 3538 0552 D7E92A01 		ldrd	r0, [r7, #168]
 3539 0556 FFF7FEFF 		bl	falcon_inner_fpr_add
 3540 055a 0FF21C43 		adr	r3, .L67
 3541 055e D3E90023 		ldrd	r2, [r3]
 3542 0562 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3543 0566 C7E92201 		strd	r0, [r7, #136]
 529:sign.c        **** 		w3 = fpr_mul(fpr_sub(c_im, c_re), fpr_invsqrt8);
 3544              		.loc 3 529 8
 3545 056a D7E92A23 		ldrd	r2, [r7, #168]
 3546 056e D7E92801 		ldrd	r0, [r7, #160]
 3547 0572 FFF7FEFF 		bl	fpr_sub
 3548 0576 0FF20043 		adr	r3, .L67
 3549 057a D3E90023 		ldrd	r2, [r3]
 3550 057e FFF7FEFF 		bl	falcon_inner_fpr_mul
 3551 0582 C7E92001 		strd	r0, [r7, #128]
 530:sign.c        **** 
 531:sign.c        **** 		x0 = w2;
 3552              		.loc 3 531 6
 3553 0586 D7E92223 		ldrd	r2, [r7, #136]
 3554 058a C7E91E23 		strd	r2, [r7, #120]
 532:sign.c        **** 		x1 = w3;
 3555              		.loc 3 532 6
 3556 058e D7E92023 		ldrd	r2, [r7, #128]
 3557 0592 C7E91C23 		strd	r2, [r7, #112]
 533:sign.c        **** 		sigma = tree0[3];
 3558              		.loc 3 533 9
 3559 0596 D7F82C31 		ldr	r3, [r7, #300]
 3560 059a D3E90623 		ldrd	r2, [r3, #24]
 3561 059e C7E91A23 		strd	r2, [r7, #104]
 534:sign.c        **** 		w2 = y0 = fpr_of(samp(samp_ctx, x0, sigma));
 3562              		.loc 3 534 20
 3563 05a2 D7E91A23 		ldrd	r2, [r7, #104]
 3564 05a6 CDE90023 		strd	r2, [sp]
 3565 05aa 796D     		ldr	r1, [r7, #84]
 3566 05ac D7E91E23 		ldrd	r2, [r7, #120]
 3567 05b0 386D     		ldr	r0, [r7, #80]
 3568 05b2 8847     		blx	r1
 3569              	.LVL6:
 3570 05b4 0346     		mov	r3, r0
 3571              		.loc 3 534 13
 3572 05b6 DA17     		asrs	r2, r3, #31
 3573 05b8 3B62     		str	r3, [r7, #32]
 3574 05ba 7A62     		str	r2, [r7, #36]
 3575 05bc D7E90801 		ldrd	r0, [r7, #32]
 3576 05c0 FFF7FEFF 		bl	fpr_of
 3577 05c4 C7E91801 		strd	r0, [r7, #96]
 3578              		.loc 3 534 6
 3579 05c8 D7E91823 		ldrd	r2, [r7, #96]
 3580 05cc C7E92223 		strd	r2, [r7, #136]
 535:sign.c        **** 		w3 = y1 = fpr_of(samp(samp_ctx, x1, sigma));
 3581              		.loc 3 535 20
 3582 05d0 D7E91A23 		ldrd	r2, [r7, #104]
 3583 05d4 CDE90023 		strd	r2, [sp]
 3584 05d8 796D     		ldr	r1, [r7, #84]
 3585 05da D7E91C23 		ldrd	r2, [r7, #112]
 3586 05de 386D     		ldr	r0, [r7, #80]
 3587 05e0 8847     		blx	r1
 3588              	.LVL7:
 3589 05e2 0346     		mov	r3, r0
 3590              		.loc 3 535 13
 3591 05e4 DA17     		asrs	r2, r3, #31
 3592 05e6 BB61     		str	r3, [r7, #24]
 3593 05e8 FA61     		str	r2, [r7, #28]
 3594 05ea D7E90601 		ldrd	r0, [r7, #24]
 3595 05ee FFF7FEFF 		bl	fpr_of
 3596 05f2 C7E91601 		strd	r0, [r7, #88]
 3597              		.loc 3 535 6
 3598 05f6 D7E91623 		ldrd	r2, [r7, #88]
 3599 05fa C7E92023 		strd	r2, [r7, #128]
 536:sign.c        **** 		a_re = fpr_sub(x0, y0);
 3600              		.loc 3 536 10
 3601 05fe D7E91823 		ldrd	r2, [r7, #96]
 3602 0602 D7E91E01 		ldrd	r0, [r7, #120]
 3603 0606 FFF7FEFF 		bl	fpr_sub
 3604 060a C7E93201 		strd	r0, [r7, #200]
 537:sign.c        **** 		a_im = fpr_sub(x1, y1);
 3605              		.loc 3 537 10
 3606 060e D7E91623 		ldrd	r2, [r7, #88]
 3607 0612 D7E91C01 		ldrd	r0, [r7, #112]
 3608 0616 FFF7FEFF 		bl	fpr_sub
 3609 061a C7E93001 		strd	r0, [r7, #192]
 538:sign.c        **** 		b_re = tree0[0];
 3610              		.loc 3 538 8
 3611 061e D7F82C31 		ldr	r3, [r7, #300]
 3612 0622 D3E90023 		ldrd	r2, [r3]
 3613 0626 C7E92E23 		strd	r2, [r7, #184]
 539:sign.c        **** 		b_im = tree0[1];
 3614              		.loc 3 539 8
 3615 062a D7F82C31 		ldr	r3, [r7, #300]
 3616 062e D3E90223 		ldrd	r2, [r3, #8]
 3617 0632 C7E92C23 		strd	r2, [r7, #176]
 540:sign.c        **** 		c_re = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
 3618              		.loc 3 540 10
 3619 0636 D7E92E23 		ldrd	r2, [r7, #184]
 3620 063a D7E93201 		ldrd	r0, [r7, #200]
 3621 063e FFF7FEFF 		bl	falcon_inner_fpr_mul
 3622 0642 0446     		mov	r4, r0
 3623 0644 0D46     		mov	r5, r1
 3624 0646 D7E92C23 		ldrd	r2, [r7, #176]
 3625 064a D7E93001 		ldrd	r0, [r7, #192]
 3626 064e FFF7FEFF 		bl	falcon_inner_fpr_mul
 3627 0652 0246     		mov	r2, r0
 3628 0654 0B46     		mov	r3, r1
 3629 0656 2046     		mov	r0, r4
 3630 0658 2946     		mov	r1, r5
 3631 065a FFF7FEFF 		bl	fpr_sub
 3632 065e C7E92A01 		strd	r0, [r7, #168]
 541:sign.c        **** 		c_im = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
 3633              		.loc 3 541 10
 3634 0662 D7E92C23 		ldrd	r2, [r7, #176]
 3635 0666 D7E93201 		ldrd	r0, [r7, #200]
 3636 066a FFF7FEFF 		bl	falcon_inner_fpr_mul
 3637 066e 0446     		mov	r4, r0
 3638 0670 0D46     		mov	r5, r1
 3639 0672 D7E92E23 		ldrd	r2, [r7, #184]
 3640 0676 D7E93001 		ldrd	r0, [r7, #192]
 3641 067a FFF7FEFF 		bl	falcon_inner_fpr_mul
 3642 067e 0246     		mov	r2, r0
 3643 0680 0B46     		mov	r3, r1
 3644 0682 2046     		mov	r0, r4
 3645 0684 2946     		mov	r1, r5
 3646 0686 FFF7FEFF 		bl	falcon_inner_fpr_add
 3647 068a C7E92801 		strd	r0, [r7, #160]
 542:sign.c        **** 		x0 = fpr_add(c_re, w0);
 3648              		.loc 3 542 8
 3649 068e D7E92623 		ldrd	r2, [r7, #152]
 3650 0692 D7E92A01 		ldrd	r0, [r7, #168]
 3651 0696 FFF7FEFF 		bl	falcon_inner_fpr_add
 3652 069a C7E91E01 		strd	r0, [r7, #120]
 543:sign.c        **** 		x1 = fpr_add(c_im, w1);
 3653              		.loc 3 543 8
 3654 069e D7E92423 		ldrd	r2, [r7, #144]
 3655 06a2 D7E92801 		ldrd	r0, [r7, #160]
 3656 06a6 FFF7FEFF 		bl	falcon_inner_fpr_add
 3657 06aa C7E91C01 		strd	r0, [r7, #112]
 544:sign.c        **** 		sigma = tree0[2];
 3658              		.loc 3 544 9
 3659 06ae D7F82C31 		ldr	r3, [r7, #300]
 3660 06b2 D3E90423 		ldrd	r2, [r3, #16]
 3661 06b6 C7E91A23 		strd	r2, [r7, #104]
 545:sign.c        **** 		w0 = fpr_of(samp(samp_ctx, x0, sigma));
 3662              		.loc 3 545 15
 3663 06ba D7E91A23 		ldrd	r2, [r7, #104]
 3664 06be CDE90023 		strd	r2, [sp]
 3665 06c2 796D     		ldr	r1, [r7, #84]
 3666 06c4 D7E91E23 		ldrd	r2, [r7, #120]
 3667 06c8 386D     		ldr	r0, [r7, #80]
 3668 06ca 8847     		blx	r1
 3669              	.LVL8:
 3670 06cc 0346     		mov	r3, r0
 3671              		.loc 3 545 8
 3672 06ce DA17     		asrs	r2, r3, #31
 3673 06d0 3B61     		str	r3, [r7, #16]
 3674 06d2 7A61     		str	r2, [r7, #20]
 3675 06d4 D7E90401 		ldrd	r0, [r7, #16]
 3676 06d8 FFF7FEFF 		bl	fpr_of
 3677 06dc C7E92601 		strd	r0, [r7, #152]
 546:sign.c        **** 		w1 = fpr_of(samp(samp_ctx, x1, sigma));
 3678              		.loc 3 546 15
 3679 06e0 D7E91A23 		ldrd	r2, [r7, #104]
 3680 06e4 CDE90023 		strd	r2, [sp]
 3681 06e8 796D     		ldr	r1, [r7, #84]
 3682 06ea D7E91C23 		ldrd	r2, [r7, #112]
 3683 06ee 386D     		ldr	r0, [r7, #80]
 3684 06f0 8847     		blx	r1
 3685              	.LVL9:
 3686 06f2 0346     		mov	r3, r0
 3687              		.loc 3 546 8
 3688 06f4 DA17     		asrs	r2, r3, #31
 3689 06f6 BB60     		str	r3, [r7, #8]
 3690 06f8 FA60     		str	r2, [r7, #12]
 3691 06fa D7E90201 		ldrd	r0, [r7, #8]
 3692 06fe FFF7FEFF 		bl	fpr_of
 3693 0702 C7E92401 		strd	r0, [r7, #144]
 547:sign.c        **** 
 548:sign.c        **** 		a_re = w0;
 3694              		.loc 3 548 8
 3695 0706 D7E92623 		ldrd	r2, [r7, #152]
 3696 070a C7E93223 		strd	r2, [r7, #200]
 549:sign.c        **** 		a_im = w1;
 3697              		.loc 3 549 8
 3698 070e D7E92423 		ldrd	r2, [r7, #144]
 3699 0712 C7E93023 		strd	r2, [r7, #192]
 550:sign.c        **** 		b_re = w2;
 3700              		.loc 3 550 8
 3701 0716 D7E92223 		ldrd	r2, [r7, #136]
 3702 071a C7E92E23 		strd	r2, [r7, #184]
 551:sign.c        **** 		b_im = w3;
 3703              		.loc 3 551 8
 3704 071e D7E92023 		ldrd	r2, [r7, #128]
 3705 0722 C7E92C23 		strd	r2, [r7, #176]
 552:sign.c        **** 		c_re = fpr_mul(fpr_sub(b_re, b_im), fpr_invsqrt2);
 3706              		.loc 3 552 10
 3707 0726 D7E92C23 		ldrd	r2, [r7, #176]
 3708 072a D7E92E01 		ldrd	r0, [r7, #184]
 3709 072e FFF7FEFF 		bl	fpr_sub
 3710 0732 93A3     		adr	r3, .L67+8
 3711 0734 D3E90023 		ldrd	r2, [r3]
 3712 0738 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3713 073c C7E92A01 		strd	r0, [r7, #168]
 553:sign.c        **** 		c_im = fpr_mul(fpr_add(b_re, b_im), fpr_invsqrt2);
 3714              		.loc 3 553 10
 3715 0740 D7E92C23 		ldrd	r2, [r7, #176]
 3716 0744 D7E92E01 		ldrd	r0, [r7, #184]
 3717 0748 FFF7FEFF 		bl	falcon_inner_fpr_add
 3718 074c 8CA3     		adr	r3, .L67+8
 3719 074e D3E90023 		ldrd	r2, [r3]
 3720 0752 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3721 0756 C7E92801 		strd	r0, [r7, #160]
 554:sign.c        **** 		z0[0] = fpr_add(a_re, c_re);
 3722              		.loc 3 554 11
 3723 075a D7E92A23 		ldrd	r2, [r7, #168]
 3724 075e D7E93201 		ldrd	r0, [r7, #200]
 3725 0762 FFF7FEFF 		bl	falcon_inner_fpr_add
 3726 0766 0246     		mov	r2, r0
 3727 0768 0B46     		mov	r3, r1
 3728              		.loc 3 554 9
 3729 076a F96C     		ldr	r1, [r7, #76]
 3730 076c C1E90023 		strd	r2, [r1]
 555:sign.c        **** 		z0[2] = fpr_add(a_im, c_im);
 3731              		.loc 3 555 5
 3732 0770 FB6C     		ldr	r3, [r7, #76]
 3733 0772 03F11004 		add	r4, r3, #16
 3734              		.loc 3 555 11
 3735 0776 D7E92823 		ldrd	r2, [r7, #160]
 3736 077a D7E93001 		ldrd	r0, [r7, #192]
 3737 077e FFF7FEFF 		bl	falcon_inner_fpr_add
 3738 0782 0246     		mov	r2, r0
 3739 0784 0B46     		mov	r3, r1
 3740              		.loc 3 555 9
 3741 0786 C4E90023 		strd	r2, [r4]
 556:sign.c        **** 		z0[1] = fpr_sub(a_re, c_re);
 3742              		.loc 3 556 5
 3743 078a FB6C     		ldr	r3, [r7, #76]
 3744 078c 03F10804 		add	r4, r3, #8
 3745              		.loc 3 556 11
 3746 0790 D7E92A23 		ldrd	r2, [r7, #168]
 3747 0794 D7E93201 		ldrd	r0, [r7, #200]
 3748 0798 FFF7FEFF 		bl	fpr_sub
 3749 079c 0246     		mov	r2, r0
 3750 079e 0B46     		mov	r3, r1
 3751              		.loc 3 556 9
 3752 07a0 C4E90023 		strd	r2, [r4]
 557:sign.c        **** 		z0[3] = fpr_sub(a_im, c_im);
 3753              		.loc 3 557 5
 3754 07a4 FB6C     		ldr	r3, [r7, #76]
 3755 07a6 03F11804 		add	r4, r3, #24
 3756              		.loc 3 557 11
 3757 07aa D7E92823 		ldrd	r2, [r7, #160]
 3758 07ae D7E93001 		ldrd	r0, [r7, #192]
 3759 07b2 FFF7FEFF 		bl	fpr_sub
 3760 07b6 0246     		mov	r2, r0
 3761 07b8 0B46     		mov	r3, r1
 3762              		.loc 3 557 9
 3763 07ba C4E90023 		strd	r2, [r4]
 558:sign.c        **** 
 559:sign.c        **** 		return;
 3764              		.loc 3 559 3
 3765 07be A0E1     		b	.L63
 3766              	.L64:
 3767              	.LBE3:
 560:sign.c        **** 	}
 561:sign.c        **** 
 562:sign.c        **** 	/*
 563:sign.c        **** 	 * Case logn == 1 is reachable only when using Falcon-2 (the
 564:sign.c        **** 	 * smallest size for which Falcon is mathematically defined, but
 565:sign.c        **** 	 * of course way too insecure to be of any use).
 566:sign.c        **** 	 */
 567:sign.c        **** 	if (logn == 1) {
 3768              		.loc 3 567 5
 3769 07c0 D7F86431 		ldr	r3, [r7, #356]
 3770 07c4 012B     		cmp	r3, #1
 3771 07c6 40F0DF80 		bne	.L66
 3772              	.LBB4:
 568:sign.c        **** 		fpr x0, x1, y0, y1, sigma;
 569:sign.c        **** 		fpr a_re, a_im, b_re, b_im, c_re, c_im;
 570:sign.c        **** 
 571:sign.c        **** 		x0 = t1[0];
 3773              		.loc 3 571 6
 3774 07ca D7F86031 		ldr	r3, [r7, #352]
 3775 07ce D3E90023 		ldrd	r2, [r3]
 3776 07d2 C7E94823 		strd	r2, [r7, #288]
 572:sign.c        **** 		x1 = t1[1];
 3777              		.loc 3 572 6
 3778 07d6 D7F86031 		ldr	r3, [r7, #352]
 3779 07da D3E90223 		ldrd	r2, [r3, #8]
 3780 07de C7E94623 		strd	r2, [r7, #280]
 573:sign.c        **** 		sigma = tree[3];
 3781              		.loc 3 573 9
 3782 07e2 D7F85831 		ldr	r3, [r7, #344]
 3783 07e6 D3E90623 		ldrd	r2, [r3, #24]
 3784 07ea C7E94423 		strd	r2, [r7, #272]
 574:sign.c        **** 		z1[0] = y0 = fpr_of(samp(samp_ctx, x0, sigma));
 3785              		.loc 3 574 23
 3786 07ee D7E94423 		ldrd	r2, [r7, #272]
 3787 07f2 CDE90023 		strd	r2, [sp]
 3788 07f6 796D     		ldr	r1, [r7, #84]
 3789 07f8 D7E94823 		ldrd	r2, [r7, #288]
 3790 07fc 386D     		ldr	r0, [r7, #80]
 3791 07fe 8847     		blx	r1
 3792              	.LVL10:
 3793 0800 0346     		mov	r3, r0
 3794              		.loc 3 574 16
 3795 0802 DA17     		asrs	r2, r3, #31
 3796 0804 3B60     		str	r3, [r7]
 3797 0806 7A60     		str	r2, [r7, #4]
 3798 0808 D7E90001 		ldrd	r0, [r7]
 3799 080c FFF7FEFF 		bl	fpr_of
 3800 0810 C7E94201 		strd	r0, [r7, #264]
 3801              		.loc 3 574 9
 3802 0814 B96C     		ldr	r1, [r7, #72]
 3803 0816 D7E94223 		ldrd	r2, [r7, #264]
 3804 081a C1E90023 		strd	r2, [r1]
 575:sign.c        **** 		z1[1] = y1 = fpr_of(samp(samp_ctx, x1, sigma));
 3805              		.loc 3 575 23
 3806 081e D7E94423 		ldrd	r2, [r7, #272]
 3807 0822 CDE90023 		strd	r2, [sp]
 3808 0826 796D     		ldr	r1, [r7, #84]
 3809 0828 D7E94623 		ldrd	r2, [r7, #280]
 3810 082c 386D     		ldr	r0, [r7, #80]
 3811 082e 8847     		blx	r1
 3812              	.LVL11:
 3813 0830 0346     		mov	r3, r0
 3814              		.loc 3 575 16
 3815 0832 DA17     		asrs	r2, r3, #31
 3816 0834 1C46     		mov	r4, r3
 3817 0836 1546     		mov	r5, r2
 3818 0838 2046     		mov	r0, r4
 3819 083a 2946     		mov	r1, r5
 3820 083c FFF7FEFF 		bl	fpr_of
 3821 0840 C7E94001 		strd	r0, [r7, #256]
 3822              		.loc 3 575 5
 3823 0844 BB6C     		ldr	r3, [r7, #72]
 3824 0846 03F10801 		add	r1, r3, #8
 3825              		.loc 3 575 9
 3826 084a D7E94023 		ldrd	r2, [r7, #256]
 3827 084e C1E90023 		strd	r2, [r1]
 576:sign.c        **** 		a_re = fpr_sub(x0, y0);
 3828              		.loc 3 576 10
 3829 0852 D7E94223 		ldrd	r2, [r7, #264]
 3830 0856 D7E94801 		ldrd	r0, [r7, #288]
 3831 085a FFF7FEFF 		bl	fpr_sub
 3832 085e C7E93E01 		strd	r0, [r7, #248]
 577:sign.c        **** 		a_im = fpr_sub(x1, y1);
 3833              		.loc 3 577 10
 3834 0862 D7E94023 		ldrd	r2, [r7, #256]
 3835 0866 D7E94601 		ldrd	r0, [r7, #280]
 3836 086a FFF7FEFF 		bl	fpr_sub
 3837 086e C7E93C01 		strd	r0, [r7, #240]
 578:sign.c        **** 		b_re = tree[0];
 3838              		.loc 3 578 8
 3839 0872 D7F85831 		ldr	r3, [r7, #344]
 3840 0876 D3E90023 		ldrd	r2, [r3]
 3841 087a C7E93A23 		strd	r2, [r7, #232]
 579:sign.c        **** 		b_im = tree[1];
 3842              		.loc 3 579 8
 3843 087e D7F85831 		ldr	r3, [r7, #344]
 3844 0882 D3E90223 		ldrd	r2, [r3, #8]
 3845 0886 C7E93823 		strd	r2, [r7, #224]
 580:sign.c        **** 		c_re = fpr_sub(fpr_mul(a_re, b_re), fpr_mul(a_im, b_im));
 3846              		.loc 3 580 10
 3847 088a D7E93A23 		ldrd	r2, [r7, #232]
 3848 088e D7E93E01 		ldrd	r0, [r7, #248]
 3849 0892 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3850 0896 0446     		mov	r4, r0
 3851 0898 0D46     		mov	r5, r1
 3852 089a D7E93823 		ldrd	r2, [r7, #224]
 3853 089e D7E93C01 		ldrd	r0, [r7, #240]
 3854 08a2 FFF7FEFF 		bl	falcon_inner_fpr_mul
 3855 08a6 0246     		mov	r2, r0
 3856 08a8 0B46     		mov	r3, r1
 3857 08aa 2046     		mov	r0, r4
 3858 08ac 2946     		mov	r1, r5
 3859 08ae FFF7FEFF 		bl	fpr_sub
 3860 08b2 C7E93601 		strd	r0, [r7, #216]
 581:sign.c        **** 		c_im = fpr_add(fpr_mul(a_re, b_im), fpr_mul(a_im, b_re));
 3861              		.loc 3 581 10
 3862 08b6 D7E93823 		ldrd	r2, [r7, #224]
 3863 08ba D7E93E01 		ldrd	r0, [r7, #248]
 3864 08be FFF7FEFF 		bl	falcon_inner_fpr_mul
 3865 08c2 0446     		mov	r4, r0
 3866 08c4 0D46     		mov	r5, r1
 3867 08c6 D7E93A23 		ldrd	r2, [r7, #232]
 3868 08ca D7E93C01 		ldrd	r0, [r7, #240]
 3869 08ce FFF7FEFF 		bl	falcon_inner_fpr_mul
 3870 08d2 0246     		mov	r2, r0
 3871 08d4 0B46     		mov	r3, r1
 3872 08d6 2046     		mov	r0, r4
 3873 08d8 2946     		mov	r1, r5
 3874 08da FFF7FEFF 		bl	falcon_inner_fpr_add
 3875 08de C7E93401 		strd	r0, [r7, #208]
 582:sign.c        **** 		x0 = fpr_add(c_re, t0[0]);
 3876              		.loc 3 582 8
 3877 08e2 D7F85C31 		ldr	r3, [r7, #348]
 3878 08e6 D3E90023 		ldrd	r2, [r3]
 3879 08ea D7E93601 		ldrd	r0, [r7, #216]
 3880 08ee FFF7FEFF 		bl	falcon_inner_fpr_add
 3881 08f2 C7E94801 		strd	r0, [r7, #288]
 583:sign.c        **** 		x1 = fpr_add(c_im, t0[1]);
 3882              		.loc 3 583 24
 3883 08f6 D7F85C31 		ldr	r3, [r7, #348]
 3884 08fa 0833     		adds	r3, r3, #8
 3885              		.loc 3 583 8
 3886 08fc D3E90023 		ldrd	r2, [r3]
 3887 0900 D7E93401 		ldrd	r0, [r7, #208]
 3888 0904 FFF7FEFF 		bl	falcon_inner_fpr_add
 3889 0908 C7E94601 		strd	r0, [r7, #280]
 584:sign.c        **** 		sigma = tree[2];
 3890              		.loc 3 584 9
 3891 090c D7F85831 		ldr	r3, [r7, #344]
 3892 0910 D3E90423 		ldrd	r2, [r3, #16]
 3893 0914 C7E94423 		strd	r2, [r7, #272]
 585:sign.c        **** 		z0[0] = fpr_of(samp(samp_ctx, x0, sigma));
 3894              		.loc 3 585 18
 3895 0918 D7E94423 		ldrd	r2, [r7, #272]
 3896 091c CDE90023 		strd	r2, [sp]
 3897 0920 796D     		ldr	r1, [r7, #84]
 3898 0922 D7E94823 		ldrd	r2, [r7, #288]
 3899 0926 386D     		ldr	r0, [r7, #80]
 3900 0928 8847     		blx	r1
 3901              	.LVL12:
 3902 092a 0346     		mov	r3, r0
 3903              		.loc 3 585 11
 3904 092c DA17     		asrs	r2, r3, #31
 3905 092e 9A46     		mov	r10, r3
 3906 0930 9346     		mov	fp, r2
 3907 0932 5046     		mov	r0, r10
 3908 0934 5946     		mov	r1, fp
 3909 0936 FFF7FEFF 		bl	fpr_of
 3910 093a 0246     		mov	r2, r0
 3911 093c 0B46     		mov	r3, r1
 3912              		.loc 3 585 9
 3913 093e F96C     		ldr	r1, [r7, #76]
 3914 0940 C1E90023 		strd	r2, [r1]
 586:sign.c        **** 		z0[1] = fpr_of(samp(samp_ctx, x1, sigma));
 3915              		.loc 3 586 18
 3916 0944 D7E94423 		ldrd	r2, [r7, #272]
 3917 0948 CDE90023 		strd	r2, [sp]
 3918 094c 796D     		ldr	r1, [r7, #84]
 3919 094e D7E94623 		ldrd	r2, [r7, #280]
 3920 0952 386D     		ldr	r0, [r7, #80]
 3921 0954 8847     		blx	r1
 3922              	.LVL13:
 3923 0956 0346     		mov	r3, r0
 3924              		.loc 3 586 11
 3925 0958 DA17     		asrs	r2, r3, #31
 3926 095a 9846     		mov	r8, r3
 3927 095c 9146     		mov	r9, r2
 3928              		.loc 3 586 5
 3929 095e FB6C     		ldr	r3, [r7, #76]
 3930 0960 03F10804 		add	r4, r3, #8
 3931              		.loc 3 586 11
 3932 0964 4046     		mov	r0, r8
 3933 0966 4946     		mov	r1, r9
 3934 0968 FFF7FEFF 		bl	fpr_of
 3935 096c 0246     		mov	r2, r0
 3936 096e 0B46     		mov	r3, r1
 3937              		.loc 3 586 9
 3938 0970 C4E90023 		strd	r2, [r4]
 587:sign.c        **** 
 588:sign.c        **** 		return;
 3939              		.loc 3 588 3
 3940 0974 C5E0     		b	.L63
 3941              	.L68:
 3942 0976 00BF     		.align	3
 3943              	.L67:
 3944 0978 CD3B7F66 		.word	1719614413
 3945 097c 9EA0D63F 		.word	1071030430
 3946 0980 CD3B7F66 		.word	1719614413
 3947 0984 9EA0E63F 		.word	1072079006
 3948              	.L66:
 3949              	.LBE4:
 589:sign.c        **** 	}
 590:sign.c        **** 
 591:sign.c        **** 	/*
 592:sign.c        **** 	 * Normal end of recursion is for logn == 0. Since the last
 593:sign.c        **** 	 * steps of the recursions were inlined in the blocks above
 594:sign.c        **** 	 * (when logn == 1 or 2), this case is not reachable, and is
 595:sign.c        **** 	 * retained here only for documentation purposes.
 596:sign.c        **** 
 597:sign.c        **** 	if (logn == 0) {
 598:sign.c        **** 		fpr x0, x1, sigma;
 599:sign.c        **** 
 600:sign.c        **** 		x0 = t0[0];
 601:sign.c        **** 		x1 = t1[0];
 602:sign.c        **** 		sigma = tree[0];
 603:sign.c        **** 		z0[0] = fpr_of(samp(samp_ctx, x0, sigma));
 604:sign.c        **** 		z1[0] = fpr_of(samp(samp_ctx, x1, sigma));
 605:sign.c        **** 		return;
 606:sign.c        **** 	}
 607:sign.c        **** 
 608:sign.c        **** 	 */
 609:sign.c        **** 
 610:sign.c        **** 	/*
 611:sign.c        **** 	 * General recursive case (logn >= 3).
 612:sign.c        **** 	 */
 613:sign.c        **** 
 614:sign.c        **** 	n = (size_t)1 << logn;
 3950              		.loc 3 614 4
 3951 0988 0122     		movs	r2, #1
 3952 098a D7F86431 		ldr	r3, [r7, #356]
 3953 098e 02FA03F3 		lsl	r3, r2, r3
 3954 0992 C7F83431 		str	r3, [r7, #308]
 615:sign.c        **** 	hn = n >> 1;
 3955              		.loc 3 615 5
 3956 0996 D7F83431 		ldr	r3, [r7, #308]
 3957 099a 5B08     		lsrs	r3, r3, #1
 3958 099c C7F83031 		str	r3, [r7, #304]
 616:sign.c        **** 	tree0 = tree + n;
 3959              		.loc 3 616 15
 3960 09a0 D7F83431 		ldr	r3, [r7, #308]
 3961 09a4 DB00     		lsls	r3, r3, #3
 3962              		.loc 3 616 8
 3963 09a6 D7F85821 		ldr	r2, [r7, #344]
 3964 09aa 1344     		add	r3, r3, r2
 3965 09ac C7F82C31 		str	r3, [r7, #300]
 617:sign.c        **** 	tree1 = tree + n + ffLDL_treesize(logn - 1);
 3966              		.loc 3 617 21
 3967 09b0 D7F86431 		ldr	r3, [r7, #356]
 3968 09b4 013B     		subs	r3, r3, #1
 3969 09b6 1846     		mov	r0, r3
 3970 09b8 FFF7FEFF 		bl	ffLDL_treesize
 3971 09bc 0246     		mov	r2, r0
 3972              		.loc 3 617 19
 3973 09be D7F83431 		ldr	r3, [r7, #308]
 3974 09c2 1344     		add	r3, r3, r2
 3975 09c4 DB00     		lsls	r3, r3, #3
 3976              		.loc 3 617 8
 3977 09c6 D7F85821 		ldr	r2, [r7, #344]
 3978 09ca 1344     		add	r3, r3, r2
 3979 09cc C7F82831 		str	r3, [r7, #296]
 618:sign.c        **** 
 619:sign.c        **** 	/*
 620:sign.c        **** 	 * We split t1 into z1 (reused as temporary storage), then do
 621:sign.c        **** 	 * the recursive invocation, with output in tmp. We finally
 622:sign.c        **** 	 * merge back into z1.
 623:sign.c        **** 	 */
 624:sign.c        **** 	Zf(poly_split_fft)(z1, z1 + hn, t1, logn);
 3980              		.loc 3 624 28
 3981 09d0 D7F83031 		ldr	r3, [r7, #304]
 3982 09d4 DB00     		lsls	r3, r3, #3
 3983              		.loc 3 624 2
 3984 09d6 BA6C     		ldr	r2, [r7, #72]
 3985 09d8 D118     		adds	r1, r2, r3
 3986 09da D7F86431 		ldr	r3, [r7, #356]
 3987 09de D7F86021 		ldr	r2, [r7, #352]
 3988 09e2 B86C     		ldr	r0, [r7, #72]
 3989 09e4 FFF7FEFF 		bl	falcon_inner_poly_split_fft
 625:sign.c        **** 	ffSampling_fft(samp, samp_ctx, tmp, tmp + hn,
 3990              		.loc 3 625 42
 3991 09e8 D7F83031 		ldr	r3, [r7, #304]
 3992 09ec DB00     		lsls	r3, r3, #3
 3993              		.loc 3 625 2
 3994 09ee D7F86821 		ldr	r2, [r7, #360]
 3995 09f2 D418     		adds	r4, r2, r3
 626:sign.c        **** 		tree1, z1, z1 + hn, logn - 1, tmp + n);
 3996              		.loc 3 626 17
 3997 09f4 D7F83031 		ldr	r3, [r7, #304]
 3998 09f8 DB00     		lsls	r3, r3, #3
 3999 09fa BA6C     		ldr	r2, [r7, #72]
 4000 09fc 1344     		add	r3, r3, r2
 625:sign.c        **** 	ffSampling_fft(samp, samp_ctx, tmp, tmp + hn,
 4001              		.loc 3 625 2
 4002 09fe D7F86421 		ldr	r2, [r7, #356]
 4003 0a02 013A     		subs	r2, r2, #1
 4004              		.loc 3 626 37
 4005 0a04 D7F83411 		ldr	r1, [r7, #308]
 4006 0a08 C900     		lsls	r1, r1, #3
 625:sign.c        **** 	ffSampling_fft(samp, samp_ctx, tmp, tmp + hn,
 4007              		.loc 3 625 2
 4008 0a0a D7F86801 		ldr	r0, [r7, #360]
 4009 0a0e 0144     		add	r1, r1, r0
 4010 0a10 0491     		str	r1, [sp, #16]
 4011 0a12 0392     		str	r2, [sp, #12]
 4012 0a14 0293     		str	r3, [sp, #8]
 4013 0a16 BB6C     		ldr	r3, [r7, #72]
 4014 0a18 0193     		str	r3, [sp, #4]
 4015 0a1a D7F82831 		ldr	r3, [r7, #296]
 4016 0a1e 0093     		str	r3, [sp]
 4017 0a20 2346     		mov	r3, r4
 4018 0a22 D7F86821 		ldr	r2, [r7, #360]
 4019 0a26 396D     		ldr	r1, [r7, #80]
 4020 0a28 786D     		ldr	r0, [r7, #84]
 4021 0a2a FFF7E9FA 		bl	ffSampling_fft
 627:sign.c        **** 	Zf(poly_merge_fft)(z1, tmp, tmp + hn, logn);
 4022              		.loc 3 627 34
 4023 0a2e D7F83031 		ldr	r3, [r7, #304]
 4024 0a32 DB00     		lsls	r3, r3, #3
 4025 0a34 D7F86821 		ldr	r2, [r7, #360]
 4026 0a38 1A44     		add	r2, r2, r3
 4027              		.loc 3 627 2
 4028 0a3a D7F86431 		ldr	r3, [r7, #356]
 4029 0a3e D7F86811 		ldr	r1, [r7, #360]
 4030 0a42 B86C     		ldr	r0, [r7, #72]
 4031 0a44 FFF7FEFF 		bl	falcon_inner_poly_merge_fft
 628:sign.c        **** 
 629:sign.c        **** 	/*
 630:sign.c        **** 	 * Compute tb0 = t0 + (t1 - z1) * L. Value tb0 ends up in tmp[].
 631:sign.c        **** 	 */
 632:sign.c        **** 	memcpy(tmp, t1, n * sizeof *t1);
 4032              		.loc 3 632 2
 4033 0a48 D7F83431 		ldr	r3, [r7, #308]
 4034 0a4c DB00     		lsls	r3, r3, #3
 4035 0a4e 1A46     		mov	r2, r3
 4036 0a50 D7F86011 		ldr	r1, [r7, #352]
 4037 0a54 D7F86801 		ldr	r0, [r7, #360]
 4038 0a58 FFF7FEFF 		bl	memcpy
 633:sign.c        **** 	Zf(poly_sub)(tmp, z1, logn);
 4039              		.loc 3 633 2
 4040 0a5c D7F86421 		ldr	r2, [r7, #356]
 4041 0a60 B96C     		ldr	r1, [r7, #72]
 4042 0a62 D7F86801 		ldr	r0, [r7, #360]
 4043 0a66 FFF7FEFF 		bl	falcon_inner_poly_sub
 634:sign.c        **** 	Zf(poly_mul_fft)(tmp, tree, logn);
 4044              		.loc 3 634 2
 4045 0a6a D7F86421 		ldr	r2, [r7, #356]
 4046 0a6e D7F85811 		ldr	r1, [r7, #344]
 4047 0a72 D7F86801 		ldr	r0, [r7, #360]
 4048 0a76 FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 635:sign.c        **** 	Zf(poly_add)(tmp, t0, logn);
 4049              		.loc 3 635 2
 4050 0a7a D7F86421 		ldr	r2, [r7, #356]
 4051 0a7e D7F85C11 		ldr	r1, [r7, #348]
 4052 0a82 D7F86801 		ldr	r0, [r7, #360]
 4053 0a86 FFF7FEFF 		bl	falcon_inner_poly_add
 636:sign.c        **** 
 637:sign.c        **** 	/*
 638:sign.c        **** 	 * Second recursive invocation.
 639:sign.c        **** 	 */
 640:sign.c        **** 	Zf(poly_split_fft)(z0, z0 + hn, tmp, logn);
 4054              		.loc 3 640 28
 4055 0a8a D7F83031 		ldr	r3, [r7, #304]
 4056 0a8e DB00     		lsls	r3, r3, #3
 4057              		.loc 3 640 2
 4058 0a90 FA6C     		ldr	r2, [r7, #76]
 4059 0a92 D118     		adds	r1, r2, r3
 4060 0a94 D7F86431 		ldr	r3, [r7, #356]
 4061 0a98 D7F86821 		ldr	r2, [r7, #360]
 4062 0a9c F86C     		ldr	r0, [r7, #76]
 4063 0a9e FFF7FEFF 		bl	falcon_inner_poly_split_fft
 641:sign.c        **** 	ffSampling_fft(samp, samp_ctx, tmp, tmp + hn,
 4064              		.loc 3 641 42
 4065 0aa2 D7F83031 		ldr	r3, [r7, #304]
 4066 0aa6 DB00     		lsls	r3, r3, #3
 4067              		.loc 3 641 2
 4068 0aa8 D7F86821 		ldr	r2, [r7, #360]
 4069 0aac D418     		adds	r4, r2, r3
 642:sign.c        **** 		tree0, z0, z0 + hn, logn - 1, tmp + n);
 4070              		.loc 3 642 17
 4071 0aae D7F83031 		ldr	r3, [r7, #304]
 4072 0ab2 DB00     		lsls	r3, r3, #3
 4073 0ab4 FA6C     		ldr	r2, [r7, #76]
 4074 0ab6 1344     		add	r3, r3, r2
 641:sign.c        **** 	ffSampling_fft(samp, samp_ctx, tmp, tmp + hn,
 4075              		.loc 3 641 2
 4076 0ab8 D7F86421 		ldr	r2, [r7, #356]
 4077 0abc 013A     		subs	r2, r2, #1
 4078              		.loc 3 642 37
 4079 0abe D7F83411 		ldr	r1, [r7, #308]
 4080 0ac2 C900     		lsls	r1, r1, #3
 641:sign.c        **** 	ffSampling_fft(samp, samp_ctx, tmp, tmp + hn,
 4081              		.loc 3 641 2
 4082 0ac4 D7F86801 		ldr	r0, [r7, #360]
 4083 0ac8 0144     		add	r1, r1, r0
 4084 0aca 0491     		str	r1, [sp, #16]
 4085 0acc 0392     		str	r2, [sp, #12]
 4086 0ace 0293     		str	r3, [sp, #8]
 4087 0ad0 FB6C     		ldr	r3, [r7, #76]
 4088 0ad2 0193     		str	r3, [sp, #4]
 4089 0ad4 D7F82C31 		ldr	r3, [r7, #300]
 4090 0ad8 0093     		str	r3, [sp]
 4091 0ada 2346     		mov	r3, r4
 4092 0adc D7F86821 		ldr	r2, [r7, #360]
 4093 0ae0 396D     		ldr	r1, [r7, #80]
 4094 0ae2 786D     		ldr	r0, [r7, #84]
 4095 0ae4 FFF78CFA 		bl	ffSampling_fft
 643:sign.c        **** 	Zf(poly_merge_fft)(z0, tmp, tmp + hn, logn);
 4096              		.loc 3 643 34
 4097 0ae8 D7F83031 		ldr	r3, [r7, #304]
 4098 0aec DB00     		lsls	r3, r3, #3
 4099 0aee D7F86821 		ldr	r2, [r7, #360]
 4100 0af2 1A44     		add	r2, r2, r3
 4101              		.loc 3 643 2
 4102 0af4 D7F86431 		ldr	r3, [r7, #356]
 4103 0af8 D7F86811 		ldr	r1, [r7, #360]
 4104 0afc F86C     		ldr	r0, [r7, #76]
 4105 0afe FFF7FEFF 		bl	falcon_inner_poly_merge_fft
 4106              	.L63:
 644:sign.c        **** }
 4107              		.loc 3 644 1
 4108 0b02 07F59C77 		add	r7, r7, #312
 4109              	.LCFI139:
 4110              		.cfi_def_cfa_offset 32
 4111 0b06 BD46     		mov	sp, r7
 4112              	.LCFI140:
 4113              		.cfi_def_cfa_register 13
 4114              		@ sp needed
 4115 0b08 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 4116              		.cfi_endproc
 4117              	.LFE30:
 4119              		.section	.text.do_sign_tree,"ax",%progbits
 4120              		.align	1
 4121              		.syntax unified
 4122              		.thumb
 4123              		.thumb_func
 4124              		.fpu softvfp
 4126              	do_sign_tree:
 4127              	.LFB31:
 645:sign.c        **** 
 646:sign.c        **** /*
 647:sign.c        ****  * Compute a signature: the signature contains two vectors, s1 and s2.
 648:sign.c        ****  * The s1 vector is not returned. The squared norm of (s1,s2) is
 649:sign.c        ****  * computed, and if it is short enough, then s2 is returned into the
 650:sign.c        ****  * s2[] buffer, and 1 is returned; otherwise, s2[] is untouched and 0 is
 651:sign.c        ****  * returned; the caller should then try again. This function uses an
 652:sign.c        ****  * expanded key.
 653:sign.c        ****  *
 654:sign.c        ****  * tmp[] must have room for at least six polynomials.
 655:sign.c        ****  */
 656:sign.c        **** static int
 657:sign.c        **** do_sign_tree(samplerZ samp, void *samp_ctx, int16_t *s2,
 658:sign.c        **** 	const fpr *restrict expanded_key,
 659:sign.c        **** 	const uint16_t *hm,
 660:sign.c        **** 	unsigned logn, fpr *restrict tmp)
 661:sign.c        **** {
 4128              		.loc 3 661 1
 4129              		.cfi_startproc
 4130              		@ args = 12, pretend = 0, frame = 96
 4131              		@ frame_needed = 1, uses_anonymous_args = 0
 4132 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 4133              	.LCFI141:
 4134              		.cfi_def_cfa_offset 20
 4135              		.cfi_offset 4, -20
 4136              		.cfi_offset 5, -16
 4137              		.cfi_offset 6, -12
 4138              		.cfi_offset 7, -8
 4139              		.cfi_offset 14, -4
 4140 0002 9FB0     		sub	sp, sp, #124
 4141              	.LCFI142:
 4142              		.cfi_def_cfa_offset 144
 4143 0004 06AF     		add	r7, sp, #24
 4144              	.LCFI143:
 4145              		.cfi_def_cfa 7, 120
 4146 0006 F860     		str	r0, [r7, #12]
 4147 0008 B960     		str	r1, [r7, #8]
 4148 000a 7A60     		str	r2, [r7, #4]
 4149 000c 3B60     		str	r3, [r7]
 662:sign.c        **** 	size_t n, u;
 663:sign.c        **** 	fpr *t0, *t1, *tx, *ty;
 664:sign.c        **** 	const fpr *b00, *b01, *b10, *b11, *tree;
 665:sign.c        **** 	fpr ni;
 666:sign.c        **** 	uint32_t sqn, ng;
 667:sign.c        **** 	int16_t *s1tmp, *s2tmp;
 668:sign.c        **** 
 669:sign.c        **** 	n = MKN(logn);
 4150              		.loc 3 669 4
 4151 000e 0122     		movs	r2, #1
 4152 0010 FB6F     		ldr	r3, [r7, #124]
 4153 0012 02FA03F3 		lsl	r3, r2, r3
 4154 0016 3B65     		str	r3, [r7, #80]
 670:sign.c        **** 	t0 = tmp;
 4155              		.loc 3 670 5
 4156 0018 D7F88030 		ldr	r3, [r7, #128]
 4157 001c FB64     		str	r3, [r7, #76]
 671:sign.c        **** 	t1 = t0 + n;
 4158              		.loc 3 671 10
 4159 001e 3B6D     		ldr	r3, [r7, #80]
 4160 0020 DB00     		lsls	r3, r3, #3
 4161              		.loc 3 671 5
 4162 0022 FA6C     		ldr	r2, [r7, #76]
 4163 0024 1344     		add	r3, r3, r2
 4164 0026 BB64     		str	r3, [r7, #72]
 672:sign.c        **** 	b00 = expanded_key + skoff_b00(logn);
 4165              		.loc 3 672 23
 4166 0028 F86F     		ldr	r0, [r7, #124]
 4167 002a FFF7FEFF 		bl	skoff_b00
 4168 002e 0346     		mov	r3, r0
 4169              		.loc 3 672 21
 4170 0030 DB00     		lsls	r3, r3, #3
 4171              		.loc 3 672 6
 4172 0032 3A68     		ldr	r2, [r7]
 4173 0034 1344     		add	r3, r3, r2
 4174 0036 7B64     		str	r3, [r7, #68]
 673:sign.c        **** 	b01 = expanded_key + skoff_b01(logn);
 4175              		.loc 3 673 23
 4176 0038 F86F     		ldr	r0, [r7, #124]
 4177 003a FFF7FEFF 		bl	skoff_b01
 4178 003e 0346     		mov	r3, r0
 4179              		.loc 3 673 21
 4180 0040 DB00     		lsls	r3, r3, #3
 4181              		.loc 3 673 6
 4182 0042 3A68     		ldr	r2, [r7]
 4183 0044 1344     		add	r3, r3, r2
 4184 0046 3B64     		str	r3, [r7, #64]
 674:sign.c        **** 	b10 = expanded_key + skoff_b10(logn);
 4185              		.loc 3 674 23
 4186 0048 F86F     		ldr	r0, [r7, #124]
 4187 004a FFF7FEFF 		bl	skoff_b10
 4188 004e 0346     		mov	r3, r0
 4189              		.loc 3 674 21
 4190 0050 DB00     		lsls	r3, r3, #3
 4191              		.loc 3 674 6
 4192 0052 3A68     		ldr	r2, [r7]
 4193 0054 1344     		add	r3, r3, r2
 4194 0056 FB63     		str	r3, [r7, #60]
 675:sign.c        **** 	b11 = expanded_key + skoff_b11(logn);
 4195              		.loc 3 675 23
 4196 0058 F86F     		ldr	r0, [r7, #124]
 4197 005a FFF7FEFF 		bl	skoff_b11
 4198 005e 0346     		mov	r3, r0
 4199              		.loc 3 675 21
 4200 0060 DB00     		lsls	r3, r3, #3
 4201              		.loc 3 675 6
 4202 0062 3A68     		ldr	r2, [r7]
 4203 0064 1344     		add	r3, r3, r2
 4204 0066 BB63     		str	r3, [r7, #56]
 676:sign.c        **** 	tree = expanded_key + skoff_tree(logn);
 4205              		.loc 3 676 24
 4206 0068 F86F     		ldr	r0, [r7, #124]
 4207 006a FFF7FEFF 		bl	skoff_tree
 4208 006e 0346     		mov	r3, r0
 4209              		.loc 3 676 22
 4210 0070 DB00     		lsls	r3, r3, #3
 4211              		.loc 3 676 7
 4212 0072 3A68     		ldr	r2, [r7]
 4213 0074 1344     		add	r3, r3, r2
 4214 0076 7B63     		str	r3, [r7, #52]
 677:sign.c        **** 
 678:sign.c        **** 	/*
 679:sign.c        **** 	 * Set the target vector to [hm, 0] (hm is the hashed message).
 680:sign.c        **** 	 */
 681:sign.c        **** 	for (u = 0; u < n; u ++) {
 4215              		.loc 3 681 9
 4216 0078 0023     		movs	r3, #0
 4217 007a FB65     		str	r3, [r7, #92]
 4218              		.loc 3 681 2
 4219 007c 17E0     		b	.L70
 4220              	.L71:
 682:sign.c        **** 		t0[u] = fpr_of(hm[u]);
 4221              		.loc 3 682 20 discriminator 3
 4222 007e FB6D     		ldr	r3, [r7, #92]
 4223 0080 5B00     		lsls	r3, r3, #1
 4224 0082 BA6F     		ldr	r2, [r7, #120]
 4225 0084 1344     		add	r3, r3, r2
 4226 0086 1B88     		ldrh	r3, [r3]
 4227              		.loc 3 682 11 discriminator 3
 4228 0088 9BB2     		uxth	r3, r3
 4229 008a 0022     		movs	r2, #0
 4230 008c 1C46     		mov	r4, r3
 4231 008e 1546     		mov	r5, r2
 4232              		.loc 3 682 5 discriminator 3
 4233 0090 FB6D     		ldr	r3, [r7, #92]
 4234 0092 DB00     		lsls	r3, r3, #3
 4235 0094 FA6C     		ldr	r2, [r7, #76]
 4236 0096 D618     		adds	r6, r2, r3
 4237              		.loc 3 682 11 discriminator 3
 4238 0098 2046     		mov	r0, r4
 4239 009a 2946     		mov	r1, r5
 4240 009c FFF7FEFF 		bl	fpr_of
 4241 00a0 0246     		mov	r2, r0
 4242 00a2 0B46     		mov	r3, r1
 4243              		.loc 3 682 9 discriminator 3
 4244 00a4 C6E90023 		strd	r2, [r6]
 681:sign.c        **** 		t0[u] = fpr_of(hm[u]);
 4245              		.loc 3 681 23 discriminator 3
 4246 00a8 FB6D     		ldr	r3, [r7, #92]
 4247 00aa 0133     		adds	r3, r3, #1
 4248 00ac FB65     		str	r3, [r7, #92]
 4249              	.L70:
 681:sign.c        **** 		t0[u] = fpr_of(hm[u]);
 4250              		.loc 3 681 2 discriminator 1
 4251 00ae FA6D     		ldr	r2, [r7, #92]
 4252 00b0 3B6D     		ldr	r3, [r7, #80]
 4253 00b2 9A42     		cmp	r2, r3
 4254 00b4 E3D3     		bcc	.L71
 683:sign.c        **** 		/* This is implicit.
 684:sign.c        **** 		t1[u] = fpr_zero;
 685:sign.c        **** 		*/
 686:sign.c        **** 	}
 687:sign.c        **** 
 688:sign.c        **** 	/*
 689:sign.c        **** 	 * Apply the lattice basis to obtain the real target
 690:sign.c        **** 	 * vector (after normalization with regards to modulus).
 691:sign.c        **** 	 */
 692:sign.c        **** 	Zf(FFT)(t0, logn);
 4255              		.loc 3 692 2
 4256 00b6 F96F     		ldr	r1, [r7, #124]
 4257 00b8 F86C     		ldr	r0, [r7, #76]
 4258 00ba FFF7FEFF 		bl	falcon_inner_FFT
 693:sign.c        **** 	ni = fpr_inverse_of_q;
 4259              		.loc 3 693 5
 4260 00be 82A3     		adr	r3, .L78
 4261 00c0 D3E90023 		ldrd	r2, [r3]
 4262 00c4 C7E90A23 		strd	r2, [r7, #40]
 694:sign.c        **** 	memcpy(t1, t0, n * sizeof *t0);
 4263              		.loc 3 694 2
 4264 00c8 3B6D     		ldr	r3, [r7, #80]
 4265 00ca DB00     		lsls	r3, r3, #3
 4266 00cc 1A46     		mov	r2, r3
 4267 00ce F96C     		ldr	r1, [r7, #76]
 4268 00d0 B86C     		ldr	r0, [r7, #72]
 4269 00d2 FFF7FEFF 		bl	memcpy
 695:sign.c        **** 	Zf(poly_mul_fft)(t1, b01, logn);
 4270              		.loc 3 695 2
 4271 00d6 FA6F     		ldr	r2, [r7, #124]
 4272 00d8 396C     		ldr	r1, [r7, #64]
 4273 00da B86C     		ldr	r0, [r7, #72]
 4274 00dc FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 696:sign.c        **** 	Zf(poly_mulconst)(t1, fpr_neg(ni), logn);
 4275              		.loc 3 696 2
 4276 00e0 D7E90A01 		ldrd	r0, [r7, #40]
 4277 00e4 FFF7FEFF 		bl	fpr_neg
 4278 00e8 0246     		mov	r2, r0
 4279 00ea 0B46     		mov	r3, r1
 4280 00ec F96F     		ldr	r1, [r7, #124]
 4281 00ee 0091     		str	r1, [sp]
 4282 00f0 B86C     		ldr	r0, [r7, #72]
 4283 00f2 FFF7FEFF 		bl	falcon_inner_poly_mulconst
 697:sign.c        **** 	Zf(poly_mul_fft)(t0, b11, logn);
 4284              		.loc 3 697 2
 4285 00f6 FA6F     		ldr	r2, [r7, #124]
 4286 00f8 B96B     		ldr	r1, [r7, #56]
 4287 00fa F86C     		ldr	r0, [r7, #76]
 4288 00fc FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 698:sign.c        **** 	Zf(poly_mulconst)(t0, ni, logn);
 4289              		.loc 3 698 2
 4290 0100 FB6F     		ldr	r3, [r7, #124]
 4291 0102 0093     		str	r3, [sp]
 4292 0104 D7E90A23 		ldrd	r2, [r7, #40]
 4293 0108 F86C     		ldr	r0, [r7, #76]
 4294 010a FFF7FEFF 		bl	falcon_inner_poly_mulconst
 699:sign.c        **** 
 700:sign.c        **** 	tx = t1 + n;
 4295              		.loc 3 700 10
 4296 010e 3B6D     		ldr	r3, [r7, #80]
 4297 0110 DB00     		lsls	r3, r3, #3
 4298              		.loc 3 700 5
 4299 0112 BA6C     		ldr	r2, [r7, #72]
 4300 0114 1344     		add	r3, r3, r2
 4301 0116 7B62     		str	r3, [r7, #36]
 701:sign.c        **** 	ty = tx + n;
 4302              		.loc 3 701 10
 4303 0118 3B6D     		ldr	r3, [r7, #80]
 4304 011a DB00     		lsls	r3, r3, #3
 4305              		.loc 3 701 5
 4306 011c 7A6A     		ldr	r2, [r7, #36]
 4307 011e 1344     		add	r3, r3, r2
 4308 0120 3B62     		str	r3, [r7, #32]
 702:sign.c        **** 
 703:sign.c        **** 	/*
 704:sign.c        **** 	 * Apply sampling. Output is written back in [tx, ty].
 705:sign.c        **** 	 */
 706:sign.c        **** 	ffSampling_fft(samp, samp_ctx, tx, ty, tree, t0, t1, logn, ty + n);
 4309              		.loc 3 706 64
 4310 0122 3B6D     		ldr	r3, [r7, #80]
 4311 0124 DB00     		lsls	r3, r3, #3
 4312              		.loc 3 706 2
 4313 0126 3A6A     		ldr	r2, [r7, #32]
 4314 0128 1344     		add	r3, r3, r2
 4315 012a 0493     		str	r3, [sp, #16]
 4316 012c FB6F     		ldr	r3, [r7, #124]
 4317 012e 0393     		str	r3, [sp, #12]
 4318 0130 BB6C     		ldr	r3, [r7, #72]
 4319 0132 0293     		str	r3, [sp, #8]
 4320 0134 FB6C     		ldr	r3, [r7, #76]
 4321 0136 0193     		str	r3, [sp, #4]
 4322 0138 7B6B     		ldr	r3, [r7, #52]
 4323 013a 0093     		str	r3, [sp]
 4324 013c 3B6A     		ldr	r3, [r7, #32]
 4325 013e 7A6A     		ldr	r2, [r7, #36]
 4326 0140 B968     		ldr	r1, [r7, #8]
 4327 0142 F868     		ldr	r0, [r7, #12]
 4328 0144 FFF7FEFF 		bl	ffSampling_fft
 707:sign.c        **** 
 708:sign.c        **** 	/*
 709:sign.c        **** 	 * Get the lattice point corresponding to that tiny vector.
 710:sign.c        **** 	 */
 711:sign.c        **** 	memcpy(t0, tx, n * sizeof *tx);
 4329              		.loc 3 711 2
 4330 0148 3B6D     		ldr	r3, [r7, #80]
 4331 014a DB00     		lsls	r3, r3, #3
 4332 014c 1A46     		mov	r2, r3
 4333 014e 796A     		ldr	r1, [r7, #36]
 4334 0150 F86C     		ldr	r0, [r7, #76]
 4335 0152 FFF7FEFF 		bl	memcpy
 712:sign.c        **** 	memcpy(t1, ty, n * sizeof *ty);
 4336              		.loc 3 712 2
 4337 0156 3B6D     		ldr	r3, [r7, #80]
 4338 0158 DB00     		lsls	r3, r3, #3
 4339 015a 1A46     		mov	r2, r3
 4340 015c 396A     		ldr	r1, [r7, #32]
 4341 015e B86C     		ldr	r0, [r7, #72]
 4342 0160 FFF7FEFF 		bl	memcpy
 713:sign.c        **** 	Zf(poly_mul_fft)(tx, b00, logn);
 4343              		.loc 3 713 2
 4344 0164 FA6F     		ldr	r2, [r7, #124]
 4345 0166 796C     		ldr	r1, [r7, #68]
 4346 0168 786A     		ldr	r0, [r7, #36]
 4347 016a FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 714:sign.c        **** 	Zf(poly_mul_fft)(ty, b10, logn);
 4348              		.loc 3 714 2
 4349 016e FA6F     		ldr	r2, [r7, #124]
 4350 0170 F96B     		ldr	r1, [r7, #60]
 4351 0172 386A     		ldr	r0, [r7, #32]
 4352 0174 FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 715:sign.c        **** 	Zf(poly_add)(tx, ty, logn);
 4353              		.loc 3 715 2
 4354 0178 FA6F     		ldr	r2, [r7, #124]
 4355 017a 396A     		ldr	r1, [r7, #32]
 4356 017c 786A     		ldr	r0, [r7, #36]
 4357 017e FFF7FEFF 		bl	falcon_inner_poly_add
 716:sign.c        **** 	memcpy(ty, t0, n * sizeof *t0);
 4358              		.loc 3 716 2
 4359 0182 3B6D     		ldr	r3, [r7, #80]
 4360 0184 DB00     		lsls	r3, r3, #3
 4361 0186 1A46     		mov	r2, r3
 4362 0188 F96C     		ldr	r1, [r7, #76]
 4363 018a 386A     		ldr	r0, [r7, #32]
 4364 018c FFF7FEFF 		bl	memcpy
 717:sign.c        **** 	Zf(poly_mul_fft)(ty, b01, logn);
 4365              		.loc 3 717 2
 4366 0190 FA6F     		ldr	r2, [r7, #124]
 4367 0192 396C     		ldr	r1, [r7, #64]
 4368 0194 386A     		ldr	r0, [r7, #32]
 4369 0196 FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 718:sign.c        **** 
 719:sign.c        **** 	memcpy(t0, tx, n * sizeof *tx);
 4370              		.loc 3 719 2
 4371 019a 3B6D     		ldr	r3, [r7, #80]
 4372 019c DB00     		lsls	r3, r3, #3
 4373 019e 1A46     		mov	r2, r3
 4374 01a0 796A     		ldr	r1, [r7, #36]
 4375 01a2 F86C     		ldr	r0, [r7, #76]
 4376 01a4 FFF7FEFF 		bl	memcpy
 720:sign.c        **** 	Zf(poly_mul_fft)(t1, b11, logn);
 4377              		.loc 3 720 2
 4378 01a8 FA6F     		ldr	r2, [r7, #124]
 4379 01aa B96B     		ldr	r1, [r7, #56]
 4380 01ac B86C     		ldr	r0, [r7, #72]
 4381 01ae FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 721:sign.c        **** 	Zf(poly_add)(t1, ty, logn);
 4382              		.loc 3 721 2
 4383 01b2 FA6F     		ldr	r2, [r7, #124]
 4384 01b4 396A     		ldr	r1, [r7, #32]
 4385 01b6 B86C     		ldr	r0, [r7, #72]
 4386 01b8 FFF7FEFF 		bl	falcon_inner_poly_add
 722:sign.c        **** 
 723:sign.c        **** 	Zf(iFFT)(t0, logn);
 4387              		.loc 3 723 2
 4388 01bc F96F     		ldr	r1, [r7, #124]
 4389 01be F86C     		ldr	r0, [r7, #76]
 4390 01c0 FFF7FEFF 		bl	falcon_inner_iFFT
 724:sign.c        **** 	Zf(iFFT)(t1, logn);
 4391              		.loc 3 724 2
 4392 01c4 F96F     		ldr	r1, [r7, #124]
 4393 01c6 B86C     		ldr	r0, [r7, #72]
 4394 01c8 FFF7FEFF 		bl	falcon_inner_iFFT
 725:sign.c        **** 
 726:sign.c        **** 	/*
 727:sign.c        **** 	 * Compute the signature.
 728:sign.c        **** 	 */
 729:sign.c        **** 	s1tmp = (int16_t *)tx;
 4395              		.loc 3 729 8
 4396 01cc 7B6A     		ldr	r3, [r7, #36]
 4397 01ce FB61     		str	r3, [r7, #28]
 730:sign.c        **** 	sqn = 0;
 4398              		.loc 3 730 6
 4399 01d0 0023     		movs	r3, #0
 4400 01d2 BB65     		str	r3, [r7, #88]
 731:sign.c        **** 	ng = 0;
 4401              		.loc 3 731 5
 4402 01d4 0023     		movs	r3, #0
 4403 01d6 7B65     		str	r3, [r7, #84]
 732:sign.c        **** 	for (u = 0; u < n; u ++) {
 4404              		.loc 3 732 9
 4405 01d8 0023     		movs	r3, #0
 4406 01da FB65     		str	r3, [r7, #92]
 4407              		.loc 3 732 2
 4408 01dc 29E0     		b	.L72
 4409              	.L73:
 4410              	.LBB5:
 733:sign.c        **** 		int32_t z;
 734:sign.c        **** 
 735:sign.c        **** 		z = (int32_t)hm[u] - (int32_t)fpr_rint(t0[u]);
 4411              		.loc 3 735 18 discriminator 3
 4412 01de FB6D     		ldr	r3, [r7, #92]
 4413 01e0 5B00     		lsls	r3, r3, #1
 4414 01e2 BA6F     		ldr	r2, [r7, #120]
 4415 01e4 1344     		add	r3, r3, r2
 4416 01e6 1B88     		ldrh	r3, [r3]
 4417              		.loc 3 735 7 discriminator 3
 4418 01e8 1C46     		mov	r4, r3
 4419              		.loc 3 735 44 discriminator 3
 4420 01ea FB6D     		ldr	r3, [r7, #92]
 4421 01ec DB00     		lsls	r3, r3, #3
 4422 01ee FA6C     		ldr	r2, [r7, #76]
 4423 01f0 1344     		add	r3, r3, r2
 4424              		.loc 3 735 33 discriminator 3
 4425 01f2 D3E90023 		ldrd	r2, [r3]
 4426 01f6 1046     		mov	r0, r2
 4427 01f8 1946     		mov	r1, r3
 4428 01fa FFF7FEFF 		bl	fpr_rint
 4429 01fe 0246     		mov	r2, r0
 4430 0200 0B46     		mov	r3, r1
 4431              		.loc 3 735 24 discriminator 3
 4432 0202 1346     		mov	r3, r2
 4433              		.loc 3 735 5 discriminator 3
 4434 0204 E31A     		subs	r3, r4, r3
 4435 0206 7B61     		str	r3, [r7, #20]
 736:sign.c        **** 		sqn += (uint32_t)(z * z);
 4436              		.loc 3 736 23 discriminator 3
 4437 0208 7B69     		ldr	r3, [r7, #20]
 4438 020a 03FB03F3 		mul	r3, r3, r3
 4439              		.loc 3 736 10 discriminator 3
 4440 020e 1A46     		mov	r2, r3
 4441              		.loc 3 736 7 discriminator 3
 4442 0210 BB6D     		ldr	r3, [r7, #88]
 4443 0212 1344     		add	r3, r3, r2
 4444 0214 BB65     		str	r3, [r7, #88]
 737:sign.c        **** 		ng |= sqn;
 4445              		.loc 3 737 6 discriminator 3
 4446 0216 7A6D     		ldr	r2, [r7, #84]
 4447 0218 BB6D     		ldr	r3, [r7, #88]
 4448 021a 1343     		orrs	r3, r3, r2
 4449 021c 7B65     		str	r3, [r7, #84]
 738:sign.c        **** 		s1tmp[u] = (int16_t)z;
 4450              		.loc 3 738 8 discriminator 3
 4451 021e FB6D     		ldr	r3, [r7, #92]
 4452 0220 5B00     		lsls	r3, r3, #1
 4453 0222 FA69     		ldr	r2, [r7, #28]
 4454 0224 1344     		add	r3, r3, r2
 4455              		.loc 3 738 14 discriminator 3
 4456 0226 7A69     		ldr	r2, [r7, #20]
 4457 0228 12B2     		sxth	r2, r2
 4458              		.loc 3 738 12 discriminator 3
 4459 022a 1A80     		strh	r2, [r3]	@ movhi
 4460              	.LBE5:
 732:sign.c        **** 		int32_t z;
 4461              		.loc 3 732 23 discriminator 3
 4462 022c FB6D     		ldr	r3, [r7, #92]
 4463 022e 0133     		adds	r3, r3, #1
 4464 0230 FB65     		str	r3, [r7, #92]
 4465              	.L72:
 732:sign.c        **** 		int32_t z;
 4466              		.loc 3 732 2 discriminator 1
 4467 0232 FA6D     		ldr	r2, [r7, #92]
 4468 0234 3B6D     		ldr	r3, [r7, #80]
 4469 0236 9A42     		cmp	r2, r3
 4470 0238 D1D3     		bcc	.L73
 739:sign.c        **** 	}
 740:sign.c        **** 	sqn |= -(ng >> 31);
 4471              		.loc 3 740 9
 4472 023a 7B6D     		ldr	r3, [r7, #84]
 4473 023c DB17     		asrs	r3, r3, #31
 4474 023e 1A46     		mov	r2, r3
 4475              		.loc 3 740 6
 4476 0240 BB6D     		ldr	r3, [r7, #88]
 4477 0242 1343     		orrs	r3, r3, r2
 4478 0244 BB65     		str	r3, [r7, #88]
 741:sign.c        **** 
 742:sign.c        **** 	/*
 743:sign.c        **** 	 * With "normal" degrees (e.g. 512 or 1024), it is very
 744:sign.c        **** 	 * improbable that the computed vector is not short enough;
 745:sign.c        **** 	 * however, it may happen in practice for the very reduced
 746:sign.c        **** 	 * versions (e.g. degree 16 or below). In that case, the caller
 747:sign.c        **** 	 * will loop, and we must not write anything into s2[] because
 748:sign.c        **** 	 * s2[] may overlap with the hashed message hm[] and we need
 749:sign.c        **** 	 * hm[] for the next iteration.
 750:sign.c        **** 	 */
 751:sign.c        **** 	s2tmp = (int16_t *)tmp;
 4479              		.loc 3 751 8
 4480 0246 D7F88030 		ldr	r3, [r7, #128]
 4481 024a BB61     		str	r3, [r7, #24]
 752:sign.c        **** 	for (u = 0; u < n; u ++) {
 4482              		.loc 3 752 9
 4483 024c 0023     		movs	r3, #0
 4484 024e FB65     		str	r3, [r7, #92]
 4485              		.loc 3 752 2
 4486 0250 17E0     		b	.L74
 4487              	.L75:
 753:sign.c        **** 		s2tmp[u] = (int16_t)-fpr_rint(t1[u]);
 4488              		.loc 3 753 35 discriminator 3
 4489 0252 FB6D     		ldr	r3, [r7, #92]
 4490 0254 DB00     		lsls	r3, r3, #3
 4491 0256 BA6C     		ldr	r2, [r7, #72]
 4492 0258 1344     		add	r3, r3, r2
 4493              		.loc 3 753 24 discriminator 3
 4494 025a D3E90023 		ldrd	r2, [r3]
 4495 025e 1046     		mov	r0, r2
 4496 0260 1946     		mov	r1, r3
 4497 0262 FFF7FEFF 		bl	fpr_rint
 4498 0266 0246     		mov	r2, r0
 4499 0268 0B46     		mov	r3, r1
 4500              		.loc 3 753 14 discriminator 3
 4501 026a 93B2     		uxth	r3, r2
 4502 026c 5B42     		rsbs	r3, r3, #0
 4503 026e 99B2     		uxth	r1, r3
 4504              		.loc 3 753 8 discriminator 3
 4505 0270 FB6D     		ldr	r3, [r7, #92]
 4506 0272 5B00     		lsls	r3, r3, #1
 4507 0274 BA69     		ldr	r2, [r7, #24]
 4508 0276 1344     		add	r3, r3, r2
 4509              		.loc 3 753 14 discriminator 3
 4510 0278 0AB2     		sxth	r2, r1
 4511              		.loc 3 753 12 discriminator 3
 4512 027a 1A80     		strh	r2, [r3]	@ movhi
 752:sign.c        **** 	for (u = 0; u < n; u ++) {
 4513              		.loc 3 752 23 discriminator 3
 4514 027c FB6D     		ldr	r3, [r7, #92]
 4515 027e 0133     		adds	r3, r3, #1
 4516 0280 FB65     		str	r3, [r7, #92]
 4517              	.L74:
 752:sign.c        **** 	for (u = 0; u < n; u ++) {
 4518              		.loc 3 752 2 discriminator 1
 4519 0282 FA6D     		ldr	r2, [r7, #92]
 4520 0284 3B6D     		ldr	r3, [r7, #80]
 4521 0286 9A42     		cmp	r2, r3
 4522 0288 E3D3     		bcc	.L75
 754:sign.c        **** 	}
 755:sign.c        **** 	if (Zf(is_short_half)(sqn, s2tmp, logn)) {
 4523              		.loc 3 755 6
 4524 028a FA6F     		ldr	r2, [r7, #124]
 4525 028c B969     		ldr	r1, [r7, #24]
 4526 028e B86D     		ldr	r0, [r7, #88]
 4527 0290 FFF7FEFF 		bl	falcon_inner_is_short_half
 4528 0294 0346     		mov	r3, r0
 4529              		.loc 3 755 5
 4530 0296 002B     		cmp	r3, #0
 4531 0298 10D0     		beq	.L76
 756:sign.c        **** 		memcpy(s2, s2tmp, n * sizeof *s2);
 4532              		.loc 3 756 3
 4533 029a 3B6D     		ldr	r3, [r7, #80]
 4534 029c 5B00     		lsls	r3, r3, #1
 4535 029e 1A46     		mov	r2, r3
 4536 02a0 B969     		ldr	r1, [r7, #24]
 4537 02a2 7868     		ldr	r0, [r7, #4]
 4538 02a4 FFF7FEFF 		bl	memcpy
 757:sign.c        **** 		memcpy(tmp, s1tmp, n * sizeof *s1tmp);
 4539              		.loc 3 757 3
 4540 02a8 3B6D     		ldr	r3, [r7, #80]
 4541 02aa 5B00     		lsls	r3, r3, #1
 4542 02ac 1A46     		mov	r2, r3
 4543 02ae F969     		ldr	r1, [r7, #28]
 4544 02b0 D7F88000 		ldr	r0, [r7, #128]
 4545 02b4 FFF7FEFF 		bl	memcpy
 758:sign.c        **** 		return 1;
 4546              		.loc 3 758 10
 4547 02b8 0123     		movs	r3, #1
 4548 02ba 00E0     		b	.L77
 4549              	.L76:
 759:sign.c        **** 	}
 760:sign.c        **** 	return 0;
 4550              		.loc 3 760 9
 4551 02bc 0023     		movs	r3, #0
 4552              	.L77:
 761:sign.c        **** }
 4553              		.loc 3 761 1
 4554 02be 1846     		mov	r0, r3
 4555 02c0 6437     		adds	r7, r7, #100
 4556              	.LCFI144:
 4557              		.cfi_def_cfa_offset 20
 4558 02c2 BD46     		mov	sp, r7
 4559              	.LCFI145:
 4560              		.cfi_def_cfa_register 13
 4561              		@ sp needed
 4562 02c4 F0BD     		pop	{r4, r5, r6, r7, pc}
 4563              	.L79:
 4564 02c6 00BF     		.align	3
 4565              	.L78:
 4566 02c8 82A79790 		.word	-1869109374
 4567 02cc E354153F 		.word	1058362595
 4568              		.cfi_endproc
 4569              	.LFE31:
 4571              		.section	.text.do_sign_dyn,"ax",%progbits
 4572              		.align	1
 4573              		.syntax unified
 4574              		.thumb
 4575              		.thumb_func
 4576              		.fpu softvfp
 4578              	do_sign_dyn:
 4579              	.LFB32:
 762:sign.c        **** 
 763:sign.c        **** /*
 764:sign.c        ****  * Compute a signature: the signature contains two vectors, s1 and s2.
 765:sign.c        ****  * The s1 vector is not returned. The squared norm of (s1,s2) is
 766:sign.c        ****  * computed, and if it is short enough, then s2 is returned into the
 767:sign.c        ****  * s2[] buffer, and 1 is returned; otherwise, s2[] is untouched and 0 is
 768:sign.c        ****  * returned; the caller should then try again.
 769:sign.c        ****  *
 770:sign.c        ****  * tmp[] must have room for at least nine polynomials.
 771:sign.c        ****  */
 772:sign.c        **** 
 773:sign.c        **** 
 774:sign.c        **** static int
 775:sign.c        **** do_sign_dyn(samplerZ samp, void *samp_ctx, int16_t *s2,
 776:sign.c        **** 	const int8_t *restrict f, const int8_t *restrict g,
 777:sign.c        **** 	const int8_t *restrict F, const int8_t *restrict G,
 778:sign.c        **** 	const uint16_t *hm, unsigned logn, fpr *restrict tmp)
 779:sign.c        **** {
 4580              		.loc 3 779 1
 4581              		.cfi_startproc
 4582              		@ args = 24, pretend = 0, frame = 104
 4583              		@ frame_needed = 1, uses_anonymous_args = 0
 4584 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 4585              	.LCFI146:
 4586              		.cfi_def_cfa_offset 20
 4587              		.cfi_offset 4, -20
 4588              		.cfi_offset 5, -16
 4589              		.cfi_offset 6, -12
 4590              		.cfi_offset 7, -8
 4591              		.cfi_offset 14, -4
 4592 0002 A1B0     		sub	sp, sp, #132
 4593              	.LCFI147:
 4594              		.cfi_def_cfa_offset 152
 4595 0004 06AF     		add	r7, sp, #24
 4596              	.LCFI148:
 4597              		.cfi_def_cfa 7, 128
 4598 0006 F860     		str	r0, [r7, #12]
 4599 0008 B960     		str	r1, [r7, #8]
 4600 000a 7A60     		str	r2, [r7, #4]
 4601 000c 3B60     		str	r3, [r7]
 780:sign.c        **** 	size_t n, u;
 781:sign.c        **** 	fpr *t0, *t1, *tx, *ty;
 782:sign.c        **** 	fpr *b00, *b01, *b10, *b11, *g00, *g01, *g11;
 783:sign.c        **** 	fpr ni;
 784:sign.c        **** 	uint32_t sqn, ng;
 785:sign.c        **** 	int16_t *s1tmp, *s2tmp;
 786:sign.c        **** 
 787:sign.c        **** 	n = MKN(logn);
 4602              		.loc 3 787 4
 4603 000e 0122     		movs	r2, #1
 4604 0010 D7F89030 		ldr	r3, [r7, #144]
 4605 0014 02FA03F3 		lsl	r3, r2, r3
 4606 0018 BB65     		str	r3, [r7, #88]
 788:sign.c        **** 
 789:sign.c        **** 	/*
 790:sign.c        **** 	 * Lattice basis is B = [[g, -f], [G, -F]]. We convert it to FFT.
 791:sign.c        **** 	 */
 792:sign.c        **** 	b00 = tmp;
 4607              		.loc 3 792 6
 4608 001a D7F89430 		ldr	r3, [r7, #148]
 4609 001e 7B65     		str	r3, [r7, #84]
 793:sign.c        **** 	b01 = b00 + n;
 4610              		.loc 3 793 12
 4611 0020 BB6D     		ldr	r3, [r7, #88]
 4612 0022 DB00     		lsls	r3, r3, #3
 4613              		.loc 3 793 6
 4614 0024 7A6D     		ldr	r2, [r7, #84]
 4615 0026 1344     		add	r3, r3, r2
 4616 0028 3B65     		str	r3, [r7, #80]
 794:sign.c        **** 	b10 = b01 + n;
 4617              		.loc 3 794 12
 4618 002a BB6D     		ldr	r3, [r7, #88]
 4619 002c DB00     		lsls	r3, r3, #3
 4620              		.loc 3 794 6
 4621 002e 3A6D     		ldr	r2, [r7, #80]
 4622 0030 1344     		add	r3, r3, r2
 4623 0032 FB64     		str	r3, [r7, #76]
 795:sign.c        **** 	b11 = b10 + n;
 4624              		.loc 3 795 12
 4625 0034 BB6D     		ldr	r3, [r7, #88]
 4626 0036 DB00     		lsls	r3, r3, #3
 4627              		.loc 3 795 6
 4628 0038 FA6C     		ldr	r2, [r7, #76]
 4629 003a 1344     		add	r3, r3, r2
 4630 003c BB64     		str	r3, [r7, #72]
 796:sign.c        **** 	smallints_to_fpr(b01, f, logn);
 4631              		.loc 3 796 2
 4632 003e D7F89020 		ldr	r2, [r7, #144]
 4633 0042 3968     		ldr	r1, [r7]
 4634 0044 386D     		ldr	r0, [r7, #80]
 4635 0046 FFF7FEFF 		bl	smallints_to_fpr
 797:sign.c        **** 	smallints_to_fpr(b00, g, logn);
 4636              		.loc 3 797 2
 4637 004a D7F89020 		ldr	r2, [r7, #144]
 4638 004e D7F88010 		ldr	r1, [r7, #128]
 4639 0052 786D     		ldr	r0, [r7, #84]
 4640 0054 FFF7FEFF 		bl	smallints_to_fpr
 798:sign.c        **** 	smallints_to_fpr(b11, F, logn);
 4641              		.loc 3 798 2
 4642 0058 D7F89020 		ldr	r2, [r7, #144]
 4643 005c D7F88410 		ldr	r1, [r7, #132]
 4644 0060 B86C     		ldr	r0, [r7, #72]
 4645 0062 FFF7FEFF 		bl	smallints_to_fpr
 799:sign.c        **** 	smallints_to_fpr(b10, G, logn);
 4646              		.loc 3 799 2
 4647 0066 D7F89020 		ldr	r2, [r7, #144]
 4648 006a D7F88810 		ldr	r1, [r7, #136]
 4649 006e F86C     		ldr	r0, [r7, #76]
 4650 0070 FFF7FEFF 		bl	smallints_to_fpr
 800:sign.c        **** 	Zf(FFT)(b01, logn);
 4651              		.loc 3 800 2
 4652 0074 D7F89010 		ldr	r1, [r7, #144]
 4653 0078 386D     		ldr	r0, [r7, #80]
 4654 007a FFF7FEFF 		bl	falcon_inner_FFT
 801:sign.c        **** 	Zf(FFT)(b00, logn);
 4655              		.loc 3 801 2
 4656 007e D7F89010 		ldr	r1, [r7, #144]
 4657 0082 786D     		ldr	r0, [r7, #84]
 4658 0084 FFF7FEFF 		bl	falcon_inner_FFT
 802:sign.c        **** 	Zf(FFT)(b11, logn);
 4659              		.loc 3 802 2
 4660 0088 D7F89010 		ldr	r1, [r7, #144]
 4661 008c B86C     		ldr	r0, [r7, #72]
 4662 008e FFF7FEFF 		bl	falcon_inner_FFT
 803:sign.c        **** 	Zf(FFT)(b10, logn);
 4663              		.loc 3 803 2
 4664 0092 D7F89010 		ldr	r1, [r7, #144]
 4665 0096 F86C     		ldr	r0, [r7, #76]
 4666 0098 FFF7FEFF 		bl	falcon_inner_FFT
 804:sign.c        **** 	Zf(poly_neg)(b01, logn);
 4667              		.loc 3 804 2
 4668 009c D7F89010 		ldr	r1, [r7, #144]
 4669 00a0 386D     		ldr	r0, [r7, #80]
 4670 00a2 FFF7FEFF 		bl	falcon_inner_poly_neg
 805:sign.c        **** 	Zf(poly_neg)(b11, logn);
 4671              		.loc 3 805 2
 4672 00a6 D7F89010 		ldr	r1, [r7, #144]
 4673 00aa B86C     		ldr	r0, [r7, #72]
 4674 00ac FFF7FEFF 		bl	falcon_inner_poly_neg
 806:sign.c        **** 
 807:sign.c        **** 	/*
 808:sign.c        **** 	 * Compute the Gram matrix G = B·B*. Formulas are:
 809:sign.c        **** 	 *   g00 = b00*adj(b00) + b01*adj(b01)
 810:sign.c        **** 	 *   g01 = b00*adj(b10) + b01*adj(b11)
 811:sign.c        **** 	 *   g10 = b10*adj(b00) + b11*adj(b01)
 812:sign.c        **** 	 *   g11 = b10*adj(b10) + b11*adj(b11)
 813:sign.c        **** 	 *
 814:sign.c        **** 	 * For historical reasons, this implementation uses
 815:sign.c        **** 	 * g00, g01 and g11 (upper triangle). g10 is not kept
 816:sign.c        **** 	 * since it is equal to adj(g01).
 817:sign.c        **** 	 *
 818:sign.c        **** 	 * We _replace_ the matrix B with the Gram matrix, but we
 819:sign.c        **** 	 * must keep b01 and b11 for computing the target vector.
 820:sign.c        **** 	 */
 821:sign.c        **** 	t0 = b11 + n;
 4675              		.loc 3 821 11
 4676 00b0 BB6D     		ldr	r3, [r7, #88]
 4677 00b2 DB00     		lsls	r3, r3, #3
 4678              		.loc 3 821 5
 4679 00b4 BA6C     		ldr	r2, [r7, #72]
 4680 00b6 1344     		add	r3, r3, r2
 4681 00b8 7B64     		str	r3, [r7, #68]
 822:sign.c        **** 	t1 = t0 + n;
 4682              		.loc 3 822 10
 4683 00ba BB6D     		ldr	r3, [r7, #88]
 4684 00bc DB00     		lsls	r3, r3, #3
 4685              		.loc 3 822 5
 4686 00be 7A6C     		ldr	r2, [r7, #68]
 4687 00c0 1344     		add	r3, r3, r2
 4688 00c2 3B64     		str	r3, [r7, #64]
 823:sign.c        **** 
 824:sign.c        **** 	memcpy(t0, b01, n * sizeof *b01);
 4689              		.loc 3 824 2
 4690 00c4 BB6D     		ldr	r3, [r7, #88]
 4691 00c6 DB00     		lsls	r3, r3, #3
 4692 00c8 1A46     		mov	r2, r3
 4693 00ca 396D     		ldr	r1, [r7, #80]
 4694 00cc 786C     		ldr	r0, [r7, #68]
 4695 00ce FFF7FEFF 		bl	memcpy
 825:sign.c        **** 	Zf(poly_mulselfadj_fft)(t0, logn);    // t0 <- b01*adj(b01)
 4696              		.loc 3 825 2
 4697 00d2 D7F89010 		ldr	r1, [r7, #144]
 4698 00d6 786C     		ldr	r0, [r7, #68]
 4699 00d8 FFF7FEFF 		bl	falcon_inner_poly_mulselfadj_fft
 826:sign.c        **** 
 827:sign.c        **** 	memcpy(t1, b00, n * sizeof *b00);
 4700              		.loc 3 827 2
 4701 00dc BB6D     		ldr	r3, [r7, #88]
 4702 00de DB00     		lsls	r3, r3, #3
 4703 00e0 1A46     		mov	r2, r3
 4704 00e2 796D     		ldr	r1, [r7, #84]
 4705 00e4 386C     		ldr	r0, [r7, #64]
 4706 00e6 FFF7FEFF 		bl	memcpy
 828:sign.c        **** 	Zf(poly_muladj_fft)(t1, b10, logn);   // t1 <- b00*adj(b10)
 4707              		.loc 3 828 2
 4708 00ea D7F89020 		ldr	r2, [r7, #144]
 4709 00ee F96C     		ldr	r1, [r7, #76]
 4710 00f0 386C     		ldr	r0, [r7, #64]
 4711 00f2 FFF7FEFF 		bl	falcon_inner_poly_muladj_fft
 829:sign.c        **** 	Zf(poly_mulselfadj_fft)(b00, logn);   // b00 <- b00*adj(b00)
 4712              		.loc 3 829 2
 4713 00f6 D7F89010 		ldr	r1, [r7, #144]
 4714 00fa 786D     		ldr	r0, [r7, #84]
 4715 00fc FFF7FEFF 		bl	falcon_inner_poly_mulselfadj_fft
 830:sign.c        **** 	Zf(poly_add)(b00, t0, logn);      // b00 <- g00
 4716              		.loc 3 830 2
 4717 0100 D7F89020 		ldr	r2, [r7, #144]
 4718 0104 796C     		ldr	r1, [r7, #68]
 4719 0106 786D     		ldr	r0, [r7, #84]
 4720 0108 FFF7FEFF 		bl	falcon_inner_poly_add
 831:sign.c        **** 	memcpy(t0, b01, n * sizeof *b01);
 4721              		.loc 3 831 2
 4722 010c BB6D     		ldr	r3, [r7, #88]
 4723 010e DB00     		lsls	r3, r3, #3
 4724 0110 1A46     		mov	r2, r3
 4725 0112 396D     		ldr	r1, [r7, #80]
 4726 0114 786C     		ldr	r0, [r7, #68]
 4727 0116 FFF7FEFF 		bl	memcpy
 832:sign.c        **** 	Zf(poly_muladj_fft)(b01, b11, logn);  // b01 <- b01*adj(b11)
 4728              		.loc 3 832 2
 4729 011a D7F89020 		ldr	r2, [r7, #144]
 4730 011e B96C     		ldr	r1, [r7, #72]
 4731 0120 386D     		ldr	r0, [r7, #80]
 4732 0122 FFF7FEFF 		bl	falcon_inner_poly_muladj_fft
 833:sign.c        **** 	Zf(poly_add)(b01, t1, logn);      // b01 <- g01
 4733              		.loc 3 833 2
 4734 0126 D7F89020 		ldr	r2, [r7, #144]
 4735 012a 396C     		ldr	r1, [r7, #64]
 4736 012c 386D     		ldr	r0, [r7, #80]
 4737 012e FFF7FEFF 		bl	falcon_inner_poly_add
 834:sign.c        **** 
 835:sign.c        **** 	Zf(poly_mulselfadj_fft)(b10, logn);   // b10 <- b10*adj(b10)
 4738              		.loc 3 835 2
 4739 0132 D7F89010 		ldr	r1, [r7, #144]
 4740 0136 F86C     		ldr	r0, [r7, #76]
 4741 0138 FFF7FEFF 		bl	falcon_inner_poly_mulselfadj_fft
 836:sign.c        **** 	memcpy(t1, b11, n * sizeof *b11);
 4742              		.loc 3 836 2
 4743 013c BB6D     		ldr	r3, [r7, #88]
 4744 013e DB00     		lsls	r3, r3, #3
 4745 0140 1A46     		mov	r2, r3
 4746 0142 B96C     		ldr	r1, [r7, #72]
 4747 0144 386C     		ldr	r0, [r7, #64]
 4748 0146 FFF7FEFF 		bl	memcpy
 837:sign.c        **** 	Zf(poly_mulselfadj_fft)(t1, logn);    // t1 <- b11*adj(b11)
 4749              		.loc 3 837 2
 4750 014a D7F89010 		ldr	r1, [r7, #144]
 4751 014e 386C     		ldr	r0, [r7, #64]
 4752 0150 FFF7FEFF 		bl	falcon_inner_poly_mulselfadj_fft
 838:sign.c        **** 	Zf(poly_add)(b10, t1, logn);      // b10 <- g11
 4753              		.loc 3 838 2
 4754 0154 D7F89020 		ldr	r2, [r7, #144]
 4755 0158 396C     		ldr	r1, [r7, #64]
 4756 015a F86C     		ldr	r0, [r7, #76]
 4757 015c FFF7FEFF 		bl	falcon_inner_poly_add
 839:sign.c        **** 
 840:sign.c        **** 	/*
 841:sign.c        **** 	 * We rename variables to make things clearer. The three elements
 842:sign.c        **** 	 * of the Gram matrix uses the first 3*n slots of tmp[], followed
 843:sign.c        **** 	 * by b11 and b01 (in that order).
 844:sign.c        **** 	 */
 845:sign.c        **** 	g00 = b00;
 4758              		.loc 3 845 6
 4759 0160 7B6D     		ldr	r3, [r7, #84]
 4760 0162 FB63     		str	r3, [r7, #60]
 846:sign.c        **** 	g01 = b01;
 4761              		.loc 3 846 6
 4762 0164 3B6D     		ldr	r3, [r7, #80]
 4763 0166 BB63     		str	r3, [r7, #56]
 847:sign.c        **** 	g11 = b10;
 4764              		.loc 3 847 6
 4765 0168 FB6C     		ldr	r3, [r7, #76]
 4766 016a 7B63     		str	r3, [r7, #52]
 848:sign.c        **** 	b01 = t0;
 4767              		.loc 3 848 6
 4768 016c 7B6C     		ldr	r3, [r7, #68]
 4769 016e 3B65     		str	r3, [r7, #80]
 849:sign.c        **** 	t0 = b01 + n;
 4770              		.loc 3 849 11
 4771 0170 BB6D     		ldr	r3, [r7, #88]
 4772 0172 DB00     		lsls	r3, r3, #3
 4773              		.loc 3 849 5
 4774 0174 3A6D     		ldr	r2, [r7, #80]
 4775 0176 1344     		add	r3, r3, r2
 4776 0178 7B64     		str	r3, [r7, #68]
 850:sign.c        **** 	t1 = t0 + n;
 4777              		.loc 3 850 10
 4778 017a BB6D     		ldr	r3, [r7, #88]
 4779 017c DB00     		lsls	r3, r3, #3
 4780              		.loc 3 850 5
 4781 017e 7A6C     		ldr	r2, [r7, #68]
 4782 0180 1344     		add	r3, r3, r2
 4783 0182 3B64     		str	r3, [r7, #64]
 851:sign.c        **** 
 852:sign.c        **** 	/*
 853:sign.c        **** 	 * Memory layout at that point:
 854:sign.c        **** 	 *   g00 g01 g11 b11 b01 t0 t1
 855:sign.c        **** 	 */
 856:sign.c        **** 
 857:sign.c        **** 	/*
 858:sign.c        **** 	 * Set the target vector to [hm, 0] (hm is the hashed message).
 859:sign.c        **** 	 */
 860:sign.c        **** 	for (u = 0; u < n; u ++) {
 4784              		.loc 3 860 9
 4785 0184 0023     		movs	r3, #0
 4786 0186 7B66     		str	r3, [r7, #100]
 4787              		.loc 3 860 2
 4788 0188 18E0     		b	.L81
 4789              	.L82:
 861:sign.c        **** 		t0[u] = fpr_of(hm[u]);
 4790              		.loc 3 861 20 discriminator 3
 4791 018a 7B6E     		ldr	r3, [r7, #100]
 4792 018c 5B00     		lsls	r3, r3, #1
 4793 018e D7F88C20 		ldr	r2, [r7, #140]
 4794 0192 1344     		add	r3, r3, r2
 4795 0194 1B88     		ldrh	r3, [r3]
 4796              		.loc 3 861 11 discriminator 3
 4797 0196 9BB2     		uxth	r3, r3
 4798 0198 0022     		movs	r2, #0
 4799 019a 1C46     		mov	r4, r3
 4800 019c 1546     		mov	r5, r2
 4801              		.loc 3 861 5 discriminator 3
 4802 019e 7B6E     		ldr	r3, [r7, #100]
 4803 01a0 DB00     		lsls	r3, r3, #3
 4804 01a2 7A6C     		ldr	r2, [r7, #68]
 4805 01a4 D618     		adds	r6, r2, r3
 4806              		.loc 3 861 11 discriminator 3
 4807 01a6 2046     		mov	r0, r4
 4808 01a8 2946     		mov	r1, r5
 4809 01aa FFF7FEFF 		bl	fpr_of
 4810 01ae 0246     		mov	r2, r0
 4811 01b0 0B46     		mov	r3, r1
 4812              		.loc 3 861 9 discriminator 3
 4813 01b2 C6E90023 		strd	r2, [r6]
 860:sign.c        **** 		t0[u] = fpr_of(hm[u]);
 4814              		.loc 3 860 23 discriminator 3
 4815 01b6 7B6E     		ldr	r3, [r7, #100]
 4816 01b8 0133     		adds	r3, r3, #1
 4817 01ba 7B66     		str	r3, [r7, #100]
 4818              	.L81:
 860:sign.c        **** 		t0[u] = fpr_of(hm[u]);
 4819              		.loc 3 860 2 discriminator 1
 4820 01bc 7A6E     		ldr	r2, [r7, #100]
 4821 01be BB6D     		ldr	r3, [r7, #88]
 4822 01c0 9A42     		cmp	r2, r3
 4823 01c2 E2D3     		bcc	.L82
 862:sign.c        **** 		/* This is implicit.
 863:sign.c        **** 		t1[u] = fpr_zero;
 864:sign.c        **** 		*/
 865:sign.c        **** 	}
 866:sign.c        **** 
 867:sign.c        **** 	/*
 868:sign.c        **** 	 * Apply the lattice basis to obtain the real target
 869:sign.c        **** 	 * vector (after normalization with regards to modulus).
 870:sign.c        **** 	 */
 871:sign.c        **** 	//trigger_high();
 872:sign.c        **** 	Zf(FFT)(t0, logn);
 4824              		.loc 3 872 2
 4825 01c4 D7F89010 		ldr	r1, [r7, #144]
 4826 01c8 786C     		ldr	r0, [r7, #68]
 4827 01ca FFF7FEFF 		bl	falcon_inner_FFT
 873:sign.c        **** 	ni = fpr_inverse_of_q;
 4828              		.loc 3 873 5
 4829 01ce C4A3     		adr	r3, .L89
 4830 01d0 D3E90023 		ldrd	r2, [r3]
 4831 01d4 C7E90A23 		strd	r2, [r7, #40]
 874:sign.c        **** 	memcpy(t1, t0, n * sizeof *t0); //t0, t1 --> hm (c)
 4832              		.loc 3 874 2
 4833 01d8 BB6D     		ldr	r3, [r7, #88]
 4834 01da DB00     		lsls	r3, r3, #3
 4835 01dc 1A46     		mov	r2, r3
 4836 01de 796C     		ldr	r1, [r7, #68]
 4837 01e0 386C     		ldr	r0, [r7, #64]
 4838 01e2 FFF7FEFF 		bl	memcpy
 875:sign.c        **** 	Zf(poly_mul_fft)(t1, b01, logn); //FFT(c), FFT(-f) 복소수 곱셈
 4839              		.loc 3 875 2
 4840 01e6 D7F89020 		ldr	r2, [r7, #144]
 4841 01ea 396D     		ldr	r1, [r7, #80]
 4842 01ec 386C     		ldr	r0, [r7, #64]
 4843 01ee FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 876:sign.c        **** 	Zf(poly_mulconst)(t1, fpr_neg(ni), logn); //-(1/q) * ( FFT(c) * FFT(-f) )
 4844              		.loc 3 876 2
 4845 01f2 D7E90A01 		ldrd	r0, [r7, #40]
 4846 01f6 FFF7FEFF 		bl	fpr_neg
 4847 01fa 0246     		mov	r2, r0
 4848 01fc 0B46     		mov	r3, r1
 4849 01fe D7F89010 		ldr	r1, [r7, #144]
 4850 0202 0091     		str	r1, [sp]
 4851 0204 386C     		ldr	r0, [r7, #64]
 4852 0206 FFF7FEFF 		bl	falcon_inner_poly_mulconst
 877:sign.c        **** 	Zf(poly_mul_fft)(t0, b11, logn);
 4853              		.loc 3 877 2
 4854 020a D7F89020 		ldr	r2, [r7, #144]
 4855 020e B96C     		ldr	r1, [r7, #72]
 4856 0210 786C     		ldr	r0, [r7, #68]
 4857 0212 FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 878:sign.c        **** 	Zf(poly_mulconst)(t0, ni, logn);
 4858              		.loc 3 878 2
 4859 0216 D7F89030 		ldr	r3, [r7, #144]
 4860 021a 0093     		str	r3, [sp]
 4861 021c D7E90A23 		ldrd	r2, [r7, #40]
 4862 0220 786C     		ldr	r0, [r7, #68]
 4863 0222 FFF7FEFF 		bl	falcon_inner_poly_mulconst
 879:sign.c        **** 	//trigger_low();
 880:sign.c        **** 
 881:sign.c        **** 	/*
 882:sign.c        **** 	 * b01 and b11 can be discarded, so we move back (t0,t1).
 883:sign.c        **** 	 * Memory layout is now:
 884:sign.c        **** 	 *      g00 g01 g11 t0 t1
 885:sign.c        **** 	 */
 886:sign.c        **** 	memcpy(b11, t0, n * 2 * sizeof *t0);
 4864              		.loc 3 886 2
 4865 0226 BB6D     		ldr	r3, [r7, #88]
 4866 0228 1B01     		lsls	r3, r3, #4
 4867 022a 1A46     		mov	r2, r3
 4868 022c 796C     		ldr	r1, [r7, #68]
 4869 022e B86C     		ldr	r0, [r7, #72]
 4870 0230 FFF7FEFF 		bl	memcpy
 887:sign.c        **** 	t0 = g11 + n;
 4871              		.loc 3 887 11
 4872 0234 BB6D     		ldr	r3, [r7, #88]
 4873 0236 DB00     		lsls	r3, r3, #3
 4874              		.loc 3 887 5
 4875 0238 7A6B     		ldr	r2, [r7, #52]
 4876 023a 1344     		add	r3, r3, r2
 4877 023c 7B64     		str	r3, [r7, #68]
 888:sign.c        **** 	t1 = t0 + n;
 4878              		.loc 3 888 10
 4879 023e BB6D     		ldr	r3, [r7, #88]
 4880 0240 DB00     		lsls	r3, r3, #3
 4881              		.loc 3 888 5
 4882 0242 7A6C     		ldr	r2, [r7, #68]
 4883 0244 1344     		add	r3, r3, r2
 4884 0246 3B64     		str	r3, [r7, #64]
 889:sign.c        **** 
 890:sign.c        **** 	/*
 891:sign.c        **** 	 * Apply sampling; result is written over (t0,t1).
 892:sign.c        **** 	 */
 893:sign.c        **** 	ffSampling_fft_dyntree(samp, samp_ctx,
 894:sign.c        **** 		t0, t1, g00, g01, g11, logn, logn, t1 + n);
 4885              		.loc 3 894 41
 4886 0248 BB6D     		ldr	r3, [r7, #88]
 4887 024a DB00     		lsls	r3, r3, #3
 893:sign.c        **** 		t0, t1, g00, g01, g11, logn, logn, t1 + n);
 4888              		.loc 3 893 2
 4889 024c 3A6C     		ldr	r2, [r7, #64]
 4890 024e 1344     		add	r3, r3, r2
 4891 0250 0593     		str	r3, [sp, #20]
 4892 0252 D7F89030 		ldr	r3, [r7, #144]
 4893 0256 0493     		str	r3, [sp, #16]
 4894 0258 D7F89030 		ldr	r3, [r7, #144]
 4895 025c 0393     		str	r3, [sp, #12]
 4896 025e 7B6B     		ldr	r3, [r7, #52]
 4897 0260 0293     		str	r3, [sp, #8]
 4898 0262 BB6B     		ldr	r3, [r7, #56]
 4899 0264 0193     		str	r3, [sp, #4]
 4900 0266 FB6B     		ldr	r3, [r7, #60]
 4901 0268 0093     		str	r3, [sp]
 4902 026a 3B6C     		ldr	r3, [r7, #64]
 4903 026c 7A6C     		ldr	r2, [r7, #68]
 4904 026e B968     		ldr	r1, [r7, #8]
 4905 0270 F868     		ldr	r0, [r7, #12]
 4906 0272 FFF7FEFF 		bl	ffSampling_fft_dyntree
 895:sign.c        **** 
 896:sign.c        **** 	/*
 897:sign.c        **** 	 * We arrange the layout back to:
 898:sign.c        **** 	 *     b00 b01 b10 b11 t0 t1
 899:sign.c        **** 	 *
 900:sign.c        **** 	 * We did not conserve the matrix basis, so we must recompute
 901:sign.c        **** 	 * it now.
 902:sign.c        **** 	 */
 903:sign.c        **** 	b00 = tmp;
 4907              		.loc 3 903 6
 4908 0276 D7F89430 		ldr	r3, [r7, #148]
 4909 027a 7B65     		str	r3, [r7, #84]
 904:sign.c        **** 	b01 = b00 + n;
 4910              		.loc 3 904 12
 4911 027c BB6D     		ldr	r3, [r7, #88]
 4912 027e DB00     		lsls	r3, r3, #3
 4913              		.loc 3 904 6
 4914 0280 7A6D     		ldr	r2, [r7, #84]
 4915 0282 1344     		add	r3, r3, r2
 4916 0284 3B65     		str	r3, [r7, #80]
 905:sign.c        **** 	b10 = b01 + n;
 4917              		.loc 3 905 12
 4918 0286 BB6D     		ldr	r3, [r7, #88]
 4919 0288 DB00     		lsls	r3, r3, #3
 4920              		.loc 3 905 6
 4921 028a 3A6D     		ldr	r2, [r7, #80]
 4922 028c 1344     		add	r3, r3, r2
 4923 028e FB64     		str	r3, [r7, #76]
 906:sign.c        **** 	b11 = b10 + n;
 4924              		.loc 3 906 12
 4925 0290 BB6D     		ldr	r3, [r7, #88]
 4926 0292 DB00     		lsls	r3, r3, #3
 4927              		.loc 3 906 6
 4928 0294 FA6C     		ldr	r2, [r7, #76]
 4929 0296 1344     		add	r3, r3, r2
 4930 0298 BB64     		str	r3, [r7, #72]
 907:sign.c        **** 	memmove(b11 + n, t0, n * 2 * sizeof *t0);
 4931              		.loc 3 907 14
 4932 029a BB6D     		ldr	r3, [r7, #88]
 4933 029c DB00     		lsls	r3, r3, #3
 4934 029e BA6C     		ldr	r2, [r7, #72]
 4935 02a0 D018     		adds	r0, r2, r3
 4936              		.loc 3 907 2
 4937 02a2 BB6D     		ldr	r3, [r7, #88]
 4938 02a4 1B01     		lsls	r3, r3, #4
 4939 02a6 1A46     		mov	r2, r3
 4940 02a8 796C     		ldr	r1, [r7, #68]
 4941 02aa FFF7FEFF 		bl	memmove
 908:sign.c        **** 	t0 = b11 + n;
 4942              		.loc 3 908 11
 4943 02ae BB6D     		ldr	r3, [r7, #88]
 4944 02b0 DB00     		lsls	r3, r3, #3
 4945              		.loc 3 908 5
 4946 02b2 BA6C     		ldr	r2, [r7, #72]
 4947 02b4 1344     		add	r3, r3, r2
 4948 02b6 7B64     		str	r3, [r7, #68]
 909:sign.c        **** 	t1 = t0 + n;
 4949              		.loc 3 909 10
 4950 02b8 BB6D     		ldr	r3, [r7, #88]
 4951 02ba DB00     		lsls	r3, r3, #3
 4952              		.loc 3 909 5
 4953 02bc 7A6C     		ldr	r2, [r7, #68]
 4954 02be 1344     		add	r3, r3, r2
 4955 02c0 3B64     		str	r3, [r7, #64]
 910:sign.c        **** 	smallints_to_fpr(b01, f, logn);
 4956              		.loc 3 910 2
 4957 02c2 D7F89020 		ldr	r2, [r7, #144]
 4958 02c6 3968     		ldr	r1, [r7]
 4959 02c8 386D     		ldr	r0, [r7, #80]
 4960 02ca FFF7FEFF 		bl	smallints_to_fpr
 911:sign.c        **** 	smallints_to_fpr(b00, g, logn);
 4961              		.loc 3 911 2
 4962 02ce D7F89020 		ldr	r2, [r7, #144]
 4963 02d2 D7F88010 		ldr	r1, [r7, #128]
 4964 02d6 786D     		ldr	r0, [r7, #84]
 4965 02d8 FFF7FEFF 		bl	smallints_to_fpr
 912:sign.c        **** 	smallints_to_fpr(b11, F, logn);
 4966              		.loc 3 912 2
 4967 02dc D7F89020 		ldr	r2, [r7, #144]
 4968 02e0 D7F88410 		ldr	r1, [r7, #132]
 4969 02e4 B86C     		ldr	r0, [r7, #72]
 4970 02e6 FFF7FEFF 		bl	smallints_to_fpr
 913:sign.c        **** 	smallints_to_fpr(b10, G, logn);
 4971              		.loc 3 913 2
 4972 02ea D7F89020 		ldr	r2, [r7, #144]
 4973 02ee D7F88810 		ldr	r1, [r7, #136]
 4974 02f2 F86C     		ldr	r0, [r7, #76]
 4975 02f4 FFF7FEFF 		bl	smallints_to_fpr
 914:sign.c        **** 	Zf(FFT)(b01, logn);
 4976              		.loc 3 914 2
 4977 02f8 D7F89010 		ldr	r1, [r7, #144]
 4978 02fc 386D     		ldr	r0, [r7, #80]
 4979 02fe FFF7FEFF 		bl	falcon_inner_FFT
 915:sign.c        **** 	Zf(FFT)(b00, logn);
 4980              		.loc 3 915 2
 4981 0302 D7F89010 		ldr	r1, [r7, #144]
 4982 0306 786D     		ldr	r0, [r7, #84]
 4983 0308 FFF7FEFF 		bl	falcon_inner_FFT
 916:sign.c        **** 	Zf(FFT)(b11, logn);
 4984              		.loc 3 916 2
 4985 030c D7F89010 		ldr	r1, [r7, #144]
 4986 0310 B86C     		ldr	r0, [r7, #72]
 4987 0312 FFF7FEFF 		bl	falcon_inner_FFT
 917:sign.c        **** 	Zf(FFT)(b10, logn);
 4988              		.loc 3 917 2
 4989 0316 D7F89010 		ldr	r1, [r7, #144]
 4990 031a F86C     		ldr	r0, [r7, #76]
 4991 031c FFF7FEFF 		bl	falcon_inner_FFT
 918:sign.c        **** 	Zf(poly_neg)(b01, logn);
 4992              		.loc 3 918 2
 4993 0320 D7F89010 		ldr	r1, [r7, #144]
 4994 0324 386D     		ldr	r0, [r7, #80]
 4995 0326 FFF7FEFF 		bl	falcon_inner_poly_neg
 919:sign.c        **** 	Zf(poly_neg)(b11, logn);
 4996              		.loc 3 919 2
 4997 032a D7F89010 		ldr	r1, [r7, #144]
 4998 032e B86C     		ldr	r0, [r7, #72]
 4999 0330 FFF7FEFF 		bl	falcon_inner_poly_neg
 920:sign.c        **** 	tx = t1 + n;
 5000              		.loc 3 920 10
 5001 0334 BB6D     		ldr	r3, [r7, #88]
 5002 0336 DB00     		lsls	r3, r3, #3
 5003              		.loc 3 920 5
 5004 0338 3A6C     		ldr	r2, [r7, #64]
 5005 033a 1344     		add	r3, r3, r2
 5006 033c 7B62     		str	r3, [r7, #36]
 921:sign.c        **** 	ty = tx + n;
 5007              		.loc 3 921 10
 5008 033e BB6D     		ldr	r3, [r7, #88]
 5009 0340 DB00     		lsls	r3, r3, #3
 5010              		.loc 3 921 5
 5011 0342 7A6A     		ldr	r2, [r7, #36]
 5012 0344 1344     		add	r3, r3, r2
 5013 0346 3B62     		str	r3, [r7, #32]
 922:sign.c        **** 
 923:sign.c        **** 	/*
 924:sign.c        **** 	 * Get the lattice point corresponding to that tiny vector.
 925:sign.c        **** 	 */
 926:sign.c        **** 	memcpy(tx, t0, n * sizeof *t0);
 5014              		.loc 3 926 2
 5015 0348 BB6D     		ldr	r3, [r7, #88]
 5016 034a DB00     		lsls	r3, r3, #3
 5017 034c 1A46     		mov	r2, r3
 5018 034e 796C     		ldr	r1, [r7, #68]
 5019 0350 786A     		ldr	r0, [r7, #36]
 5020 0352 FFF7FEFF 		bl	memcpy
 927:sign.c        **** 	memcpy(ty, t1, n * sizeof *t1);
 5021              		.loc 3 927 2
 5022 0356 BB6D     		ldr	r3, [r7, #88]
 5023 0358 DB00     		lsls	r3, r3, #3
 5024 035a 1A46     		mov	r2, r3
 5025 035c 396C     		ldr	r1, [r7, #64]
 5026 035e 386A     		ldr	r0, [r7, #32]
 5027 0360 FFF7FEFF 		bl	memcpy
 928:sign.c        **** 	Zf(poly_mul_fft)(tx, b00, logn);
 5028              		.loc 3 928 2
 5029 0364 D7F89020 		ldr	r2, [r7, #144]
 5030 0368 796D     		ldr	r1, [r7, #84]
 5031 036a 786A     		ldr	r0, [r7, #36]
 5032 036c FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 929:sign.c        **** 	Zf(poly_mul_fft)(ty, b10, logn);
 5033              		.loc 3 929 2
 5034 0370 D7F89020 		ldr	r2, [r7, #144]
 5035 0374 F96C     		ldr	r1, [r7, #76]
 5036 0376 386A     		ldr	r0, [r7, #32]
 5037 0378 FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 930:sign.c        **** 	Zf(poly_add)(tx, ty, logn);
 5038              		.loc 3 930 2
 5039 037c D7F89020 		ldr	r2, [r7, #144]
 5040 0380 396A     		ldr	r1, [r7, #32]
 5041 0382 786A     		ldr	r0, [r7, #36]
 5042 0384 FFF7FEFF 		bl	falcon_inner_poly_add
 931:sign.c        **** 	memcpy(ty, t0, n * sizeof *t0);
 5043              		.loc 3 931 2
 5044 0388 BB6D     		ldr	r3, [r7, #88]
 5045 038a DB00     		lsls	r3, r3, #3
 5046 038c 1A46     		mov	r2, r3
 5047 038e 796C     		ldr	r1, [r7, #68]
 5048 0390 386A     		ldr	r0, [r7, #32]
 5049 0392 FFF7FEFF 		bl	memcpy
 932:sign.c        **** 	Zf(poly_mul_fft)(ty, b01, logn);
 5050              		.loc 3 932 2
 5051 0396 D7F89020 		ldr	r2, [r7, #144]
 5052 039a 396D     		ldr	r1, [r7, #80]
 5053 039c 386A     		ldr	r0, [r7, #32]
 5054 039e FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 933:sign.c        **** 
 934:sign.c        **** 	memcpy(t0, tx, n * sizeof *tx);
 5055              		.loc 3 934 2
 5056 03a2 BB6D     		ldr	r3, [r7, #88]
 5057 03a4 DB00     		lsls	r3, r3, #3
 5058 03a6 1A46     		mov	r2, r3
 5059 03a8 796A     		ldr	r1, [r7, #36]
 5060 03aa 786C     		ldr	r0, [r7, #68]
 5061 03ac FFF7FEFF 		bl	memcpy
 935:sign.c        **** 	Zf(poly_mul_fft)(t1, b11, logn);
 5062              		.loc 3 935 2
 5063 03b0 D7F89020 		ldr	r2, [r7, #144]
 5064 03b4 B96C     		ldr	r1, [r7, #72]
 5065 03b6 386C     		ldr	r0, [r7, #64]
 5066 03b8 FFF7FEFF 		bl	falcon_inner_poly_mul_fft
 936:sign.c        **** 	Zf(poly_add)(t1, ty, logn);
 5067              		.loc 3 936 2
 5068 03bc D7F89020 		ldr	r2, [r7, #144]
 5069 03c0 396A     		ldr	r1, [r7, #32]
 5070 03c2 386C     		ldr	r0, [r7, #64]
 5071 03c4 FFF7FEFF 		bl	falcon_inner_poly_add
 937:sign.c        **** 	Zf(iFFT)(t0, logn);
 5072              		.loc 3 937 2
 5073 03c8 D7F89010 		ldr	r1, [r7, #144]
 5074 03cc 786C     		ldr	r0, [r7, #68]
 5075 03ce FFF7FEFF 		bl	falcon_inner_iFFT
 938:sign.c        **** 	Zf(iFFT)(t1, logn);
 5076              		.loc 3 938 2
 5077 03d2 D7F89010 		ldr	r1, [r7, #144]
 5078 03d6 386C     		ldr	r0, [r7, #64]
 5079 03d8 FFF7FEFF 		bl	falcon_inner_iFFT
 939:sign.c        **** 
 940:sign.c        **** 	s1tmp = (int16_t *)tx;
 5080              		.loc 3 940 8
 5081 03dc 7B6A     		ldr	r3, [r7, #36]
 5082 03de FB61     		str	r3, [r7, #28]
 941:sign.c        **** 	sqn = 0;
 5083              		.loc 3 941 6
 5084 03e0 0023     		movs	r3, #0
 5085 03e2 3B66     		str	r3, [r7, #96]
 942:sign.c        **** 	ng = 0;
 5086              		.loc 3 942 5
 5087 03e4 0023     		movs	r3, #0
 5088 03e6 FB65     		str	r3, [r7, #92]
 943:sign.c        **** 	for (u = 0; u < n; u ++) {
 5089              		.loc 3 943 9
 5090 03e8 0023     		movs	r3, #0
 5091 03ea 7B66     		str	r3, [r7, #100]
 5092              		.loc 3 943 2
 5093 03ec 2AE0     		b	.L83
 5094              	.L84:
 5095              	.LBB6:
 944:sign.c        **** 		int32_t z;
 945:sign.c        **** 
 946:sign.c        **** 		z = (int32_t)hm[u] - (int32_t)fpr_rint(t0[u]);
 5096              		.loc 3 946 18 discriminator 3
 5097 03ee 7B6E     		ldr	r3, [r7, #100]
 5098 03f0 5B00     		lsls	r3, r3, #1
 5099 03f2 D7F88C20 		ldr	r2, [r7, #140]
 5100 03f6 1344     		add	r3, r3, r2
 5101 03f8 1B88     		ldrh	r3, [r3]
 5102              		.loc 3 946 7 discriminator 3
 5103 03fa 1C46     		mov	r4, r3
 5104              		.loc 3 946 44 discriminator 3
 5105 03fc 7B6E     		ldr	r3, [r7, #100]
 5106 03fe DB00     		lsls	r3, r3, #3
 5107 0400 7A6C     		ldr	r2, [r7, #68]
 5108 0402 1344     		add	r3, r3, r2
 5109              		.loc 3 946 33 discriminator 3
 5110 0404 D3E90023 		ldrd	r2, [r3]
 5111 0408 1046     		mov	r0, r2
 5112 040a 1946     		mov	r1, r3
 5113 040c FFF7FEFF 		bl	fpr_rint
 5114 0410 0246     		mov	r2, r0
 5115 0412 0B46     		mov	r3, r1
 5116              		.loc 3 946 24 discriminator 3
 5117 0414 1346     		mov	r3, r2
 5118              		.loc 3 946 5 discriminator 3
 5119 0416 E31A     		subs	r3, r4, r3
 5120 0418 7B61     		str	r3, [r7, #20]
 947:sign.c        **** 		sqn += (uint32_t)(z * z);
 5121              		.loc 3 947 23 discriminator 3
 5122 041a 7B69     		ldr	r3, [r7, #20]
 5123 041c 03FB03F3 		mul	r3, r3, r3
 5124              		.loc 3 947 10 discriminator 3
 5125 0420 1A46     		mov	r2, r3
 5126              		.loc 3 947 7 discriminator 3
 5127 0422 3B6E     		ldr	r3, [r7, #96]
 5128 0424 1344     		add	r3, r3, r2
 5129 0426 3B66     		str	r3, [r7, #96]
 948:sign.c        **** 		ng |= sqn;
 5130              		.loc 3 948 6 discriminator 3
 5131 0428 FA6D     		ldr	r2, [r7, #92]
 5132 042a 3B6E     		ldr	r3, [r7, #96]
 5133 042c 1343     		orrs	r3, r3, r2
 5134 042e FB65     		str	r3, [r7, #92]
 949:sign.c        **** 		s1tmp[u] = (int16_t)z;
 5135              		.loc 3 949 8 discriminator 3
 5136 0430 7B6E     		ldr	r3, [r7, #100]
 5137 0432 5B00     		lsls	r3, r3, #1
 5138 0434 FA69     		ldr	r2, [r7, #28]
 5139 0436 1344     		add	r3, r3, r2
 5140              		.loc 3 949 14 discriminator 3
 5141 0438 7A69     		ldr	r2, [r7, #20]
 5142 043a 12B2     		sxth	r2, r2
 5143              		.loc 3 949 12 discriminator 3
 5144 043c 1A80     		strh	r2, [r3]	@ movhi
 5145              	.LBE6:
 943:sign.c        **** 		int32_t z;
 5146              		.loc 3 943 23 discriminator 3
 5147 043e 7B6E     		ldr	r3, [r7, #100]
 5148 0440 0133     		adds	r3, r3, #1
 5149 0442 7B66     		str	r3, [r7, #100]
 5150              	.L83:
 943:sign.c        **** 		int32_t z;
 5151              		.loc 3 943 2 discriminator 1
 5152 0444 7A6E     		ldr	r2, [r7, #100]
 5153 0446 BB6D     		ldr	r3, [r7, #88]
 5154 0448 9A42     		cmp	r2, r3
 5155 044a D0D3     		bcc	.L84
 950:sign.c        **** 	}
 951:sign.c        **** 	sqn |= -(ng >> 31);
 5156              		.loc 3 951 9
 5157 044c FB6D     		ldr	r3, [r7, #92]
 5158 044e DB17     		asrs	r3, r3, #31
 5159 0450 1A46     		mov	r2, r3
 5160              		.loc 3 951 6
 5161 0452 3B6E     		ldr	r3, [r7, #96]
 5162 0454 1343     		orrs	r3, r3, r2
 5163 0456 3B66     		str	r3, [r7, #96]
 952:sign.c        **** 
 953:sign.c        **** 	/*
 954:sign.c        **** 	 * With "normal" degrees (e.g. 512 or 1024), it is very
 955:sign.c        **** 	 * improbable that the computed vector is not short enough;
 956:sign.c        **** 	 * however, it may happen in practice for the very reduced
 957:sign.c        **** 	 * versions (e.g. degree 16 or below). In that case, the caller
 958:sign.c        **** 	 * will loop, and we must not write anything into s2[] because
 959:sign.c        **** 	 * s2[] may overlap with the hashed message hm[] and we need
 960:sign.c        **** 	 * hm[] for the next iteration.
 961:sign.c        **** 	 */
 962:sign.c        **** 	s2tmp = (int16_t *)tmp;
 5164              		.loc 3 962 8
 5165 0458 D7F89430 		ldr	r3, [r7, #148]
 5166 045c BB61     		str	r3, [r7, #24]
 963:sign.c        **** 	for (u = 0; u < n; u ++) {
 5167              		.loc 3 963 9
 5168 045e 0023     		movs	r3, #0
 5169 0460 7B66     		str	r3, [r7, #100]
 5170              		.loc 3 963 2
 5171 0462 17E0     		b	.L85
 5172              	.L86:
 964:sign.c        **** 		s2tmp[u] = (int16_t)-fpr_rint(t1[u]);
 5173              		.loc 3 964 35 discriminator 3
 5174 0464 7B6E     		ldr	r3, [r7, #100]
 5175 0466 DB00     		lsls	r3, r3, #3
 5176 0468 3A6C     		ldr	r2, [r7, #64]
 5177 046a 1344     		add	r3, r3, r2
 5178              		.loc 3 964 24 discriminator 3
 5179 046c D3E90023 		ldrd	r2, [r3]
 5180 0470 1046     		mov	r0, r2
 5181 0472 1946     		mov	r1, r3
 5182 0474 FFF7FEFF 		bl	fpr_rint
 5183 0478 0246     		mov	r2, r0
 5184 047a 0B46     		mov	r3, r1
 5185              		.loc 3 964 14 discriminator 3
 5186 047c 93B2     		uxth	r3, r2
 5187 047e 5B42     		rsbs	r3, r3, #0
 5188 0480 99B2     		uxth	r1, r3
 5189              		.loc 3 964 8 discriminator 3
 5190 0482 7B6E     		ldr	r3, [r7, #100]
 5191 0484 5B00     		lsls	r3, r3, #1
 5192 0486 BA69     		ldr	r2, [r7, #24]
 5193 0488 1344     		add	r3, r3, r2
 5194              		.loc 3 964 14 discriminator 3
 5195 048a 0AB2     		sxth	r2, r1
 5196              		.loc 3 964 12 discriminator 3
 5197 048c 1A80     		strh	r2, [r3]	@ movhi
 963:sign.c        **** 	for (u = 0; u < n; u ++) {
 5198              		.loc 3 963 23 discriminator 3
 5199 048e 7B6E     		ldr	r3, [r7, #100]
 5200 0490 0133     		adds	r3, r3, #1
 5201 0492 7B66     		str	r3, [r7, #100]
 5202              	.L85:
 963:sign.c        **** 	for (u = 0; u < n; u ++) {
 5203              		.loc 3 963 2 discriminator 1
 5204 0494 7A6E     		ldr	r2, [r7, #100]
 5205 0496 BB6D     		ldr	r3, [r7, #88]
 5206 0498 9A42     		cmp	r2, r3
 5207 049a E3D3     		bcc	.L86
 965:sign.c        **** 	}
 966:sign.c        **** 	if (Zf(is_short_half)(sqn, s2tmp, logn)) {
 5208              		.loc 3 966 6
 5209 049c D7F89020 		ldr	r2, [r7, #144]
 5210 04a0 B969     		ldr	r1, [r7, #24]
 5211 04a2 386E     		ldr	r0, [r7, #96]
 5212 04a4 FFF7FEFF 		bl	falcon_inner_is_short_half
 5213 04a8 0346     		mov	r3, r0
 5214              		.loc 3 966 5
 5215 04aa 002B     		cmp	r3, #0
 5216 04ac 10D0     		beq	.L87
 967:sign.c        **** 		memcpy(s2, s2tmp, n * sizeof *s2);
 5217              		.loc 3 967 3
 5218 04ae BB6D     		ldr	r3, [r7, #88]
 5219 04b0 5B00     		lsls	r3, r3, #1
 5220 04b2 1A46     		mov	r2, r3
 5221 04b4 B969     		ldr	r1, [r7, #24]
 5222 04b6 7868     		ldr	r0, [r7, #4]
 5223 04b8 FFF7FEFF 		bl	memcpy
 968:sign.c        **** 		memcpy(tmp, s1tmp, n * sizeof *s1tmp);
 5224              		.loc 3 968 3
 5225 04bc BB6D     		ldr	r3, [r7, #88]
 5226 04be 5B00     		lsls	r3, r3, #1
 5227 04c0 1A46     		mov	r2, r3
 5228 04c2 F969     		ldr	r1, [r7, #28]
 5229 04c4 D7F89400 		ldr	r0, [r7, #148]
 5230 04c8 FFF7FEFF 		bl	memcpy
 969:sign.c        **** 		return 1;
 5231              		.loc 3 969 10
 5232 04cc 0123     		movs	r3, #1
 5233 04ce 00E0     		b	.L88
 5234              	.L87:
 970:sign.c        **** 	}
 971:sign.c        **** 	return 0;
 5235              		.loc 3 971 9
 5236 04d0 0023     		movs	r3, #0
 5237              	.L88:
 972:sign.c        **** }
 5238              		.loc 3 972 1
 5239 04d2 1846     		mov	r0, r3
 5240 04d4 6C37     		adds	r7, r7, #108
 5241              	.LCFI149:
 5242              		.cfi_def_cfa_offset 20
 5243 04d6 BD46     		mov	sp, r7
 5244              	.LCFI150:
 5245              		.cfi_def_cfa_register 13
 5246              		@ sp needed
 5247 04d8 F0BD     		pop	{r4, r5, r6, r7, pc}
 5248              	.L90:
 5249 04da 00BFAFF3 		.align	3
 5249      0080
 5250              	.L89:
 5251 04e0 82A79790 		.word	-1869109374
 5252 04e4 E354153F 		.word	1058362595
 5253              		.cfi_endproc
 5254              	.LFE32:
 5256              		.section	.text.falcon_inner_gaussian0_sampler,"ax",%progbits
 5257              		.align	1
 5258              		.global	falcon_inner_gaussian0_sampler
 5259              		.syntax unified
 5260              		.thumb
 5261              		.thumb_func
 5262              		.fpu softvfp
 5264              	falcon_inner_gaussian0_sampler:
 5265              	.LFB33:
 973:sign.c        **** 
 974:sign.c        **** /*
 975:sign.c        ****  * Sample an integer value along a half-gaussian distribution centered
 976:sign.c        ****  * on zero and standard deviation 1.8205, with a precision of 72 bits.
 977:sign.c        ****  */
 978:sign.c        **** int
 979:sign.c        **** Zf(gaussian0_sampler)(prng *p)
 980:sign.c        **** {
 5266              		.loc 3 980 1
 5267              		.cfi_startproc
 5268              		@ args = 0, pretend = 0, frame = 56
 5269              		@ frame_needed = 1, uses_anonymous_args = 0
 5270 0000 80B5     		push	{r7, lr}
 5271              	.LCFI151:
 5272              		.cfi_def_cfa_offset 8
 5273              		.cfi_offset 7, -8
 5274              		.cfi_offset 14, -4
 5275 0002 8EB0     		sub	sp, sp, #56
 5276              	.LCFI152:
 5277              		.cfi_def_cfa_offset 64
 5278 0004 00AF     		add	r7, sp, #0
 5279              	.LCFI153:
 5280              		.cfi_def_cfa_register 7
 5281 0006 7860     		str	r0, [r7, #4]
 981:sign.c        **** 
 982:sign.c        **** 	static const uint32_t dist[] = {
 983:sign.c        **** 		10745844u,  3068844u,  3741698u,
 984:sign.c        **** 		 5559083u,  1580863u,  8248194u,
 985:sign.c        **** 		 2260429u, 13669192u,  2736639u,
 986:sign.c        **** 		  708981u,  4421575u, 10046180u,
 987:sign.c        **** 		  169348u,  7122675u,  4136815u,
 988:sign.c        **** 		   30538u, 13063405u,  7650655u,
 989:sign.c        **** 		    4132u, 14505003u,  7826148u,
 990:sign.c        **** 		     417u, 16768101u, 11363290u,
 991:sign.c        **** 		      31u,  8444042u,  8086568u,
 992:sign.c        **** 		       1u, 12844466u,   265321u,
 993:sign.c        **** 		       0u,  1232676u, 13644283u,
 994:sign.c        **** 		       0u,    38047u,  9111839u,
 995:sign.c        **** 		       0u,      870u,  6138264u,
 996:sign.c        **** 		       0u,       14u, 12545723u,
 997:sign.c        **** 		       0u,        0u,  3104126u,
 998:sign.c        **** 		       0u,        0u,    28824u,
 999:sign.c        **** 		       0u,        0u,      198u,
1000:sign.c        **** 		       0u,        0u,        1u
1001:sign.c        **** 	};
1002:sign.c        **** 
1003:sign.c        **** 	uint32_t v0, v1, v2, hi;
1004:sign.c        **** 	uint64_t lo;
1005:sign.c        **** 	size_t u;
1006:sign.c        **** 	int z;
1007:sign.c        **** 
1008:sign.c        **** 	/*
1009:sign.c        **** 	 * Get a random 72-bit value, into three 24-bit limbs v0..v2.
1010:sign.c        **** 	 */
1011:sign.c        **** 	lo = prng_get_u64(p);
 5282              		.loc 3 1011 7
 5283 0008 7868     		ldr	r0, [r7, #4]
 5284 000a FFF7FEFF 		bl	prng_get_u64
 5285 000e C7E90A01 		strd	r0, [r7, #40]
1012:sign.c        **** 	hi = prng_get_u8(p);
 5286              		.loc 3 1012 7
 5287 0012 7868     		ldr	r0, [r7, #4]
 5288 0014 FFF7FEFF 		bl	prng_get_u8
 5289 0018 7862     		str	r0, [r7, #36]
1013:sign.c        **** 	v0 = (uint32_t)lo & 0xFFFFFF;
 5290              		.loc 3 1013 7
 5291 001a BB6A     		ldr	r3, [r7, #40]
 5292              		.loc 3 1013 5
 5293 001c 23F07F43 		bic	r3, r3, #-16777216
 5294 0020 3B62     		str	r3, [r7, #32]
1014:sign.c        **** 	v1 = (uint32_t)(lo >> 24) & 0xFFFFFF;
 5295              		.loc 3 1014 21
 5296 0022 D7E90A01 		ldrd	r0, [r7, #40]
 5297 0026 4FF00002 		mov	r2, #0
 5298 002a 4FF00003 		mov	r3, #0
 5299 002e 020E     		lsrs	r2, r0, #24
 5300 0030 42EA0122 		orr	r2, r2, r1, lsl #8
 5301 0034 0B0E     		lsrs	r3, r1, #24
 5302              		.loc 3 1014 7
 5303 0036 1346     		mov	r3, r2
 5304              		.loc 3 1014 5
 5305 0038 23F07F43 		bic	r3, r3, #-16777216
 5306 003c FB61     		str	r3, [r7, #28]
1015:sign.c        **** 	v2 = (uint32_t)(lo >> 48) | (hi << 16);
 5307              		.loc 3 1015 21
 5308 003e D7E90A01 		ldrd	r0, [r7, #40]
 5309 0042 4FF00002 		mov	r2, #0
 5310 0046 4FF00003 		mov	r3, #0
 5311 004a 0A0C     		lsrs	r2, r1, #16
 5312 004c 0023     		movs	r3, #0
 5313              		.loc 3 1015 34
 5314 004e 7B6A     		ldr	r3, [r7, #36]
 5315 0050 1B04     		lsls	r3, r3, #16
 5316              		.loc 3 1015 5
 5317 0052 1343     		orrs	r3, r3, r2
 5318 0054 BB61     		str	r3, [r7, #24]
1016:sign.c        **** 
1017:sign.c        **** 	/*
1018:sign.c        **** 	 * Sampled value is z, such that v0..v2 is lower than the first
1019:sign.c        **** 	 * z elements of the table.
1020:sign.c        **** 	 */
1021:sign.c        **** 	z = 0;
 5319              		.loc 3 1021 4
 5320 0056 0023     		movs	r3, #0
 5321 0058 3B63     		str	r3, [r7, #48]
1022:sign.c        **** 	for (u = 0; u < (sizeof dist) / sizeof(dist[0]); u += 3) {
 5322              		.loc 3 1022 9
 5323 005a 0023     		movs	r3, #0
 5324 005c 7B63     		str	r3, [r7, #52]
 5325              		.loc 3 1022 2
 5326 005e 2AE0     		b	.L92
 5327              	.L93:
 5328              	.LBB7:
1023:sign.c        **** 		uint32_t w0, w1, w2, cc;
1024:sign.c        **** 
1025:sign.c        **** 		w0 = dist[u + 2];
 5329              		.loc 3 1025 15 discriminator 3
 5330 0060 7B6B     		ldr	r3, [r7, #52]
 5331 0062 0233     		adds	r3, r3, #2
 5332              		.loc 3 1025 6 discriminator 3
 5333 0064 184A     		ldr	r2, .L95
 5334 0066 52F82330 		ldr	r3, [r2, r3, lsl #2]
 5335 006a 7B61     		str	r3, [r7, #20]
1026:sign.c        **** 		w1 = dist[u + 1];
 5336              		.loc 3 1026 15 discriminator 3
 5337 006c 7B6B     		ldr	r3, [r7, #52]
 5338 006e 0133     		adds	r3, r3, #1
 5339              		.loc 3 1026 6 discriminator 3
 5340 0070 154A     		ldr	r2, .L95
 5341 0072 52F82330 		ldr	r3, [r2, r3, lsl #2]
 5342 0076 3B61     		str	r3, [r7, #16]
1027:sign.c        **** 		w2 = dist[u + 0];
 5343              		.loc 3 1027 6 discriminator 3
 5344 0078 134A     		ldr	r2, .L95
 5345 007a 7B6B     		ldr	r3, [r7, #52]
 5346 007c 52F82330 		ldr	r3, [r2, r3, lsl #2]
 5347 0080 FB60     		str	r3, [r7, #12]
1028:sign.c        **** 		cc = (v0 - w0) >> 31;
 5348              		.loc 3 1028 12 discriminator 3
 5349 0082 3A6A     		ldr	r2, [r7, #32]
 5350 0084 7B69     		ldr	r3, [r7, #20]
 5351 0086 D31A     		subs	r3, r2, r3
 5352              		.loc 3 1028 6 discriminator 3
 5353 0088 DB0F     		lsrs	r3, r3, #31
 5354 008a BB60     		str	r3, [r7, #8]
1029:sign.c        **** 		cc = (v1 - w1 - cc) >> 31;
 5355              		.loc 3 1029 12 discriminator 3
 5356 008c FA69     		ldr	r2, [r7, #28]
 5357 008e 3B69     		ldr	r3, [r7, #16]
 5358 0090 D21A     		subs	r2, r2, r3
 5359              		.loc 3 1029 17 discriminator 3
 5360 0092 BB68     		ldr	r3, [r7, #8]
 5361 0094 D31A     		subs	r3, r2, r3
 5362              		.loc 3 1029 6 discriminator 3
 5363 0096 DB0F     		lsrs	r3, r3, #31
 5364 0098 BB60     		str	r3, [r7, #8]
1030:sign.c        **** 		cc = (v2 - w2 - cc) >> 31;
 5365              		.loc 3 1030 12 discriminator 3
 5366 009a BA69     		ldr	r2, [r7, #24]
 5367 009c FB68     		ldr	r3, [r7, #12]
 5368 009e D21A     		subs	r2, r2, r3
 5369              		.loc 3 1030 17 discriminator 3
 5370 00a0 BB68     		ldr	r3, [r7, #8]
 5371 00a2 D31A     		subs	r3, r2, r3
 5372              		.loc 3 1030 6 discriminator 3
 5373 00a4 DB0F     		lsrs	r3, r3, #31
 5374 00a6 BB60     		str	r3, [r7, #8]
1031:sign.c        **** 		z += (int)cc;
 5375              		.loc 3 1031 8 discriminator 3
 5376 00a8 BB68     		ldr	r3, [r7, #8]
 5377              		.loc 3 1031 5 discriminator 3
 5378 00aa 3A6B     		ldr	r2, [r7, #48]
 5379 00ac 1344     		add	r3, r3, r2
 5380 00ae 3B63     		str	r3, [r7, #48]
 5381              	.LBE7:
1022:sign.c        **** 		uint32_t w0, w1, w2, cc;
 5382              		.loc 3 1022 53 discriminator 3
 5383 00b0 7B6B     		ldr	r3, [r7, #52]
 5384 00b2 0333     		adds	r3, r3, #3
 5385 00b4 7B63     		str	r3, [r7, #52]
 5386              	.L92:
1022:sign.c        **** 		uint32_t w0, w1, w2, cc;
 5387              		.loc 3 1022 2 discriminator 1
 5388 00b6 7B6B     		ldr	r3, [r7, #52]
 5389 00b8 352B     		cmp	r3, #53
 5390 00ba D1D9     		bls	.L93
1032:sign.c        **** 	}
1033:sign.c        **** 	return z;
 5391              		.loc 3 1033 9
 5392 00bc 3B6B     		ldr	r3, [r7, #48]
1034:sign.c        **** 
1035:sign.c        **** }
 5393              		.loc 3 1035 1
 5394 00be 1846     		mov	r0, r3
 5395 00c0 3837     		adds	r7, r7, #56
 5396              	.LCFI154:
 5397              		.cfi_def_cfa_offset 8
 5398 00c2 BD46     		mov	sp, r7
 5399              	.LCFI155:
 5400              		.cfi_def_cfa_register 13
 5401              		@ sp needed
 5402 00c4 80BD     		pop	{r7, pc}
 5403              	.L96:
 5404 00c6 00BF     		.align	2
 5405              	.L95:
 5406 00c8 40010000 		.word	dist.0
 5407              		.cfi_endproc
 5408              	.LFE33:
 5410              		.section	.text.BerExp,"ax",%progbits
 5411              		.align	1
 5412              		.syntax unified
 5413              		.thumb
 5414              		.thumb_func
 5415              		.fpu softvfp
 5417              	BerExp:
 5418              	.LFB34:
1036:sign.c        **** 
1037:sign.c        **** /*
1038:sign.c        ****  * Sample a bit with probability exp(-x) for some x >= 0.
1039:sign.c        ****  */
1040:sign.c        **** static int
1041:sign.c        **** BerExp(prng *p, fpr x, fpr ccs)
1042:sign.c        **** {
 5419              		.loc 3 1042 1
 5420              		.cfi_startproc
 5421              		@ args = 8, pretend = 0, frame = 72
 5422              		@ frame_needed = 1, uses_anonymous_args = 0
 5423 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 5424              	.LCFI156:
 5425              		.cfi_def_cfa_offset 32
 5426              		.cfi_offset 4, -32
 5427              		.cfi_offset 5, -28
 5428              		.cfi_offset 7, -24
 5429              		.cfi_offset 8, -20
 5430              		.cfi_offset 9, -16
 5431              		.cfi_offset 10, -12
 5432              		.cfi_offset 11, -8
 5433              		.cfi_offset 14, -4
 5434 0004 92B0     		sub	sp, sp, #72
 5435              	.LCFI157:
 5436              		.cfi_def_cfa_offset 104
 5437 0006 00AF     		add	r7, sp, #0
 5438              	.LCFI158:
 5439              		.cfi_def_cfa_register 7
 5440 0008 F861     		str	r0, [r7, #28]
 5441 000a C7E90423 		strd	r2, [r7, #16]
1043:sign.c        **** 	int s, i;
1044:sign.c        **** 	fpr r;
1045:sign.c        **** 	uint32_t sw, w;
1046:sign.c        **** 	uint64_t z;
1047:sign.c        **** 
1048:sign.c        **** 	/*
1049:sign.c        **** 	 * Reduce x modulo log(2): x = s*log(2) + r, with s an integer,
1050:sign.c        **** 	 * and 0 <= r < log(2). Since x >= 0, we can use fpr_trunc().
1051:sign.c        **** 	 */
1052:sign.c        **** 	s = (int)fpr_trunc(fpr_mul(x, fpr_inv_log2));
 5442              		.loc 3 1052 11
 5443 000e 42A3     		adr	r3, .L101
 5444 0010 D3E90023 		ldrd	r2, [r3]
 5445 0014 D7E90401 		ldrd	r0, [r7, #16]
 5446 0018 FFF7FEFF 		bl	falcon_inner_fpr_mul
 5447 001c 0246     		mov	r2, r0
 5448 001e 0B46     		mov	r3, r1
 5449 0020 1046     		mov	r0, r2
 5450 0022 1946     		mov	r1, r3
 5451 0024 FFF7FEFF 		bl	fpr_trunc
 5452 0028 0246     		mov	r2, r0
 5453 002a 0B46     		mov	r3, r1
 5454              		.loc 3 1052 4
 5455 002c 1346     		mov	r3, r2
 5456 002e 3B64     		str	r3, [r7, #64]
1053:sign.c        **** 	r = fpr_sub(x, fpr_mul(fpr_of(s), fpr_log2));
 5457              		.loc 3 1053 6
 5458 0030 3B6C     		ldr	r3, [r7, #64]
 5459 0032 DA17     		asrs	r2, r3, #31
 5460 0034 BB60     		str	r3, [r7, #8]
 5461 0036 FA60     		str	r2, [r7, #12]
 5462 0038 D7E90201 		ldrd	r0, [r7, #8]
 5463 003c FFF7FEFF 		bl	fpr_of
 5464 0040 37A3     		adr	r3, .L101+8
 5465 0042 D3E90023 		ldrd	r2, [r3]
 5466 0046 FFF7FEFF 		bl	falcon_inner_fpr_mul
 5467 004a 0246     		mov	r2, r0
 5468 004c 0B46     		mov	r3, r1
 5469 004e D7E90401 		ldrd	r0, [r7, #16]
 5470 0052 FFF7FEFF 		bl	fpr_sub
 5471 0056 C7E90E01 		strd	r0, [r7, #56]
1054:sign.c        **** 
1055:sign.c        **** 	/*
1056:sign.c        **** 	 * It may happen (quite rarely) that s >= 64; if sigma = 1.2
1057:sign.c        **** 	 * (the minimum value for sigma), r = 0 and b = 1, then we get
1058:sign.c        **** 	 * s >= 64 if the half-Gaussian produced a z >= 13, which happens
1059:sign.c        **** 	 * with probability about 0.000000000230383991, which is
1060:sign.c        **** 	 * approximatively equal to 2^(-32). In any case, if s >= 64,
1061:sign.c        **** 	 * then BerExp will be non-zero with probability less than
1062:sign.c        **** 	 * 2^(-64), so we can simply saturate s at 63.
1063:sign.c        **** 	 */
1064:sign.c        **** 	sw = (uint32_t)s;
 5472              		.loc 3 1064 5
 5473 005a 3B6C     		ldr	r3, [r7, #64]
 5474 005c 7B63     		str	r3, [r7, #52]
1065:sign.c        **** 	sw ^= (sw ^ 63) & -((63 - sw) >> 31);
 5475              		.loc 3 1065 12
 5476 005e 7B6B     		ldr	r3, [r7, #52]
 5477 0060 83F03F03 		eor	r3, r3, #63
 5478              		.loc 3 1065 26
 5479 0064 7A6B     		ldr	r2, [r7, #52]
 5480 0066 C2F13F02 		rsb	r2, r2, #63
 5481              		.loc 3 1065 20
 5482 006a D217     		asrs	r2, r2, #31
 5483              		.loc 3 1065 18
 5484 006c 1340     		ands	r3, r3, r2
 5485              		.loc 3 1065 5
 5486 006e 7A6B     		ldr	r2, [r7, #52]
 5487 0070 5340     		eors	r3, r3, r2
 5488 0072 7B63     		str	r3, [r7, #52]
1066:sign.c        **** 	s = (int)sw;
 5489              		.loc 3 1066 4
 5490 0074 7B6B     		ldr	r3, [r7, #52]
 5491 0076 3B64     		str	r3, [r7, #64]
1067:sign.c        **** 
1068:sign.c        **** 	/*
1069:sign.c        **** 	 * Compute exp(-r); we know that 0 <= r < log(2) at this point, so
1070:sign.c        **** 	 * we can use fpr_expm_p63(), which yields a result scaled to 2^63.
1071:sign.c        **** 	 * We scale it up to 2^64, then right-shift it by s bits because
1072:sign.c        **** 	 * we really want exp(-x) = 2^(-s)*exp(-r).
1073:sign.c        **** 	 *
1074:sign.c        **** 	 * The "-1" operation makes sure that the value fits on 64 bits
1075:sign.c        **** 	 * (i.e. if r = 0, we may get 2^64, and we prefer 2^64-1 in that
1076:sign.c        **** 	 * case). The bias is negligible since fpr_expm_p63() only computes
1077:sign.c        **** 	 * with 51 bits of precision or so.
1078:sign.c        **** 	 */
1079:sign.c        **** 	z = ((fpr_expm_p63(r, ccs) << 1) - 1) >> s;
 5492              		.loc 3 1079 8
 5493 0078 D7E91A23 		ldrd	r2, [r7, #104]
 5494 007c D7E90E01 		ldrd	r0, [r7, #56]
 5495 0080 FFF7FEFF 		bl	falcon_inner_fpr_expm_p63
 5496 0084 0246     		mov	r2, r0
 5497 0086 0B46     		mov	r3, r1
 5498              		.loc 3 1079 29
 5499 0088 9118     		adds	r1, r2, r2
 5500 008a 3960     		str	r1, [r7]
 5501 008c 5B41     		adcs	r3, r3, r3
 5502 008e 7B60     		str	r3, [r7, #4]
 5503 0090 D7E90023 		ldrd	r2, [r7]
 5504              		.loc 3 1079 35
 5505 0094 12F1FF3A 		adds	r10, r2, #-1
 5506 0098 43F1FF3B 		adc	fp, r3, #-1
 5507              		.loc 3 1079 4
 5508 009c 3B6C     		ldr	r3, [r7, #64]
 5509 009e C3F12001 		rsb	r1, r3, #32
 5510 00a2 A3F12002 		sub	r2, r3, #32
 5511 00a6 2AFA03F4 		lsr	r4, r10, r3
 5512 00aa 0BFA01F1 		lsl	r1, fp, r1
 5513 00ae 0C43     		orrs	r4, r4, r1
 5514 00b0 2BFA02F2 		lsr	r2, fp, r2
 5515 00b4 1443     		orrs	r4, r4, r2
 5516 00b6 2BFA03F5 		lsr	r5, fp, r3
 5517 00ba C7E90A45 		strd	r4, [r7, #40]
1080:sign.c        **** 
1081:sign.c        **** 	/*
1082:sign.c        **** 	 * Sample a bit with probability exp(-x). Since x = s*log(2) + r,
1083:sign.c        **** 	 * exp(-x) = 2^-s * exp(-r), we compare lazily exp(-x) with the
1084:sign.c        **** 	 * PRNG output to limit its consumption, the sign of the difference
1085:sign.c        **** 	 * yields the expected result.
1086:sign.c        **** 	 */
1087:sign.c        **** 	i = 64;
 5518              		.loc 3 1087 4
 5519 00be 4023     		movs	r3, #64
 5520 00c0 7B64     		str	r3, [r7, #68]
 5521              	.L99:
1088:sign.c        **** 	do {
1089:sign.c        **** 		i -= 8;
 5522              		.loc 3 1089 5 discriminator 2
 5523 00c2 7B6C     		ldr	r3, [r7, #68]
 5524 00c4 083B     		subs	r3, r3, #8
 5525 00c6 7B64     		str	r3, [r7, #68]
1090:sign.c        **** 		w = prng_get_u8(p) - ((uint32_t)(z >> i) & 0xFF);
 5526              		.loc 3 1090 7 discriminator 2
 5527 00c8 F869     		ldr	r0, [r7, #28]
 5528 00ca FFF7FEFF 		bl	prng_get_u8
 5529 00ce 0546     		mov	r5, r0
 5530              		.loc 3 1090 38 discriminator 2
 5531 00d0 D7E90A23 		ldrd	r2, [r7, #40]
 5532 00d4 796C     		ldr	r1, [r7, #68]
 5533 00d6 C1F12004 		rsb	r4, r1, #32
 5534 00da A1F12000 		sub	r0, r1, #32
 5535 00de 22FA01F8 		lsr	r8, r2, r1
 5536 00e2 03FA04F4 		lsl	r4, r3, r4
 5537 00e6 48EA0408 		orr	r8, r8, r4
 5538 00ea 23FA00F0 		lsr	r0, r3, r0
 5539 00ee 48EA0008 		orr	r8, r8, r0
 5540 00f2 23FA01F9 		lsr	r9, r3, r1
 5541              		.loc 3 1090 25 discriminator 2
 5542 00f6 4346     		mov	r3, r8
 5543              		.loc 3 1090 44 discriminator 2
 5544 00f8 DBB2     		uxtb	r3, r3
 5545              		.loc 3 1090 5 discriminator 2
 5546 00fa EB1A     		subs	r3, r5, r3
 5547 00fc 7B62     		str	r3, [r7, #36]
1091:sign.c        **** 	} while (!w && i > 0);
 5548              		.loc 3 1091 2 discriminator 2
 5549 00fe 7B6A     		ldr	r3, [r7, #36]
 5550 0100 002B     		cmp	r3, #0
 5551 0102 02D1     		bne	.L98
 5552              		.loc 3 1091 14 discriminator 1
 5553 0104 7B6C     		ldr	r3, [r7, #68]
 5554 0106 002B     		cmp	r3, #0
 5555 0108 DBDC     		bgt	.L99
 5556              	.L98:
1092:sign.c        **** 	return (int)(w >> 31);
 5557              		.loc 3 1092 17
 5558 010a 7B6A     		ldr	r3, [r7, #36]
 5559 010c DB0F     		lsrs	r3, r3, #31
1093:sign.c        **** }
 5560              		.loc 3 1093 1
 5561 010e 1846     		mov	r0, r3
 5562 0110 4837     		adds	r7, r7, #72
 5563              	.LCFI159:
 5564              		.cfi_def_cfa_offset 32
 5565 0112 BD46     		mov	sp, r7
 5566              	.LCFI160:
 5567              		.cfi_def_cfa_register 13
 5568              		@ sp needed
 5569 0114 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 5570              	.L102:
 5571              		.align	3
 5572              	.L101:
 5573 0118 FE822B65 		.word	1697350398
 5574 011c 4715F73F 		.word	1073157447
 5575 0120 EF39FAFE 		.word	-17155601
 5576 0124 422EE63F 		.word	1072049730
 5577              		.cfi_endproc
 5578              	.LFE34:
 5580              		.section	.text.falcon_inner_sampler,"ax",%progbits
 5581              		.align	1
 5582              		.global	falcon_inner_sampler
 5583              		.syntax unified
 5584              		.thumb
 5585              		.thumb_func
 5586              		.fpu softvfp
 5588              	falcon_inner_sampler:
 5589              	.LFB35:
1094:sign.c        **** 
1095:sign.c        **** /*
1096:sign.c        ****  * The sampler produces a random integer that follows a discrete Gaussian
1097:sign.c        ****  * distribution, centered on mu, and with standard deviation sigma. The
1098:sign.c        ****  * provided parameter isigma is equal to 1/sigma.
1099:sign.c        ****  *
1100:sign.c        ****  * The value of sigma MUST lie between 1 and 2 (i.e. isigma lies between
1101:sign.c        ****  * 0.5 and 1); in Falcon, sigma should always be between 1.2 and 1.9.
1102:sign.c        ****  */
1103:sign.c        **** int
1104:sign.c        **** Zf(sampler)(void *ctx, fpr mu, fpr isigma)
1105:sign.c        **** {
 5590              		.loc 3 1105 1
 5591              		.cfi_startproc
 5592              		@ args = 8, pretend = 0, frame = 72
 5593              		@ frame_needed = 1, uses_anonymous_args = 0
 5594 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 5595              	.LCFI161:
 5596              		.cfi_def_cfa_offset 32
 5597              		.cfi_offset 4, -32
 5598              		.cfi_offset 5, -28
 5599              		.cfi_offset 7, -24
 5600              		.cfi_offset 8, -20
 5601              		.cfi_offset 9, -16
 5602              		.cfi_offset 10, -12
 5603              		.cfi_offset 11, -8
 5604              		.cfi_offset 14, -4
 5605 0004 94B0     		sub	sp, sp, #80
 5606              	.LCFI162:
 5607              		.cfi_def_cfa_offset 112
 5608 0006 02AF     		add	r7, sp, #8
 5609              	.LCFI163:
 5610              		.cfi_def_cfa 7, 104
 5611 0008 F860     		str	r0, [r7, #12]
 5612 000a C7E90023 		strd	r2, [r7]
1106:sign.c        **** 	sampler_context *spc;
1107:sign.c        **** 	int s;
1108:sign.c        **** 	fpr r, dss, ccs;
1109:sign.c        **** 
1110:sign.c        **** 	spc = ctx;
 5613              		.loc 3 1110 6
 5614 000e FB68     		ldr	r3, [r7, #12]
 5615 0010 7B64     		str	r3, [r7, #68]
1111:sign.c        **** 
1112:sign.c        **** 	/*
1113:sign.c        **** 	 * Center is mu. We compute mu = s + r where s is an integer
1114:sign.c        **** 	 * and 0 <= r < 1.
1115:sign.c        **** 	 */
1116:sign.c        **** 	s = (int)fpr_floor(mu);
 5616              		.loc 3 1116 11
 5617 0012 D7E90001 		ldrd	r0, [r7]
 5618 0016 FFF7FEFF 		bl	fpr_floor
 5619 001a 0246     		mov	r2, r0
 5620 001c 0B46     		mov	r3, r1
 5621              		.loc 3 1116 4
 5622 001e 1346     		mov	r3, r2
 5623 0020 3B64     		str	r3, [r7, #64]
1117:sign.c        **** 	r = fpr_sub(mu, fpr_of(s));
 5624              		.loc 3 1117 6
 5625 0022 3B6C     		ldr	r3, [r7, #64]
 5626 0024 DA17     		asrs	r2, r3, #31
 5627 0026 9A46     		mov	r10, r3
 5628 0028 9346     		mov	fp, r2
 5629 002a 5046     		mov	r0, r10
 5630 002c 5946     		mov	r1, fp
 5631 002e FFF7FEFF 		bl	fpr_of
 5632 0032 0246     		mov	r2, r0
 5633 0034 0B46     		mov	r3, r1
 5634 0036 D7E90001 		ldrd	r0, [r7]
 5635 003a FFF7FEFF 		bl	fpr_sub
 5636 003e C7E90E01 		strd	r0, [r7, #56]
1118:sign.c        **** 
1119:sign.c        **** 	/*
1120:sign.c        **** 	 * dss = 1/(2*sigma^2) = 0.5*(isigma^2).
1121:sign.c        **** 	 */
1122:sign.c        **** 	dss = fpr_half(fpr_sqr(isigma));
 5637              		.loc 3 1122 8
 5638 0042 D7E91A01 		ldrd	r0, [r7, #104]
 5639 0046 FFF7FEFF 		bl	fpr_sqr
 5640 004a 0246     		mov	r2, r0
 5641 004c 0B46     		mov	r3, r1
 5642 004e 1046     		mov	r0, r2
 5643 0050 1946     		mov	r1, r3
 5644 0052 FFF7FEFF 		bl	fpr_half
 5645 0056 C7E90C01 		strd	r0, [r7, #48]
1123:sign.c        **** 
1124:sign.c        **** 	/*
1125:sign.c        **** 	 * ccs = sigma_min / sigma = sigma_min * isigma.
1126:sign.c        **** 	 */
1127:sign.c        **** 	ccs = fpr_mul(isigma, spc->sigma_min);
 5646              		.loc 3 1127 8
 5647 005a 7B6C     		ldr	r3, [r7, #68]
 5648 005c D3E9C423 		ldrd	r2, [r3, #784]
 5649 0060 D7E91A01 		ldrd	r0, [r7, #104]
 5650 0064 FFF7FEFF 		bl	falcon_inner_fpr_mul
 5651 0068 C7E90A01 		strd	r0, [r7, #40]
 5652              	.L106:
 5653              	.LBB8:
1128:sign.c        **** 
1129:sign.c        **** 	/*
1130:sign.c        **** 	 * We now need to sample on center r.
1131:sign.c        **** 	 */
1132:sign.c        **** 	for (;;) {
1133:sign.c        **** 		int z0, z, b;
1134:sign.c        **** 		fpr x;
1135:sign.c        **** 
1136:sign.c        **** 		/*
1137:sign.c        **** 		 * Sample z for a Gaussian distribution. Then get a
1138:sign.c        **** 		 * random bit b to turn the sampling into a bimodal
1139:sign.c        **** 		 * distribution: if b = 1, we use z+1, otherwise we
1140:sign.c        **** 		 * use -z. We thus have two situations:
1141:sign.c        **** 		 *
1142:sign.c        **** 		 *  - b = 1: z >= 1 and sampled against a Gaussian
1143:sign.c        **** 		 *    centered on 1.
1144:sign.c        **** 		 *  - b = 0: z <= 0 and sampled against a Gaussian
1145:sign.c        **** 		 *    centered on 0.
1146:sign.c        **** 		 */
1147:sign.c        **** 		z0 = Zf(gaussian0_sampler)(&spc->p);
 5654              		.loc 3 1147 8
 5655 006c 7B6C     		ldr	r3, [r7, #68]
 5656 006e 1846     		mov	r0, r3
 5657 0070 FFF7FEFF 		bl	falcon_inner_gaussian0_sampler
 5658 0074 7862     		str	r0, [r7, #36]
1148:sign.c        **** 		b = (int)prng_get_u8(&spc->p) & 1;
 5659              		.loc 3 1148 12
 5660 0076 7B6C     		ldr	r3, [r7, #68]
 5661 0078 1846     		mov	r0, r3
 5662 007a FFF7FEFF 		bl	prng_get_u8
 5663 007e 0346     		mov	r3, r0
 5664              		.loc 3 1148 5
 5665 0080 03F00103 		and	r3, r3, #1
 5666 0084 3B62     		str	r3, [r7, #32]
1149:sign.c        **** 		z = b + ((b << 1) - 1) * z0;
 5667              		.loc 3 1149 15
 5668 0086 3B6A     		ldr	r3, [r7, #32]
 5669 0088 5B00     		lsls	r3, r3, #1
 5670              		.loc 3 1149 21
 5671 008a 013B     		subs	r3, r3, #1
 5672              		.loc 3 1149 26
 5673 008c 7A6A     		ldr	r2, [r7, #36]
 5674 008e 02FB03F3 		mul	r3, r2, r3
 5675              		.loc 3 1149 5
 5676 0092 3A6A     		ldr	r2, [r7, #32]
 5677 0094 1344     		add	r3, r3, r2
 5678 0096 FB61     		str	r3, [r7, #28]
1150:sign.c        **** 
1151:sign.c        **** 		/*
1152:sign.c        **** 		 * Rejection sampling. We want a Gaussian centered on r;
1153:sign.c        **** 		 * but we sampled against a Gaussian centered on b (0 or
1154:sign.c        **** 		 * 1). But we know that z is always in the range where
1155:sign.c        **** 		 * our sampling distribution is greater than the Gaussian
1156:sign.c        **** 		 * distribution, so rejection works.
1157:sign.c        **** 		 *
1158:sign.c        **** 		 * We got z with distribution:
1159:sign.c        **** 		 *    G(z) = exp(-((z-b)^2)/(2*sigma0^2))
1160:sign.c        **** 		 * We target distribution:
1161:sign.c        **** 		 *    S(z) = exp(-((z-r)^2)/(2*sigma^2))
1162:sign.c        **** 		 * Rejection sampling works by keeping the value z with
1163:sign.c        **** 		 * probability S(z)/G(z), and starting again otherwise.
1164:sign.c        **** 		 * This requires S(z) <= G(z), which is the case here.
1165:sign.c        **** 		 * Thus, we simply need to keep our z with probability:
1166:sign.c        **** 		 *    P = exp(-x)
1167:sign.c        **** 		 * where:
1168:sign.c        **** 		 *    x = ((z-r)^2)/(2*sigma^2) - ((z-b)^2)/(2*sigma0^2)
1169:sign.c        **** 		 *
1170:sign.c        **** 		 * Here, we scale up the Bernouilli distribution, which
1171:sign.c        **** 		 * makes rejection more probable, but makes rejection
1172:sign.c        **** 		 * rate sufficiently decorrelated from the Gaussian
1173:sign.c        **** 		 * center and standard deviation that the whole sampler
1174:sign.c        **** 		 * can be said to be constant-time.
1175:sign.c        **** 		 */
1176:sign.c        **** 		x = fpr_mul(fpr_sqr(fpr_sub(fpr_of(z), r)), dss);
 5679              		.loc 3 1176 7
 5680 0098 FB69     		ldr	r3, [r7, #28]
 5681 009a DA17     		asrs	r2, r3, #31
 5682 009c 1C46     		mov	r4, r3
 5683 009e 1546     		mov	r5, r2
 5684 00a0 2046     		mov	r0, r4
 5685 00a2 2946     		mov	r1, r5
 5686 00a4 FFF7FEFF 		bl	fpr_of
 5687 00a8 D7E90E23 		ldrd	r2, [r7, #56]
 5688 00ac FFF7FEFF 		bl	fpr_sub
 5689 00b0 0246     		mov	r2, r0
 5690 00b2 0B46     		mov	r3, r1
 5691 00b4 1046     		mov	r0, r2
 5692 00b6 1946     		mov	r1, r3
 5693 00b8 FFF7FEFF 		bl	fpr_sqr
 5694 00bc D7E90C23 		ldrd	r2, [r7, #48]
 5695 00c0 FFF7FEFF 		bl	falcon_inner_fpr_mul
 5696 00c4 C7E90401 		strd	r0, [r7, #16]
1177:sign.c        **** 		x = fpr_sub(x, fpr_mul(fpr_of(z0 * z0), fpr_inv_2sqrsigma0));
 5697              		.loc 3 1177 36
 5698 00c8 7B6A     		ldr	r3, [r7, #36]
 5699 00ca 03FB03F3 		mul	r3, r3, r3
 5700              		.loc 3 1177 7
 5701 00ce DA17     		asrs	r2, r3, #31
 5702 00d0 9846     		mov	r8, r3
 5703 00d2 9146     		mov	r9, r2
 5704 00d4 4046     		mov	r0, r8
 5705 00d6 4946     		mov	r1, r9
 5706 00d8 FFF7FEFF 		bl	fpr_of
 5707 00dc 10A3     		adr	r3, .L108
 5708 00de D3E90023 		ldrd	r2, [r3]
 5709 00e2 FFF7FEFF 		bl	falcon_inner_fpr_mul
 5710 00e6 0246     		mov	r2, r0
 5711 00e8 0B46     		mov	r3, r1
 5712 00ea D7E90401 		ldrd	r0, [r7, #16]
 5713 00ee FFF7FEFF 		bl	fpr_sub
 5714 00f2 C7E90401 		strd	r0, [r7, #16]
1178:sign.c        **** 		if (BerExp(&spc->p, x, ccs)) {
 5715              		.loc 3 1178 7
 5716 00f6 796C     		ldr	r1, [r7, #68]
 5717 00f8 D7E90A23 		ldrd	r2, [r7, #40]
 5718 00fc CDE90023 		strd	r2, [sp]
 5719 0100 D7E90423 		ldrd	r2, [r7, #16]
 5720 0104 0846     		mov	r0, r1
 5721 0106 FFF7FEFF 		bl	BerExp
 5722 010a 0346     		mov	r3, r0
 5723              		.loc 3 1178 6
 5724 010c 002B     		cmp	r3, #0
 5725 010e ADD0     		beq	.L106
1179:sign.c        **** 			/*
1180:sign.c        **** 			 * Rejection sampling was centered on r, but the
1181:sign.c        **** 			 * actual center is mu = s + r.
1182:sign.c        **** 			 */
1183:sign.c        **** 			return s + z;
 5726              		.loc 3 1183 13
 5727 0110 3A6C     		ldr	r2, [r7, #64]
 5728 0112 FB69     		ldr	r3, [r7, #28]
 5729 0114 1344     		add	r3, r3, r2
 5730              	.LBE8:
1184:sign.c        **** 		}
1185:sign.c        **** 	}
1186:sign.c        **** }
 5731              		.loc 3 1186 1
 5732 0116 1846     		mov	r0, r3
 5733 0118 4837     		adds	r7, r7, #72
 5734              	.LCFI164:
 5735              		.cfi_def_cfa_offset 32
 5736 011a BD46     		mov	sp, r7
 5737              	.LCFI165:
 5738              		.cfi_def_cfa_register 13
 5739              		@ sp needed
 5740 011c BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 5741              	.L109:
 5742              		.align	3
 5743              	.L108:
 5744 0120 C2BB83C1 		.word	-1048331326
 5745 0124 8B4FC33F 		.word	1069764491
 5746              		.cfi_endproc
 5747              	.LFE35:
 5749              		.section	.text.falcon_inner_sign_tree,"ax",%progbits
 5750              		.align	1
 5751              		.global	falcon_inner_sign_tree
 5752              		.syntax unified
 5753              		.thumb
 5754              		.thumb_func
 5755              		.fpu softvfp
 5757              	falcon_inner_sign_tree:
 5758              	.LFB36:
1187:sign.c        **** 
1188:sign.c        **** /* see inner.h */
1189:sign.c        **** void
1190:sign.c        **** Zf(sign_tree)(int16_t *sig, inner_shake256_context *rng,
1191:sign.c        **** 	const fpr *restrict expanded_key,
1192:sign.c        **** 	const uint16_t *hm, unsigned logn, uint8_t *tmp)
1193:sign.c        **** {
 5759              		.loc 3 1193 1
 5760              		.cfi_startproc
 5761              		@ args = 8, pretend = 0, frame = 824
 5762              		@ frame_needed = 1, uses_anonymous_args = 0
 5763 0000 90B5     		push	{r4, r7, lr}
 5764              	.LCFI166:
 5765              		.cfi_def_cfa_offset 12
 5766              		.cfi_offset 4, -12
 5767              		.cfi_offset 7, -8
 5768              		.cfi_offset 14, -4
 5769 0002 ADF5537D 		sub	sp, sp, #844
 5770              	.LCFI167:
 5771              		.cfi_def_cfa_offset 856
 5772 0006 04AF     		add	r7, sp, #16
 5773              	.LCFI168:
 5774              		.cfi_def_cfa 7, 840
 5775 0008 07F54E74 		add	r4, r7, #824
 5776 000c A4F54B74 		sub	r4, r4, #812
 5777 0010 2060     		str	r0, [r4]
 5778 0012 07F54E70 		add	r0, r7, #824
 5779 0016 A0F54C70 		sub	r0, r0, #816
 5780 001a 0160     		str	r1, [r0]
 5781 001c 07F54E71 		add	r1, r7, #824
 5782 0020 A1F54D71 		sub	r1, r1, #820
 5783 0024 0A60     		str	r2, [r1]
 5784 0026 07F54E72 		add	r2, r7, #824
 5785 002a A2F54E72 		sub	r2, r2, #824
 5786 002e 1360     		str	r3, [r2]
1194:sign.c        **** 	fpr *ftmp;
1195:sign.c        **** 
1196:sign.c        **** 	ftmp = (fpr *)tmp;
 5787              		.loc 3 1196 7
 5788 0030 D7F84C33 		ldr	r3, [r7, #844]
 5789 0034 C7F83433 		str	r3, [r7, #820]
 5790              	.L112:
 5791              	.LBB9:
1197:sign.c        **** 	for (;;) {
1198:sign.c        **** 		/*
1199:sign.c        **** 		 * Signature produces short vectors s1 and s2. The
1200:sign.c        **** 		 * signature is acceptable only if the aggregate vector
1201:sign.c        **** 		 * s1,s2 is short; we must use the same bound as the
1202:sign.c        **** 		 * verifier.
1203:sign.c        **** 		 *
1204:sign.c        **** 		 * If the signature is acceptable, then we return only s2
1205:sign.c        **** 		 * (the verifier recomputes s1 from s2, the hashed message,
1206:sign.c        **** 		 * and the public key).
1207:sign.c        **** 		 */
1208:sign.c        **** 		sampler_context spc;
1209:sign.c        **** 		samplerZ samp;
1210:sign.c        **** 		void *samp_ctx;
1211:sign.c        **** 
1212:sign.c        **** 		/*
1213:sign.c        **** 		 * Normal sampling. We use a fast PRNG seeded from our
1214:sign.c        **** 		 * SHAKE context ('rng').
1215:sign.c        **** 		 */
1216:sign.c        **** 		spc.sigma_min = fpr_sigma_min[logn];
 5792              		.loc 3 1216 32
 5793 0038 214A     		ldr	r2, .L115
 5794 003a D7F84833 		ldr	r3, [r7, #840]
 5795 003e DB00     		lsls	r3, r3, #3
 5796 0040 1344     		add	r3, r3, r2
 5797 0042 D3E90023 		ldrd	r2, [r3]
 5798              		.loc 3 1216 17
 5799 0046 07F54E71 		add	r1, r7, #824
 5800 004a A1F54A71 		sub	r1, r1, #808
 5801 004e C1E9C423 		strd	r2, [r1, #784]
1217:sign.c        **** 		Zf(prng_init)(&spc.p, rng);
 5802              		.loc 3 1217 3
 5803 0052 07F54E73 		add	r3, r7, #824
 5804 0056 A3F54C73 		sub	r3, r3, #816
 5805 005a 07F11002 		add	r2, r7, #16
 5806 005e 1968     		ldr	r1, [r3]
 5807 0060 1046     		mov	r0, r2
 5808 0062 FFF7FEFF 		bl	falcon_inner_prng_init
1218:sign.c        **** 		samp = Zf(sampler);
 5809              		.loc 3 1218 8
 5810 0066 174B     		ldr	r3, .L115+4
 5811 0068 C7F83033 		str	r3, [r7, #816]
1219:sign.c        **** 		samp_ctx = &spc;
 5812              		.loc 3 1219 12
 5813 006c 07F11003 		add	r3, r7, #16
 5814 0070 C7F82C33 		str	r3, [r7, #812]
1220:sign.c        **** 
1221:sign.c        **** 		/*
1222:sign.c        **** 		 * Do the actual signature.
1223:sign.c        **** 		 */
1224:sign.c        **** 		if (do_sign_tree(samp, samp_ctx, sig,
 5815              		.loc 3 1224 7
 5816 0074 07F54E73 		add	r3, r7, #824
 5817 0078 A3F54D73 		sub	r3, r3, #820
 5818 007c 07F54E72 		add	r2, r7, #824
 5819 0080 A2F54B72 		sub	r2, r2, #812
 5820 0084 D7F83413 		ldr	r1, [r7, #820]
 5821 0088 0291     		str	r1, [sp, #8]
 5822 008a D7F84813 		ldr	r1, [r7, #840]
 5823 008e 0191     		str	r1, [sp, #4]
 5824 0090 07F54E71 		add	r1, r7, #824
 5825 0094 A1F54E71 		sub	r1, r1, #824
 5826 0098 0968     		ldr	r1, [r1]
 5827 009a 0091     		str	r1, [sp]
 5828 009c 1B68     		ldr	r3, [r3]
 5829 009e 1268     		ldr	r2, [r2]
 5830 00a0 D7F82C13 		ldr	r1, [r7, #812]
 5831 00a4 D7F83003 		ldr	r0, [r7, #816]
 5832 00a8 FFF7FEFF 		bl	do_sign_tree
 5833 00ac 0346     		mov	r3, r0
 5834              		.loc 3 1224 6
 5835 00ae 002B     		cmp	r3, #0
 5836 00b0 00D1     		bne	.L114
 5837              	.LBE9:
1197:sign.c        **** 		/*
 5838              		.loc 3 1197 11
 5839 00b2 C1E7     		b	.L112
 5840              	.L114:
1225:sign.c        **** 			expanded_key, hm, logn, ftmp))
1226:sign.c        **** 		{
1227:sign.c        **** 			break;
1228:sign.c        **** 		}
1229:sign.c        **** 	}
1230:sign.c        **** }
 5841              		.loc 3 1230 1
 5842 00b4 00BF     		nop
 5843 00b6 07F54F77 		add	r7, r7, #828
 5844              	.LCFI169:
 5845              		.cfi_def_cfa_offset 12
 5846 00ba BD46     		mov	sp, r7
 5847              	.LCFI170:
 5848              		.cfi_def_cfa_register 13
 5849              		@ sp needed
 5850 00bc 90BD     		pop	{r4, r7, pc}
 5851              	.L116:
 5852 00be 00BF     		.align	2
 5853              	.L115:
 5854 00c0 70000000 		.word	fpr_sigma_min
 5855 00c4 00000000 		.word	falcon_inner_sampler
 5856              		.cfi_endproc
 5857              	.LFE36:
 5859              		.section	.text.falcon_inner_sign_dyn,"ax",%progbits
 5860              		.align	1
 5861              		.global	falcon_inner_sign_dyn
 5862              		.syntax unified
 5863              		.thumb
 5864              		.thumb_func
 5865              		.fpu softvfp
 5867              	falcon_inner_sign_dyn:
 5868              	.LFB37:
1231:sign.c        **** 
1232:sign.c        **** /* see inner.h */
1233:sign.c        **** void
1234:sign.c        **** Zf(sign_dyn)(int16_t *sig, inner_shake256_context *rng,
1235:sign.c        **** 	const int8_t *restrict f, const int8_t *restrict g,
1236:sign.c        **** 	const int8_t *restrict F, const int8_t *restrict G,
1237:sign.c        **** 	const uint16_t *hm, unsigned logn, uint8_t *tmp)
1238:sign.c        **** {
 5869              		.loc 3 1238 1
 5870              		.cfi_startproc
 5871              		@ args = 20, pretend = 0, frame = 824
 5872              		@ frame_needed = 1, uses_anonymous_args = 0
 5873 0000 90B5     		push	{r4, r7, lr}
 5874              	.LCFI171:
 5875              		.cfi_def_cfa_offset 12
 5876              		.cfi_offset 4, -12
 5877              		.cfi_offset 7, -8
 5878              		.cfi_offset 14, -4
 5879 0002 ADF5557D 		sub	sp, sp, #852
 5880              	.LCFI172:
 5881              		.cfi_def_cfa_offset 864
 5882 0006 06AF     		add	r7, sp, #24
 5883              	.LCFI173:
 5884              		.cfi_def_cfa 7, 840
 5885 0008 07F54E74 		add	r4, r7, #824
 5886 000c A4F54B74 		sub	r4, r4, #812
 5887 0010 2060     		str	r0, [r4]
 5888 0012 07F54E70 		add	r0, r7, #824
 5889 0016 A0F54C70 		sub	r0, r0, #816
 5890 001a 0160     		str	r1, [r0]
 5891 001c 07F54E71 		add	r1, r7, #824
 5892 0020 A1F54D71 		sub	r1, r1, #820
 5893 0024 0A60     		str	r2, [r1]
 5894 0026 07F54E72 		add	r2, r7, #824
 5895 002a A2F54E72 		sub	r2, r2, #824
 5896 002e 1360     		str	r3, [r2]
1239:sign.c        **** 	fpr *ftmp;
1240:sign.c        **** 
1241:sign.c        **** 	ftmp = (fpr *)tmp;
 5897              		.loc 3 1241 7
 5898 0030 D7F85833 		ldr	r3, [r7, #856]
 5899 0034 C7F83433 		str	r3, [r7, #820]
 5900              	.L119:
 5901              	.LBB10:
1242:sign.c        **** 	for (;;) {
1243:sign.c        **** 		/*
1244:sign.c        **** 		 * Signature produces short vectors s1 and s2. The
1245:sign.c        **** 		 * signature is acceptable only if the aggregate vector
1246:sign.c        **** 		 * s1,s2 is short; we must use the same bound as the
1247:sign.c        **** 		 * verifier.
1248:sign.c        **** 		 *
1249:sign.c        **** 		 * If the signature is acceptable, then we return only s2
1250:sign.c        **** 		 * (the verifier recomputes s1 from s2, the hashed message,
1251:sign.c        **** 		 * and the public key).
1252:sign.c        **** 		 */
1253:sign.c        **** 		sampler_context spc;
1254:sign.c        **** 		samplerZ samp;
1255:sign.c        **** 		void *samp_ctx;
1256:sign.c        **** 
1257:sign.c        **** 		/*
1258:sign.c        **** 		 * Normal sampling. We use a fast PRNG seeded from our
1259:sign.c        **** 		 * SHAKE context ('rng').
1260:sign.c        **** 		 */
1261:sign.c        **** 		spc.sigma_min = fpr_sigma_min[logn];
 5902              		.loc 3 1261 32
 5903 0038 254A     		ldr	r2, .L122
 5904 003a D7F85433 		ldr	r3, [r7, #852]
 5905 003e DB00     		lsls	r3, r3, #3
 5906 0040 1344     		add	r3, r3, r2
 5907 0042 D3E90023 		ldrd	r2, [r3]
 5908              		.loc 3 1261 17
 5909 0046 07F54E71 		add	r1, r7, #824
 5910 004a A1F54A71 		sub	r1, r1, #808
 5911 004e C1E9C423 		strd	r2, [r1, #784]
1262:sign.c        **** 		Zf(prng_init)(&spc.p, rng); //해시
 5912              		.loc 3 1262 3
 5913 0052 07F54E73 		add	r3, r7, #824
 5914 0056 A3F54C73 		sub	r3, r3, #816
 5915 005a 07F11002 		add	r2, r7, #16
 5916 005e 1968     		ldr	r1, [r3]
 5917 0060 1046     		mov	r0, r2
 5918 0062 FFF7FEFF 		bl	falcon_inner_prng_init
1263:sign.c        **** 		samp = Zf(sampler);
 5919              		.loc 3 1263 8
 5920 0066 1B4B     		ldr	r3, .L122+4
 5921 0068 C7F83033 		str	r3, [r7, #816]
1264:sign.c        **** 		samp_ctx = &spc;
 5922              		.loc 3 1264 12
 5923 006c 07F11003 		add	r3, r7, #16
 5924 0070 C7F82C33 		str	r3, [r7, #812]
1265:sign.c        **** 
1266:sign.c        **** 		/*
1267:sign.c        **** 		 * Do the actual signature.
1268:sign.c        **** 		 */
1269:sign.c        **** 		if (do_sign_dyn(samp, samp_ctx, sig,
 5925              		.loc 3 1269 7
 5926 0074 07F54E73 		add	r3, r7, #824
 5927 0078 A3F54D73 		sub	r3, r3, #820
 5928 007c 07F54E72 		add	r2, r7, #824
 5929 0080 A2F54B72 		sub	r2, r2, #812
 5930 0084 D7F83413 		ldr	r1, [r7, #820]
 5931 0088 0591     		str	r1, [sp, #20]
 5932 008a D7F85413 		ldr	r1, [r7, #852]
 5933 008e 0491     		str	r1, [sp, #16]
 5934 0090 D7F85013 		ldr	r1, [r7, #848]
 5935 0094 0391     		str	r1, [sp, #12]
 5936 0096 D7F84C13 		ldr	r1, [r7, #844]
 5937 009a 0291     		str	r1, [sp, #8]
 5938 009c D7F84813 		ldr	r1, [r7, #840]
 5939 00a0 0191     		str	r1, [sp, #4]
 5940 00a2 07F54E71 		add	r1, r7, #824
 5941 00a6 A1F54E71 		sub	r1, r1, #824
 5942 00aa 0968     		ldr	r1, [r1]
 5943 00ac 0091     		str	r1, [sp]
 5944 00ae 1B68     		ldr	r3, [r3]
 5945 00b0 1268     		ldr	r2, [r2]
 5946 00b2 D7F82C13 		ldr	r1, [r7, #812]
 5947 00b6 D7F83003 		ldr	r0, [r7, #816]
 5948 00ba FFF7FEFF 		bl	do_sign_dyn
 5949 00be 0346     		mov	r3, r0
 5950              		.loc 3 1269 6
 5951 00c0 002B     		cmp	r3, #0
 5952 00c2 00D1     		bne	.L121
 5953              	.LBE10:
1242:sign.c        **** 		/*
 5954              		.loc 3 1242 11
 5955 00c4 B8E7     		b	.L119
 5956              	.L121:
1270:sign.c        **** 			f, g, F, G, hm, logn, ftmp))
1271:sign.c        **** 		{
1272:sign.c        **** 			break;
1273:sign.c        **** 		}
1274:sign.c        **** 	}
1275:sign.c        **** }
 5957              		.loc 3 1275 1
 5958 00c6 00BF     		nop
 5959 00c8 07F54F77 		add	r7, r7, #828
 5960              	.LCFI174:
 5961              		.cfi_def_cfa_offset 12
 5962 00cc BD46     		mov	sp, r7
 5963              	.LCFI175:
 5964              		.cfi_def_cfa_register 13
 5965              		@ sp needed
 5966 00ce 90BD     		pop	{r4, r7, pc}
 5967              	.L123:
 5968              		.align	2
 5969              	.L122:
 5970 00d0 70000000 		.word	fpr_sigma_min
 5971 00d4 00000000 		.word	falcon_inner_sampler
 5972              		.cfi_endproc
 5973              	.LFE37:
 5975              		.section	.rodata
 5976              		.align	2
 5979              	dist.0:
 5980 0140 F4F7A300 		.word	10745844
 5981 0144 ACD32E00 		.word	3068844
 5982 0148 02183900 		.word	3741698
 5983 014c 2BD35400 		.word	5559083
 5984 0150 3F1F1800 		.word	1580863
 5985 0154 82DB7D00 		.word	8248194
 5986 0158 CD7D2200 		.word	2260429
 5987 015c 4893D000 		.word	13669192
 5988 0160 FFC12900 		.word	2736639
 5989 0164 75D10A00 		.word	708981
 5990 0168 C7774300 		.word	4421575
 5991 016c E44A9900 		.word	10046180
 5992 0170 84950200 		.word	169348
 5993 0174 F3AE6C00 		.word	7122675
 5994 0178 6F1F3F00 		.word	4136815
 5995 017c 4A770000 		.word	30538
 5996 0180 ED54C700 		.word	13063405
 5997 0184 5FBD7400 		.word	7650655
 5998 0188 24100000 		.word	4132
 5999 018c 2B54DD00 		.word	14505003
 6000 0190 E46A7700 		.word	7826148
 6001 0194 A1010000 		.word	417
 6002 0198 65DCFF00 		.word	16768101
 6003 019c DA63AD00 		.word	11363290
 6004 01a0 1F000000 		.word	31
 6005 01a4 8AD88000 		.word	8444042
 6006 01a8 28647B00 		.word	8086568
 6007 01ac 01000000 		.word	1
 6008 01b0 B2FDC300 		.word	12844466
 6009 01b4 690C0400 		.word	265321
 6010 01b8 00000000 		.word	0
 6011 01bc 24CF1200 		.word	1232676
 6012 01c0 FB31D000 		.word	13644283
 6013 01c4 00000000 		.word	0
 6014 01c8 9F940000 		.word	38047
 6015 01cc 1F098B00 		.word	9111839
 6016 01d0 00000000 		.word	0
 6017 01d4 66030000 		.word	870
 6018 01d8 98A95D00 		.word	6138264
 6019 01dc 00000000 		.word	0
 6020 01e0 0E000000 		.word	14
 6021 01e4 BB6EBF00 		.word	12545723
 6022 01e8 00000000 		.word	0
 6023 01ec 00000000 		.word	0
 6024 01f0 7E5D2F00 		.word	3104126
 6025 01f4 00000000 		.word	0
 6026 01f8 00000000 		.word	0
 6027 01fc 98700000 		.word	28824
 6028 0200 00000000 		.word	0
 6029 0204 00000000 		.word	0
 6030 0208 C6000000 		.word	198
 6031 020c 00000000 		.word	0
 6032 0210 00000000 		.word	0
 6033 0214 01000000 		.word	1
 6034              		.text
 6035              	.Letext0:
 6036              		.file 4 "c:\\users\\user\\chipwhisperer5_64\\cw\\home\\portable\\armgcc\\gcc-arm-none-eabi-10-2020
 6037              		.file 5 "c:\\users\\user\\chipwhisperer5_64\\cw\\home\\portable\\armgcc\\gcc-arm-none-eabi-10-2020
 6038              		.file 6 "c:\\users\\user\\chipwhisperer5_64\\cw\\home\\portable\\armgcc\\gcc-arm-none-eabi-10-2020
DEFINED SYMBOLS
                            *ABS*:00000000 sign.c
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:16     .text.fpr_ursh:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:23     .text.fpr_ursh:00000000 fpr_ursh
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:127    .text.fpr_irsh:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:133    .text.fpr_irsh:00000000 fpr_irsh
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:238    .text.fpr_ulsh:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:244    .text.fpr_ulsh:00000000 fpr_ulsh
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:347    .text.fpr_of:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:353    .text.fpr_of:00000000 fpr_of
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:392    .rodata:00000000 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:395    .rodata:00000000 fpr_q
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:401    .rodata:00000008 fpr_inverse_of_q
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:407    .rodata:00000010 fpr_inv_2sqrsigma0
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:413    .rodata:00000018 fpr_inv_sigma
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:439    .rodata:00000070 fpr_sigma_min
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:465    .rodata:000000c8 fpr_log2
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:471    .rodata:000000d0 fpr_inv_log2
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:477    .rodata:000000d8 fpr_bnorm_max
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:483    .rodata:000000e0 fpr_zero
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:488    .rodata:000000e8 fpr_one
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:494    .rodata:000000f0 fpr_two
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:500    .rodata:000000f8 fpr_onehalf
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:506    .rodata:00000100 fpr_invsqrt2
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:512    .rodata:00000108 fpr_invsqrt8
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:518    .rodata:00000110 fpr_ptwo31
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:524    .rodata:00000118 fpr_ptwo31m1
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:530    .rodata:00000120 fpr_mtwo31m1
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:536    .rodata:00000128 fpr_ptwo63m1
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:542    .rodata:00000130 fpr_mtwo63m1
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:548    .rodata:00000138 fpr_ptwo63
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:552    .text.fpr_rint:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:558    .text.fpr_rint:00000000 fpr_rint
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:770    .text.fpr_floor:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:776    .text.fpr_floor:00000000 fpr_floor
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:935    .text.fpr_trunc:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:941    .text.fpr_trunc:00000000 fpr_trunc
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1077   .text.fpr_sub:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1083   .text.fpr_sub:00000000 fpr_sub
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1130   .text.fpr_neg:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1136   .text.fpr_neg:00000000 fpr_neg
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1180   .text.fpr_half:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1186   .text.fpr_half:00000000 fpr_half
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1270   .text.fpr_sqr:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1276   .text.fpr_sqr:00000000 fpr_sqr
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1315   .text.prng_get_u64:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1321   .text.prng_get_u64:00000000 prng_get_u64
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1563   .text.prng_get_u8:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1569   .text.prng_get_u8:00000000 prng_get_u8
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1625   .text.ffLDL_treesize:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1631   .text.ffLDL_treesize:00000000 ffLDL_treesize
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1674   .text.ffLDL_fft_inner:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1680   .text.ffLDL_fft_inner:00000000 ffLDL_fft_inner
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1812   .text.ffLDL_fft:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1818   .text.ffLDL_fft:00000000 ffLDL_fft
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1980   .text.ffLDL_binary_normalize:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:1986   .text.ffLDL_binary_normalize:00000000 ffLDL_binary_normalize
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2078   .text.ffLDL_binary_normalize:00000084 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2083   .text.smallints_to_fpr:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2089   .text.smallints_to_fpr:00000000 smallints_to_fpr
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2171   .text.skoff_b00:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2177   .text.skoff_b00:00000000 skoff_b00
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2215   .text.skoff_b01:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2221   .text.skoff_b01:00000000 skoff_b01
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2261   .text.skoff_b10:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2267   .text.skoff_b10:00000000 skoff_b10
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2307   .text.skoff_b11:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2313   .text.skoff_b11:00000000 skoff_b11
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2353   .text.skoff_tree:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2359   .text.skoff_tree:00000000 skoff_tree
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2399   .text.falcon_inner_expand_privkey:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2406   .text.falcon_inner_expand_privkey:00000000 falcon_inner_expand_privkey
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2674   .text.ffSampling_fft_dyntree:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:2680   .text.ffSampling_fft_dyntree:00000000 ffSampling_fft_dyntree
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:3031   .text.ffSampling_fft_dyntree:00000254 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:3036   .text.ffSampling_fft:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:3042   .text.ffSampling_fft:00000000 ffSampling_fft
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:3944   .text.ffSampling_fft:00000978 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:3951   .text.ffSampling_fft:00000988 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:4120   .text.do_sign_tree:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:4126   .text.do_sign_tree:00000000 do_sign_tree
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:4566   .text.do_sign_tree:000002c8 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:4572   .text.do_sign_dyn:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:4578   .text.do_sign_dyn:00000000 do_sign_dyn
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5251   .text.do_sign_dyn:000004e0 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5257   .text.falcon_inner_gaussian0_sampler:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5264   .text.falcon_inner_gaussian0_sampler:00000000 falcon_inner_gaussian0_sampler
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5406   .text.falcon_inner_gaussian0_sampler:000000c8 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5979   .rodata:00000140 dist.0
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5411   .text.BerExp:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5417   .text.BerExp:00000000 BerExp
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5573   .text.BerExp:00000118 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5581   .text.falcon_inner_sampler:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5588   .text.falcon_inner_sampler:00000000 falcon_inner_sampler
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5744   .text.falcon_inner_sampler:00000120 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5750   .text.falcon_inner_sign_tree:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5757   .text.falcon_inner_sign_tree:00000000 falcon_inner_sign_tree
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5854   .text.falcon_inner_sign_tree:000000c0 $d
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5860   .text.falcon_inner_sign_dyn:00000000 $t
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5867   .text.falcon_inner_sign_dyn:00000000 falcon_inner_sign_dyn
C:\Users\user\AppData\Local\Temp\ccGJlIJQ.s:5970   .text.falcon_inner_sign_dyn:000000d0 $d

UNDEFINED SYMBOLS
falcon_inner_fpr_scaled
falcon_inner_fpr_add
falcon_inner_fpr_mul
falcon_inner_prng_refill
falcon_inner_poly_LDLmv_fft
falcon_inner_poly_split_fft
memcpy
falcon_inner_fpr_sqrt
falcon_inner_FFT
falcon_inner_poly_neg
falcon_inner_poly_mulselfadj_fft
falcon_inner_poly_add
falcon_inner_poly_muladj_fft
falcon_inner_poly_LDL_fft
falcon_inner_poly_merge_fft
falcon_inner_poly_sub
falcon_inner_poly_mul_fft
falcon_inner_poly_mulconst
falcon_inner_iFFT
falcon_inner_is_short_half
memmove
falcon_inner_fpr_expm_p63
falcon_inner_prng_init
