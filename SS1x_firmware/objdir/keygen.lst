   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"keygen.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.fpr_ursh,"ax",%progbits
  16              		.align	1
  17              		.arch armv7e-m
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	fpr_ursh:
  24              	.LFB1:
  25              		.file 1 "fpr.h"
   1:fpr.h         **** /*
   2:fpr.h         ****  * Floating-point operations.
   3:fpr.h         ****  *
   4:fpr.h         ****  * ==========================(LICENSE BEGIN)============================
   5:fpr.h         ****  *
   6:fpr.h         ****  * Copyright (c) 2017-2019  Falcon Project
   7:fpr.h         ****  *
   8:fpr.h         ****  * Permission is hereby granted, free of charge, to any person obtaining
   9:fpr.h         ****  * a copy of this software and associated documentation files (the
  10:fpr.h         ****  * "Software"), to deal in the Software without restriction, including
  11:fpr.h         ****  * without limitation the rights to use, copy, modify, merge, publish,
  12:fpr.h         ****  * distribute, sublicense, and/or sell copies of the Software, and to
  13:fpr.h         ****  * permit persons to whom the Software is furnished to do so, subject to
  14:fpr.h         ****  * the following conditions:
  15:fpr.h         ****  *
  16:fpr.h         ****  * The above copyright notice and this permission notice shall be
  17:fpr.h         ****  * included in all copies or substantial portions of the Software.
  18:fpr.h         ****  *
  19:fpr.h         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  20:fpr.h         ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  21:fpr.h         ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  22:fpr.h         ****  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  23:fpr.h         ****  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  24:fpr.h         ****  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  25:fpr.h         ****  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  26:fpr.h         ****  *
  27:fpr.h         ****  * ===========================(LICENSE END)=============================
  28:fpr.h         ****  *
  29:fpr.h         ****  * @author   Thomas Pornin <thomas.pornin@nccgroup.com>
  30:fpr.h         ****  */
  31:fpr.h         **** 
  32:fpr.h         **** 
  33:fpr.h         **** /* ====================================================================== */
  34:fpr.h         **** /*
  35:fpr.h         ****  * Custom floating-point implementation with integer arithmetics. We
  36:fpr.h         ****  * use IEEE-754 "binary64" format, with some simplifications:
  37:fpr.h         ****  *
  38:fpr.h         ****  *   - Top bit is s = 1 for negative, 0 for positive.
  39:fpr.h         ****  *
  40:fpr.h         ****  *   - Exponent e uses the next 11 bits (bits 52 to 62, inclusive).
  41:fpr.h         ****  *
  42:fpr.h         ****  *   - Mantissa m uses the 52 low bits.
  43:fpr.h         ****  *
  44:fpr.h         ****  * Encoded value is, in general: (-1)^s * 2^(e-1023) * (1 + m*2^(-52))
  45:fpr.h         ****  * i.e. the mantissa really is a 53-bit number (less than 2.0, but not
  46:fpr.h         ****  * less than 1.0), but the top bit (equal to 1 by definition) is omitted
  47:fpr.h         ****  * in the encoding.
  48:fpr.h         ****  *
  49:fpr.h         ****  * In IEEE-754, there are some special values:
  50:fpr.h         ****  *
  51:fpr.h         ****  *   - If e = 2047, then the value is either an infinite (m = 0) or
  52:fpr.h         ****  *     a NaN (m != 0).
  53:fpr.h         ****  *
  54:fpr.h         ****  *   - If e = 0, then the value is either a zero (m = 0) or a subnormal,
  55:fpr.h         ****  *     aka "denormalized number" (m != 0).
  56:fpr.h         ****  *
  57:fpr.h         ****  * Of these, we only need the zeros. The caller is responsible for not
  58:fpr.h         ****  * providing operands that would lead to infinites, NaNs or subnormals.
  59:fpr.h         ****  * If inputs are such that values go out of range, then indeterminate
  60:fpr.h         ****  * values are returned (it would still be deterministic, but no specific
  61:fpr.h         ****  * value may be relied upon).
  62:fpr.h         ****  *
  63:fpr.h         ****  * At the C level, the three parts are stored in a 64-bit unsigned
  64:fpr.h         ****  * word.
  65:fpr.h         ****  *
  66:fpr.h         ****  * One may note that a property of the IEEE-754 format is that order
  67:fpr.h         ****  * is preserved for positive values: if two positive floating-point
  68:fpr.h         ****  * values x and y are such that x < y, then their respective encodings
  69:fpr.h         ****  * as _signed_ 64-bit integers i64(x) and i64(y) will be such that
  70:fpr.h         ****  * i64(x) < i64(y). For negative values, order is reversed: if x < 0,
  71:fpr.h         ****  * y < 0, and x < y, then ia64(x) > ia64(y).
  72:fpr.h         ****  *
  73:fpr.h         ****  * IMPORTANT ASSUMPTIONS:
  74:fpr.h         ****  * ======================
  75:fpr.h         ****  *
  76:fpr.h         ****  * For proper computations, and constant-time behaviour, we assume the
  77:fpr.h         ****  * following:
  78:fpr.h         ****  *
  79:fpr.h         ****  *   - 32x32->64 multiplication (unsigned) has an execution time that
  80:fpr.h         ****  *     is independent of its operands. This is true of most modern
  81:fpr.h         ****  *     x86 and ARM cores. Notable exceptions are the ARM Cortex M0, M0+
  82:fpr.h         ****  *     and M3 (in the M0 and M0+, this is done in software, so it depends
  83:fpr.h         ****  *     on that routine), and the PowerPC cores from the G3/G4 lines.
  84:fpr.h         ****  *     For more info, see: https://www.bearssl.org/ctmul.html
  85:fpr.h         ****  *
  86:fpr.h         ****  *   - Left-shifts and right-shifts of 32-bit values have an execution
  87:fpr.h         ****  *     time which does not depend on the shifted value nor on the
  88:fpr.h         ****  *     shift count. An historical exception is the Pentium IV, but most
  89:fpr.h         ****  *     modern CPU have barrel shifters. Some small microcontrollers
  90:fpr.h         ****  *     might have varying-time shifts (not the ARM Cortex M*, though).
  91:fpr.h         ****  *
  92:fpr.h         ****  *   - Right-shift of a signed negative value performs a sign extension.
  93:fpr.h         ****  *     As per the C standard, this operation returns an
  94:fpr.h         ****  *     implementation-defined result (this is NOT an "undefined
  95:fpr.h         ****  *     behaviour"). On most/all systems, an arithmetic shift is
  96:fpr.h         ****  *     performed, because this is what makes most sense.
  97:fpr.h         ****  */
  98:fpr.h         **** 
  99:fpr.h         **** /*
 100:fpr.h         ****  * Normally we should declare the 'fpr' type to be a struct or union
 101:fpr.h         ****  * around the internal 64-bit value; however, we want to use the
 102:fpr.h         ****  * direct 64-bit integer type to enable a lighter call convention on
 103:fpr.h         ****  * ARM platforms. This means that direct (invalid) use of operators
 104:fpr.h         ****  * such as '*' or '+' will not be caught by the compiler. We rely on
 105:fpr.h         ****  * the "normal" (non-emulated) code to detect such instances.
 106:fpr.h         ****  */
 107:fpr.h         **** typedef uint64_t fpr;
 108:fpr.h         **** 
 109:fpr.h         **** /*
 110:fpr.h         ****  * For computations, we split values into an integral mantissa in the
 111:fpr.h         ****  * 2^54..2^55 range, and an (adjusted) exponent. The lowest bit is
 112:fpr.h         ****  * "sticky" (it is set to 1 if any of the bits below it is 1); when
 113:fpr.h         ****  * re-encoding, the low two bits are dropped, but may induce an
 114:fpr.h         ****  * increment in the value for proper rounding.
 115:fpr.h         ****  */
 116:fpr.h         **** 
 117:fpr.h         **** /*
 118:fpr.h         ****  * Right-shift a 64-bit unsigned value by a possibly secret shift count.
 119:fpr.h         ****  * We assumed that the underlying architecture had a barrel shifter for
 120:fpr.h         ****  * 32-bit shifts, but for 64-bit shifts on a 32-bit system, this will
 121:fpr.h         ****  * typically invoke a software routine that is not necessarily
 122:fpr.h         ****  * constant-time; hence the function below.
 123:fpr.h         ****  *
 124:fpr.h         ****  * Shift count n MUST be in the 0..63 range.
 125:fpr.h         ****  */
 126:fpr.h         **** static inline uint64_t
 127:fpr.h         **** fpr_ursh(uint64_t x, int n)
 128:fpr.h         **** {
  26              		.loc 1 128 1
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 40
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31 0000 2DE9B00F 		push	{r4, r5, r7, r8, r9, r10, fp}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 28
  34              		.cfi_offset 4, -28
  35              		.cfi_offset 5, -24
  36              		.cfi_offset 7, -20
  37              		.cfi_offset 8, -16
  38              		.cfi_offset 9, -12
  39              		.cfi_offset 10, -8
  40              		.cfi_offset 11, -4
  41 0004 8BB0     		sub	sp, sp, #44
  42              	.LCFI1:
  43              		.cfi_def_cfa_offset 72
  44 0006 00AF     		add	r7, sp, #0
  45              	.LCFI2:
  46              		.cfi_def_cfa_register 7
  47 0008 C7E90801 		strd	r0, [r7, #32]
  48 000c FA61     		str	r2, [r7, #28]
 129:fpr.h         **** 	x ^= (x ^ (x >> 32)) & -(uint64_t)(n >> 5);
  49              		.loc 1 129 15
  50 000e D7E90823 		ldrd	r2, [r7, #32]
  51 0012 4FF00000 		mov	r0, #0
  52 0016 4FF00001 		mov	r1, #0
  53 001a 1800     		movs	r0, r3
  54 001c 0021     		movs	r1, #0
  55              		.loc 1 129 10
  56 001e D7E90823 		ldrd	r2, [r7, #32]
  57 0022 80EA020C 		eor	ip, r0, r2
  58 0026 C7F810C0 		str	ip, [r7, #16]
  59 002a 4B40     		eors	r3, r3, r1
  60 002c 7B61     		str	r3, [r7, #20]
  61              		.loc 1 129 39
  62 002e FB69     		ldr	r3, [r7, #28]
  63 0030 5B11     		asrs	r3, r3, #5
  64              		.loc 1 129 26
  65 0032 DA17     		asrs	r2, r3, #31
  66 0034 BB60     		str	r3, [r7, #8]
  67 0036 FA60     		str	r2, [r7, #12]
  68              		.loc 1 129 25
  69 0038 0023     		movs	r3, #0
  70 003a D7E90212 		ldrd	r1, [r7, #8]
  71 003e 0846     		mov	r0, r1
  72 0040 D0F1000A 		rsbs	r10, r0, #0
  73 0044 63EB020B 		sbc	fp, r3, r2
  74              		.loc 1 129 23
  75 0048 D7E90423 		ldrd	r2, [r7, #16]
  76 004c 1146     		mov	r1, r2
  77 004e 01EA0A04 		and	r4, r1, r10
  78 0052 03EA0B05 		and	r5, r3, fp
  79              		.loc 1 129 4
  80 0056 D7E90823 		ldrd	r2, [r7, #32]
  81 005a 82EA0401 		eor	r1, r2, r4
  82 005e 3960     		str	r1, [r7]
  83 0060 6B40     		eors	r3, r3, r5
  84 0062 7B60     		str	r3, [r7, #4]
  85 0064 D7E90034 		ldrd	r3, [r7]
  86 0068 C7E90834 		strd	r3, [r7, #32]
 130:fpr.h         **** 	return x >> (n & 31);
  87              		.loc 1 130 17
  88 006c FB69     		ldr	r3, [r7, #28]
  89 006e 03F01F01 		and	r1, r3, #31
  90              		.loc 1 130 11
  91 0072 D7E90823 		ldrd	r2, [r7, #32]
  92 0076 C1F12004 		rsb	r4, r1, #32
  93 007a A1F12000 		sub	r0, r1, #32
  94 007e 22FA01F8 		lsr	r8, r2, r1
  95 0082 03FA04F4 		lsl	r4, r3, r4
  96 0086 48EA0408 		orr	r8, r8, r4
  97 008a 23FA00F0 		lsr	r0, r3, r0
  98 008e 48EA0008 		orr	r8, r8, r0
  99 0092 23FA01F9 		lsr	r9, r3, r1
 100 0096 4246     		mov	r2, r8
 101 0098 4B46     		mov	r3, r9
 131:fpr.h         **** }
 102              		.loc 1 131 1
 103 009a 1046     		mov	r0, r2
 104 009c 1946     		mov	r1, r3
 105 009e 2C37     		adds	r7, r7, #44
 106              	.LCFI3:
 107              		.cfi_def_cfa_offset 28
 108 00a0 BD46     		mov	sp, r7
 109              	.LCFI4:
 110              		.cfi_def_cfa_register 13
 111              		@ sp needed
 112 00a2 BDE8B00F 		pop	{r4, r5, r7, r8, r9, r10, fp}
 113              	.LCFI5:
 114              		.cfi_restore 11
 115              		.cfi_restore 10
 116              		.cfi_restore 9
 117              		.cfi_restore 8
 118              		.cfi_restore 7
 119              		.cfi_restore 5
 120              		.cfi_restore 4
 121              		.cfi_def_cfa_offset 0
 122 00a6 7047     		bx	lr
 123              		.cfi_endproc
 124              	.LFE1:
 126              		.section	.text.fpr_ulsh,"ax",%progbits
 127              		.align	1
 128              		.syntax unified
 129              		.thumb
 130              		.thumb_func
 131              		.fpu softvfp
 133              	fpr_ulsh:
 134              	.LFB3:
 132:fpr.h         **** 
 133:fpr.h         **** /*
 134:fpr.h         ****  * Right-shift a 64-bit signed value by a possibly secret shift count
 135:fpr.h         ****  * (see fpr_ursh() for the rationale).
 136:fpr.h         ****  *
 137:fpr.h         ****  * Shift count n MUST be in the 0..63 range.
 138:fpr.h         ****  */
 139:fpr.h         **** static inline int64_t
 140:fpr.h         **** fpr_irsh(int64_t x, int n)
 141:fpr.h         **** {
 142:fpr.h         **** 	x ^= (x ^ (x >> 32)) & -(int64_t)(n >> 5);
 143:fpr.h         **** 	return x >> (n & 31);
 144:fpr.h         **** }
 145:fpr.h         **** 
 146:fpr.h         **** /*
 147:fpr.h         ****  * Left-shift a 64-bit unsigned value by a possibly secret shift count
 148:fpr.h         ****  * (see fpr_ursh() for the rationale).
 149:fpr.h         ****  *
 150:fpr.h         ****  * Shift count n MUST be in the 0..63 range.
 151:fpr.h         ****  */
 152:fpr.h         **** static inline uint64_t
 153:fpr.h         **** fpr_ulsh(uint64_t x, int n)
 154:fpr.h         **** {
 135              		.loc 1 154 1
 136              		.cfi_startproc
 137              		@ args = 0, pretend = 0, frame = 40
 138              		@ frame_needed = 1, uses_anonymous_args = 0
 139              		@ link register save eliminated.
 140 0000 2DE9B00F 		push	{r4, r5, r7, r8, r9, r10, fp}
 141              	.LCFI6:
 142              		.cfi_def_cfa_offset 28
 143              		.cfi_offset 4, -28
 144              		.cfi_offset 5, -24
 145              		.cfi_offset 7, -20
 146              		.cfi_offset 8, -16
 147              		.cfi_offset 9, -12
 148              		.cfi_offset 10, -8
 149              		.cfi_offset 11, -4
 150 0004 8BB0     		sub	sp, sp, #44
 151              	.LCFI7:
 152              		.cfi_def_cfa_offset 72
 153 0006 00AF     		add	r7, sp, #0
 154              	.LCFI8:
 155              		.cfi_def_cfa_register 7
 156 0008 C7E90801 		strd	r0, [r7, #32]
 157 000c FA61     		str	r2, [r7, #28]
 155:fpr.h         **** 	x ^= (x ^ (x << 32)) & -(uint64_t)(n >> 5);
 158              		.loc 1 155 15
 159 000e D7E90823 		ldrd	r2, [r7, #32]
 160 0012 4FF00000 		mov	r0, #0
 161 0016 4FF00001 		mov	r1, #0
 162 001a 1100     		movs	r1, r2
 163 001c 0020     		movs	r0, #0
 164              		.loc 1 155 10
 165 001e D7E90823 		ldrd	r2, [r7, #32]
 166 0022 80EA020C 		eor	ip, r0, r2
 167 0026 C7F810C0 		str	ip, [r7, #16]
 168 002a 4B40     		eors	r3, r3, r1
 169 002c 7B61     		str	r3, [r7, #20]
 170              		.loc 1 155 39
 171 002e FB69     		ldr	r3, [r7, #28]
 172 0030 5B11     		asrs	r3, r3, #5
 173              		.loc 1 155 26
 174 0032 DA17     		asrs	r2, r3, #31
 175 0034 BB60     		str	r3, [r7, #8]
 176 0036 FA60     		str	r2, [r7, #12]
 177              		.loc 1 155 25
 178 0038 0023     		movs	r3, #0
 179 003a D7E90212 		ldrd	r1, [r7, #8]
 180 003e 0846     		mov	r0, r1
 181 0040 D0F1000A 		rsbs	r10, r0, #0
 182 0044 63EB020B 		sbc	fp, r3, r2
 183              		.loc 1 155 23
 184 0048 D7E90423 		ldrd	r2, [r7, #16]
 185 004c 1146     		mov	r1, r2
 186 004e 01EA0A04 		and	r4, r1, r10
 187 0052 03EA0B05 		and	r5, r3, fp
 188              		.loc 1 155 4
 189 0056 D7E90823 		ldrd	r2, [r7, #32]
 190 005a 82EA0401 		eor	r1, r2, r4
 191 005e 3960     		str	r1, [r7]
 192 0060 6B40     		eors	r3, r3, r5
 193 0062 7B60     		str	r3, [r7, #4]
 194 0064 D7E90034 		ldrd	r3, [r7]
 195 0068 C7E90834 		strd	r3, [r7, #32]
 156:fpr.h         **** 	return x << (n & 31);
 196              		.loc 1 156 17
 197 006c FB69     		ldr	r3, [r7, #28]
 198 006e 03F01F01 		and	r1, r3, #31
 199              		.loc 1 156 11
 200 0072 D7E90823 		ldrd	r2, [r7, #32]
 201 0076 A1F12004 		sub	r4, r1, #32
 202 007a C1F12000 		rsb	r0, r1, #32
 203 007e 03FA01F9 		lsl	r9, r3, r1
 204 0082 02FA04F4 		lsl	r4, r2, r4
 205 0086 49EA0409 		orr	r9, r9, r4
 206 008a 22FA00F0 		lsr	r0, r2, r0
 207 008e 49EA0009 		orr	r9, r9, r0
 208 0092 02FA01F8 		lsl	r8, r2, r1
 209 0096 4246     		mov	r2, r8
 210 0098 4B46     		mov	r3, r9
 157:fpr.h         **** }
 211              		.loc 1 157 1
 212 009a 1046     		mov	r0, r2
 213 009c 1946     		mov	r1, r3
 214 009e 2C37     		adds	r7, r7, #44
 215              	.LCFI9:
 216              		.cfi_def_cfa_offset 28
 217 00a0 BD46     		mov	sp, r7
 218              	.LCFI10:
 219              		.cfi_def_cfa_register 13
 220              		@ sp needed
 221 00a2 BDE8B00F 		pop	{r4, r5, r7, r8, r9, r10, fp}
 222              	.LCFI11:
 223              		.cfi_restore 11
 224              		.cfi_restore 10
 225              		.cfi_restore 9
 226              		.cfi_restore 8
 227              		.cfi_restore 7
 228              		.cfi_restore 5
 229              		.cfi_restore 4
 230              		.cfi_def_cfa_offset 0
 231 00a6 7047     		bx	lr
 232              		.cfi_endproc
 233              	.LFE3:
 235              		.section	.text.fpr_of,"ax",%progbits
 236              		.align	1
 237              		.syntax unified
 238              		.thumb
 239              		.thumb_func
 240              		.fpu softvfp
 242              	fpr_of:
 243              	.LFB5:
 158:fpr.h         **** 
 159:fpr.h         **** /*
 160:fpr.h         ****  * Expectations:
 161:fpr.h         ****  *   s = 0 or 1
 162:fpr.h         ****  *   exponent e is "arbitrary" and unbiased
 163:fpr.h         ****  *   2^54 <= m < 2^55
 164:fpr.h         ****  * Numerical value is (-1)^2 * m * 2^e
 165:fpr.h         ****  *
 166:fpr.h         ****  * Exponents which are too low lead to value zero. If the exponent is
 167:fpr.h         ****  * too large, the returned value is indeterminate.
 168:fpr.h         ****  *
 169:fpr.h         ****  * If m = 0, then a zero is returned (using the provided sign).
 170:fpr.h         ****  * If e < -1076, then a zero is returned (regardless of the value of m).
 171:fpr.h         ****  * If e >= -1076 and e != 0, m must be within the expected range
 172:fpr.h         ****  * (2^54 to 2^55-1).
 173:fpr.h         ****  */
 174:fpr.h         **** 
 175:fpr.h         **** static inline fpr
 176:fpr.h         **** FPR(int s, int e, uint64_t m)
 177:fpr.h         **** {
 178:fpr.h         **** 	fpr x;
 179:fpr.h         **** 	uint32_t t;
 180:fpr.h         **** 	unsigned f;
 181:fpr.h         **** 
 182:fpr.h         **** 	/*
 183:fpr.h         **** 	 * If e >= -1076, then the value is "normal"; otherwise, it
 184:fpr.h         **** 	 * should be a subnormal, which we clamp down to zero.
 185:fpr.h         **** 	 */
 186:fpr.h         **** 	e += 1076;
 187:fpr.h         **** 	t = (uint32_t)e >> 31;
 188:fpr.h         **** 	m &= (uint64_t)t - 1;
 189:fpr.h         **** 
 190:fpr.h         **** 	/*
 191:fpr.h         **** 	 * If m = 0 then we want a zero; make e = 0 too, but conserve
 192:fpr.h         **** 	 * the sign.
 193:fpr.h         **** 	 */
 194:fpr.h         **** 	t = (uint32_t)(m >> 54);
 195:fpr.h         **** 	e &= -(int)t;
 196:fpr.h         **** 
 197:fpr.h         **** 	/*
 198:fpr.h         **** 	 * The 52 mantissa bits come from m. Value m has its top bit set
 199:fpr.h         **** 	 * (unless it is a zero); we leave it "as is": the top bit will
 200:fpr.h         **** 	 * increment the exponent by 1, except when m = 0, which is
 201:fpr.h         **** 	 * exactly what we want.
 202:fpr.h         **** 	 */
 203:fpr.h         **** 	x = (((uint64_t)s << 63) | (m >> 2)) + ((uint64_t)(uint32_t)e << 52);
 204:fpr.h         **** 
 205:fpr.h         **** 	/*
 206:fpr.h         **** 	 * Rounding: if the low three bits of m are 011, 110 or 111,
 207:fpr.h         **** 	 * then the value should be incremented to get the next
 208:fpr.h         **** 	 * representable value. This implements the usual
 209:fpr.h         **** 	 * round-to-nearest rule (with preference to even values in case
 210:fpr.h         **** 	 * of a tie). Note that the increment may make a carry spill
 211:fpr.h         **** 	 * into the exponent field, which is again exactly what we want
 212:fpr.h         **** 	 * in that case.
 213:fpr.h         **** 	 */
 214:fpr.h         **** 	f = (unsigned)m & 7U;
 215:fpr.h         **** 	x += (0xC8U >> f) & 1;
 216:fpr.h         **** 	return x;
 217:fpr.h         **** }
 218:fpr.h         **** 
 219:fpr.h         **** #define fpr_scaled   Zf(fpr_scaled)
 220:fpr.h         **** fpr fpr_scaled(int64_t i, int sc);
 221:fpr.h         **** 
 222:fpr.h         **** static inline fpr
 223:fpr.h         **** fpr_of(int64_t i)
 224:fpr.h         **** {
 244              		.loc 1 224 1
 245              		.cfi_startproc
 246              		@ args = 0, pretend = 0, frame = 8
 247              		@ frame_needed = 1, uses_anonymous_args = 0
 248 0000 80B5     		push	{r7, lr}
 249              	.LCFI12:
 250              		.cfi_def_cfa_offset 8
 251              		.cfi_offset 7, -8
 252              		.cfi_offset 14, -4
 253 0002 82B0     		sub	sp, sp, #8
 254              	.LCFI13:
 255              		.cfi_def_cfa_offset 16
 256 0004 00AF     		add	r7, sp, #0
 257              	.LCFI14:
 258              		.cfi_def_cfa_register 7
 259 0006 C7E90001 		strd	r0, [r7]
 225:fpr.h         **** 	return fpr_scaled(i, 0);
 260              		.loc 1 225 9
 261 000a 0022     		movs	r2, #0
 262 000c D7E90001 		ldrd	r0, [r7]
 263 0010 FFF7FEFF 		bl	falcon_inner_fpr_scaled
 264 0014 0246     		mov	r2, r0
 265 0016 0B46     		mov	r3, r1
 226:fpr.h         **** }
 266              		.loc 1 226 1
 267 0018 1046     		mov	r0, r2
 268 001a 1946     		mov	r1, r3
 269 001c 0837     		adds	r7, r7, #8
 270              	.LCFI15:
 271              		.cfi_def_cfa_offset 8
 272 001e BD46     		mov	sp, r7
 273              	.LCFI16:
 274              		.cfi_def_cfa_register 13
 275              		@ sp needed
 276 0020 80BD     		pop	{r7, pc}
 277              		.cfi_endproc
 278              	.LFE5:
 280              		.section	.rodata
 281              		.align	3
 284              	fpr_q:
 285 0000 00000000 		.word	0
 286 0004 8000C840 		.word	1086849152
 287              		.align	3
 290              	fpr_inverse_of_q:
 291 0008 82A79790 		.word	-1869109374
 292 000c E354153F 		.word	1058362595
 293              		.align	3
 296              	fpr_inv_2sqrsigma0:
 297 0010 C2BB83C1 		.word	-1048331326
 298 0014 8B4FC33F 		.word	1069764491
 299              		.align	3
 302              	fpr_inv_sigma:
 303 0018 00000000 		.word	0
 304 001c 00000000 		.word	0
 305 0020 9A16247E 		.word	2116294298
 306 0024 EB487C3F 		.word	1065109739
 307 0028 D9AE8C54 		.word	1418505945
 308 002c 0AE57B3F 		.word	1065084170
 309 0030 2C769EE0 		.word	-526485972
 310 0034 2E857B3F 		.word	1065059630
 311 0038 36DACAD3 		.word	-741680586
 312 003c 5EFC7A3F 		.word	1065024606
 313 0040 EDB37609 		.word	158774253
 314 0044 3B7B7A3F 		.word	1064991547
 315 0048 989CCA82 		.word	-2100650856
 316 004c 12017A3F 		.word	1064960274
 317 0050 36275FCE 		.word	-832624842
 318 0054 498D793F 		.word	1064930633
 319 0058 EED96EC5 		.word	-982590994
 320 005c 571F793F 		.word	1064902487
 321 0060 CAC764DE 		.word	-563820598
 322 0064 C2B6783F 		.word	1064875714
 323 0068 E31A31F6 		.word	-164554013
 324 006c 1E53783F 		.word	1064850206
 325              		.align	3
 328              	fpr_sigma_min:
 329 0070 00000000 		.word	0
 330 0074 00000000 		.word	0
 331 0078 8B564406 		.word	105141899
 332 007c 38DDF13F 		.word	1072815416
 333 0080 2686ADDC 		.word	-592607706
 334 0084 2E1DF23F 		.word	1072831790
 335 0088 7A7CAAE1 		.word	-508920710
 336 008c 465CF23F 		.word	1072847942
 337 0090 25FB4A57 		.word	1464531749
 338 0094 5CB9F23F 		.word	1072871772
 339 0098 B622FEC7 		.word	-939646282
 340 009c AB14F33F 		.word	1072895147
 341 00a0 C3D77534 		.word	880138179
 342 00a4 4E6EF33F 		.word	1072918094
 343 00a8 24C2A166 		.word	1721877028
 344 00ac 5AC6F33F 		.word	1072940634
 345 00b0 A0B38C35 		.word	898413472
 346 00b4 E51CF43F 		.word	1072962789
 347 00b8 757A1FBF 		.word	-1088456075
 348 00bc 0172F43F 		.word	1072984577
 349 00c0 64C79099 		.word	-1718565020
 350 00c4 C1C5F43F 		.word	1073006017
 351              		.align	3
 354              	fpr_log2:
 355 00c8 EF39FAFE 		.word	-17155601
 356 00cc 422EE63F 		.word	1072049730
 357              		.align	3
 360              	fpr_inv_log2:
 361 00d0 FE822B65 		.word	1697350398
 362 00d4 4715F73F 		.word	1073157447
 363              		.align	3
 366              	fpr_bnorm_max:
 367 00d8 ACADD85F 		.word	1608035756
 368 00dc 9A6DD040 		.word	1087401370
 369              		.align	3
 372              	fpr_zero:
 373 00e0 00000000 		.space	8
 373      00000000 
 374              		.align	3
 377              	fpr_one:
 378 00e8 00000000 		.word	0
 379 00ec 0000F03F 		.word	1072693248
 380              		.align	3
 383              	fpr_two:
 384 00f0 00000000 		.word	0
 385 00f4 00000040 		.word	1073741824
 386              		.align	3
 389              	fpr_onehalf:
 390 00f8 00000000 		.word	0
 391 00fc 0000E03F 		.word	1071644672
 392              		.align	3
 395              	fpr_invsqrt2:
 396 0100 CD3B7F66 		.word	1719614413
 397 0104 9EA0E63F 		.word	1072079006
 398              		.align	3
 401              	fpr_invsqrt8:
 402 0108 CD3B7F66 		.word	1719614413
 403 010c 9EA0D63F 		.word	1071030430
 404              		.align	3
 407              	fpr_ptwo31:
 408 0110 00000000 		.word	0
 409 0114 0000E041 		.word	1105199104
 410              		.align	3
 413              	fpr_ptwo31m1:
 414 0118 0000C0FF 		.word	-4194304
 415 011c FFFFDF41 		.word	1105199103
 416              		.align	3
 419              	fpr_mtwo31m1:
 420 0120 0000C0FF 		.word	-4194304
 421 0124 FFFFDFC1 		.word	-1042284545
 422              		.align	3
 425              	fpr_ptwo63m1:
 426 0128 00000000 		.word	0
 427 012c 0000E043 		.word	1138753536
 428              		.align	3
 431              	fpr_mtwo63m1:
 432 0130 00000000 		.word	0
 433 0134 0000E0C3 		.word	-1008730112
 434              		.align	3
 437              	fpr_ptwo63:
 438 0138 00000000 		.word	0
 439 013c 0000E043 		.word	1138753536
 440              		.section	.text.fpr_rint,"ax",%progbits
 441              		.align	1
 442              		.syntax unified
 443              		.thumb
 444              		.thumb_func
 445              		.fpu softvfp
 447              	fpr_rint:
 448              	.LFB6:
 227:fpr.h         **** 
 228:fpr.h         **** static const fpr fpr_q = 4667981563525332992;
 229:fpr.h         **** static const fpr fpr_inverse_of_q = 4545632735260551042;
 230:fpr.h         **** static const fpr fpr_inv_2sqrsigma0 = 4594603506513722306;
 231:fpr.h         **** static const fpr fpr_inv_sigma[] = {
 232:fpr.h         **** 	0,  /* unused */
 233:fpr.h         **** 	4574611497772390042,
 234:fpr.h         **** 	4574501679055810265,
 235:fpr.h         **** 	4574396282908341804,
 236:fpr.h         **** 	4574245855758572086,
 237:fpr.h         **** 	4574103865040221165,
 238:fpr.h         **** 	4573969550563515544,
 239:fpr.h         **** 	4573842244705920822,
 240:fpr.h         **** 	4573721358406441454,
 241:fpr.h         **** 	4573606369665796042,
 242:fpr.h         **** 	4573496814039276259
 243:fpr.h         **** };
 244:fpr.h         **** static const fpr fpr_sigma_min[] = {
 245:fpr.h         **** 	0,  /* unused */
 246:fpr.h         **** 	4607707126469777035,
 247:fpr.h         **** 	4607777455861499430,
 248:fpr.h         **** 	4607846828256951418,
 249:fpr.h         **** 	4607949175006100261,
 250:fpr.h         **** 	4608049571757433526,
 251:fpr.h         **** 	4608148125896792003,
 252:fpr.h         **** 	4608244935301382692,
 253:fpr.h         **** 	4608340089478362016,
 254:fpr.h         **** 	4608433670533905013,
 255:fpr.h         **** 	4608525754002622308
 256:fpr.h         **** };
 257:fpr.h         **** static const fpr fpr_log2 = 4604418534313441775;
 258:fpr.h         **** static const fpr fpr_inv_log2 = 4609176140021203710;
 259:fpr.h         **** static const fpr fpr_bnorm_max = 4670353323383631276;
 260:fpr.h         **** static const fpr fpr_zero = 0;
 261:fpr.h         **** static const fpr fpr_one = 4607182418800017408;
 262:fpr.h         **** static const fpr fpr_two = 4611686018427387904;
 263:fpr.h         **** static const fpr fpr_onehalf = 4602678819172646912;
 264:fpr.h         **** static const fpr fpr_invsqrt2 = 4604544271217802189;
 265:fpr.h         **** static const fpr fpr_invsqrt8 = 4600040671590431693;
 266:fpr.h         **** static const fpr fpr_ptwo31 = 4746794007248502784;
 267:fpr.h         **** static const fpr fpr_ptwo31m1 = 4746794007244308480;
 268:fpr.h         **** static const fpr fpr_mtwo31m1 = 13970166044099084288U;
 269:fpr.h         **** static const fpr fpr_ptwo63m1 = 4890909195324358656;
 270:fpr.h         **** static const fpr fpr_mtwo63m1 = 14114281232179134464U;
 271:fpr.h         **** static const fpr fpr_ptwo63 = 4890909195324358656;
 272:fpr.h         **** 
 273:fpr.h         **** static inline int64_t
 274:fpr.h         **** fpr_rint(fpr x)
 275:fpr.h         **** {
 449              		.loc 1 275 1
 450              		.cfi_startproc
 451              		@ args = 0, pretend = 0, frame = 128
 452              		@ frame_needed = 1, uses_anonymous_args = 0
 453 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 454              	.LCFI17:
 455              		.cfi_def_cfa_offset 32
 456              		.cfi_offset 4, -32
 457              		.cfi_offset 5, -28
 458              		.cfi_offset 7, -24
 459              		.cfi_offset 8, -20
 460              		.cfi_offset 9, -16
 461              		.cfi_offset 10, -12
 462              		.cfi_offset 11, -8
 463              		.cfi_offset 14, -4
 464 0004 A0B0     		sub	sp, sp, #128
 465              	.LCFI18:
 466              		.cfi_def_cfa_offset 160
 467 0006 00AF     		add	r7, sp, #0
 468              	.LCFI19:
 469              		.cfi_def_cfa_register 7
 470 0008 C7E91401 		strd	r0, [r7, #80]
 276:fpr.h         **** 	uint64_t m, d;
 277:fpr.h         **** 	int e;
 278:fpr.h         **** 	uint32_t s, dd, f;
 279:fpr.h         **** 
 280:fpr.h         **** 	/*
 281:fpr.h         **** 	 * We assume that the value fits in -(2^63-1)..+(2^63-1). We can
 282:fpr.h         **** 	 * thus extract the mantissa as a 63-bit integer, then right-shift
 283:fpr.h         **** 	 * it as needed.
 284:fpr.h         **** 	 */
 285:fpr.h         **** 	m = ((x << 10) | ((uint64_t)1 << 62)) & (((uint64_t)1 << 63) - 1);
 471              		.loc 1 285 10
 472 000c D7E91423 		ldrd	r2, [r7, #80]
 473 0010 4FF00000 		mov	r0, #0
 474 0014 4FF00001 		mov	r1, #0
 475 0018 9902     		lsls	r1, r3, #10
 476 001a 41EA9251 		orr	r1, r1, r2, lsr #22
 477 001e 9002     		lsls	r0, r2, #10
 478              		.loc 1 285 40
 479 0020 0446     		mov	r4, r0
 480 0022 21F04045 		bic	r5, r1, #-1073741824
 481              		.loc 1 285 4
 482 0026 A246     		mov	r10, r4
 483 0028 45F0804B 		orr	fp, r5, #1073741824
 484 002c C7E91EAB 		strd	r10, [r7, #120]
 286:fpr.h         **** 	e = 1085 - ((int)(x >> 52) & 0x7FF);
 485              		.loc 1 286 22
 486 0030 D7E91423 		ldrd	r2, [r7, #80]
 487 0034 4FF00000 		mov	r0, #0
 488 0038 4FF00001 		mov	r1, #0
 489 003c 180D     		lsrs	r0, r3, #20
 490 003e 0021     		movs	r1, #0
 491              		.loc 1 286 14
 492 0040 0346     		mov	r3, r0
 493              		.loc 1 286 29
 494 0042 C3F30A03 		ubfx	r3, r3, #0, #11
 495              		.loc 1 286 4
 496 0046 C3F58763 		rsb	r3, r3, #1080
 497 004a 0533     		adds	r3, r3, #5
 498 004c 7B67     		str	r3, [r7, #116]
 287:fpr.h         **** 
 288:fpr.h         **** 	/*
 289:fpr.h         **** 	 * If a shift of more than 63 bits is needed, then simply set m
 290:fpr.h         **** 	 * to zero. This also covers the case of an input operand equal
 291:fpr.h         **** 	 * to zero.
 292:fpr.h         **** 	 */
 293:fpr.h         **** 	m &= -(uint64_t)((uint32_t)(e - 64) >> 31);
 499              		.loc 1 293 32
 500 004e 7B6F     		ldr	r3, [r7, #116]
 501 0050 403B     		subs	r3, r3, #64
 502              		.loc 1 293 38
 503 0052 DB0F     		lsrs	r3, r3, #31
 504              		.loc 1 293 8
 505 0054 0022     		movs	r2, #0
 506 0056 BB64     		str	r3, [r7, #72]
 507 0058 FA64     		str	r2, [r7, #76]
 508              		.loc 1 293 7
 509 005a 0023     		movs	r3, #0
 510 005c D7E91212 		ldrd	r1, [r7, #72]
 511 0060 0846     		mov	r0, r1
 512 0062 D0F10008 		rsbs	r8, r0, #0
 513 0066 63EB0209 		sbc	r9, r3, r2
 514              		.loc 1 293 4
 515 006a D7E91E23 		ldrd	r2, [r7, #120]
 516 006e 02EA0801 		and	r1, r2, r8
 517 0072 B960     		str	r1, [r7, #8]
 518 0074 03EA0903 		and	r3, r3, r9
 519 0078 FB60     		str	r3, [r7, #12]
 520 007a D7E90234 		ldrd	r3, [r7, #8]
 521 007e C7E91E34 		strd	r3, [r7, #120]
 294:fpr.h         **** 	e &= 63;
 522              		.loc 1 294 4
 523 0082 7B6F     		ldr	r3, [r7, #116]
 524 0084 03F03F03 		and	r3, r3, #63
 525 0088 7B67     		str	r3, [r7, #116]
 295:fpr.h         **** 
 296:fpr.h         **** 	/*
 297:fpr.h         **** 	 * Right-shift m as needed. Shift count is e. Proper rounding
 298:fpr.h         **** 	 * mandates that:
 299:fpr.h         **** 	 *   - If the highest dropped bit is zero, then round low.
 300:fpr.h         **** 	 *   - If the highest dropped bit is one, and at least one of the
 301:fpr.h         **** 	 *     other dropped bits is one, then round up.
 302:fpr.h         **** 	 *   - If the highest dropped bit is one, and all other dropped
 303:fpr.h         **** 	 *     bits are zero, then round up if the lowest kept bit is 1,
 304:fpr.h         **** 	 *     or low otherwise (i.e. ties are broken by "rounding to even").
 305:fpr.h         **** 	 *
 306:fpr.h         **** 	 * We thus first extract a word consisting of all the dropped bit
 307:fpr.h         **** 	 * AND the lowest kept bit; then we shrink it down to three bits,
 308:fpr.h         **** 	 * the lowest being "sticky".
 309:fpr.h         **** 	 */
 310:fpr.h         **** 	d = fpr_ulsh(m, 63 - e);
 526              		.loc 1 310 6
 527 008a 7B6F     		ldr	r3, [r7, #116]
 528 008c C3F13F03 		rsb	r3, r3, #63
 529 0090 1A46     		mov	r2, r3
 530 0092 D7E91E01 		ldrd	r0, [r7, #120]
 531 0096 FFF7FEFF 		bl	fpr_ulsh
 532 009a C7E91A01 		strd	r0, [r7, #104]
 311:fpr.h         **** 	dd = (uint32_t)d | ((uint32_t)(d >> 32) & 0x1FFFFFFF);
 533              		.loc 1 311 7
 534 009e BC6E     		ldr	r4, [r7, #104]
 535              		.loc 1 311 35
 536 00a0 D7E91A23 		ldrd	r2, [r7, #104]
 537 00a4 4FF00000 		mov	r0, #0
 538 00a8 4FF00001 		mov	r1, #0
 539 00ac 1800     		movs	r0, r3
 540 00ae 0021     		movs	r1, #0
 541              		.loc 1 311 22
 542 00b0 0346     		mov	r3, r0
 543              		.loc 1 311 42
 544 00b2 23F06043 		bic	r3, r3, #-536870912
 545              		.loc 1 311 5
 546 00b6 2343     		orrs	r3, r3, r4
 547 00b8 7B66     		str	r3, [r7, #100]
 312:fpr.h         **** 	f = (uint32_t)(d >> 61) | ((dd | -dd) >> 31);
 548              		.loc 1 312 19
 549 00ba D7E91A23 		ldrd	r2, [r7, #104]
 550 00be 4FF00000 		mov	r0, #0
 551 00c2 4FF00001 		mov	r1, #0
 552 00c6 580F     		lsrs	r0, r3, #29
 553 00c8 0021     		movs	r1, #0
 554              		.loc 1 312 6
 555 00ca 0146     		mov	r1, r0
 556              		.loc 1 312 35
 557 00cc 7B6E     		ldr	r3, [r7, #100]
 558 00ce 5A42     		rsbs	r2, r3, #0
 559              		.loc 1 312 33
 560 00d0 7B6E     		ldr	r3, [r7, #100]
 561 00d2 1343     		orrs	r3, r3, r2
 562              		.loc 1 312 40
 563 00d4 DB0F     		lsrs	r3, r3, #31
 564              		.loc 1 312 4
 565 00d6 0B43     		orrs	r3, r3, r1
 566 00d8 3B66     		str	r3, [r7, #96]
 313:fpr.h         **** 	m = fpr_ursh(m, e) + (uint64_t)((0xC8U >> f) & 1U);
 567              		.loc 1 313 6
 568 00da 7A6F     		ldr	r2, [r7, #116]
 569 00dc D7E91E01 		ldrd	r0, [r7, #120]
 570 00e0 FFF7FEFF 		bl	fpr_ursh
 571              		.loc 1 313 41
 572 00e4 C822     		movs	r2, #200
 573 00e6 3B6E     		ldr	r3, [r7, #96]
 574 00e8 22FA03F3 		lsr	r3, r2, r3
 575              		.loc 1 313 47
 576 00ec 0022     		movs	r2, #0
 577 00ee 3B64     		str	r3, [r7, #64]
 578 00f0 7A64     		str	r2, [r7, #68]
 579              		.loc 1 313 23
 580 00f2 3B6C     		ldr	r3, [r7, #64]
 581 00f4 03F00103 		and	r3, r3, #1
 582 00f8 BB63     		str	r3, [r7, #56]
 583 00fa 0023     		movs	r3, #0
 584 00fc FB63     		str	r3, [r7, #60]
 585              		.loc 1 313 4
 586 00fe D7E90E45 		ldrd	r4, [r7, #56]
 587 0102 2346     		mov	r3, r4
 588 0104 C318     		adds	r3, r0, r3
 589 0106 3B60     		str	r3, [r7]
 590 0108 2B46     		mov	r3, r5
 591 010a 41EB0303 		adc	r3, r1, r3
 592 010e 7B60     		str	r3, [r7, #4]
 593 0110 D7E90034 		ldrd	r3, [r7]
 594 0114 C7E91E34 		strd	r3, [r7, #120]
 314:fpr.h         **** 
 315:fpr.h         **** 	/*
 316:fpr.h         **** 	 * Apply the sign bit.
 317:fpr.h         **** 	 */
 318:fpr.h         **** 	s = (uint32_t)(x >> 63);
 595              		.loc 1 318 19
 596 0118 D7E91401 		ldrd	r0, [r7, #80]
 597 011c 4FF00002 		mov	r2, #0
 598 0120 4FF00003 		mov	r3, #0
 599 0124 CA0F     		lsrs	r2, r1, #31
 600 0126 0023     		movs	r3, #0
 601              		.loc 1 318 4
 602 0128 1346     		mov	r3, r2
 603 012a FB65     		str	r3, [r7, #92]
 319:fpr.h         **** 	return ((int64_t)m ^ -(int64_t)s) + (int64_t)s;
 604              		.loc 1 319 24
 605 012c FB6D     		ldr	r3, [r7, #92]
 606 012e 0022     		movs	r2, #0
 607 0130 3B63     		str	r3, [r7, #48]
 608 0132 7A63     		str	r2, [r7, #52]
 609              		.loc 1 319 23
 610 0134 0023     		movs	r3, #0
 611 0136 D7E90C01 		ldrd	r0, [r7, #48]
 612 013a 0246     		mov	r2, r0
 613 013c 5242     		negs	r2, r2
 614 013e BA62     		str	r2, [r7, #40]
 615 0140 0A46     		mov	r2, r1
 616 0142 63EB0203 		sbc	r3, r3, r2
 617 0146 FB62     		str	r3, [r7, #44]
 618              		.loc 1 319 10
 619 0148 D7E91E23 		ldrd	r2, [r7, #120]
 620              		.loc 1 319 21
 621 014c D7E90A01 		ldrd	r0, [r7, #40]
 622 0150 0446     		mov	r4, r0
 623 0152 5440     		eors	r4, r4, r2
 624 0154 3C62     		str	r4, [r7, #32]
 625 0156 5940     		eors	r1, r1, r3
 626 0158 7962     		str	r1, [r7, #36]
 627              		.loc 1 319 38
 628 015a FB6D     		ldr	r3, [r7, #92]
 629 015c 0022     		movs	r2, #0
 630 015e BB61     		str	r3, [r7, #24]
 631 0160 FA61     		str	r2, [r7, #28]
 632              		.loc 1 319 36
 633 0162 D7E90845 		ldrd	r4, [r7, #32]
 634 0166 2346     		mov	r3, r4
 635 0168 D7E90601 		ldrd	r0, [r7, #24]
 636 016c 0246     		mov	r2, r0
 637 016e 9B18     		adds	r3, r3, r2
 638 0170 3B61     		str	r3, [r7, #16]
 639 0172 0B46     		mov	r3, r1
 640 0174 2A46     		mov	r2, r5
 641 0176 42EB0303 		adc	r3, r2, r3
 642 017a 7B61     		str	r3, [r7, #20]
 643 017c D7E90423 		ldrd	r2, [r7, #16]
 320:fpr.h         **** }
 644              		.loc 1 320 1
 645 0180 1046     		mov	r0, r2
 646 0182 1946     		mov	r1, r3
 647 0184 8037     		adds	r7, r7, #128
 648              	.LCFI20:
 649              		.cfi_def_cfa_offset 32
 650 0186 BD46     		mov	sp, r7
 651              	.LCFI21:
 652              		.cfi_def_cfa_register 13
 653              		@ sp needed
 654 0188 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 655              		.cfi_endproc
 656              	.LFE6:
 658              		.section	.text.fpr_sqr,"ax",%progbits
 659              		.align	1
 660              		.syntax unified
 661              		.thumb
 662              		.thumb_func
 663              		.fpu softvfp
 665              	fpr_sqr:
 666              	.LFB13:
 321:fpr.h         **** 
 322:fpr.h         **** static inline int64_t
 323:fpr.h         **** fpr_floor(fpr x)
 324:fpr.h         **** {
 325:fpr.h         **** 	uint64_t t;
 326:fpr.h         **** 	int64_t xi;
 327:fpr.h         **** 	int e, cc;
 328:fpr.h         **** 
 329:fpr.h         **** 	/*
 330:fpr.h         **** 	 * We extract the integer as a _signed_ 64-bit integer with
 331:fpr.h         **** 	 * a scaling factor. Since we assume that the value fits
 332:fpr.h         **** 	 * in the -(2^63-1)..+(2^63-1) range, we can left-shift the
 333:fpr.h         **** 	 * absolute value to make it in the 2^62..2^63-1 range: we
 334:fpr.h         **** 	 * will only need a right-shift afterwards.
 335:fpr.h         **** 	 */
 336:fpr.h         **** 	e = (int)(x >> 52) & 0x7FF;
 337:fpr.h         **** 	t = x >> 63;
 338:fpr.h         **** 	xi = (int64_t)(((x << 10) | ((uint64_t)1 << 62))
 339:fpr.h         **** 		& (((uint64_t)1 << 63) - 1));
 340:fpr.h         **** 	xi = (xi ^ -(int64_t)t) + (int64_t)t;
 341:fpr.h         **** 	cc = 1085 - e;
 342:fpr.h         **** 
 343:fpr.h         **** 	/*
 344:fpr.h         **** 	 * We perform an arithmetic right-shift on the value. This
 345:fpr.h         **** 	 * applies floor() semantics on both positive and negative values
 346:fpr.h         **** 	 * (rounding toward minus infinity).
 347:fpr.h         **** 	 */
 348:fpr.h         **** 	xi = fpr_irsh(xi, cc & 63);
 349:fpr.h         **** 
 350:fpr.h         **** 	/*
 351:fpr.h         **** 	 * If the true shift count was 64 or more, then we should instead
 352:fpr.h         **** 	 * replace xi with 0 (if nonnegative) or -1 (if negative). Edge
 353:fpr.h         **** 	 * case: -0 will be floored to -1, not 0 (whether this is correct
 354:fpr.h         **** 	 * is debatable; in any case, the other functions normalize zero
 355:fpr.h         **** 	 * to +0).
 356:fpr.h         **** 	 *
 357:fpr.h         **** 	 * For an input of zero, the non-shifted xi was incorrect (we used
 358:fpr.h         **** 	 * a top implicit bit of value 1, not 0), but this does not matter
 359:fpr.h         **** 	 * since this operation will clamp it down.
 360:fpr.h         **** 	 */
 361:fpr.h         **** 	xi ^= (xi ^ -(int64_t)t) & -(int64_t)((uint32_t)(63 - cc) >> 31);
 362:fpr.h         **** 	return xi;
 363:fpr.h         **** }
 364:fpr.h         **** 
 365:fpr.h         **** static inline int64_t
 366:fpr.h         **** fpr_trunc(fpr x)
 367:fpr.h         **** {
 368:fpr.h         **** 	uint64_t t, xu;
 369:fpr.h         **** 	int e, cc;
 370:fpr.h         **** 
 371:fpr.h         **** 	/*
 372:fpr.h         **** 	 * Extract the absolute value. Since we assume that the value
 373:fpr.h         **** 	 * fits in the -(2^63-1)..+(2^63-1) range, we can left-shift
 374:fpr.h         **** 	 * the absolute value into the 2^62..2^63-1 range, and then
 375:fpr.h         **** 	 * do a right shift afterwards.
 376:fpr.h         **** 	 */
 377:fpr.h         **** 	e = (int)(x >> 52) & 0x7FF;
 378:fpr.h         **** 	xu = ((x << 10) | ((uint64_t)1 << 62)) & (((uint64_t)1 << 63) - 1);
 379:fpr.h         **** 	cc = 1085 - e;
 380:fpr.h         **** 	xu = fpr_ursh(xu, cc & 63);
 381:fpr.h         **** 
 382:fpr.h         **** 	/*
 383:fpr.h         **** 	 * If the exponent is too low (cc > 63), then the shift was wrong
 384:fpr.h         **** 	 * and we must clamp the value to 0. This also covers the case
 385:fpr.h         **** 	 * of an input equal to zero.
 386:fpr.h         **** 	 */
 387:fpr.h         **** 	xu &= -(uint64_t)((uint32_t)(cc - 64) >> 31);
 388:fpr.h         **** 
 389:fpr.h         **** 	/*
 390:fpr.h         **** 	 * Apply back the sign, if the source value is negative.
 391:fpr.h         **** 	 */
 392:fpr.h         **** 	t = x >> 63;
 393:fpr.h         **** 	xu = (xu ^ -t) + t;
 394:fpr.h         **** 	return *(int64_t *)&xu;
 395:fpr.h         **** }
 396:fpr.h         **** 
 397:fpr.h         **** #define fpr_add   Zf(fpr_add)
 398:fpr.h         **** fpr fpr_add(fpr x, fpr y);
 399:fpr.h         **** 
 400:fpr.h         **** static inline fpr
 401:fpr.h         **** fpr_sub(fpr x, fpr y)
 402:fpr.h         **** {
 403:fpr.h         **** 	y ^= (uint64_t)1 << 63;
 404:fpr.h         **** 	return fpr_add(x, y);
 405:fpr.h         **** }
 406:fpr.h         **** 
 407:fpr.h         **** static inline fpr
 408:fpr.h         **** fpr_neg(fpr x)
 409:fpr.h         **** {
 410:fpr.h         **** 	x ^= (uint64_t)1 << 63;
 411:fpr.h         **** 	return x;
 412:fpr.h         **** }
 413:fpr.h         **** 
 414:fpr.h         **** static inline fpr
 415:fpr.h         **** fpr_half(fpr x)
 416:fpr.h         **** {
 417:fpr.h         **** 	/*
 418:fpr.h         **** 	 * To divide a value by 2, we just have to subtract 1 from its
 419:fpr.h         **** 	 * exponent, but we have to take care of zero.
 420:fpr.h         **** 	 */
 421:fpr.h         **** 	uint32_t t;
 422:fpr.h         **** 
 423:fpr.h         **** 	x -= (uint64_t)1 << 52;
 424:fpr.h         **** 	t = (((uint32_t)(x >> 52) & 0x7FF) + 1) >> 11;
 425:fpr.h         **** 	x &= (uint64_t)t - 1;
 426:fpr.h         **** 	return x;
 427:fpr.h         **** }
 428:fpr.h         **** 
 429:fpr.h         **** static inline fpr
 430:fpr.h         **** fpr_double(fpr x)
 431:fpr.h         **** {
 432:fpr.h         **** 	/*
 433:fpr.h         **** 	 * To double a value, we just increment by one the exponent. We
 434:fpr.h         **** 	 * don't care about infinites or NaNs; however, 0 is a
 435:fpr.h         **** 	 * special case.
 436:fpr.h         **** 	 */
 437:fpr.h         **** 	x += (uint64_t)((((unsigned)(x >> 52) & 0x7FFU) + 0x7FFU) >> 11) << 52;
 438:fpr.h         **** 	return x;
 439:fpr.h         **** }
 440:fpr.h         **** 
 441:fpr.h         **** #define fpr_mul   Zf(fpr_mul)
 442:fpr.h         **** fpr fpr_mul(fpr x, fpr y);
 443:fpr.h         **** 
 444:fpr.h         **** static inline fpr
 445:fpr.h         **** fpr_sqr(fpr x)
 446:fpr.h         **** {
 667              		.loc 1 446 1
 668              		.cfi_startproc
 669              		@ args = 0, pretend = 0, frame = 8
 670              		@ frame_needed = 1, uses_anonymous_args = 0
 671 0000 80B5     		push	{r7, lr}
 672              	.LCFI22:
 673              		.cfi_def_cfa_offset 8
 674              		.cfi_offset 7, -8
 675              		.cfi_offset 14, -4
 676 0002 82B0     		sub	sp, sp, #8
 677              	.LCFI23:
 678              		.cfi_def_cfa_offset 16
 679 0004 00AF     		add	r7, sp, #0
 680              	.LCFI24:
 681              		.cfi_def_cfa_register 7
 682 0006 C7E90001 		strd	r0, [r7]
 447:fpr.h         **** 	return fpr_mul(x, x);
 683              		.loc 1 447 9
 684 000a D7E90023 		ldrd	r2, [r7]
 685 000e D7E90001 		ldrd	r0, [r7]
 686 0012 FFF7FEFF 		bl	falcon_inner_fpr_mul
 687 0016 0246     		mov	r2, r0
 688 0018 0B46     		mov	r3, r1
 448:fpr.h         **** }
 689              		.loc 1 448 1
 690 001a 1046     		mov	r0, r2
 691 001c 1946     		mov	r1, r3
 692 001e 0837     		adds	r7, r7, #8
 693              	.LCFI25:
 694              		.cfi_def_cfa_offset 8
 695 0020 BD46     		mov	sp, r7
 696              	.LCFI26:
 697              		.cfi_def_cfa_register 13
 698              		@ sp needed
 699 0022 80BD     		pop	{r7, pc}
 700              		.cfi_endproc
 701              	.LFE13:
 703              		.section	.text.fpr_lt,"ax",%progbits
 704              		.align	1
 705              		.syntax unified
 706              		.thumb
 707              		.thumb_func
 708              		.fpu softvfp
 710              	fpr_lt:
 711              	.LFB15:
 449:fpr.h         **** 
 450:fpr.h         **** #define fpr_div   Zf(fpr_div)
 451:fpr.h         **** fpr fpr_div(fpr x, fpr y);
 452:fpr.h         **** 
 453:fpr.h         **** static inline fpr
 454:fpr.h         **** fpr_inv(fpr x)
 455:fpr.h         **** {
 456:fpr.h         **** 	return fpr_div(4607182418800017408u, x);
 457:fpr.h         **** }
 458:fpr.h         **** 
 459:fpr.h         **** #define fpr_sqrt   Zf(fpr_sqrt)
 460:fpr.h         **** fpr fpr_sqrt(fpr x);
 461:fpr.h         **** 
 462:fpr.h         **** static inline int
 463:fpr.h         **** fpr_lt(fpr x, fpr y)
 464:fpr.h         **** {
 712              		.loc 1 464 1
 713              		.cfi_startproc
 714              		@ args = 0, pretend = 0, frame = 24
 715              		@ frame_needed = 1, uses_anonymous_args = 0
 716              		@ link register save eliminated.
 717 0000 F0B4     		push	{r4, r5, r6, r7}
 718              	.LCFI27:
 719              		.cfi_def_cfa_offset 16
 720              		.cfi_offset 4, -16
 721              		.cfi_offset 5, -12
 722              		.cfi_offset 6, -8
 723              		.cfi_offset 7, -4
 724 0002 86B0     		sub	sp, sp, #24
 725              	.LCFI28:
 726              		.cfi_def_cfa_offset 40
 727 0004 00AF     		add	r7, sp, #0
 728              	.LCFI29:
 729              		.cfi_def_cfa_register 7
 730 0006 C7E90201 		strd	r0, [r7, #8]
 731 000a C7E90023 		strd	r2, [r7]
 465:fpr.h         **** 	/*
 466:fpr.h         **** 	 * If x >= 0 or y >= 0, a signed comparison yields the proper
 467:fpr.h         **** 	 * result:
 468:fpr.h         **** 	 *   - For positive values, the order is preserved.
 469:fpr.h         **** 	 *   - The sign bit is at the same place as in integers, so
 470:fpr.h         **** 	 *     sign is preserved.
 471:fpr.h         **** 	 *
 472:fpr.h         **** 	 * If both x and y are negative, then the order is reversed.
 473:fpr.h         **** 	 * We cannot simply invert the comparison result in that case
 474:fpr.h         **** 	 * because it would not handle the edge case x = y properly.
 475:fpr.h         **** 	 */
 476:fpr.h         **** 	int cc0, cc1;
 477:fpr.h         **** 
 478:fpr.h         **** 	cc0 = *(int64_t *)&x < *(int64_t *)&y;
 732              		.loc 1 478 20
 733 000e 07F10803 		add	r3, r7, #8
 734              		.loc 1 478 8
 735 0012 D3E90001 		ldrd	r0, [r3]
 736              		.loc 1 478 37
 737 0016 3B46     		mov	r3, r7
 738              		.loc 1 478 25
 739 0018 D3E90023 		ldrd	r2, [r3]
 740              		.loc 1 478 23
 741 001c 9042     		cmp	r0, r2
 742 001e 71EB0303 		sbcs	r3, r1, r3
 743 0022 B4BF     		ite	lt
 744 0024 0123     		movlt	r3, #1
 745 0026 0023     		movge	r3, #0
 746 0028 DBB2     		uxtb	r3, r3
 747              		.loc 1 478 6
 748 002a 7B61     		str	r3, [r7, #20]
 479:fpr.h         **** 	cc1 = *(int64_t *)&x > *(int64_t *)&y;
 749              		.loc 1 479 20
 750 002c 07F10803 		add	r3, r7, #8
 751              		.loc 1 479 8
 752 0030 D3E90023 		ldrd	r2, [r3]
 753              		.loc 1 479 37
 754 0034 3946     		mov	r1, r7
 755              		.loc 1 479 25
 756 0036 D1E90001 		ldrd	r0, [r1]
 757              		.loc 1 479 23
 758 003a 9042     		cmp	r0, r2
 759 003c 71EB0303 		sbcs	r3, r1, r3
 760 0040 B4BF     		ite	lt
 761 0042 0123     		movlt	r3, #1
 762 0044 0023     		movge	r3, #0
 763 0046 DBB2     		uxtb	r3, r3
 764              		.loc 1 479 6
 765 0048 3B61     		str	r3, [r7, #16]
 480:fpr.h         **** 	return cc0 ^ ((cc0 ^ cc1) & (int)((x & y) >> 63));
 766              		.loc 1 480 21
 767 004a 7A69     		ldr	r2, [r7, #20]
 768 004c 3B69     		ldr	r3, [r7, #16]
 769 004e 82EA0306 		eor	r6, r2, r3
 770              		.loc 1 480 39
 771 0052 D7E90201 		ldrd	r0, [r7, #8]
 772 0056 D7E90023 		ldrd	r2, [r7]
 773 005a 00EA0204 		and	r4, r0, r2
 774 005e 01EA0305 		and	r5, r1, r3
 775              		.loc 1 480 44
 776 0062 4FF00002 		mov	r2, #0
 777 0066 4FF00003 		mov	r3, #0
 778 006a EA0F     		lsrs	r2, r5, #31
 779 006c 0023     		movs	r3, #0
 780              		.loc 1 480 30
 781 006e 1346     		mov	r3, r2
 782              		.loc 1 480 28
 783 0070 06EA0302 		and	r2, r6, r3
 784              		.loc 1 480 13
 785 0074 7B69     		ldr	r3, [r7, #20]
 786 0076 5340     		eors	r3, r3, r2
 481:fpr.h         **** }
 787              		.loc 1 481 1
 788 0078 1846     		mov	r0, r3
 789 007a 1837     		adds	r7, r7, #24
 790              	.LCFI30:
 791              		.cfi_def_cfa_offset 16
 792 007c BD46     		mov	sp, r7
 793              	.LCFI31:
 794              		.cfi_def_cfa_register 13
 795              		@ sp needed
 796 007e F0BC     		pop	{r4, r5, r6, r7}
 797              	.LCFI32:
 798              		.cfi_restore 7
 799              		.cfi_restore 6
 800              		.cfi_restore 5
 801              		.cfi_restore 4
 802              		.cfi_def_cfa_offset 0
 803 0080 7047     		bx	lr
 804              		.cfi_endproc
 805              	.LFE15:
 807              		.section	.rodata
 808              		.align	2
 811              	PRIMES:
 812 0140 01D8FF7F 		.word	2147473409
 813 0144 45ADD616 		.word	383167813
 814 0148 FF270000 		.word	10239
 815 014c 0190FE7F 		.word	2147389441
 816 0150 89F29F0C 		.word	211808905
 817 0154 E10C191C 		.word	471403745
 818 0158 0188FE7F 		.word	2147387393
 819 015c 5AD53E02 		.word	37672282
 820 0160 190B3C4F 		.word	1329335065
 821 0164 0160FE7F 		.word	2147377153
 822 0168 3E2AD775 		.word	1977035326
 823 016c BEEAB539 		.word	968223422
 824 0170 0118FE7F 		.word	2147358721
 825 0174 3AA09B3F 		.word	1067163706
 826 0178 EF2DE507 		.word	132460015
 827 017c 0100FE7F 		.word	2147352577
 828 0180 FADDBA5F 		.word	1606082042
 829 0184 B157AF23 		.word	598693809
 830 0188 01E8FD7F 		.word	2147346433
 831 018c F9163B79 		.word	2033915641
 832 0190 A034F53E 		.word	1056257184
 833 0194 01C8FD7F 		.word	2147338241
 834 0198 81899262 		.word	1653770625
 835 019c 36531C19 		.word	421286710
 836 01a0 0158FD7F 		.word	2147309569
 837 01a4 335C9F25 		.word	631200819
 838 01a8 32953B42 		.word	1111201074
 839 01ac 0128FD7F 		.word	2147297281
 840 01b0 F7F97E79 		.word	2038364663
 841 01b4 9DB61B3E 		.word	1042003613
 842 01b8 0120FD7F 		.word	2147295233
 843 01bc E3FDF974 		.word	1962540515
 844 01c0 A1A12801 		.word	19440033
 845 01c4 0148FC7F 		.word	2147239937
 846 01c8 E7B72C7D 		.word	2100082663
 847 01cc 78E10E15 		.word	353296760
 848 01d0 0138FC7F 		.word	2147235841
 849 01d4 6E95AE76 		.word	1991153006
 850 01d8 CBB98F65 		.word	1703918027
 851 01dc 01F0FB7F 		.word	2147217409
 852 01e0 7AB7C71E 		.word	516405114
 853 01e4 BD96094B 		.word	1258919613
 854 01e8 01C0FB7F 		.word	2147205121
 855 01ec 94276618 		.word	409347988
 856 01f0 D1E9F340 		.word	1089726929
 857 01f4 01A0FB7F 		.word	2147196929
 858 01f8 BFEF4C37 		.word	927788991
 859 01fc CC3E0174 		.word	1946238668
 860 0200 0158FB7F 		.word	2147178497
 861 0204 2B0FC443 		.word	1136922411
 862 0208 C4044A50 		.word	1347028164
 863 020c 0128FA7F 		.word	2147100673
 864 0210 3C2FC633 		.word	868626236
 865 0214 B3ECCA29 		.word	701164723
 866 0218 01E0F97F 		.word	2147082241
 867 021c C82E1671 		.word	1897279176
 868 0220 C632D324 		.word	617820870
 869 0224 01C0F97F 		.word	2147074049
 870 0228 B3179570 		.word	1888819123
 871 022c 6DB87009 		.word	158382189
 872 0230 0168F97F 		.word	2147051521
 873 0234 F7907D01 		.word	25006327
 874 0238 8FA9281F 		.word	522758543
 875 023c 0148F97F 		.word	2147043329
 876 0240 8FF58513 		.word	327546255
 877 0244 450D3802 		.word	37227845
 878 0248 0138F97F 		.word	2147039233
 879 024c C82EAD2D 		.word	766324424
 880 0250 8CA58D43 		.word	1133356428
 881 0254 0170F87F 		.word	2146988033
 882 0258 5256086F 		.word	1862817362
 883 025c D1086704 		.word	73861329
 884 0260 0110F87F 		.word	2146963457
 885 0264 D80A1E18 		.word	404622040
 886 0268 2B49EC26 		.word	653019435
 887 026c 0100F87F 		.word	2146959361
 888 0270 5EE26D73 		.word	1936581214
 889 0274 B5AD503B 		.word	995143093
 890 0278 01B0F77F 		.word	2146938881
 891 027c F033F85C 		.word	1559770096
 892 0280 2922D825 		.word	634921513
 893 0284 0138F77F 		.word	2146908161
 894 0288 DCB93019 		.word	422623708
 895 028c 4C9D5176 		.word	1985060172
 896 0290 01E0F67F 		.word	2146885633
 897 0294 B2066168 		.word	1751189170
 898 0298 EAC0C611 		.word	298238186
 899 029c 01A8F67F 		.word	2146871297
 900 02a0 5B9C8122 		.word	578919515
 901 02a4 0DAE6411 		.word	291810829
 902 02a8 0148F67F 		.word	2146846721
 903 02ac 41366742 		.word	1114060353
 904 02b0 728F9736 		.word	915902322
 905 02b4 0118F67F 		.word	2146834433
 906 02b8 22105B7B 		.word	2069565474
 907 02bc 4447DA02 		.word	47859524
 908 02c0 01D8F57F 		.word	2146818049
 909 02c4 08398E5C 		.word	1552824584
 910 02c8 5F778526 		.word	646281055
 911 02cc 0130F57F 		.word	2146775041
 912 02d0 C7569F71 		.word	1906267847
 913 02d4 BBFE3C5F 		.word	1597832891
 914 02d8 01E8F47F 		.word	2146756609
 915 02dc BA4F1D6E 		.word	1847414714
 916 02e0 082E3349 		.word	1228090888
 917 02e4 01B8F47F 		.word	2146744321
 918 02e8 8690686C 		.word	1818792070
 919 02ec 25191E46 		.word	1176377637
 920 02f0 01A0F47F 		.word	2146738177
 921 02f4 DE56A442 		.word	1118066398
 922 02f8 4E95E13E 		.word	1054971214
 923 02fc 0198F47F 		.word	2146736129
 924 0300 BE541A03 		.word	52057278
 925 0304 49E4A237 		.word	933422153
 926 0308 0140F47F 		.word	2146713601
 927 030c 30294D23 		.word	592259376
 928 0310 4657D753 		.word	1406621510
 929 0314 01F8F37F 		.word	2146695169
 930 0318 1588AF0F 		.word	263161877
 931 031c 8D88405A 		.word	1514178701
 932 0320 0160F37F 		.word	2146656257
 933 0324 ABCFD928 		.word	685363115
 934 0328 0315EB16 		.word	384505091
 935 032c 0148F37F 		.word	2146650113
 936 0330 B8FD4B37 		.word	927727032
 937 0334 79BF0A20 		.word	537575289
 938 0338 0138F37F 		.word	2146646017
 939 033c 123D2203 		.word	52575506
 940 0340 65A4416B 		.word	1799464037
 941 0344 0130F37F 		.word	2146643969
 942 0348 247B1A4C 		.word	1276803876
 943 034c 30696750 		.word	1348954416
 944 0350 0190F27F 		.word	2146603009
 945 0354 59178530 		.word	814028633
 946 0358 B8F9B05A 		.word	1521547704
 947 035c 0118F27F 		.word	2146572289
 948 0360 5815126E 		.word	1846678872
 949 0364 F9B5214E 		.word	1310832121
 950 0368 01B8F17F 		.word	2146547713
 951 036c 9A71CC36 		.word	919368090
 952 0370 4556BD3C 		.word	1019041349
 953 0374 0120F17F 		.word	2146508801
 954 0378 BC940B28 		.word	671847612
 955 037c E0B84C02 		.word	38582496
 956 0380 01E0F07F 		.word	2146492417
 957 0384 0026EC10 		.word	283911680
 958 0388 7227BC1F 		.word	532424562
 959 038c 01D8F07F 		.word	2146490369
 960 0390 1B54196A 		.word	1780044827
 961 0394 EAB56E35 		.word	896447978
 962 0398 0160F07F 		.word	2146459649
 963 039c 32978C13 		.word	327980850
 964 03a0 5440264F 		.word	1327906900
 965 03a4 0130F07F 		.word	2146447361
 966 03a8 D5941D4E 		.word	1310561493
 967 03ac 05C42339 		.word	958645253
 968 03b0 0118F07F 		.word	2146441217
 969 03b4 BEE49018 		.word	412148926
 970 03b8 D8681F11 		.word	287271128
 971 03bc 0108F07F 		.word	2146437121
 972 03c0 91AB7911 		.word	293186449
 973 03c4 4675CB77 		.word	2009822534
 974 03c8 01F0EF7F 		.word	2146430977
 975 03cc F4D8AB0A 		.word	179034356
 976 03d0 80110351 		.word	1359155584
 977 03d4 01C0EF7F 		.word	2146418689
 978 03d8 D0DA705A 		.word	1517345488
 979 03dc E006B56A 		.word	1790248672
 980 03e0 0190EF7F 		.word	2146406401
 981 03e4 66764F60 		.word	1615820390
 982 03e8 23A4765E 		.word	1584833571
 983 03ec 0188EF7F 		.word	2146404353
 984 03f0 35B34531 		.word	826651445
 985 03f4 72EC2F24 		.word	607120498
 986 03f8 0128EF7F 		.word	2146379777
 987 03fc 1C3E3A00 		.word	3816988
 988 0400 EFAB1271 		.word	1897049071
 989 0404 01E8EE7F 		.word	2146363393
 990 0408 F83BCD48 		.word	1221409784
 991 040c 5F046E76 		.word	1986921567
 992 0410 01C8EE7F 		.word	2146355201
 993 0414 1070BC52 		.word	1388081168
 994 0418 F87BA932 		.word	849968120
 995 041c 0180EE7F 		.word	2146336769
 996 0420 55D17E6B 		.word	1803473237
 997 0424 E498AD62 		.word	1655544036
 998 0428 0120EE7F 		.word	2146312193
 999 042c 3124013D 		.word	1023484977
 1000 0430 97E64F10 		.word	273671831
 1001 0434 01D8ED7F 		.word	2146293761
 1002 0438 D8F60C40 		.word	1074591448
 1003 043c 8710DC1B 		.word	467406983
 1004 0440 01B0ED7F 		.word	2146283521
 1005 0444 BC479131 		.word	831604668
 1006 0448 9EA3D55A 		.word	1523950494
 1007 044c 0178EC7F 		.word	2146203649
 1008 0450 8F767D2A 		.word	712865423
 1009 0454 8E84C945 		.word	1170834574
 1010 0458 01B8EB7F 		.word	2146154497
 1011 045c 82A13369 		.word	1764991362
 1012 0460 BB6C783F 		.word	1064856763
 1013 0464 0188EB7F 		.word	2146142209
 1014 0468 65276525 		.word	627386213
 1015 046c 57ADDA53 		.word	1406840151
 1016 0470 0150EB7F 		.word	2146127873
 1017 0474 FD2FAC61 		.word	1638674429
 1018 0478 415B7A7C 		.word	2088393537
 1019 047c 01E0EA7F 		.word	2146099201
 1020 0480 FA565C5A 		.word	1516001018
 1021 0484 DAD62A29 		.word	690673370
 1022 0488 01C8EA7F 		.word	2146093057
 1023 048c C1152F4D 		.word	1294931393
 1024 0490 629AC812 		.word	315136610
 1025 0494 01C0EA7F 		.word	2146091009
 1026 0498 2DAAC673 		.word	1942399533
 1027 049c 6108073A 		.word	973539425
 1028 04a0 0190EA7F 		.word	2146078721
 1029 04a4 B6FEE06D 		.word	1843461814
 1030 04a8 ECF0177F 		.word	2132275436
 1031 04ac 0148EA7F 		.word	2146060289
 1032 04b0 2A747D41 		.word	1098740778
 1033 04b4 39A07B15 		.word	360423481
 1034 04b8 0118EA7F 		.word	2146048001
 1035 04bc 30B76460 		.word	1617213232
 1036 04c0 EEDE5874 		.word	1951981294
 1037 04c4 0100EA7F 		.word	2146041857
 1038 04c8 8110A26B 		.word	1805783169
 1039 04cc A16AB87B 		.word	2075683489
 1040 04d0 01A8E97F 		.word	2146019329
 1041 04d4 05D13610 		.word	272027909
 1042 04d8 4E038068 		.word	1753219918
 1043 04dc 0128E97F 		.word	2145986561
 1044 04e0 2831EA47 		.word	1206530344
 1045 04e4 56CE3C79 		.word	2034028118
 1046 04e8 0100E97F 		.word	2145976321
 1047 04ec 106A224A 		.word	1243769360
 1048 04f0 6C52F045 		.word	1173377644
 1049 04f4 01D0E87F 		.word	2145964033
 1050 04f8 479CE134 		.word	887200839
 1051 04fc 4AC45F4C 		.word	1281344586
 1052 0500 01F0E77F 		.word	2145906689
 1053 0504 17AA6862 		.word	1651026455
 1054 0508 A82E0336 		.word	906178216
 1055 050c 0178E77F 		.word	2145875969
 1056 0510 F096BB63 		.word	1673238256
 1057 0514 BCDE323E 		.word	1043521212
 1058 0518 0168E77F 		.word	2145871873
 1059 051c EA4B1C49 		.word	1226591210
 1060 0520 0C336F53 		.word	1399796492
 1061 0524 01F0E67F 		.word	2145841153
 1062 0528 B5845757 		.word	1465353397
 1063 052c BAB0F24E 		.word	1324527802
 1064 0530 01D0E67F 		.word	2145832961
 1065 0534 395B9544 		.word	1150638905
 1066 0538 97A90621 		.word	554084759
 1067 053c 0190E67F 		.word	2145816577
 1068 0540 AA5F350D 		.word	221601706
 1069 0544 3FB47819 		.word	427340863
 1070 0548 0118E67F 		.word	2145785857
 1071 054c F9064B24 		.word	608896761
 1072 0550 92CADE12 		.word	316590738
 1073 0554 01A0E57F 		.word	2145755137
 1074 0558 9EE20B66 		.word	1712054942
 1075 055c A04A6464 		.word	1684294304
 1076 0560 0170E57F 		.word	2145742849
 1077 0564 93909F4D 		.word	1302302867
 1078 0568 9CAF342B 		.word	724873116
 1079 056c 0138E57F 		.word	2145728513
 1080 0570 7D7CCC1E 		.word	516717693
 1081 0574 B4C8BA19 		.word	431671476
 1082 0578 01C8E47F 		.word	2145699841
 1083 057c 5B63441F 		.word	524575579
 1084 0580 29018B60 		.word	1619722537
 1085 0584 01A8E47F 		.word	2145691649
 1086 0588 97B5C672 		.word	1925625239
 1087 058c E3FF963A 		.word	982974435
 1088 0590 0198E47F 		.word	2145687553
 1089 0594 CEF5A41B 		.word	463795662
 1090 0598 FCF7134D 		.word	1293154300
 1091 059c 0160E47F 		.word	2145673217
 1092 05a0 1C76FF2D 		.word	771716636
 1093 05a4 6DDD8E34 		.word	881778029
 1094 05a8 01B8E37F 		.word	2145630209
 1095 05ac F102FA59 		.word	1509556977
 1096 05b0 FC2CE931 		.word	837364988
 1097 05b4 0130E37F 		.word	2145595393
 1098 05b8 10AAA70D 		.word	229091856
 1099 05bc AB1FC332 		.word	851648427
 1100 05c0 0110E37F 		.word	2145587201
 1101 05c4 49911A6B 		.word	1796903241
 1102 05c8 588EDE25 		.word	635342424
 1103 05cc 0120E27F 		.word	2145525761
 1104 05d0 22C7A22A 		.word	715310882
 1105 05d4 3178F863 		.word	1677228081
 1106 05d8 01A8E17F 		.word	2145495041
 1107 05dc DA560B3E 		.word	1040930522
 1108 05e0 4839F60B 		.word	200685896
 1109 05e4 0138E17F 		.word	2145466369
 1110 05e8 CDDC9C38 		.word	949804237
 1111 05ec D261D56B 		.word	1809146322
 1112 05f0 01E8E07F 		.word	2145445889
 1113 05f4 5ABEC563 		.word	1673903706
 1114 05f8 916BAE05 		.word	95316881
 1115 05fc 0110E07F 		.word	2145390593
 1116 0600 9CF41830 		.word	806941852
 1117 0604 9FCA2755 		.word	1428671135
 1118 0608 01C8DF7F 		.word	2145372161
 1119 060c 6CD69853 		.word	1402525292
 1120 0610 A67F7F09 		.word	159350694
 1121 0614 01A0DF7F 		.word	2145361921
 1122 0618 EA44A57E 		.word	2124760298
 1123 061c 9D45B85E 		.word	1589134749
 1124 0620 0198DF7F 		.word	2145359873
 1125 0624 5B9F9148 		.word	1217503067
 1126 0628 6241135D 		.word	1561543010
 1127 062c 0188DF7F 		.word	2145355777
 1128 0630 1AAE2A14 		.word	338341402
 1129 0634 6FB0FF04 		.word	83865711
 1130 0638 0158DF7F 		.word	2145343489
 1131 063c 04825852 		.word	1381532164
 1132 0640 F2713B26 		.word	641430002
 1133 0644 0110DF7F 		.word	2145325057
 1134 0648 B6F64970 		.word	1883895478
 1135 064c 87991A5B 		.word	1528469895
 1136 0650 01F8DE7F 		.word	2145318913
 1137 0654 B822984F 		.word	1335370424
 1138 0658 4C2DEC03 		.word	65809740
 1139 065c 01E0DE7F 		.word	2145312769
 1140 0660 6AB33577 		.word	2000008042
 1141 0664 10746D72 		.word	1919775760
 1142 0668 01B0DE7F 		.word	2145300481
 1143 066c D2934E39 		.word	961450962
 1144 0670 E24C4949 		.word	1229540578
 1145 0674 0168DE7F 		.word	2145282049
 1146 0678 CF9E4436 		.word	910466767
 1147 067c ED371175 		.word	1964062701
 1148 0680 01A8DD7F 		.word	2145232897
 1149 0684 8D38AB30 		.word	816527501
 1150 0688 7FC6D41A 		.word	450152063
 1151 068c 0170DD7F 		.word	2145218561
 1152 0690 FA508A55 		.word	1435128058
 1153 0694 840BF66A 		.word	1794509700
 1154 0698 01F8DC7F 		.word	2145187841
 1155 069c 1F40FF01 		.word	33505311
 1156 06a0 7E50D84B 		.word	1272467582
 1157 06a4 01E0DC7F 		.word	2145181697
 1158 06a8 09531410 		.word	269767433
 1159 06ac 49AE4652 		.word	1380363849
 1160 06b0 01C8DC7F 		.word	2145175553
 1161 06b4 FB625C03 		.word	56386299
 1162 06b8 92D97D4E 		.word	1316870546
 1163 06bc 0150DB7F 		.word	2145079297
 1164 06c0 2571947D 		.word	2106880293
 1165 06c4 5C24F552 		.word	1391797340
 1166 06c8 0170DA7F 		.word	2145021953
 1167 06cc 686A5750 		.word	1347906152
 1168 06d0 4E1FF22A 		.word	720510798
 1169 06d4 0158DA7F 		.word	2145015809
 1170 06d8 6E0C530C 		.word	206769262
 1171 06dc 73476F62 		.word	1651459955
 1172 06e0 0128DA7F 		.word	2145003521
 1173 06e4 14A66270 		.word	1885513236
 1174 06e8 A44F0D53 		.word	1393381284
 1175 06ec 0180D97F 		.word	2144960513
 1176 06f0 033AE86B 		.word	1810381315
 1177 06f4 FB52E701 		.word	31937275
 1178 06f8 0140D97F 		.word	2144944129
 1179 06fc 1E6CDF4D 		.word	1306487838
 1180 0700 80E55D78 		.word	2019419520
 1181 0704 0120D97F 		.word	2144935937
 1182 0708 9A393902 		.word	37304730
 1183 070c 9EE4C26D 		.word	1841489054
 1184 0710 0180D87F 		.word	2144894977
 1185 0714 F8F3735F 		.word	1601434616
 1186 0718 27AC6A09 		.word	157985831
 1187 071c 0168D87F 		.word	2144888833
 1188 0720 92CBE205 		.word	98749330
 1189 0724 64BDDF7E 		.word	2128592228
 1190 0728 0148D87F 		.word	2144880641
 1191 072c 5A90A369 		.word	1772327002
 1192 0730 5834BF7B 		.word	2076128344
 1193 0734 0108D87F 		.word	2144864257
 1194 0738 CA31B753 		.word	1404514762
 1195 073c 2CE2FE78 		.word	2029969964
 1196 0740 0178D77F 		.word	2144827393
 1197 0744 72E6C12F 		.word	801236594
 1198 0748 94A33C18 		.word	406627220
 1199 074c 0128D77F 		.word	2144806913
 1200 0750 A3A2D014 		.word	349217443
 1201 0754 E2AA7859 		.word	1501080290
 1202 0758 0100D77F 		.word	2144796673
 1203 075c 0813F35B 		.word	1542656776
 1204 0760 078E427C 		.word	2084736519
 1205 0764 01B8D67F 		.word	2144778241
 1206 0768 24592A48 		.word	1210734884
 1207 076c 4B321868 		.word	1746416203
 1208 0770 0170D67F 		.word	2144759809
 1209 0774 C3B55744 		.word	1146598851
 1210 0778 6961B42A 		.word	716464489
 1211 077c 0168D67F 		.word	2144757761
 1212 0780 50061111 		.word	286328400
 1213 0784 31E2B36C 		.word	1823728177
 1214 0788 01F8D57F 		.word	2144729089
 1215 078c 6F115250 		.word	1347555695
 1216 0790 11FA786D 		.word	1836644881
 1217 0794 01F0D57F 		.word	2144727041
 1218 0798 EE43086B 		.word	1795703790
 1219 079c DC17031F 		.word	520296412
 1220 07a0 0178D57F 		.word	2144696321
 1221 07a4 9531A24D 		.word	1302475157
 1222 07a8 B933D732 		.word	852964281
 1223 07ac 0108D57F 		.word	2144667649
 1224 07b0 EE962040 		.word	1075877614
 1225 07b4 9F94191E 		.word	504992927
 1226 07b8 0198D37F 		.word	2144573441
 1227 07bc F0ECD80B 		.word	198765808
 1228 07c0 96AC6360 		.word	1617144982
 1229 07c4 0150D37F 		.word	2144555009
 1230 07c8 BF232A13 		.word	321528767
 1231 07cc CBA44909 		.word	155821259
 1232 07d0 0140D37F 		.word	2144550913
 1233 07d4 7CC88630 		.word	814139516
 1234 07d8 6C0B7A6C 		.word	1819937644
 1235 07dc 0108D37F 		.word	2144536577
 1236 07e0 26F40A22 		.word	571143206
 1237 07e4 2F556539 		.word	962942255
 1238 07e8 01D8D27F 		.word	2144524289
 1239 07ec C60A1D68 		.word	1746733766
 1240 07f0 99B52500 		.word	2471321
 1241 07f4 01A8D27F 		.word	2144512001
 1242 07f8 A596906C 		.word	1821415077
 1243 07fc DB006707 		.word	124190939
 1244 0800 0100D27F 		.word	2144468993
 1245 0804 BA9BB536 		.word	917871546
 1246 0808 662F1B4B 		.word	1260072806
 1247 080c 01D8D17F 		.word	2144458753
 1248 0810 3D338E16 		.word	378417981
 1249 0814 F3B5885D 		.word	1569240563
 1250 0818 0148D17F 		.word	2144421889
 1251 081c E4CA710A 		.word	175229668
 1252 0820 1BC3D06C 		.word	1825620763
 1253 0824 0118D17F 		.word	2144409601
 1254 0828 43FE4765 		.word	1699216963
 1255 082c 75B9F514 		.word	351648117
 1256 0830 0180D07F 		.word	2144370689
 1257 0834 A7AEE33F 		.word	1071885991
 1258 0838 2DC21C39 		.word	958186029
 1259 083c 0128D07F 		.word	2144348161
 1260 0840 7B8D1769 		.word	1763151227
 1261 0844 26243520 		.word	540353574
 1262 0848 01F8CF7F 		.word	2144335873
 1263 084c 1498313F 		.word	1060214804
 1264 0850 FFF6CF36 		.word	919598847
 1265 0854 01E0CF7F 		.word	2144329729
 1266 0858 C6728C27 		.word	663515846
 1267 085c DC285756 		.word	1448552668
 1268 0860 01D8CF7F 		.word	2144327681
 1269 0864 B1620C3F 		.word	1057776305
 1270 0868 F8152E23 		.word	590222840
 1271 086c 0190CF7F 		.word	2144309249
 1272 0870 F082A265 		.word	1705149168
 1273 0874 A011FB56 		.word	1459294624
 1274 0878 0160CF7F 		.word	2144296961
 1275 087c E9AC6B13 		.word	325823721
 1276 0880 66004A62 		.word	1649016934
 1277 0884 0148CF7F 		.word	2144290817
 1278 0888 EDD2082C 		.word	738775789
 1279 088c 8632AB1A 		.word	447427206
 1280 0890 0190CE7F 		.word	2144243713
 1281 0894 62425C39 		.word	962347618
 1282 0898 67DD3A35 		.word	893050215
 1283 089c 0178CE7F 		.word	2144237569
 1284 08a0 F537A962 		.word	1655257077
 1285 08a4 BE0BB235 		.word	900860862
 1286 08a8 0150CD7F 		.word	2144161793
 1287 08ac E6C76F0E 		.word	242206694
 1288 08b0 00C7735D 		.word	1567868672
 1289 08b4 0138CD7F 		.word	2144155649
 1290 08b8 8C58DC2D 		.word	769415308
 1291 08bc 2EDD624A 		.word	1247993134
 1292 08c0 01F0CC7F 		.word	2144137217
 1293 08c4 F7511A13 		.word	320492023
 1294 08c8 2E1CBF1E 		.word	515841070
 1295 08cc 01B0CC7F 		.word	2144120833
 1296 08d0 6A15B761 		.word	1639388522
 1297 08d4 76A7F22D 		.word	770877302
 1298 08d8 01F0CB7F 		.word	2144071681
 1299 08dc 91B50269 		.word	1761785233
 1300 08e0 B8FD7939 		.word	964296120
 1301 08e4 01D8CB7F 		.word	2144065537
 1302 08e8 61E90519 		.word	419817825
 1303 08ec F867310C 		.word	204564472
 1304 08f0 0148CB7F 		.word	2144028673
 1305 08f4 2520B327 		.word	666050597
 1306 08f8 F06DA27C 		.word	2091019760
 1307 08fc 0100CB7F 		.word	2144010241
 1308 0900 0FB44254 		.word	1413657615
 1309 0904 1290855A 		.word	1518702610
 1310 0908 0120CA7F 		.word	2143952897
 1311 090c 8A62CF49 		.word	1238327946
 1312 0910 CF2E5A1C 		.word	475672271
 1313 0914 01F0C97F 		.word	2143940609
 1314 0918 756A4D12 		.word	307063413
 1315 091c FECA2346 		.word	1176750846
 1316 0920 0198C97F 		.word	2143918081
 1317 0924 D770F57A 		.word	2062905559
 1318 0928 0B66E52E 		.word	786785803
 1319 092c 0150C97F 		.word	2143899649
 1320 0930 51FBC14F 		.word	1338112849
 1321 0934 73AF1E5D 		.word	1562292083
 1322 0938 0130C97F 		.word	2143891457
 1323 093c 29E10F04 		.word	68149545
 1324 0940 F30D3205 		.word	87166451
 1325 0944 0118C97F 		.word	2143885313
 1326 0948 FACCF036 		.word	921750778
 1327 094c B6FE8217 		.word	394460854
 1328 0950 01A0C87F 		.word	2143854593
 1329 0954 41C4E62A 		.word	719766593
 1330 0958 CCCDFA07 		.word	133877196
 1331 095c 0158C87F 		.word	2143836161
 1332 0960 2A738244 		.word	1149399850
 1333 0964 43A3F56E 		.word	1861591875
 1334 0968 0138C77F 		.word	2143762433
 1335 096c 2686316E 		.word	1848739366
 1336 0970 C1BCA04F 		.word	1335934145
 1337 0974 0120C77F 		.word	2143756289
 1338 0978 1673134F 		.word	1326674710
 1339 097c C4A42306 		.word	102999236
 1340 0980 0178C67F 		.word	2143713281
 1341 0984 5F0B2A30 		.word	808061791
 1342 0988 D4E5F444 		.word	1156900308
 1343 098c 0120C67F 		.word	2143690753
 1344 0990 63812617 		.word	388399459
 1345 0994 B391D372 		.word	1926468019
 1346 0998 01D0C57F 		.word	2143670273
 1347 099c AEE41B55 		.word	1427891374
 1348 09a0 F9F3B468 		.word	1756689401
 1349 09a4 01C0C57F 		.word	2143666177
 1350 09a8 7D75F971 		.word	1912173949
 1351 09ac BDC5CE3A 		.word	986629565
 1352 09b0 0170C57F 		.word	2143645697
 1353 09b4 AFA1A979 		.word	2041160111
 1354 09b8 31DF2916 		.word	371842865
 1355 09bc 0160C57F 		.word	2143641601
 1356 09c0 51D4494C 		.word	1279906897
 1357 09c4 CE65A378 		.word	2023974350
 1358 09c8 0148C57F 		.word	2143635457
 1359 09cc 568CF12A 		.word	720473174
 1360 09d0 C6E0CA52 		.word	1389027526
 1361 09d4 0110C57F 		.word	2143621121
 1362 09d8 4FA1624D 		.word	1298309455
 1363 09dc C6DD4567 		.word	1732632006
 1364 09e0 01B8C47F 		.word	2143598593
 1365 09e4 683C505C 		.word	1548762216
 1366 09e8 22A9CD6C 		.word	1825417506
 1367 09ec 0140C47F 		.word	2143567873
 1368 09f0 88B5FB24 		.word	620475784
 1369 09f4 61B10040 		.word	1073787233
 1370 09f8 0128C47F 		.word	2143561729
 1371 09fc CF8B3673 		.word	1932954575
 1372 0a00 CD249338 		.word	949167309
 1373 0a04 0108C47F 		.word	2143553537
 1374 0a08 886D1E15 		.word	354315656
 1375 0a0c 9E177862 		.word	1652037534
 1376 0a10 01D8C37F 		.word	2143541249
 1377 0a14 A0CB6A22 		.word	577424288
 1378 0a18 22506341 		.word	1097027618
 1379 0a1c 01B0C37F 		.word	2143531009
 1380 0a20 A68D5415 		.word	357862822
 1381 0a24 B777871C 		.word	478640055
 1382 0a28 0190C37F 		.word	2143522817
 1383 0a2c 29C04378 		.word	2017706025
 1384 0a30 543C6B5C 		.word	1550531668
 1385 0a34 0150C37F 		.word	2143506433
 1386 0a38 3BB5DD7B 		.word	2078127419
 1387 0a3c A5EABC6C 		.word	1824320165
 1388 0a40 0108C37F 		.word	2143488001
 1389 0a44 D5E39024 		.word	613475285
 1390 0a48 F6459B5F 		.word	1604011510
 1391 0a4c 01C0C27F 		.word	2143469569
 1392 0a50 AB766A57 		.word	1466594987
 1393 0a54 5C5DED1D 		.word	502095196
 1394 0a58 0118C27F 		.word	2143426561
 1395 0a5c BB1D7C42 		.word	1115430331
 1396 0a60 B7E5433E 		.word	1044637111
 1397 0a64 0170C17F 		.word	2143383553
 1398 0a68 7D339500 		.word	9778045
 1399 0a6c F64A6571 		.word	1902463734
 1400 0a70 0158C17F 		.word	2143377409
 1401 0a74 BC0ED45C 		.word	1557401276
 1402 0a78 4B38997A 		.word	2056861771
 1403 0a7c 0120C17F 		.word	2143363073
 1404 0a80 6749DD26 		.word	652036455
 1405 0a84 437F2D75 		.word	1965915971
 1406 0a88 0190BF7F 		.word	2143260673
 1407 0a8c 33BC4B57 		.word	1464581171
 1408 0a90 C510CB5A 		.word	1523257541
 1409 0a94 0158BF7F 		.word	2143246337
 1410 0a98 6150D36F 		.word	1876119649
 1411 0a9c DCFB912D 		.word	764541916
 1412 0aa0 01C8BE7F 		.word	2143209473
 1413 0aa4 21D54260 		.word	1614992673
 1414 0aa8 4C247B72 		.word	1920672844
 1415 0aac 01B0BE7F 		.word	2143203329
 1416 0ab0 8FAA793A 		.word	981052047
 1417 0ab4 81122D7A 		.word	2049774209
 1418 0ab8 0108BE7F 		.word	2143160321
 1419 0abc 8D681C6E 		.word	1847355533
 1420 0ac0 71926C2B 		.word	728535665
 1421 0ac4 0190BD7F 		.word	2143129601
 1422 0ac8 B9408D39 		.word	965558457
 1423 0acc C0DBF123 		.word	603052992
 1424 0ad0 0178BD7F 		.word	2143123457
 1425 0ad4 27479A7F 		.word	2140817191
 1426 0ad8 07647F00 		.word	8348679
 1427 0adc 0120BD7F 		.word	2143100929
 1428 0ae0 C35E395C 		.word	1547263683
 1429 0ae4 FFC96029 		.word	694209023
 1430 0ae8 0100BD7F 		.word	2143092737
 1431 0aec FA675A26 		.word	643459066
 1432 0af0 45670376 		.word	1979934533
 1433 0af4 01D8BC7F 		.word	2143082497
 1434 0af8 82DD3D0B 		.word	188603778
 1435 0afc B6FCC478 		.word	2026175670
 1436 0b00 0188BC7F 		.word	2143062017
 1437 0b04 1FD8C862 		.word	1657329695
 1438 0b08 5B727F16 		.word	377451099
 1439 0b0c 0160BC7F 		.word	2143051777
 1440 0b10 8E45DA06 		.word	114967950
 1441 0b14 B1405E3A 		.word	979255473
 1442 0b18 01F8BB7F 		.word	2143025153
 1443 0b1c 6E013C65 		.word	1698431342
 1444 0b20 60FD6056 		.word	1449196896
 1445 0b24 01B0BB7F 		.word	2143006721
 1446 0b28 AB2E076F 		.word	1862741675
 1447 0b2c 3DF5B067 		.word	1739650365
 1448 0b30 0188BB7F 		.word	2142996481
 1449 0b34 E9B8192D 		.word	756660457
 1450 0b38 3232603B 		.word	996160050
 1451 0b3c 0138BB7F 		.word	2142976001
 1452 0b40 CA144E37 		.word	927864010
 1453 0b44 56AE8C45 		.word	1166847574
 1454 0b48 0110BB7F 		.word	2142965761
 1455 0b4c DD47F235 		.word	905070557
 1456 0b50 26EE7427 		.word	661974566
 1457 0b54 0150BA7F 		.word	2142916609
 1458 0b58 92957002 		.word	40932754
 1459 0b5c 27EA856A 		.word	1787161127
 1460 0b60 01F0B97F 		.word	2142892033
 1461 0b64 F0407E76 		.word	1987985648
 1462 0b68 D6CC4028 		.word	675335382
 1463 0b6c 01D8B97F 		.word	2142885889
 1464 0b70 7BD7882F 		.word	797497211
 1465 0b74 A5DBDC4E 		.word	1323096997
 1466 0b78 01A0B97F 		.word	2142871553
 1467 0b7c E691437B 		.word	2068025830
 1468 0b80 27892754 		.word	1411877159
 1469 0b84 0178B97F 		.word	2142861313
 1470 0b88 02A68C48 		.word	1217177090
 1471 0b8c BF67BC55 		.word	1438410687
 1472 0b90 0100B97F 		.word	2142830593
 1473 0b94 C7AC6E18 		.word	409906375
 1474 0b98 9A695F69 		.word	1767860634
 1475 0b9c 0198B87F 		.word	2142803969
 1476 0ba0 41CF6447 		.word	1197788993
 1477 0ba4 07DA7115 		.word	359782919
 1478 0ba8 0150B87F 		.word	2142785537
 1479 0bac 95DF5F26 		.word	643817365
 1480 0bb0 3EFEA11E 		.word	513932862
 1481 0bb4 0138B87F 		.word	2142779393
 1482 0bb8 420C5866 		.word	1717046338
 1483 0bbc 91CE0C0D 		.word	218943121
 1484 0bc0 0160B77F 		.word	2142724097
 1485 0bc4 FE2B5305 		.word	89336830
 1486 0bc8 C923D618 		.word	416687049
 1487 0bcc 0120B77F 		.word	2142707713
 1488 0bd0 05B55A00 		.word	5944581
 1489 0bd4 D354DF50 		.word	1356813523
 1490 0bd8 0160B67F 		.word	2142658561
 1491 0bdc F7EBEC34 		.word	887942135
 1492 0be0 4AE89E7B 		.word	2074011722
 1493 0be4 0110B67F 		.word	2142638081
 1494 0be8 C4130D09 		.word	151851972
 1495 0bec A3693062 		.word	1647339939
 1496 0bf0 01F0B47F 		.word	2142564353
 1497 0bf4 8153D264 		.word	1691505537
 1498 0bf8 086C6658 		.word	1483107336
 1499 0bfc 0178B47F 		.word	2142533633
 1500 0c00 C8C59B76 		.word	1989920200
 1501 0c04 010DB543 		.word	1135938817
 1502 0c08 0168B47F 		.word	2142529537
 1503 0c0c 96312D39 		.word	959263126
 1504 0c10 01E24F5B 		.word	1531961857
 1505 0c14 0160B47F 		.word	2142527489
 1506 0c18 3910041B 		.word	453251129
 1507 0c1c D20CDA66 		.word	1725566162
 1508 0c20 0100B47F 		.word	2142502913
 1509 0c24 C6ED8D5B 		.word	1536028102
 1510 0c28 89E9D90A 		.word	182053257
 1511 0c2c 01F0B37F 		.word	2142498817
 1512 0c30 6AA0FB21 		.word	570138730
 1513 0c34 772DCF29 		.word	701443447
 1514 0c38 01B0B27F 		.word	2142416897
 1515 0c3c 281A7D13 		.word	326965800
 1516 0c40 AB948D18 		.word	411931819
 1517 0c44 01E0B17F 		.word	2142363649
 1518 0c48 02A0E063 		.word	1675665410
 1519 0c4c 35826E5A 		.word	1517191733
 1520 0c50 01B0B17F 		.word	2142351361
 1521 0c54 9E96BA39 		.word	968529566
 1522 0c58 BF77EB5D 		.word	1575712703
 1523 0c5c 0160B17F 		.word	2142330881
 1524 0c60 96B58C52 		.word	1384953238
 1525 0c64 8C237269 		.word	1769087884
 1526 0c68 0120B17F 		.word	2142314497
 1527 0c6c FA44D975 		.word	1977173242
 1528 0c70 74BC4C6D 		.word	1833745524
 1529 0c74 01C0B07F 		.word	2142289921
 1530 0c78 49D7AA05 		.word	95082313
 1531 0c7c C5653566 		.word	1714775493
 1532 0c80 01A8B07F 		.word	2142283777
 1533 0c84 4FF88406 		.word	109377615
 1534 0c88 D5D2CF3F 		.word	1070584533
 1535 0c8c 0190B07F 		.word	2142277633
 1536 0c90 FECB0201 		.word	16960510
 1537 0c94 5911DA29 		.word	702157145
 1538 0c98 0158B07F 		.word	2142263297
 1539 0c9c C3170321 		.word	553850819
 1540 0ca0 2B19B619 		.word	431364395
 1541 0ca4 0180AF7F 		.word	2142208001
 1542 0ca8 FF7B640E 		.word	241466367
 1543 0cac 6E106D7A 		.word	2053967982
 1544 0cb0 01D8AE7F 		.word	2142164993
 1545 0cb4 0E9E076B 		.word	1795661326
 1546 0cb8 B094803D 		.word	1031836848
 1547 0cbc 01D0AD7F 		.word	2142097409
 1548 0cc0 7EBD4548 		.word	1212530046
 1549 0cc4 BF097C2A 		.word	712772031
 1550 0cc8 01A8AD7F 		.word	2142087169
 1551 0ccc 18842269 		.word	1763869720
 1552 0cd0 E3EF0231 		.word	822276067
 1553 0cd4 0188AD7F 		.word	2142078977
 1554 0cd8 B1A96326 		.word	644065713
 1555 0cdc 62DA3769 		.word	1765268066
 1556 0ce0 0178AD7F 		.word	2142074881
 1557 0ce4 C83CB706 		.word	112671944
 1558 0ce8 3D875626 		.word	643204925
 1559 0cec 0100AD7F 		.word	2142044161
 1560 0cf0 FFECB752 		.word	1387785471
 1561 0cf4 7E3B5C4D 		.word	1297890174
 1562 0cf8 01B8AC7F 		.word	2142025729
 1563 0cfc E124B92E 		.word	783885537
 1564 0d00 0249A13B 		.word	1000425730
 1565 0d04 0180AC7F 		.word	2142011393
 1566 0d08 184FFB35 		.word	905662232
 1567 0d0c 49A01964 		.word	1679401033
 1568 0d10 01F0AB7F 		.word	2141974529
 1569 0d14 91CDAB2F 		.word	799788433
 1570 0d18 05F0E61B 		.word	468119557
 1571 0d1c 0178AB7F 		.word	2141943809
 1572 0d20 7C483073 		.word	1932544124
 1573 0d24 D3DBC71A 		.word	449305555
 1574 0d28 0150AB7F 		.word	2141933569
 1575 0d2c F8520A5B 		.word	1527403256
 1576 0d30 95E22D32 		.word	841867925
 1577 0d34 0148AB7F 		.word	2141931521
 1578 0d38 63E0544A 		.word	1247076451
 1579 0d3c 2CDA552C 		.word	743823916
 1580 0d40 01D8AA7F 		.word	2141902849
 1581 0d44 F35D8147 		.word	1199660531
 1582 0d48 6645F117 		.word	401687910
 1583 0d4c 01A8AA7F 		.word	2141890561
 1584 0d50 7ED6F208 		.word	150132350
 1585 0d54 4C428A66 		.word	1720336972
 1586 0d58 0128AA7F 		.word	2141857793
 1587 0d5c 52BFBC4C 		.word	1287438162
 1588 0d60 29039227 		.word	663880489
 1589 0d64 01C8A97F 		.word	2141833217
 1590 0d68 C333D624 		.word	618017731
 1591 0d6c 4AEA6E6C 		.word	1819208266
 1592 0d70 0198A97F 		.word	2141820929
 1593 0d74 0E5C943B 		.word	999578638
 1594 0d78 B074A153 		.word	1403090096
 1595 0d7c 0110A97F 		.word	2141786113
 1596 0d80 55B1E004 		.word	81834325
 1597 0d84 E569CF5A 		.word	1523542501
 1598 0d88 01D8A87F 		.word	2141771777
 1599 0d8c 88152707 		.word	120001928
 1600 0d90 8C4FA11B 		.word	463556492
 1601 0d94 01A8A87F 		.word	2141759489
 1602 0d98 BD854C07 		.word	122455485
 1603 0d9c 1AD5A77E 		.word	2124928282
 1604 0da0 0180A87F 		.word	2141749249
 1605 0da4 F9887608 		.word	141986041
 1606 0da8 D16F0C38 		.word	940339153
 1607 0dac 0188A77F 		.word	2141685761
 1608 0db0 DE6AFE34 		.word	889088734
 1609 0db4 FB99701C 		.word	477141499
 1610 0db8 0158A77F 		.word	2141673473
 1611 0dbc C9175313 		.word	324212681
 1612 0dc0 5AE1E842 		.word	1122558298
 1613 0dc4 0148A77F 		.word	2141669377
 1614 0dc8 EB601546 		.word	1175806187
 1615 0dcc 41CDE251 		.word	1373818177
 1616 0dd0 0110A77F 		.word	2141655041
 1617 0dd4 26066142 		.word	1113654822
 1618 0dd8 2A23B211 		.word	296887082
 1619 0ddc 0108A67F 		.word	2141587457
 1620 0de0 1A09133B 		.word	991103258
 1621 0de4 1320875E 		.word	1585913875
 1622 0de8 01F8A57F 		.word	2141583361
 1623 0dec 91738853 		.word	1401451409
 1624 0df0 10516F6B 		.word	1802457360
 1625 0df4 01D8A57F 		.word	2141575169
 1626 0df8 CE77B25D 		.word	1571977166
 1627 0dfc 94DE7B2A 		.word	712760980
 1628 0e00 0168A57F 		.word	2141546497
 1629 0e04 A0700842 		.word	1107849376
 1630 0e08 9D9B854A 		.word	1250270109
 1631 0e0c 01F0A47F 		.word	2141515777
 1632 0e10 DB06B70B 		.word	196544219
 1633 0e14 6A253815 		.word	356001130
 1634 0e18 01A0A47F 		.word	2141495297
 1635 0e1c B2335467 		.word	1733571506
 1636 0e20 A2AE393F 		.word	1060744866
 1637 0e24 0170A47F 		.word	2141483009
 1638 0e28 EB7F2A13 		.word	321552363
 1639 0e2c 42CCA245 		.word	1168297026
 1640 0e30 0110A47F 		.word	2141458433
 1641 0e34 8B2C261E 		.word	505818251
 1642 0e38 5B23B42B 		.word	733225819
 1643 0e3c 0190A27F 		.word	2141360129
 1644 0e40 2256343D 		.word	1026840098
 1645 0e44 048E8638 		.word	948342276
 1646 0e48 0108A27F 		.word	2141325313
 1647 0e4c B0985538 		.word	945133744
 1648 0e50 AEB3F47E 		.word	2129965998
 1649 0e54 01E8A17F 		.word	2141317121
 1650 0e58 64B9866F 		.word	1871100260
 1651 0e5c 1AD6E66D 		.word	1843844634
 1652 0e60 0170A17F 		.word	2141286401
 1653 0e64 8AFDBA6A 		.word	1790639498
 1654 0e68 A0FC5568 		.word	1750465696
 1655 0e6c 0128A17F 		.word	2141267969
 1656 0e70 E0311152 		.word	1376858592
 1657 0e74 5096180B 		.word	186160720
 1658 0e78 01F8A07F 		.word	2141255681
 1659 0e7c F89DF07E 		.word	2129698296
 1660 0e80 47D5DB6F 		.word	1876677959
 1661 0e84 01C8A07F 		.word	2141243393
 1662 0e88 D0087D7F 		.word	2138900688
 1663 0e8c 9CECDE4F 		.word	1340009628
 1664 0e90 0158A07F 		.word	2141214721
 1665 0e94 EBFF3773 		.word	1933049835
 1666 0e98 D5CED640 		.word	1087819477
 1667 0e9c 0150A07F 		.word	2141212673
 1668 0ea0 EB532B71 		.word	1898664939
 1669 0ea4 F133796A 		.word	1786328049
 1670 0ea8 0128A07F 		.word	2141202433
 1671 0eac CCC8053B 		.word	990234828
 1672 0eb0 B9AB1138 		.word	940682169
 1673 0eb4 01C09F7F 		.word	2141175809
 1674 0eb8 65D8D353 		.word	1406392421
 1675 0ebc 3258313B 		.word	993089586
 1676 0ec0 01989F7F 		.word	2141165569
 1677 0ec4 A3C24F4B 		.word	1263518371
 1678 0ec8 57163A11 		.word	289019479
 1679 0ecc 01309E7F 		.word	2141073409
 1680 0ed0 93D38C58 		.word	1485624211
 1681 0ed4 C265451E 		.word	507864514
 1682 0ed8 01E09D7F 		.word	2141052929
 1683 0edc C4DF5C70 		.word	1885134788
 1684 0ee0 F1558D12 		.word	311252465
 1685 0ee4 01B09D7F 		.word	2141040641
 1686 0ee8 3FDE974C 		.word	1285021247
 1687 0eec 26D5BE10 		.word	280941862
 1688 0ef0 01809D7F 		.word	2141028353
 1689 0ef4 067C0D5B 		.word	1527610374
 1690 0ef8 E6945A16 		.word	375035110
 1691 0efc 01409D7F 		.word	2141011969
 1692 0f00 F8DB7B53 		.word	1400626168
 1693 0f04 2C12D109 		.word	164696620
 1694 0f08 01109D7F 		.word	2140999681
 1695 0f0c 7832BA25 		.word	632959608
 1696 0f10 5BA99639 		.word	966175067
 1697 0f14 01089D7F 		.word	2140997633
 1698 0f18 32D2ED79 		.word	2045628978
 1699 0f1c DE68F14C 		.word	1290889438
 1700 0f20 01F89C7F 		.word	2140993537
 1701 0f24 23F03454 		.word	1412755491
 1702 0f28 6DA25F16 		.word	375366253
 1703 0f2c 01309C7F 		.word	2140942337
 1704 0f30 F059E22A 		.word	719477232
 1705 0f34 14C3CF2E 		.word	785367828
 1706 0f38 01F09B7F 		.word	2140925953
 1707 0f3c 3C11B202 		.word	45224252
 1708 0f40 7DC6DC31 		.word	836552317
 1709 0f44 01D09B7F 		.word	2140917761
 1710 0f48 4C2AFC44 		.word	1157376588
 1711 0f4c D1DBB63B 		.word	1001839569
 1712 0f50 01589B7F 		.word	2140887041
 1713 0f54 70479910 		.word	278480752
 1714 0f58 FC1E187D 		.word	2098732796
 1715 0f5c 01989A7F 		.word	2140837889
 1716 0f60 71802163 		.word	1663139953
 1717 0f64 5A911437 		.word	924094810
 1718 0f68 01D8997F 		.word	2140788737
 1719 0f6c 8733D52F 		.word	802501511
 1720 0f70 9EDAE979 		.word	2045368990
 1721 0f74 0180997F 		.word	2140766209
 1722 0f78 AD467C6C 		.word	1820083885
 1723 0f7c 50544E6B 		.word	1800295504
 1724 0f80 0178997F 		.word	2140764161
 1725 0f84 3119B645 		.word	1169561905
 1726 0f88 6318937D 		.word	2106792035
 1727 0f8c 0170987F 		.word	2140696577
 1728 0f90 7ACA9D07 		.word	127781498
 1729 0f94 CBE26970 		.word	1885987531
 1730 0f98 0140987F 		.word	2140684289
 1731 0f9c 8D5CF400 		.word	16014477
 1732 0fa0 DBEE7341 		.word	1098116827
 1733 0fa4 01C8977F 		.word	2140653569
 1734 0fa8 96C0B127 		.word	665960598
 1735 0fac B7E5176B 		.word	1796728247
 1736 0fb0 01E0967F 		.word	2140594177
 1737 0fb4 B3382C3E 		.word	1043085491
 1738 0fb8 DA4E7D16 		.word	377310938
 1739 0fbc 01A8967F 		.word	2140579841
 1740 0fc0 43034967 		.word	1732838211
 1741 0fc4 59F0AC59 		.word	1504505945
 1742 0fc8 0180967F 		.word	2140569601
 1743 0fcc 83400112 		.word	302071939
 1744 0fd0 48165B15 		.word	358291016
 1745 0fd4 0178967F 		.word	2140567553
 1746 0fd8 05B2770B 		.word	192393733
 1747 0fdc F71ECB71 		.word	1909137143
 1748 0fe0 0150967F 		.word	2140557313
 1749 0fe4 93283C18 		.word	406595731
 1750 0fe8 DE1D0E46 		.word	1175330270
 1751 0fec 0130967F 		.word	2140549121
 1752 0ff0 E6583D68 		.word	1748850918
 1753 0ff4 9FF84A1F 		.word	525007007
 1754 0ff8 0118957F 		.word	2140477441
 1755 0ffc 16CCC41D 		.word	499436566
 1756 1000 0640763D 		.word	1031159814
 1757 1004 01F8947F 		.word	2140469249
 1758 1008 B1246A70 		.word	1886004401
 1759 100c 58CF633D 		.word	1029951320
 1760 1010 0150947F 		.word	2140426241
 1761 1014 64596758 		.word	1483168100
 1762 1018 35E7E963 		.word	1676273461
 1763 101c 0138947F 		.word	2140420097
 1764 1020 F161176A 		.word	1779917297
 1765 1024 1C4F6D32 		.word	846024476
 1766 1028 0120947F 		.word	2140413953
 1767 102c 1D912B1F 		.word	522948893
 1768 1030 655D436C 		.word	1816354149
 1769 1034 01A8937F 		.word	2140383233
 1770 1038 79481E73 		.word	1931364473
 1771 103c 99724D4D 		.word	1296921241
 1772 1040 0168937F 		.word	2140366849
 1773 1044 0B8A4872 		.word	1917356555
 1774 1048 2C09C608 		.word	147196204
 1775 104c 0138937F 		.word	2140354561
 1776 1050 0141FB00 		.word	16466177
 1777 1054 CBE66850 		.word	1349052107
 1778 1058 0120937F 		.word	2140348417
 1779 105c 3CD4C76F 		.word	1875366972
 1780 1060 02C2E46E 		.word	1860485634
 1781 1064 01C0927F 		.word	2140323841
 1782 1068 1D9E351B 		.word	456498717
 1783 106c 6325B56A 		.word	1790256483
 1784 1070 01B8927F 		.word	2140321793
 1785 1074 D51A2061 		.word	1629493973
 1786 1078 104EF108 		.word	150031888
 1787 107c 01A0927F 		.word	2140315649
 1788 1080 9AB57D71 		.word	1904063898
 1789 1084 97049317 		.word	395510935
 1790 1088 0118927F 		.word	2140280833
 1791 108c 8845576A 		.word	1784104328
 1792 1090 356E8E31 		.word	831417909
 1793 1094 01A0917F 		.word	2140250113
 1794 1098 6394430F 		.word	256087139
 1795 109c EDB39029 		.word	697349101
 1796 10a0 0150917F 		.word	2140229633
 1797 10a4 6ED92817 		.word	388553070
 1798 10a8 AA3F890E 		.word	243875754
 1799 10ac 0138917F 		.word	2140223489
 1800 10b0 18548D2C 		.word	747459608
 1801 10b4 02673953 		.word	1396270850
 1802 10b8 01E0907F 		.word	2140200961
 1803 10bc FFAB3E1E 		.word	507423743
 1804 10c0 F122FC70 		.word	1895572209
 1805 10c4 0148907F 		.word	2140162049
 1806 10c8 20B79322 		.word	580106016
 1807 10cc 3DC3E879 		.word	2045297469
 1808 10d0 0118907F 		.word	2140149761
 1809 10d4 CCC3762A 		.word	712426444
 1810 10d8 CB79CD2E 		.word	785217995
 1811 10dc 01E88F7F 		.word	2140137473
 1812 10e0 A02FED55 		.word	1441607584
 1813 10e4 EFEEFF1F 		.word	536866543
 1814 10e8 01A08F7F 		.word	2140119041
 1815 10ec 96C3A714 		.word	346538902
 1816 10f0 DDECBC67 		.word	1740434653
 1817 10f4 01308F7F 		.word	2140090369
 1818 10f8 C5C9D810 		.word	282642885
 1819 10fc D6364101 		.word	21051094
 1820 1100 01F88E7F 		.word	2140076033
 1821 1104 E413E453 		.word	1407456228
 1822 1108 8D701113 		.word	319910029
 1823 110c 01888E7F 		.word	2140047361
 1824 1110 C4058560 		.word	1619330500
 1825 1114 06B9BA58 		.word	1488632070
 1826 1118 01708E7F 		.word	2140041217
 1827 111c 40D6897C 		.word	2089408064
 1828 1120 1615ED77 		.word	2012026134
 1829 1124 01F08D7F 		.word	2140008449
 1830 1128 403EA865 		.word	1705524800
 1831 112c F8262B60 		.word	1613440760
 1832 1130 01A88C7F 		.word	2139924481
 1833 1134 E9E60A6E 		.word	1846208233
 1834 1138 0929554C 		.word	1280649481
 1835 113c 01608C7F 		.word	2139906049
 1836 1140 23A3F93A 		.word	989438755
 1837 1144 FC85AB46 		.word	1185646076
 1838 1148 01C88B7F 		.word	2139867137
 1839 114c 62AEBC5A 		.word	1522314850
 1840 1150 EB393816 		.word	372783595
 1841 1154 01688B7F 		.word	2139842561
 1842 1158 B1FC3A64 		.word	1681587377
 1843 115c 6BD7EC0C 		.word	216848235
 1844 1160 01288B7F 		.word	2139826177
 1845 1164 BC01297B 		.word	2066284988
 1846 1168 28EE646A 		.word	1784999464
 1847 116c 01208B7F 		.word	2139824129
 1848 1170 96C5A91C 		.word	480888214
 1849 1174 137A335A 		.word	1513323027
 1850 1178 01988A7F 		.word	2139789313
 1851 117c B07E8A32 		.word	847937200
 1852 1180 DBFB2633 		.word	858192859
 1853 1184 01808A7F 		.word	2139783169
 1854 1188 32F0DE61 		.word	1642000434
 1855 118c 08A75E5E 		.word	1583261448
 1856 1190 01508A7F 		.word	2139770881
 1857 1194 C5EF1138 		.word	940699589
 1858 1198 5409B60A 		.word	179702100
 1859 119c 01488A7F 		.word	2139768833
 1860 11a0 4A07D012 		.word	315623242
 1861 11a4 44D27E39 		.word	964612676
 1862 11a8 01B8887F 		.word	2139666433
 1863 11ac B390C413 		.word	331649203
 1864 11b0 22E4932D 		.word	764666914
 1865 11b4 0158887F 		.word	2139641857
 1866 11b8 2F44497E 		.word	2118730799
 1867 11bc 24754E4E 		.word	1313764644
 1868 11c0 0140887F 		.word	2139635713
 1869 11c4 E395F11E 		.word	519149027
 1870 11c8 A18DF21E 		.word	519212449
 1871 11cc 01B0877F 		.word	2139598849
 1872 11d0 4239FB5A 		.word	1526413634
 1873 11d4 20FA7A69 		.word	1769667104
 1874 11d8 0150877F 		.word	2139574273
 1875 11dc 42DCD920 		.word	551148610
 1876 11e0 557FEB30 		.word	820739925
 1877 11e4 0138877F 		.word	2139568129
 1878 11e8 72E4A852 		.word	1386800242
 1879 11ec ADF9281C 		.word	472447405
 1880 11f0 01F0867F 		.word	2139549697
 1881 11f4 82FE8030 		.word	813760130
 1882 11f8 536C2E54 		.word	1412328531
 1883 11fc 01C0867F 		.word	2139537409
 1884 1200 F44F4760 		.word	1615286260
 1885 1204 23EEEC5F 		.word	1609362979
 1886 1208 01D0857F 		.word	2139475969
 1887 120c C36A9E50 		.word	1352559299
 1888 1210 25E62165 		.word	1696720421
 1889 1214 0180857F 		.word	2139455489
 1890 1218 C1C3813E 		.word	1048691649
 1891 121c E831785E 		.word	1584935400
 1892 1220 0128857F 		.word	2139432961
 1893 1224 F5BDD431 		.word	836025845
 1894 1228 BEB2A138 		.word	950121150
 1895 122c 0108857F 		.word	2139424769
 1896 1230 CD7BE15C 		.word	1558281165
 1897 1234 8A8C7B61 		.word	1635486858
 1898 1238 01C0847F 		.word	2139406337
 1899 123c DF520567 		.word	1728402143
 1900 1240 05ACCD63 		.word	1674423301
 1901 1244 0198847F 		.word	2139396097
 1902 1248 C6D9FA66 		.word	1727715782
 1903 124c D0F66B58 		.word	1483470544
 1904 1250 0168847F 		.word	2139383809
 1905 1254 F39E2341 		.word	1092853491
 1906 1258 0C38D067 		.word	1741699084
 1907 125c 0130847F 		.word	2139369473
 1908 1260 436B2C29 		.word	690776899
 1909 1264 759A134A 		.word	1242798709
 1910 1268 01E8837F 		.word	2139351041
 1911 126c 2C7A6D69 		.word	1768782380
 1912 1270 717F677E 		.word	2120712049
 1913 1274 01A8837F 		.word	2139334657
 1914 1278 F7CEB567 		.word	1739968247
 1915 127c 49181255 		.word	1427249225
 1916 1280 01A0837F 		.word	2139332609
 1917 1284 7F3B385C 		.word	1547189119
 1918 1288 62652225 		.word	623011170
 1919 128c 0148837F 		.word	2139310081
 1920 1290 8DF64650 		.word	1346827917
 1921 1294 EE78B15F 		.word	1605466350
 1922 1298 0130837F 		.word	2139303937
 1923 129c 3C580316 		.word	369317948
 1924 12a0 7F456031 		.word	828392831
 1925 12a4 0128837F 		.word	2139301889
 1926 12a8 D713025D 		.word	1560417239
 1927 12ac 03D5936A 		.word	1788073219
 1928 12b0 01E0827F 		.word	2139283457
 1929 12b4 D70EAC4D 		.word	1303121623
 1930 12b8 BE307823 		.word	595079358
 1931 12bc 0158827F 		.word	2139248641
 1932 12c0 96DFBC50 		.word	1354555286
 1933 12c4 31C22D22 		.word	573424177
 1934 12c8 0138827F 		.word	2139240449
 1935 12cc E863A203 		.word	60974056
 1936 12d0 9BF3CB34 		.word	885781403
 1937 12d4 01F0817F 		.word	2139222017
 1938 12d8 AD9E3115 		.word	355573421
 1939 12dc 77D1C748 		.word	1221054839
 1940 12e0 01D8817F 		.word	2139215873
 1941 12e4 02C4C321 		.word	566477826
 1942 12e8 6440C266 		.word	1724006500
 1943 12ec 01D8807F 		.word	2139150337
 1944 12f0 6915F133 		.word	871437673
 1945 12f4 EE6CE95F 		.word	1609133294
 1946 12f8 01C0807F 		.word	2139144193
 1947 12fc E27C1A58 		.word	1478130914
 1948 1300 C1BFCC43 		.word	1137491905
 1949 1304 0158807F 		.word	2139117569
 1950 1308 9A3C8F6E 		.word	1854880922
 1951 130c BB968039 		.word	964728507
 1952 1310 01B87F7F 		.word	2139076609
 1953 1314 D775100C 		.word	202405335
 1954 1318 1069172D 		.word	756508944
 1955 131c 01807F7F 		.word	2139062273
 1956 1320 9DF76D53 		.word	1399715741
 1957 1324 CB5FBD34 		.word	884826059
 1958 1328 01407F7F 		.word	2139045889
 1959 132c A6AFA53E 		.word	1051045798
 1960 1330 B492A947 		.word	1202295476
 1961 1334 01107F7F 		.word	2139033601
 1962 1338 86AAC965 		.word	1707715206
 1963 133c 8A22AF25 		.word	632234634
 1964 1340 01A87E7F 		.word	2139006977
 1965 1344 53A75879 		.word	2035853139
 1966 1348 C257CE0D 		.word	231626690
 1967 134c 01D07D7F 		.word	2138951681
 1968 1350 E499F50A 		.word	183867876
 1969 1354 1F38F831 		.word	838350879
 1970 1358 01B87D7F 		.word	2138945537
 1971 135c 85F7A353 		.word	1403254661
 1972 1360 AA921B18 		.word	404460202
 1973 1364 01587D7F 		.word	2138920961
 1974 1368 736C8712 		.word	310865011
 1975 136c C1AD774C 		.word	1282911681
 1976 1370 01307D7F 		.word	2138910721
 1977 1374 A93F2F4F 		.word	1328496553
 1978 1378 1FDD2A06 		.word	103472415
 1979 137c 01187D7F 		.word	2138904577
 1980 1380 41E0B204 		.word	78831681
 1981 1384 4DD0373B 		.word	993513549
 1982 1388 01107D7F 		.word	2138902529
 1983 138c 2BFCA84E 		.word	1319697451
 1984 1390 69D2EF3E 		.word	1055904361
 1985 1394 01C07B7F 		.word	2138816513
 1986 1398 B88BE816 		.word	384338872
 1987 139c 6595B265 		.word	1706202469
 1988 13a0 01A87B7F 		.word	2138810369
 1989 13a4 B3C6A940 		.word	1084868275
 1990 13a8 79242E18 		.word	405677177
 1991 13ac 01507B7F 		.word	2138787841
 1992 13b0 5C8CE917 		.word	401181788
 1993 13b4 0D121C75 		.word	1964773901
 1994 13b8 01207B7F 		.word	2138775553
 1995 13bc 7CE44C6E 		.word	1850532988
 1996 13c0 710B554A 		.word	1247087473
 1997 13c4 01007B7F 		.word	2138767361
 1998 13c8 8D2D1C34 		.word	874261901
 1999 13cc 5DF9F05D 		.word	1576073565
 2000 13d0 01D87A7F 		.word	2138757121
 2001 13d4 366DC746 		.word	1187474742
 2002 13d8 273D383B 		.word	993541415
 2003 13dc 01B87A7F 		.word	2138748929
 2004 13e0 082A3E6A 		.word	1782458888
 2005 13e4 53112E3E 		.word	1043206483
 2006 13e8 01A87A7F 		.word	2138744833
 2007 13ec 479ECE48 		.word	1221500487
 2008 13f0 BB2FB12F 		.word	800141243
 2009 13f4 01907A7F 		.word	2138738689
 2010 13f8 18FBA418 		.word	413465368
 2011 13fc CE527756 		.word	1450660558
 2012 1400 01E8797F 		.word	2138695681
 2013 1404 14EF0C2C 		.word	739045140
 2014 1408 10D66B14 		.word	342611472
 2015 140c 0158797F 		.word	2138658817
 2016 1410 7C90D050 		.word	1355845756
 2017 1414 8E311828 		.word	672674190
 2018 1418 0120797F 		.word	2138644481
 2019 141c 1A214324 		.word	608379162
 2020 1420 0C5CB95B 		.word	1538874380
 2021 1424 01F0787F 		.word	2138632193
 2022 1428 72A31F56 		.word	1444914034
 2023 142c 166FF128 		.word	686911254
 2024 1430 0190787F 		.word	2138607617
 2025 1434 EA0DE41C 		.word	484707818
 2026 1438 F6878A55 		.word	1435142134
 2027 143c 0150787F 		.word	2138591233
 2028 1440 3D842720 		.word	539460669
 2029 1444 B5D5EA4C 		.word	1290458549
 2030 1448 0108787F 		.word	2138572801
 2031 144c AEDEC87C 		.word	2093538990
 2032 1450 568ADF77 		.word	2011138646
 2033 1454 01B8777F 		.word	2138552321
 2034 1458 6C5B8844 		.word	1149786988
 2035 145c BBC92840 		.word	1076414907
 2036 1460 01A0777F 		.word	2138546177
 2037 1464 4EE21B32 		.word	840688206
 2038 1468 B98FB47D 		.word	2108985273
 2039 146c 0170777F 		.word	2138533889
 2040 1470 F34D7F0C 		.word	209669619
 2041 1474 FDDECF0B 		.word	198172413
 2042 1478 0148777F 		.word	2138523649
 2043 147c 0287C575 		.word	1975879426
 2044 1480 C0881D4C 		.word	1277003968
 2045 1484 01C8767F 		.word	2138490881
 2046 1488 C8389450 		.word	1351891144
 2047 148c FD75D475 		.word	1976858109
 2048 1490 0150767F 		.word	2138460161
 2049 1494 351E526C 		.word	1817321013
 2050 1498 D563F975 		.word	1979278293
 2051 149c 01D8757F 		.word	2138429441
 2052 14a0 F9D03B74 		.word	1950077177
 2053 14a4 0847200C 		.word	203441928
 2054 14a8 0168757F 		.word	2138400769
 2055 14ac 81C82D36 		.word	908970113
 2056 14b0 3D8C7425 		.word	628395069
 2057 14b4 0160757F 		.word	2138398721
 2058 14b8 B0441B0D 		.word	219890864
 2059 14bc E896352D 		.word	758486760
 2060 14c0 0108757F 		.word	2138376193
 2061 14c4 ABF6E14D 		.word	1306654379
 2062 14c8 AA4A443A 		.word	977554090
 2063 14cc 01A8747F 		.word	2138351617
 2064 14d0 62ABCF11 		.word	298822498
 2065 14d4 976C7D77 		.word	2004708503
 2066 14d8 0170747F 		.word	2138337281
 2067 14dc 981C501A 		.word	441457816
 2068 14e0 7C80863E 		.word	1049002108
 2069 14e4 0130747F 		.word	2138320897
 2070 14e8 8CBF765A 		.word	1517731724
 2071 14ec A949F755 		.word	1442269609
 2072 14f0 01B8737F 		.word	2138290177
 2073 14f4 1D90D150 		.word	1355911197
 2074 14f8 1F592D62 		.word	1647139103
 2075 14fc 01E0727F 		.word	2138234881
 2076 1500 5F32AB1F 		.word	531313247
 2077 1504 DAE01A68 		.word	1746591962
 2078 1508 0190727F 		.word	2138214401
 2079 150c F2B53671 		.word	1899410930
 2080 1510 FC77932E 		.word	781416444
 2081 1514 0160727F 		.word	2138202113
 2082 1518 3577176C 		.word	1813477173
 2083 151c E383B560 		.word	1622508515
 2084 1520 0138727F 		.word	2138191873
 2085 1524 BB09C240 		.word	1086458299
 2086 1528 677E1E3D 		.word	1025408615
 2087 152c 0118727F 		.word	2138183681
 2088 1530 2B462377 		.word	1998800427
 2089 1534 FAFB4B31 		.word	827063290
 2090 1538 01F0717F 		.word	2138173441
 2091 153c E2D88472 		.word	1921308898
 2092 1540 E50EAF2C 		.word	749670117
 2093 1544 01E0707F 		.word	2138103809
 2094 1548 94039D60 		.word	1620902804
 2095 154c 3F34C47E 		.word	2126787647
 2096 1550 01D0707F 		.word	2138099713
 2097 1554 9D266431 		.word	828647069
 2098 1558 194ED470 		.word	1892961817
 2099 155c 0198707F 		.word	2138085377
 2100 1560 2B82B10A 		.word	179405355
 2101 1564 E761ED5A 		.word	1525506535
 2102 1568 0138707F 		.word	2138060801
 2103 156c A394B224 		.word	615683235
 2104 1570 EAAA134B 		.word	1259580138
 2105 1574 01F86F7F 		.word	2138044417
 2106 1578 D0940379 		.word	2030277840
 2107 157c 02083167 		.word	1731266562
 2108 1580 01F06F7F 		.word	2138042369
 2109 1584 2C7C687C 		.word	2087222316
 2110 1588 33D10761 		.word	1627902259
 2111 158c 01C86F7F 		.word	2138032129
 2112 1590 E8898807 		.word	126388712
 2113 1594 D8841442 		.word	1108640984
 2114 1598 01786F7F 		.word	2138011649
 2115 159c 76709E2A 		.word	715026550
 2116 15a0 9224AD3C 		.word	1017980050
 2117 15a4 01306F7F 		.word	2137993217
 2118 15a8 AD07F464 		.word	1693714349
 2119 15ac 90819250 		.word	1351778704
 2120 15b0 01986D7F 		.word	2137888769
 2121 15b4 D335E04C 		.word	1289762259
 2122 15b8 65E2C43E 		.word	1053090405
 2123 15bc 01106D7F 		.word	2137853953
 2124 15c0 52A2EB0B 		.word	199991890
 2125 15c4 9576C14A 		.word	1254192789
 2126 15c8 01C06C7F 		.word	2137833473
 2127 15cc 75F41C38 		.word	941421685
 2128 15d0 E4107735 		.word	896995556
 2129 15d4 01806C7F 		.word	2137817089
 2130 15d8 3E72BA2C 		.word	750416446
 2131 15dc 8D38914A 		.word	1251031181
 2132 15e0 01206C7F 		.word	2137792513
 2133 15e4 EFA8912F 		.word	798075119
 2134 15e8 906AF015 		.word	368077456
 2135 15ec 01086C7F 		.word	2137786369
 2136 15f0 87825D34 		.word	878543495
 2137 15f4 B191B63D 		.word	1035375025
 2138 15f8 01C06B7F 		.word	2137767937
 2139 15fc 0AB08E00 		.word	9351178
 2140 1600 BEC3EF44 		.word	1156563902
 2141 1604 01906B7F 		.word	2137755649
 2142 1608 0E306452 		.word	1382297614
 2143 160c 5FDB8664 		.word	1686559583
 2144 1610 01186B7F 		.word	2137724929
 2145 1614 52493250 		.word	1345472850
 2146 1618 8B7E3364 		.word	1681096331
 2147 161c 01C86A7F 		.word	2137704449
 2148 1620 B101C031 		.word	834666929
 2149 1624 AF749525 		.word	630551727
 2150 1628 01506A7F 		.word	2137673729
 2151 162c E17E1E62 		.word	1646165729
 2152 1630 B306C770 		.word	1892091571
 2153 1634 0180697F 		.word	2137620481
 2154 1638 4DBD6D2E 		.word	778943821
 2155 163c 0D63E302 		.word	48456461
 2156 1640 0178697F 		.word	2137618433
 2157 1644 737D2A67 		.word	1730837875
 2158 1648 95711F66 		.word	1713336725
 2159 164c 01E8687F 		.word	2137581569
 2160 1650 63A30430 		.word	805610339
 2161 1654 5F363052 		.word	1378891359
 2162 1658 0140687F 		.word	2137538561
 2163 165c 74042E0C 		.word	204342388
 2164 1660 E4283D74 		.word	1950165220
 2165 1664 0110687F 		.word	2137526273
 2166 1668 BA781674 		.word	1947629754
 2167 166c C13A7459 		.word	1500789441
 2168 1670 01E8677F 		.word	2137516033
 2169 1674 B5D7E82A 		.word	719902645
 2170 1678 FCF06059 		.word	1499525372
 2171 167c 0188677F 		.word	2137491457
 2172 1680 3D68BC0D 		.word	230451261
 2173 1684 6DBA2921 		.word	556382829
 2174 1688 01C0667F 		.word	2137440257
 2175 168c 251B633A 		.word	979573541
 2176 1690 E3389A18 		.word	412760291
 2177 1694 01C0657F 		.word	2137374721
 2178 1698 E0BB4D37 		.word	927841248
 2179 169c 61C47974 		.word	1954137185
 2180 16a0 0190657F 		.word	2137362433
 2181 16a4 FF8D224A 		.word	1243778559
 2182 16a8 A0315233 		.word	861024672
 2183 16ac 01D0647F 		.word	2137313281
 2184 16b0 8533F34F 		.word	1341338501
 2185 16b4 B25A733A 		.word	980638386
 2186 16b8 01C8647F 		.word	2137311233
 2187 16bc 0ED2DF37 		.word	937415182
 2188 16c0 D53EE26A 		.word	1793212117
 2189 16c4 01F0637F 		.word	2137255937
 2190 16c8 FCCA672F 		.word	795331324
 2191 16cc 5DC20E54 		.word	1410253405
 2192 16d0 01C0637F 		.word	2137243649
 2193 16d4 F35BFC08 		.word	150756339
 2194 16d8 4F093E75 		.word	1966999887
 2195 16dc 01D0627F 		.word	2137182209
 2196 16e0 E279BC09 		.word	163346914
 2197 16e4 37649773 		.word	1939301431
 2198 16e8 01A8627F 		.word	2137171969
 2199 16ec CB956174 		.word	1952552395
 2200 16f0 75183C2D 		.word	758913141
 2201 16f4 0178627F 		.word	2137159681
 2202 16f8 718B0522 		.word	570788721
 2203 16fc 7A9E080D 		.word	218668666
 2204 1700 0148627F 		.word	2137147393
 2205 1704 AAAF0C71 		.word	1896656810
 2206 1708 C973EE79 		.word	2045670345
 2207 170c 0130627F 		.word	2137141249
 2208 1710 922E5E15 		.word	358493842
 2209 1714 5B19E31E 		.word	518199643
 2210 1718 0128627F 		.word	2137139201
 2211 171c 35D4B459 		.word	1505023029
 2212 1720 A80A3728 		.word	674695848
 2213 1724 0110627F 		.word	2137133057
 2214 1728 BFE3A901 		.word	27911103
 2215 172c 12638731 		.word	830956306
 2216 1730 01E8617F 		.word	2137122817
 2217 1734 C960361A 		.word	439771337
 2218 1738 0684B35C 		.word	1555268614
 2219 173c 01D0617F 		.word	2137116673
 2220 1740 2387252F 		.word	790988579
 2221 1744 FF0D8C6F 		.word	1871449599
 2222 1748 01B8617F 		.word	2137110529
 2223 174c B276C119 		.word	432109234
 2224 1750 98296330 		.word	811805080
 2225 1754 0198617F 		.word	2137102337
 2226 1758 6DEBEF50 		.word	1357900653
 2227 175c 09A1A146 		.word	1184997641
 2228 1760 0188617F 		.word	2137098241
 2229 1764 BB17B41E 		.word	515119035
 2230 1768 27664366 		.word	1715693095
 2231 176c 0168617F 		.word	2137090049
 2232 1770 E35C5A18 		.word	408575203
 2233 1774 F1A7507C 		.word	2085660657
 2234 1778 0158617F 		.word	2137085953
 2235 177c 7FC9097D 		.word	2097793407
 2236 1780 53AC7150 		.word	1349626963
 2237 1784 01E0607F 		.word	2137055233
 2238 1788 72F7C95C 		.word	1556739954
 2239 178c B3A56C56 		.word	1449960883
 2240 1790 0180607F 		.word	2137030657
 2241 1794 BA67225C 		.word	1545758650
 2242 1798 A4EA9D51 		.word	1369303716
 2243 179c 01D85F7F 		.word	2136987649
 2244 17a0 CA1CD313 		.word	332602570
 2245 17a4 2A023106 		.word	103875114
 2246 17a8 01905F7F 		.word	2136969217
 2247 17ac 02066859 		.word	1499989506
 2248 17b0 93D11E63 		.word	1662964115
 2249 17b4 01E05E7F 		.word	2136924161
 2250 17b8 71671533 		.word	857040753
 2251 17bc 1A4F4800 		.word	4738842
 2252 17c0 01705E7F 		.word	2136895489
 2253 17c4 08702974 		.word	1948872712
 2254 17c8 FB290022 		.word	570436091
 2255 17cc 01685E7F 		.word	2136893441
 2256 17d0 68CF8303 		.word	58969960
 2257 17d4 C21D7B5D 		.word	1568349634
 2258 17d8 01505E7F 		.word	2136887297
 2259 17dc 2365CA7E 		.word	2127193379
 2260 17e0 04FF4E10 		.word	273612548
 2261 17e4 01C05D7F 		.word	2136850433
 2262 17e8 17EAA006 		.word	111208983
 2263 17ec 9C8D6846 		.word	1181257116
 2264 17f0 01205D7F 		.word	2136809473
 2265 17f4 A642FE60 		.word	1627275942
 2266 17f8 139E2764 		.word	1680317971
 2267 17fc 01705C7F 		.word	2136764417
 2268 1800 19E3DE5D 		.word	1574888217
 2269 1804 C3CBD500 		.word	14011331
 2270 1808 01185C7F 		.word	2136741889
 2271 180c AFCAD500 		.word	14011055
 2272 1810 CB864D43 		.word	1129154251
 2273 1814 01E05B7F 		.word	2136727553
 2274 1818 23382302 		.word	35862563
 2275 181c 7520966D 		.word	1838555253
 2276 1820 01C85B7F 		.word	2136721409
 2277 1824 12D27D12 		.word	310235666
 2278 1828 B4E44B51 		.word	1363928244
 2279 182c 01705B7F 		.word	2136698881
 2280 1830 92B71B60 		.word	1612429202
 2281 1834 5491015D 		.word	1560383828
 2282 1838 01B05A7F 		.word	2136649729
 2283 183c 63BEDC43 		.word	1138540131
 2284 1840 1C40AF2F 		.word	800014364
 2285 1844 01085A7F 		.word	2136606721
 2286 1848 2FBAE623 		.word	602323503
 2287 184c CC516B55 		.word	1433096652
 2288 1850 0160597F 		.word	2136563713
 2289 1854 F14ADC0A 		.word	182209265
 2290 1858 9EF06A72 		.word	1919611038
 2291 185c 0140597F 		.word	2136555521
 2292 1860 3D3C5213 		.word	324156477
 2293 1864 FFB7DE09 		.word	165591039
 2294 1868 0128597F 		.word	2136549377
 2295 186c 194BA70B 		.word	195513113
 2296 1870 21AEF10C 		.word	217165345
 2297 1874 01D0587F 		.word	2136526849
 2298 1878 AE72A13E 		.word	1050768046
 2299 187c 8FE30138 		.word	939647887
 2300 1880 0188587F 		.word	2136508417
 2301 1884 9D716E70 		.word	1886286237
 2302 1888 2C1E8E60 		.word	1619926572
 2303 188c 0110587F 		.word	2136477697
 2304 1890 307C5624 		.word	609647664
 2305 1894 450D1702 		.word	35065157
 2306 1898 01F8577F 		.word	2136471553
 2307 189c 98177E28 		.word	679352216
 2308 18a0 8CB88F56 		.word	1452259468
 2309 18a4 01C0577F 		.word	2136457217
 2310 18a8 0FBDAA07 		.word	128630031
 2311 18ac 89B32931 		.word	824816521
 2312 18b0 0138577F 		.word	2136422401
 2313 18b4 C8EE2D01 		.word	19787464
 2314 18b8 26ACF55A 		.word	1526049830
 2315 18bc 0130577F 		.word	2136420353
 2316 18c0 24789F29 		.word	698316836
 2317 18c4 27763B5B 		.word	1530623527
 2318 18c8 0170567F 		.word	2136371201
 2319 18cc 656B7562 		.word	1651862373
 2320 18d0 0542936B 		.word	1804812805
 2321 18d4 01E0557F 		.word	2136334337
 2322 18d8 A5757713 		.word	326596005
 2323 18dc BADC1514 		.word	336977082
 2324 18e0 01B0557F 		.word	2136322049
 2325 18e4 7A2BC503 		.word	63253370
 2326 18e8 77918B71 		.word	1904972151
 2327 18ec 0150557F 		.word	2136297473
 2328 18f0 CC6D9B12 		.word	312176076
 2329 18f4 8B4B430A 		.word	172182411
 2330 18f8 0190547F 		.word	2136248321
 2331 18fc 1198B916 		.word	381261841
 2332 1900 DEFDFE15 		.word	369032670
 2333 1904 0178547F 		.word	2136242177
 2334 1908 05286115 		.word	358688773
 2335 190c 3A89C061 		.word	1640007994
 2336 1910 0148547F 		.word	2136229889
 2337 1914 44D58E1E 		.word	512677188
 2338 1918 C9568104 		.word	75585225
 2339 191c 0120547F 		.word	2136219649
 2340 1920 7236DF7C 		.word	2095003250
 2341 1924 05216D75 		.word	1970086149
 2342 1928 01F0537F 		.word	2136207361
 2343 192c 22F5D271 		.word	1909650722
 2344 1930 A3930D20 		.word	537760675
 2345 1934 0178537F 		.word	2136176641
 2346 1938 83A08C4F 		.word	1334616195
 2347 193c 032A675B 		.word	1533487619
 2348 1940 0130537F 		.word	2136158209
 2349 1944 C0C7F27C 		.word	2096285632
 2350 1948 5A5CE36A 		.word	1793285210
 2351 194c 01F8527F 		.word	2136143873
 2352 1950 BD391771 		.word	1897347517
 2353 1954 F7B38311 		.word	293843959
 2354 1958 01D0527F 		.word	2136133633
 2355 195c AECE0C37 		.word	923586222
 2356 1960 EA7DF43C 		.word	1022655978
 2357 1964 0140527F 		.word	2136096769
 2358 1968 5F1D5057 		.word	1464868191
 2359 196c 6A334E5A 		.word	1515074410
 2360 1970 0138527F 		.word	2136094721
 2361 1974 601F7178 		.word	2020679520
 2362 1978 0812E27A 		.word	2061636104
 2363 197c 01F0517F 		.word	2136076289
 2364 1980 A73B5511 		.word	290798503
 2365 1984 99882A6C 		.word	1814726809
 2366 1988 0168517F 		.word	2136041473
 2367 198c 96B75209 		.word	156415894
 2368 1990 010C8D4A 		.word	1250757633
 2369 1994 01B8507F 		.word	2135996417
 2370 1998 E4E0BA11 		.word	297459940
 2371 199c CC5F7B43 		.word	1132158924
 2372 19a0 0118507F 		.word	2135955457
 2373 19a4 E8C01C20 		.word	538755304
 2374 19a8 6C85A964 		.word	1688831340
 2375 19ac 00000000 		.word	0
 2376 19b0 00000000 		.word	0
 2377 19b4 00000000 		.word	0
 2378              		.section	.text.modp_set,"ax",%progbits
 2379              		.align	1
 2380              		.syntax unified
 2381              		.thumb
 2382              		.thumb_func
 2383              		.fpu softvfp
 2385              	modp_set:
 2386              	.LFB18:
 2387              		.file 2 "keygen.c"
   1:keygen.c      **** /*
   2:keygen.c      ****  * Falcon key pair generation.
   3:keygen.c      ****  *
   4:keygen.c      ****  * ==========================(LICENSE BEGIN)============================
   5:keygen.c      ****  *
   6:keygen.c      ****  * Copyright (c) 2017-2019  Falcon Project
   7:keygen.c      ****  *
   8:keygen.c      ****  * Permission is hereby granted, free of charge, to any person obtaining
   9:keygen.c      ****  * a copy of this software and associated documentation files (the
  10:keygen.c      ****  * "Software"), to deal in the Software without restriction, including
  11:keygen.c      ****  * without limitation the rights to use, copy, modify, merge, publish,
  12:keygen.c      ****  * distribute, sublicense, and/or sell copies of the Software, and to
  13:keygen.c      ****  * permit persons to whom the Software is furnished to do so, subject to
  14:keygen.c      ****  * the following conditions:
  15:keygen.c      ****  *
  16:keygen.c      ****  * The above copyright notice and this permission notice shall be
  17:keygen.c      ****  * included in all copies or substantial portions of the Software.
  18:keygen.c      ****  *
  19:keygen.c      ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  20:keygen.c      ****  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  21:keygen.c      ****  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  22:keygen.c      ****  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  23:keygen.c      ****  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  24:keygen.c      ****  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  25:keygen.c      ****  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  26:keygen.c      ****  *
  27:keygen.c      ****  * ===========================(LICENSE END)=============================
  28:keygen.c      ****  *
  29:keygen.c      ****  * @author   Thomas Pornin <thomas.pornin@nccgroup.com>
  30:keygen.c      ****  */
  31:keygen.c      **** 
  32:keygen.c      **** #include "inner.h"
  33:keygen.c      **** 
  34:keygen.c      **** #define MKN(logn)   ((size_t)1 << (logn))
  35:keygen.c      **** 
  36:keygen.c      **** /* ==================================================================== */
  37:keygen.c      **** /*
  38:keygen.c      ****  * Modular arithmetics.
  39:keygen.c      ****  *
  40:keygen.c      ****  * We implement a few functions for computing modulo a small integer p.
  41:keygen.c      ****  *
  42:keygen.c      ****  * All functions require that 2^30 < p < 2^31. Moreover, operands must
  43:keygen.c      ****  * be in the 0..p-1 range.
  44:keygen.c      ****  *
  45:keygen.c      ****  * Modular addition and subtraction work for all such p.
  46:keygen.c      ****  *
  47:keygen.c      ****  * Montgomery multiplication requires that p is odd, and must be provided
  48:keygen.c      ****  * with an additional value p0i = -1/p mod 2^31. See below for some basics
  49:keygen.c      ****  * on Montgomery multiplication.
  50:keygen.c      ****  *
  51:keygen.c      ****  * Division computes an inverse modulo p by an exponentiation (with
  52:keygen.c      ****  * exponent p-2): this works only if p is prime. Multiplication
  53:keygen.c      ****  * requirements also apply, i.e. p must be odd and p0i must be provided.
  54:keygen.c      ****  *
  55:keygen.c      ****  * The NTT and inverse NTT need all of the above, and also that
  56:keygen.c      ****  * p = 1 mod 2048.
  57:keygen.c      ****  *
  58:keygen.c      ****  * -----------------------------------------------------------------------
  59:keygen.c      ****  *
  60:keygen.c      ****  * We use Montgomery representation with 31-bit values:
  61:keygen.c      ****  *
  62:keygen.c      ****  *   Let R = 2^31 mod p. When 2^30 < p < 2^31, R = 2^31 - p.
  63:keygen.c      ****  *   Montgomery representation of an integer x modulo p is x*R mod p.
  64:keygen.c      ****  *
  65:keygen.c      ****  *   Montgomery multiplication computes (x*y)/R mod p for
  66:keygen.c      ****  *   operands x and y. Therefore:
  67:keygen.c      ****  *
  68:keygen.c      ****  *    - if operands are x*R and y*R (Montgomery representations of x and
  69:keygen.c      ****  *      y), then Montgomery multiplication computes (x*R*y*R)/R = (x*y)*R
  70:keygen.c      ****  *      mod p, which is the Montgomery representation of the product x*y;
  71:keygen.c      ****  *
  72:keygen.c      ****  *    - if operands are x*R and y (or x and y*R), then Montgomery
  73:keygen.c      ****  *      multiplication returns x*y mod p: mixed-representation
  74:keygen.c      ****  *      multiplications yield results in normal representation.
  75:keygen.c      ****  *
  76:keygen.c      ****  * To convert to Montgomery representation, we multiply by R, which is done
  77:keygen.c      ****  * by Montgomery-multiplying by R^2. Stand-alone conversion back from
  78:keygen.c      ****  * Montgomery representation is Montgomery-multiplication by 1.
  79:keygen.c      ****  */
  80:keygen.c      **** 
  81:keygen.c      **** /*
  82:keygen.c      ****  * Precomputed small primes. Each element contains the following:
  83:keygen.c      ****  *
  84:keygen.c      ****  *  p   The prime itself.
  85:keygen.c      ****  *
  86:keygen.c      ****  *  g   A primitive root of phi = X^N+1 (in field Z_p).
  87:keygen.c      ****  *
  88:keygen.c      ****  *  s   The inverse of the product of all previous primes in the array,
  89:keygen.c      ****  *      computed modulo p and in Montgomery representation.
  90:keygen.c      ****  *
  91:keygen.c      ****  * All primes are such that p = 1 mod 2048, and are lower than 2^31. They
  92:keygen.c      ****  * are listed in decreasing order.
  93:keygen.c      ****  */
  94:keygen.c      **** 
  95:keygen.c      **** typedef struct {
  96:keygen.c      **** 	uint32_t p;
  97:keygen.c      **** 	uint32_t g;
  98:keygen.c      **** 	uint32_t s;
  99:keygen.c      **** } small_prime;
 100:keygen.c      **** 
 101:keygen.c      **** static const small_prime PRIMES[] = {
 102:keygen.c      **** 	{ 2147473409,  383167813,      10239 },
 103:keygen.c      **** 	{ 2147389441,  211808905,  471403745 },
 104:keygen.c      **** 	{ 2147387393,   37672282, 1329335065 },
 105:keygen.c      **** 	{ 2147377153, 1977035326,  968223422 },
 106:keygen.c      **** 	{ 2147358721, 1067163706,  132460015 },
 107:keygen.c      **** 	{ 2147352577, 1606082042,  598693809 },
 108:keygen.c      **** 	{ 2147346433, 2033915641, 1056257184 },
 109:keygen.c      **** 	{ 2147338241, 1653770625,  421286710 },
 110:keygen.c      **** 	{ 2147309569,  631200819, 1111201074 },
 111:keygen.c      **** 	{ 2147297281, 2038364663, 1042003613 },
 112:keygen.c      **** 	{ 2147295233, 1962540515,   19440033 },
 113:keygen.c      **** 	{ 2147239937, 2100082663,  353296760 },
 114:keygen.c      **** 	{ 2147235841, 1991153006, 1703918027 },
 115:keygen.c      **** 	{ 2147217409,  516405114, 1258919613 },
 116:keygen.c      **** 	{ 2147205121,  409347988, 1089726929 },
 117:keygen.c      **** 	{ 2147196929,  927788991, 1946238668 },
 118:keygen.c      **** 	{ 2147178497, 1136922411, 1347028164 },
 119:keygen.c      **** 	{ 2147100673,  868626236,  701164723 },
 120:keygen.c      **** 	{ 2147082241, 1897279176,  617820870 },
 121:keygen.c      **** 	{ 2147074049, 1888819123,  158382189 },
 122:keygen.c      **** 	{ 2147051521,   25006327,  522758543 },
 123:keygen.c      **** 	{ 2147043329,  327546255,   37227845 },
 124:keygen.c      **** 	{ 2147039233,  766324424, 1133356428 },
 125:keygen.c      **** 	{ 2146988033, 1862817362,   73861329 },
 126:keygen.c      **** 	{ 2146963457,  404622040,  653019435 },
 127:keygen.c      **** 	{ 2146959361, 1936581214,  995143093 },
 128:keygen.c      **** 	{ 2146938881, 1559770096,  634921513 },
 129:keygen.c      **** 	{ 2146908161,  422623708, 1985060172 },
 130:keygen.c      **** 	{ 2146885633, 1751189170,  298238186 },
 131:keygen.c      **** 	{ 2146871297,  578919515,  291810829 },
 132:keygen.c      **** 	{ 2146846721, 1114060353,  915902322 },
 133:keygen.c      **** 	{ 2146834433, 2069565474,   47859524 },
 134:keygen.c      **** 	{ 2146818049, 1552824584,  646281055 },
 135:keygen.c      **** 	{ 2146775041, 1906267847, 1597832891 },
 136:keygen.c      **** 	{ 2146756609, 1847414714, 1228090888 },
 137:keygen.c      **** 	{ 2146744321, 1818792070, 1176377637 },
 138:keygen.c      **** 	{ 2146738177, 1118066398, 1054971214 },
 139:keygen.c      **** 	{ 2146736129,   52057278,  933422153 },
 140:keygen.c      **** 	{ 2146713601,  592259376, 1406621510 },
 141:keygen.c      **** 	{ 2146695169,  263161877, 1514178701 },
 142:keygen.c      **** 	{ 2146656257,  685363115,  384505091 },
 143:keygen.c      **** 	{ 2146650113,  927727032,  537575289 },
 144:keygen.c      **** 	{ 2146646017,   52575506, 1799464037 },
 145:keygen.c      **** 	{ 2146643969, 1276803876, 1348954416 },
 146:keygen.c      **** 	{ 2146603009,  814028633, 1521547704 },
 147:keygen.c      **** 	{ 2146572289, 1846678872, 1310832121 },
 148:keygen.c      **** 	{ 2146547713,  919368090, 1019041349 },
 149:keygen.c      **** 	{ 2146508801,  671847612,   38582496 },
 150:keygen.c      **** 	{ 2146492417,  283911680,  532424562 },
 151:keygen.c      **** 	{ 2146490369, 1780044827,  896447978 },
 152:keygen.c      **** 	{ 2146459649,  327980850, 1327906900 },
 153:keygen.c      **** 	{ 2146447361, 1310561493,  958645253 },
 154:keygen.c      **** 	{ 2146441217,  412148926,  287271128 },
 155:keygen.c      **** 	{ 2146437121,  293186449, 2009822534 },
 156:keygen.c      **** 	{ 2146430977,  179034356, 1359155584 },
 157:keygen.c      **** 	{ 2146418689, 1517345488, 1790248672 },
 158:keygen.c      **** 	{ 2146406401, 1615820390, 1584833571 },
 159:keygen.c      **** 	{ 2146404353,  826651445,  607120498 },
 160:keygen.c      **** 	{ 2146379777,    3816988, 1897049071 },
 161:keygen.c      **** 	{ 2146363393, 1221409784, 1986921567 },
 162:keygen.c      **** 	{ 2146355201, 1388081168,  849968120 },
 163:keygen.c      **** 	{ 2146336769, 1803473237, 1655544036 },
 164:keygen.c      **** 	{ 2146312193, 1023484977,  273671831 },
 165:keygen.c      **** 	{ 2146293761, 1074591448,  467406983 },
 166:keygen.c      **** 	{ 2146283521,  831604668, 1523950494 },
 167:keygen.c      **** 	{ 2146203649,  712865423, 1170834574 },
 168:keygen.c      **** 	{ 2146154497, 1764991362, 1064856763 },
 169:keygen.c      **** 	{ 2146142209,  627386213, 1406840151 },
 170:keygen.c      **** 	{ 2146127873, 1638674429, 2088393537 },
 171:keygen.c      **** 	{ 2146099201, 1516001018,  690673370 },
 172:keygen.c      **** 	{ 2146093057, 1294931393,  315136610 },
 173:keygen.c      **** 	{ 2146091009, 1942399533,  973539425 },
 174:keygen.c      **** 	{ 2146078721, 1843461814, 2132275436 },
 175:keygen.c      **** 	{ 2146060289, 1098740778,  360423481 },
 176:keygen.c      **** 	{ 2146048001, 1617213232, 1951981294 },
 177:keygen.c      **** 	{ 2146041857, 1805783169, 2075683489 },
 178:keygen.c      **** 	{ 2146019329,  272027909, 1753219918 },
 179:keygen.c      **** 	{ 2145986561, 1206530344, 2034028118 },
 180:keygen.c      **** 	{ 2145976321, 1243769360, 1173377644 },
 181:keygen.c      **** 	{ 2145964033,  887200839, 1281344586 },
 182:keygen.c      **** 	{ 2145906689, 1651026455,  906178216 },
 183:keygen.c      **** 	{ 2145875969, 1673238256, 1043521212 },
 184:keygen.c      **** 	{ 2145871873, 1226591210, 1399796492 },
 185:keygen.c      **** 	{ 2145841153, 1465353397, 1324527802 },
 186:keygen.c      **** 	{ 2145832961, 1150638905,  554084759 },
 187:keygen.c      **** 	{ 2145816577,  221601706,  427340863 },
 188:keygen.c      **** 	{ 2145785857,  608896761,  316590738 },
 189:keygen.c      **** 	{ 2145755137, 1712054942, 1684294304 },
 190:keygen.c      **** 	{ 2145742849, 1302302867,  724873116 },
 191:keygen.c      **** 	{ 2145728513,  516717693,  431671476 },
 192:keygen.c      **** 	{ 2145699841,  524575579, 1619722537 },
 193:keygen.c      **** 	{ 2145691649, 1925625239,  982974435 },
 194:keygen.c      **** 	{ 2145687553,  463795662, 1293154300 },
 195:keygen.c      **** 	{ 2145673217,  771716636,  881778029 },
 196:keygen.c      **** 	{ 2145630209, 1509556977,  837364988 },
 197:keygen.c      **** 	{ 2145595393,  229091856,  851648427 },
 198:keygen.c      **** 	{ 2145587201, 1796903241,  635342424 },
 199:keygen.c      **** 	{ 2145525761,  715310882, 1677228081 },
 200:keygen.c      **** 	{ 2145495041, 1040930522,  200685896 },
 201:keygen.c      **** 	{ 2145466369,  949804237, 1809146322 },
 202:keygen.c      **** 	{ 2145445889, 1673903706,   95316881 },
 203:keygen.c      **** 	{ 2145390593,  806941852, 1428671135 },
 204:keygen.c      **** 	{ 2145372161, 1402525292,  159350694 },
 205:keygen.c      **** 	{ 2145361921, 2124760298, 1589134749 },
 206:keygen.c      **** 	{ 2145359873, 1217503067, 1561543010 },
 207:keygen.c      **** 	{ 2145355777,  338341402,   83865711 },
 208:keygen.c      **** 	{ 2145343489, 1381532164,  641430002 },
 209:keygen.c      **** 	{ 2145325057, 1883895478, 1528469895 },
 210:keygen.c      **** 	{ 2145318913, 1335370424,   65809740 },
 211:keygen.c      **** 	{ 2145312769, 2000008042, 1919775760 },
 212:keygen.c      **** 	{ 2145300481,  961450962, 1229540578 },
 213:keygen.c      **** 	{ 2145282049,  910466767, 1964062701 },
 214:keygen.c      **** 	{ 2145232897,  816527501,  450152063 },
 215:keygen.c      **** 	{ 2145218561, 1435128058, 1794509700 },
 216:keygen.c      **** 	{ 2145187841,   33505311, 1272467582 },
 217:keygen.c      **** 	{ 2145181697,  269767433, 1380363849 },
 218:keygen.c      **** 	{ 2145175553,   56386299, 1316870546 },
 219:keygen.c      **** 	{ 2145079297, 2106880293, 1391797340 },
 220:keygen.c      **** 	{ 2145021953, 1347906152,  720510798 },
 221:keygen.c      **** 	{ 2145015809,  206769262, 1651459955 },
 222:keygen.c      **** 	{ 2145003521, 1885513236, 1393381284 },
 223:keygen.c      **** 	{ 2144960513, 1810381315,   31937275 },
 224:keygen.c      **** 	{ 2144944129, 1306487838, 2019419520 },
 225:keygen.c      **** 	{ 2144935937,   37304730, 1841489054 },
 226:keygen.c      **** 	{ 2144894977, 1601434616,  157985831 },
 227:keygen.c      **** 	{ 2144888833,   98749330, 2128592228 },
 228:keygen.c      **** 	{ 2144880641, 1772327002, 2076128344 },
 229:keygen.c      **** 	{ 2144864257, 1404514762, 2029969964 },
 230:keygen.c      **** 	{ 2144827393,  801236594,  406627220 },
 231:keygen.c      **** 	{ 2144806913,  349217443, 1501080290 },
 232:keygen.c      **** 	{ 2144796673, 1542656776, 2084736519 },
 233:keygen.c      **** 	{ 2144778241, 1210734884, 1746416203 },
 234:keygen.c      **** 	{ 2144759809, 1146598851,  716464489 },
 235:keygen.c      **** 	{ 2144757761,  286328400, 1823728177 },
 236:keygen.c      **** 	{ 2144729089, 1347555695, 1836644881 },
 237:keygen.c      **** 	{ 2144727041, 1795703790,  520296412 },
 238:keygen.c      **** 	{ 2144696321, 1302475157,  852964281 },
 239:keygen.c      **** 	{ 2144667649, 1075877614,  504992927 },
 240:keygen.c      **** 	{ 2144573441,  198765808, 1617144982 },
 241:keygen.c      **** 	{ 2144555009,  321528767,  155821259 },
 242:keygen.c      **** 	{ 2144550913,  814139516, 1819937644 },
 243:keygen.c      **** 	{ 2144536577,  571143206,  962942255 },
 244:keygen.c      **** 	{ 2144524289, 1746733766,    2471321 },
 245:keygen.c      **** 	{ 2144512001, 1821415077,  124190939 },
 246:keygen.c      **** 	{ 2144468993,  917871546, 1260072806 },
 247:keygen.c      **** 	{ 2144458753,  378417981, 1569240563 },
 248:keygen.c      **** 	{ 2144421889,  175229668, 1825620763 },
 249:keygen.c      **** 	{ 2144409601, 1699216963,  351648117 },
 250:keygen.c      **** 	{ 2144370689, 1071885991,  958186029 },
 251:keygen.c      **** 	{ 2144348161, 1763151227,  540353574 },
 252:keygen.c      **** 	{ 2144335873, 1060214804,  919598847 },
 253:keygen.c      **** 	{ 2144329729,  663515846, 1448552668 },
 254:keygen.c      **** 	{ 2144327681, 1057776305,  590222840 },
 255:keygen.c      **** 	{ 2144309249, 1705149168, 1459294624 },
 256:keygen.c      **** 	{ 2144296961,  325823721, 1649016934 },
 257:keygen.c      **** 	{ 2144290817,  738775789,  447427206 },
 258:keygen.c      **** 	{ 2144243713,  962347618,  893050215 },
 259:keygen.c      **** 	{ 2144237569, 1655257077,  900860862 },
 260:keygen.c      **** 	{ 2144161793,  242206694, 1567868672 },
 261:keygen.c      **** 	{ 2144155649,  769415308, 1247993134 },
 262:keygen.c      **** 	{ 2144137217,  320492023,  515841070 },
 263:keygen.c      **** 	{ 2144120833, 1639388522,  770877302 },
 264:keygen.c      **** 	{ 2144071681, 1761785233,  964296120 },
 265:keygen.c      **** 	{ 2144065537,  419817825,  204564472 },
 266:keygen.c      **** 	{ 2144028673,  666050597, 2091019760 },
 267:keygen.c      **** 	{ 2144010241, 1413657615, 1518702610 },
 268:keygen.c      **** 	{ 2143952897, 1238327946,  475672271 },
 269:keygen.c      **** 	{ 2143940609,  307063413, 1176750846 },
 270:keygen.c      **** 	{ 2143918081, 2062905559,  786785803 },
 271:keygen.c      **** 	{ 2143899649, 1338112849, 1562292083 },
 272:keygen.c      **** 	{ 2143891457,   68149545,   87166451 },
 273:keygen.c      **** 	{ 2143885313,  921750778,  394460854 },
 274:keygen.c      **** 	{ 2143854593,  719766593,  133877196 },
 275:keygen.c      **** 	{ 2143836161, 1149399850, 1861591875 },
 276:keygen.c      **** 	{ 2143762433, 1848739366, 1335934145 },
 277:keygen.c      **** 	{ 2143756289, 1326674710,  102999236 },
 278:keygen.c      **** 	{ 2143713281,  808061791, 1156900308 },
 279:keygen.c      **** 	{ 2143690753,  388399459, 1926468019 },
 280:keygen.c      **** 	{ 2143670273, 1427891374, 1756689401 },
 281:keygen.c      **** 	{ 2143666177, 1912173949,  986629565 },
 282:keygen.c      **** 	{ 2143645697, 2041160111,  371842865 },
 283:keygen.c      **** 	{ 2143641601, 1279906897, 2023974350 },
 284:keygen.c      **** 	{ 2143635457,  720473174, 1389027526 },
 285:keygen.c      **** 	{ 2143621121, 1298309455, 1732632006 },
 286:keygen.c      **** 	{ 2143598593, 1548762216, 1825417506 },
 287:keygen.c      **** 	{ 2143567873,  620475784, 1073787233 },
 288:keygen.c      **** 	{ 2143561729, 1932954575,  949167309 },
 289:keygen.c      **** 	{ 2143553537,  354315656, 1652037534 },
 290:keygen.c      **** 	{ 2143541249,  577424288, 1097027618 },
 291:keygen.c      **** 	{ 2143531009,  357862822,  478640055 },
 292:keygen.c      **** 	{ 2143522817, 2017706025, 1550531668 },
 293:keygen.c      **** 	{ 2143506433, 2078127419, 1824320165 },
 294:keygen.c      **** 	{ 2143488001,  613475285, 1604011510 },
 295:keygen.c      **** 	{ 2143469569, 1466594987,  502095196 },
 296:keygen.c      **** 	{ 2143426561, 1115430331, 1044637111 },
 297:keygen.c      **** 	{ 2143383553,    9778045, 1902463734 },
 298:keygen.c      **** 	{ 2143377409, 1557401276, 2056861771 },
 299:keygen.c      **** 	{ 2143363073,  652036455, 1965915971 },
 300:keygen.c      **** 	{ 2143260673, 1464581171, 1523257541 },
 301:keygen.c      **** 	{ 2143246337, 1876119649,  764541916 },
 302:keygen.c      **** 	{ 2143209473, 1614992673, 1920672844 },
 303:keygen.c      **** 	{ 2143203329,  981052047, 2049774209 },
 304:keygen.c      **** 	{ 2143160321, 1847355533,  728535665 },
 305:keygen.c      **** 	{ 2143129601,  965558457,  603052992 },
 306:keygen.c      **** 	{ 2143123457, 2140817191,    8348679 },
 307:keygen.c      **** 	{ 2143100929, 1547263683,  694209023 },
 308:keygen.c      **** 	{ 2143092737,  643459066, 1979934533 },
 309:keygen.c      **** 	{ 2143082497,  188603778, 2026175670 },
 310:keygen.c      **** 	{ 2143062017, 1657329695,  377451099 },
 311:keygen.c      **** 	{ 2143051777,  114967950,  979255473 },
 312:keygen.c      **** 	{ 2143025153, 1698431342, 1449196896 },
 313:keygen.c      **** 	{ 2143006721, 1862741675, 1739650365 },
 314:keygen.c      **** 	{ 2142996481,  756660457,  996160050 },
 315:keygen.c      **** 	{ 2142976001,  927864010, 1166847574 },
 316:keygen.c      **** 	{ 2142965761,  905070557,  661974566 },
 317:keygen.c      **** 	{ 2142916609,   40932754, 1787161127 },
 318:keygen.c      **** 	{ 2142892033, 1987985648,  675335382 },
 319:keygen.c      **** 	{ 2142885889,  797497211, 1323096997 },
 320:keygen.c      **** 	{ 2142871553, 2068025830, 1411877159 },
 321:keygen.c      **** 	{ 2142861313, 1217177090, 1438410687 },
 322:keygen.c      **** 	{ 2142830593,  409906375, 1767860634 },
 323:keygen.c      **** 	{ 2142803969, 1197788993,  359782919 },
 324:keygen.c      **** 	{ 2142785537,  643817365,  513932862 },
 325:keygen.c      **** 	{ 2142779393, 1717046338,  218943121 },
 326:keygen.c      **** 	{ 2142724097,   89336830,  416687049 },
 327:keygen.c      **** 	{ 2142707713,    5944581, 1356813523 },
 328:keygen.c      **** 	{ 2142658561,  887942135, 2074011722 },
 329:keygen.c      **** 	{ 2142638081,  151851972, 1647339939 },
 330:keygen.c      **** 	{ 2142564353, 1691505537, 1483107336 },
 331:keygen.c      **** 	{ 2142533633, 1989920200, 1135938817 },
 332:keygen.c      **** 	{ 2142529537,  959263126, 1531961857 },
 333:keygen.c      **** 	{ 2142527489,  453251129, 1725566162 },
 334:keygen.c      **** 	{ 2142502913, 1536028102,  182053257 },
 335:keygen.c      **** 	{ 2142498817,  570138730,  701443447 },
 336:keygen.c      **** 	{ 2142416897,  326965800,  411931819 },
 337:keygen.c      **** 	{ 2142363649, 1675665410, 1517191733 },
 338:keygen.c      **** 	{ 2142351361,  968529566, 1575712703 },
 339:keygen.c      **** 	{ 2142330881, 1384953238, 1769087884 },
 340:keygen.c      **** 	{ 2142314497, 1977173242, 1833745524 },
 341:keygen.c      **** 	{ 2142289921,   95082313, 1714775493 },
 342:keygen.c      **** 	{ 2142283777,  109377615, 1070584533 },
 343:keygen.c      **** 	{ 2142277633,   16960510,  702157145 },
 344:keygen.c      **** 	{ 2142263297,  553850819,  431364395 },
 345:keygen.c      **** 	{ 2142208001,  241466367, 2053967982 },
 346:keygen.c      **** 	{ 2142164993, 1795661326, 1031836848 },
 347:keygen.c      **** 	{ 2142097409, 1212530046,  712772031 },
 348:keygen.c      **** 	{ 2142087169, 1763869720,  822276067 },
 349:keygen.c      **** 	{ 2142078977,  644065713, 1765268066 },
 350:keygen.c      **** 	{ 2142074881,  112671944,  643204925 },
 351:keygen.c      **** 	{ 2142044161, 1387785471, 1297890174 },
 352:keygen.c      **** 	{ 2142025729,  783885537, 1000425730 },
 353:keygen.c      **** 	{ 2142011393,  905662232, 1679401033 },
 354:keygen.c      **** 	{ 2141974529,  799788433,  468119557 },
 355:keygen.c      **** 	{ 2141943809, 1932544124,  449305555 },
 356:keygen.c      **** 	{ 2141933569, 1527403256,  841867925 },
 357:keygen.c      **** 	{ 2141931521, 1247076451,  743823916 },
 358:keygen.c      **** 	{ 2141902849, 1199660531,  401687910 },
 359:keygen.c      **** 	{ 2141890561,  150132350, 1720336972 },
 360:keygen.c      **** 	{ 2141857793, 1287438162,  663880489 },
 361:keygen.c      **** 	{ 2141833217,  618017731, 1819208266 },
 362:keygen.c      **** 	{ 2141820929,  999578638, 1403090096 },
 363:keygen.c      **** 	{ 2141786113,   81834325, 1523542501 },
 364:keygen.c      **** 	{ 2141771777,  120001928,  463556492 },
 365:keygen.c      **** 	{ 2141759489,  122455485, 2124928282 },
 366:keygen.c      **** 	{ 2141749249,  141986041,  940339153 },
 367:keygen.c      **** 	{ 2141685761,  889088734,  477141499 },
 368:keygen.c      **** 	{ 2141673473,  324212681, 1122558298 },
 369:keygen.c      **** 	{ 2141669377, 1175806187, 1373818177 },
 370:keygen.c      **** 	{ 2141655041, 1113654822,  296887082 },
 371:keygen.c      **** 	{ 2141587457,  991103258, 1585913875 },
 372:keygen.c      **** 	{ 2141583361, 1401451409, 1802457360 },
 373:keygen.c      **** 	{ 2141575169, 1571977166,  712760980 },
 374:keygen.c      **** 	{ 2141546497, 1107849376, 1250270109 },
 375:keygen.c      **** 	{ 2141515777,  196544219,  356001130 },
 376:keygen.c      **** 	{ 2141495297, 1733571506, 1060744866 },
 377:keygen.c      **** 	{ 2141483009,  321552363, 1168297026 },
 378:keygen.c      **** 	{ 2141458433,  505818251,  733225819 },
 379:keygen.c      **** 	{ 2141360129, 1026840098,  948342276 },
 380:keygen.c      **** 	{ 2141325313,  945133744, 2129965998 },
 381:keygen.c      **** 	{ 2141317121, 1871100260, 1843844634 },
 382:keygen.c      **** 	{ 2141286401, 1790639498, 1750465696 },
 383:keygen.c      **** 	{ 2141267969, 1376858592,  186160720 },
 384:keygen.c      **** 	{ 2141255681, 2129698296, 1876677959 },
 385:keygen.c      **** 	{ 2141243393, 2138900688, 1340009628 },
 386:keygen.c      **** 	{ 2141214721, 1933049835, 1087819477 },
 387:keygen.c      **** 	{ 2141212673, 1898664939, 1786328049 },
 388:keygen.c      **** 	{ 2141202433,  990234828,  940682169 },
 389:keygen.c      **** 	{ 2141175809, 1406392421,  993089586 },
 390:keygen.c      **** 	{ 2141165569, 1263518371,  289019479 },
 391:keygen.c      **** 	{ 2141073409, 1485624211,  507864514 },
 392:keygen.c      **** 	{ 2141052929, 1885134788,  311252465 },
 393:keygen.c      **** 	{ 2141040641, 1285021247,  280941862 },
 394:keygen.c      **** 	{ 2141028353, 1527610374,  375035110 },
 395:keygen.c      **** 	{ 2141011969, 1400626168,  164696620 },
 396:keygen.c      **** 	{ 2140999681,  632959608,  966175067 },
 397:keygen.c      **** 	{ 2140997633, 2045628978, 1290889438 },
 398:keygen.c      **** 	{ 2140993537, 1412755491,  375366253 },
 399:keygen.c      **** 	{ 2140942337,  719477232,  785367828 },
 400:keygen.c      **** 	{ 2140925953,   45224252,  836552317 },
 401:keygen.c      **** 	{ 2140917761, 1157376588, 1001839569 },
 402:keygen.c      **** 	{ 2140887041,  278480752, 2098732796 },
 403:keygen.c      **** 	{ 2140837889, 1663139953,  924094810 },
 404:keygen.c      **** 	{ 2140788737,  802501511, 2045368990 },
 405:keygen.c      **** 	{ 2140766209, 1820083885, 1800295504 },
 406:keygen.c      **** 	{ 2140764161, 1169561905, 2106792035 },
 407:keygen.c      **** 	{ 2140696577,  127781498, 1885987531 },
 408:keygen.c      **** 	{ 2140684289,   16014477, 1098116827 },
 409:keygen.c      **** 	{ 2140653569,  665960598, 1796728247 },
 410:keygen.c      **** 	{ 2140594177, 1043085491,  377310938 },
 411:keygen.c      **** 	{ 2140579841, 1732838211, 1504505945 },
 412:keygen.c      **** 	{ 2140569601,  302071939,  358291016 },
 413:keygen.c      **** 	{ 2140567553,  192393733, 1909137143 },
 414:keygen.c      **** 	{ 2140557313,  406595731, 1175330270 },
 415:keygen.c      **** 	{ 2140549121, 1748850918,  525007007 },
 416:keygen.c      **** 	{ 2140477441,  499436566, 1031159814 },
 417:keygen.c      **** 	{ 2140469249, 1886004401, 1029951320 },
 418:keygen.c      **** 	{ 2140426241, 1483168100, 1676273461 },
 419:keygen.c      **** 	{ 2140420097, 1779917297,  846024476 },
 420:keygen.c      **** 	{ 2140413953,  522948893, 1816354149 },
 421:keygen.c      **** 	{ 2140383233, 1931364473, 1296921241 },
 422:keygen.c      **** 	{ 2140366849, 1917356555,  147196204 },
 423:keygen.c      **** 	{ 2140354561,   16466177, 1349052107 },
 424:keygen.c      **** 	{ 2140348417, 1875366972, 1860485634 },
 425:keygen.c      **** 	{ 2140323841,  456498717, 1790256483 },
 426:keygen.c      **** 	{ 2140321793, 1629493973,  150031888 },
 427:keygen.c      **** 	{ 2140315649, 1904063898,  395510935 },
 428:keygen.c      **** 	{ 2140280833, 1784104328,  831417909 },
 429:keygen.c      **** 	{ 2140250113,  256087139,  697349101 },
 430:keygen.c      **** 	{ 2140229633,  388553070,  243875754 },
 431:keygen.c      **** 	{ 2140223489,  747459608, 1396270850 },
 432:keygen.c      **** 	{ 2140200961,  507423743, 1895572209 },
 433:keygen.c      **** 	{ 2140162049,  580106016, 2045297469 },
 434:keygen.c      **** 	{ 2140149761,  712426444,  785217995 },
 435:keygen.c      **** 	{ 2140137473, 1441607584,  536866543 },
 436:keygen.c      **** 	{ 2140119041,  346538902, 1740434653 },
 437:keygen.c      **** 	{ 2140090369,  282642885,   21051094 },
 438:keygen.c      **** 	{ 2140076033, 1407456228,  319910029 },
 439:keygen.c      **** 	{ 2140047361, 1619330500, 1488632070 },
 440:keygen.c      **** 	{ 2140041217, 2089408064, 2012026134 },
 441:keygen.c      **** 	{ 2140008449, 1705524800, 1613440760 },
 442:keygen.c      **** 	{ 2139924481, 1846208233, 1280649481 },
 443:keygen.c      **** 	{ 2139906049,  989438755, 1185646076 },
 444:keygen.c      **** 	{ 2139867137, 1522314850,  372783595 },
 445:keygen.c      **** 	{ 2139842561, 1681587377,  216848235 },
 446:keygen.c      **** 	{ 2139826177, 2066284988, 1784999464 },
 447:keygen.c      **** 	{ 2139824129,  480888214, 1513323027 },
 448:keygen.c      **** 	{ 2139789313,  847937200,  858192859 },
 449:keygen.c      **** 	{ 2139783169, 1642000434, 1583261448 },
 450:keygen.c      **** 	{ 2139770881,  940699589,  179702100 },
 451:keygen.c      **** 	{ 2139768833,  315623242,  964612676 },
 452:keygen.c      **** 	{ 2139666433,  331649203,  764666914 },
 453:keygen.c      **** 	{ 2139641857, 2118730799, 1313764644 },
 454:keygen.c      **** 	{ 2139635713,  519149027,  519212449 },
 455:keygen.c      **** 	{ 2139598849, 1526413634, 1769667104 },
 456:keygen.c      **** 	{ 2139574273,  551148610,  820739925 },
 457:keygen.c      **** 	{ 2139568129, 1386800242,  472447405 },
 458:keygen.c      **** 	{ 2139549697,  813760130, 1412328531 },
 459:keygen.c      **** 	{ 2139537409, 1615286260, 1609362979 },
 460:keygen.c      **** 	{ 2139475969, 1352559299, 1696720421 },
 461:keygen.c      **** 	{ 2139455489, 1048691649, 1584935400 },
 462:keygen.c      **** 	{ 2139432961,  836025845,  950121150 },
 463:keygen.c      **** 	{ 2139424769, 1558281165, 1635486858 },
 464:keygen.c      **** 	{ 2139406337, 1728402143, 1674423301 },
 465:keygen.c      **** 	{ 2139396097, 1727715782, 1483470544 },
 466:keygen.c      **** 	{ 2139383809, 1092853491, 1741699084 },
 467:keygen.c      **** 	{ 2139369473,  690776899, 1242798709 },
 468:keygen.c      **** 	{ 2139351041, 1768782380, 2120712049 },
 469:keygen.c      **** 	{ 2139334657, 1739968247, 1427249225 },
 470:keygen.c      **** 	{ 2139332609, 1547189119,  623011170 },
 471:keygen.c      **** 	{ 2139310081, 1346827917, 1605466350 },
 472:keygen.c      **** 	{ 2139303937,  369317948,  828392831 },
 473:keygen.c      **** 	{ 2139301889, 1560417239, 1788073219 },
 474:keygen.c      **** 	{ 2139283457, 1303121623,  595079358 },
 475:keygen.c      **** 	{ 2139248641, 1354555286,  573424177 },
 476:keygen.c      **** 	{ 2139240449,   60974056,  885781403 },
 477:keygen.c      **** 	{ 2139222017,  355573421, 1221054839 },
 478:keygen.c      **** 	{ 2139215873,  566477826, 1724006500 },
 479:keygen.c      **** 	{ 2139150337,  871437673, 1609133294 },
 480:keygen.c      **** 	{ 2139144193, 1478130914, 1137491905 },
 481:keygen.c      **** 	{ 2139117569, 1854880922,  964728507 },
 482:keygen.c      **** 	{ 2139076609,  202405335,  756508944 },
 483:keygen.c      **** 	{ 2139062273, 1399715741,  884826059 },
 484:keygen.c      **** 	{ 2139045889, 1051045798, 1202295476 },
 485:keygen.c      **** 	{ 2139033601, 1707715206,  632234634 },
 486:keygen.c      **** 	{ 2139006977, 2035853139,  231626690 },
 487:keygen.c      **** 	{ 2138951681,  183867876,  838350879 },
 488:keygen.c      **** 	{ 2138945537, 1403254661,  404460202 },
 489:keygen.c      **** 	{ 2138920961,  310865011, 1282911681 },
 490:keygen.c      **** 	{ 2138910721, 1328496553,  103472415 },
 491:keygen.c      **** 	{ 2138904577,   78831681,  993513549 },
 492:keygen.c      **** 	{ 2138902529, 1319697451, 1055904361 },
 493:keygen.c      **** 	{ 2138816513,  384338872, 1706202469 },
 494:keygen.c      **** 	{ 2138810369, 1084868275,  405677177 },
 495:keygen.c      **** 	{ 2138787841,  401181788, 1964773901 },
 496:keygen.c      **** 	{ 2138775553, 1850532988, 1247087473 },
 497:keygen.c      **** 	{ 2138767361,  874261901, 1576073565 },
 498:keygen.c      **** 	{ 2138757121, 1187474742,  993541415 },
 499:keygen.c      **** 	{ 2138748929, 1782458888, 1043206483 },
 500:keygen.c      **** 	{ 2138744833, 1221500487,  800141243 },
 501:keygen.c      **** 	{ 2138738689,  413465368, 1450660558 },
 502:keygen.c      **** 	{ 2138695681,  739045140,  342611472 },
 503:keygen.c      **** 	{ 2138658817, 1355845756,  672674190 },
 504:keygen.c      **** 	{ 2138644481,  608379162, 1538874380 },
 505:keygen.c      **** 	{ 2138632193, 1444914034,  686911254 },
 506:keygen.c      **** 	{ 2138607617,  484707818, 1435142134 },
 507:keygen.c      **** 	{ 2138591233,  539460669, 1290458549 },
 508:keygen.c      **** 	{ 2138572801, 2093538990, 2011138646 },
 509:keygen.c      **** 	{ 2138552321, 1149786988, 1076414907 },
 510:keygen.c      **** 	{ 2138546177,  840688206, 2108985273 },
 511:keygen.c      **** 	{ 2138533889,  209669619,  198172413 },
 512:keygen.c      **** 	{ 2138523649, 1975879426, 1277003968 },
 513:keygen.c      **** 	{ 2138490881, 1351891144, 1976858109 },
 514:keygen.c      **** 	{ 2138460161, 1817321013, 1979278293 },
 515:keygen.c      **** 	{ 2138429441, 1950077177,  203441928 },
 516:keygen.c      **** 	{ 2138400769,  908970113,  628395069 },
 517:keygen.c      **** 	{ 2138398721,  219890864,  758486760 },
 518:keygen.c      **** 	{ 2138376193, 1306654379,  977554090 },
 519:keygen.c      **** 	{ 2138351617,  298822498, 2004708503 },
 520:keygen.c      **** 	{ 2138337281,  441457816, 1049002108 },
 521:keygen.c      **** 	{ 2138320897, 1517731724, 1442269609 },
 522:keygen.c      **** 	{ 2138290177, 1355911197, 1647139103 },
 523:keygen.c      **** 	{ 2138234881,  531313247, 1746591962 },
 524:keygen.c      **** 	{ 2138214401, 1899410930,  781416444 },
 525:keygen.c      **** 	{ 2138202113, 1813477173, 1622508515 },
 526:keygen.c      **** 	{ 2138191873, 1086458299, 1025408615 },
 527:keygen.c      **** 	{ 2138183681, 1998800427,  827063290 },
 528:keygen.c      **** 	{ 2138173441, 1921308898,  749670117 },
 529:keygen.c      **** 	{ 2138103809, 1620902804, 2126787647 },
 530:keygen.c      **** 	{ 2138099713,  828647069, 1892961817 },
 531:keygen.c      **** 	{ 2138085377,  179405355, 1525506535 },
 532:keygen.c      **** 	{ 2138060801,  615683235, 1259580138 },
 533:keygen.c      **** 	{ 2138044417, 2030277840, 1731266562 },
 534:keygen.c      **** 	{ 2138042369, 2087222316, 1627902259 },
 535:keygen.c      **** 	{ 2138032129,  126388712, 1108640984 },
 536:keygen.c      **** 	{ 2138011649,  715026550, 1017980050 },
 537:keygen.c      **** 	{ 2137993217, 1693714349, 1351778704 },
 538:keygen.c      **** 	{ 2137888769, 1289762259, 1053090405 },
 539:keygen.c      **** 	{ 2137853953,  199991890, 1254192789 },
 540:keygen.c      **** 	{ 2137833473,  941421685,  896995556 },
 541:keygen.c      **** 	{ 2137817089,  750416446, 1251031181 },
 542:keygen.c      **** 	{ 2137792513,  798075119,  368077456 },
 543:keygen.c      **** 	{ 2137786369,  878543495, 1035375025 },
 544:keygen.c      **** 	{ 2137767937,    9351178, 1156563902 },
 545:keygen.c      **** 	{ 2137755649, 1382297614, 1686559583 },
 546:keygen.c      **** 	{ 2137724929, 1345472850, 1681096331 },
 547:keygen.c      **** 	{ 2137704449,  834666929,  630551727 },
 548:keygen.c      **** 	{ 2137673729, 1646165729, 1892091571 },
 549:keygen.c      **** 	{ 2137620481,  778943821,   48456461 },
 550:keygen.c      **** 	{ 2137618433, 1730837875, 1713336725 },
 551:keygen.c      **** 	{ 2137581569,  805610339, 1378891359 },
 552:keygen.c      **** 	{ 2137538561,  204342388, 1950165220 },
 553:keygen.c      **** 	{ 2137526273, 1947629754, 1500789441 },
 554:keygen.c      **** 	{ 2137516033,  719902645, 1499525372 },
 555:keygen.c      **** 	{ 2137491457,  230451261,  556382829 },
 556:keygen.c      **** 	{ 2137440257,  979573541,  412760291 },
 557:keygen.c      **** 	{ 2137374721,  927841248, 1954137185 },
 558:keygen.c      **** 	{ 2137362433, 1243778559,  861024672 },
 559:keygen.c      **** 	{ 2137313281, 1341338501,  980638386 },
 560:keygen.c      **** 	{ 2137311233,  937415182, 1793212117 },
 561:keygen.c      **** 	{ 2137255937,  795331324, 1410253405 },
 562:keygen.c      **** 	{ 2137243649,  150756339, 1966999887 },
 563:keygen.c      **** 	{ 2137182209,  163346914, 1939301431 },
 564:keygen.c      **** 	{ 2137171969, 1952552395,  758913141 },
 565:keygen.c      **** 	{ 2137159681,  570788721,  218668666 },
 566:keygen.c      **** 	{ 2137147393, 1896656810, 2045670345 },
 567:keygen.c      **** 	{ 2137141249,  358493842,  518199643 },
 568:keygen.c      **** 	{ 2137139201, 1505023029,  674695848 },
 569:keygen.c      **** 	{ 2137133057,   27911103,  830956306 },
 570:keygen.c      **** 	{ 2137122817,  439771337, 1555268614 },
 571:keygen.c      **** 	{ 2137116673,  790988579, 1871449599 },
 572:keygen.c      **** 	{ 2137110529,  432109234,  811805080 },
 573:keygen.c      **** 	{ 2137102337, 1357900653, 1184997641 },
 574:keygen.c      **** 	{ 2137098241,  515119035, 1715693095 },
 575:keygen.c      **** 	{ 2137090049,  408575203, 2085660657 },
 576:keygen.c      **** 	{ 2137085953, 2097793407, 1349626963 },
 577:keygen.c      **** 	{ 2137055233, 1556739954, 1449960883 },
 578:keygen.c      **** 	{ 2137030657, 1545758650, 1369303716 },
 579:keygen.c      **** 	{ 2136987649,  332602570,  103875114 },
 580:keygen.c      **** 	{ 2136969217, 1499989506, 1662964115 },
 581:keygen.c      **** 	{ 2136924161,  857040753,    4738842 },
 582:keygen.c      **** 	{ 2136895489, 1948872712,  570436091 },
 583:keygen.c      **** 	{ 2136893441,   58969960, 1568349634 },
 584:keygen.c      **** 	{ 2136887297, 2127193379,  273612548 },
 585:keygen.c      **** 	{ 2136850433,  111208983, 1181257116 },
 586:keygen.c      **** 	{ 2136809473, 1627275942, 1680317971 },
 587:keygen.c      **** 	{ 2136764417, 1574888217,   14011331 },
 588:keygen.c      **** 	{ 2136741889,   14011055, 1129154251 },
 589:keygen.c      **** 	{ 2136727553,   35862563, 1838555253 },
 590:keygen.c      **** 	{ 2136721409,  310235666, 1363928244 },
 591:keygen.c      **** 	{ 2136698881, 1612429202, 1560383828 },
 592:keygen.c      **** 	{ 2136649729, 1138540131,  800014364 },
 593:keygen.c      **** 	{ 2136606721,  602323503, 1433096652 },
 594:keygen.c      **** 	{ 2136563713,  182209265, 1919611038 },
 595:keygen.c      **** 	{ 2136555521,  324156477,  165591039 },
 596:keygen.c      **** 	{ 2136549377,  195513113,  217165345 },
 597:keygen.c      **** 	{ 2136526849, 1050768046,  939647887 },
 598:keygen.c      **** 	{ 2136508417, 1886286237, 1619926572 },
 599:keygen.c      **** 	{ 2136477697,  609647664,   35065157 },
 600:keygen.c      **** 	{ 2136471553,  679352216, 1452259468 },
 601:keygen.c      **** 	{ 2136457217,  128630031,  824816521 },
 602:keygen.c      **** 	{ 2136422401,   19787464, 1526049830 },
 603:keygen.c      **** 	{ 2136420353,  698316836, 1530623527 },
 604:keygen.c      **** 	{ 2136371201, 1651862373, 1804812805 },
 605:keygen.c      **** 	{ 2136334337,  326596005,  336977082 },
 606:keygen.c      **** 	{ 2136322049,   63253370, 1904972151 },
 607:keygen.c      **** 	{ 2136297473,  312176076,  172182411 },
 608:keygen.c      **** 	{ 2136248321,  381261841,  369032670 },
 609:keygen.c      **** 	{ 2136242177,  358688773, 1640007994 },
 610:keygen.c      **** 	{ 2136229889,  512677188,   75585225 },
 611:keygen.c      **** 	{ 2136219649, 2095003250, 1970086149 },
 612:keygen.c      **** 	{ 2136207361, 1909650722,  537760675 },
 613:keygen.c      **** 	{ 2136176641, 1334616195, 1533487619 },
 614:keygen.c      **** 	{ 2136158209, 2096285632, 1793285210 },
 615:keygen.c      **** 	{ 2136143873, 1897347517,  293843959 },
 616:keygen.c      **** 	{ 2136133633,  923586222, 1022655978 },
 617:keygen.c      **** 	{ 2136096769, 1464868191, 1515074410 },
 618:keygen.c      **** 	{ 2136094721, 2020679520, 2061636104 },
 619:keygen.c      **** 	{ 2136076289,  290798503, 1814726809 },
 620:keygen.c      **** 	{ 2136041473,  156415894, 1250757633 },
 621:keygen.c      **** 	{ 2135996417,  297459940, 1132158924 },
 622:keygen.c      **** 	{ 2135955457,  538755304, 1688831340 },
 623:keygen.c      **** 	{ 0, 0, 0 }
 624:keygen.c      **** };
 625:keygen.c      **** 
 626:keygen.c      **** /*
 627:keygen.c      ****  * Reduce a small signed integer modulo a small prime. The source
 628:keygen.c      ****  * value x MUST be such that -p < x < p.
 629:keygen.c      ****  */
 630:keygen.c      **** static inline uint32_t
 631:keygen.c      **** modp_set(int32_t x, uint32_t p)
 632:keygen.c      **** {
 2388              		.loc 2 632 1
 2389              		.cfi_startproc
 2390              		@ args = 0, pretend = 0, frame = 16
 2391              		@ frame_needed = 1, uses_anonymous_args = 0
 2392              		@ link register save eliminated.
 2393 0000 80B4     		push	{r7}
 2394              	.LCFI33:
 2395              		.cfi_def_cfa_offset 4
 2396              		.cfi_offset 7, -4
 2397 0002 85B0     		sub	sp, sp, #20
 2398              	.LCFI34:
 2399              		.cfi_def_cfa_offset 24
 2400 0004 00AF     		add	r7, sp, #0
 2401              	.LCFI35:
 2402              		.cfi_def_cfa_register 7
 2403 0006 7860     		str	r0, [r7, #4]
 2404 0008 3960     		str	r1, [r7]
 633:keygen.c      **** 	uint32_t w;
 634:keygen.c      **** 
 635:keygen.c      **** 	w = (uint32_t)x;
 2405              		.loc 2 635 4
 2406 000a 7B68     		ldr	r3, [r7, #4]
 2407 000c FB60     		str	r3, [r7, #12]
 636:keygen.c      **** 	w += p & -(w >> 31);
 2408              		.loc 2 636 11
 2409 000e FB68     		ldr	r3, [r7, #12]
 2410 0010 DB17     		asrs	r3, r3, #31
 2411 0012 1A46     		mov	r2, r3
 2412              		.loc 2 636 9
 2413 0014 3B68     		ldr	r3, [r7]
 2414 0016 1340     		ands	r3, r3, r2
 2415              		.loc 2 636 4
 2416 0018 FA68     		ldr	r2, [r7, #12]
 2417 001a 1344     		add	r3, r3, r2
 2418 001c FB60     		str	r3, [r7, #12]
 637:keygen.c      **** 	return w;
 2419              		.loc 2 637 9
 2420 001e FB68     		ldr	r3, [r7, #12]
 638:keygen.c      **** }
 2421              		.loc 2 638 1
 2422 0020 1846     		mov	r0, r3
 2423 0022 1437     		adds	r7, r7, #20
 2424              	.LCFI36:
 2425              		.cfi_def_cfa_offset 4
 2426 0024 BD46     		mov	sp, r7
 2427              	.LCFI37:
 2428              		.cfi_def_cfa_register 13
 2429              		@ sp needed
 2430 0026 80BC     		pop	{r7}
 2431              	.LCFI38:
 2432              		.cfi_restore 7
 2433              		.cfi_def_cfa_offset 0
 2434 0028 7047     		bx	lr
 2435              		.cfi_endproc
 2436              	.LFE18:
 2438              		.section	.text.modp_norm,"ax",%progbits
 2439              		.align	1
 2440              		.syntax unified
 2441              		.thumb
 2442              		.thumb_func
 2443              		.fpu softvfp
 2445              	modp_norm:
 2446              	.LFB19:
 639:keygen.c      **** 
 640:keygen.c      **** /*
 641:keygen.c      ****  * Normalize a modular integer around 0.
 642:keygen.c      ****  */
 643:keygen.c      **** static inline int32_t
 644:keygen.c      **** modp_norm(uint32_t x, uint32_t p)
 645:keygen.c      **** {
 2447              		.loc 2 645 1
 2448              		.cfi_startproc
 2449              		@ args = 0, pretend = 0, frame = 8
 2450              		@ frame_needed = 1, uses_anonymous_args = 0
 2451              		@ link register save eliminated.
 2452 0000 80B4     		push	{r7}
 2453              	.LCFI39:
 2454              		.cfi_def_cfa_offset 4
 2455              		.cfi_offset 7, -4
 2456 0002 83B0     		sub	sp, sp, #12
 2457              	.LCFI40:
 2458              		.cfi_def_cfa_offset 16
 2459 0004 00AF     		add	r7, sp, #0
 2460              	.LCFI41:
 2461              		.cfi_def_cfa_register 7
 2462 0006 7860     		str	r0, [r7, #4]
 2463 0008 3960     		str	r1, [r7]
 646:keygen.c      **** 	return (int32_t)(x - (p & (((x - ((p + 1) >> 1)) >> 31) - 1)));
 2464              		.loc 2 646 39
 2465 000a 3B68     		ldr	r3, [r7]
 2466 000c 0133     		adds	r3, r3, #1
 2467              		.loc 2 646 44
 2468 000e 5B08     		lsrs	r3, r3, #1
 2469              		.loc 2 646 33
 2470 0010 7A68     		ldr	r2, [r7, #4]
 2471 0012 D31A     		subs	r3, r2, r3
 2472              		.loc 2 646 51
 2473 0014 DB0F     		lsrs	r3, r3, #31
 2474              		.loc 2 646 58
 2475 0016 5A1E     		subs	r2, r3, #1
 2476              		.loc 2 646 26
 2477 0018 3B68     		ldr	r3, [r7]
 2478 001a 1340     		ands	r3, r3, r2
 2479              		.loc 2 646 21
 2480 001c 7A68     		ldr	r2, [r7, #4]
 2481 001e D31A     		subs	r3, r2, r3
 647:keygen.c      **** }
 2482              		.loc 2 647 1
 2483 0020 1846     		mov	r0, r3
 2484 0022 0C37     		adds	r7, r7, #12
 2485              	.LCFI42:
 2486              		.cfi_def_cfa_offset 4
 2487 0024 BD46     		mov	sp, r7
 2488              	.LCFI43:
 2489              		.cfi_def_cfa_register 13
 2490              		@ sp needed
 2491 0026 80BC     		pop	{r7}
 2492              	.LCFI44:
 2493              		.cfi_restore 7
 2494              		.cfi_def_cfa_offset 0
 2495 0028 7047     		bx	lr
 2496              		.cfi_endproc
 2497              	.LFE19:
 2499              		.section	.text.modp_ninv31,"ax",%progbits
 2500              		.align	1
 2501              		.syntax unified
 2502              		.thumb
 2503              		.thumb_func
 2504              		.fpu softvfp
 2506              	modp_ninv31:
 2507              	.LFB20:
 648:keygen.c      **** 
 649:keygen.c      **** /*
 650:keygen.c      ****  * Compute -1/p mod 2^31. This works for all odd integers p that fit
 651:keygen.c      ****  * on 31 bits.
 652:keygen.c      ****  */
 653:keygen.c      **** static uint32_t
 654:keygen.c      **** modp_ninv31(uint32_t p)
 655:keygen.c      **** {
 2508              		.loc 2 655 1
 2509              		.cfi_startproc
 2510              		@ args = 0, pretend = 0, frame = 16
 2511              		@ frame_needed = 1, uses_anonymous_args = 0
 2512              		@ link register save eliminated.
 2513 0000 80B4     		push	{r7}
 2514              	.LCFI45:
 2515              		.cfi_def_cfa_offset 4
 2516              		.cfi_offset 7, -4
 2517 0002 85B0     		sub	sp, sp, #20
 2518              	.LCFI46:
 2519              		.cfi_def_cfa_offset 24
 2520 0004 00AF     		add	r7, sp, #0
 2521              	.LCFI47:
 2522              		.cfi_def_cfa_register 7
 2523 0006 7860     		str	r0, [r7, #4]
 656:keygen.c      **** 	uint32_t y;
 657:keygen.c      **** 
 658:keygen.c      **** 	y = 2 - p;
 2524              		.loc 2 658 4
 2525 0008 7B68     		ldr	r3, [r7, #4]
 2526 000a C3F10203 		rsb	r3, r3, #2
 2527 000e FB60     		str	r3, [r7, #12]
 659:keygen.c      **** 	y *= 2 - p * y;
 2528              		.loc 2 659 13
 2529 0010 7B68     		ldr	r3, [r7, #4]
 2530 0012 FA68     		ldr	r2, [r7, #12]
 2531 0014 02FB03F3 		mul	r3, r2, r3
 2532              		.loc 2 659 9
 2533 0018 C3F10202 		rsb	r2, r3, #2
 2534              		.loc 2 659 4
 2535 001c FB68     		ldr	r3, [r7, #12]
 2536 001e 02FB03F3 		mul	r3, r2, r3
 2537 0022 FB60     		str	r3, [r7, #12]
 660:keygen.c      **** 	y *= 2 - p * y;
 2538              		.loc 2 660 13
 2539 0024 7B68     		ldr	r3, [r7, #4]
 2540 0026 FA68     		ldr	r2, [r7, #12]
 2541 0028 02FB03F3 		mul	r3, r2, r3
 2542              		.loc 2 660 9
 2543 002c C3F10202 		rsb	r2, r3, #2
 2544              		.loc 2 660 4
 2545 0030 FB68     		ldr	r3, [r7, #12]
 2546 0032 02FB03F3 		mul	r3, r2, r3
 2547 0036 FB60     		str	r3, [r7, #12]
 661:keygen.c      **** 	y *= 2 - p * y;
 2548              		.loc 2 661 13
 2549 0038 7B68     		ldr	r3, [r7, #4]
 2550 003a FA68     		ldr	r2, [r7, #12]
 2551 003c 02FB03F3 		mul	r3, r2, r3
 2552              		.loc 2 661 9
 2553 0040 C3F10202 		rsb	r2, r3, #2
 2554              		.loc 2 661 4
 2555 0044 FB68     		ldr	r3, [r7, #12]
 2556 0046 02FB03F3 		mul	r3, r2, r3
 2557 004a FB60     		str	r3, [r7, #12]
 662:keygen.c      **** 	y *= 2 - p * y;
 2558              		.loc 2 662 13
 2559 004c 7B68     		ldr	r3, [r7, #4]
 2560 004e FA68     		ldr	r2, [r7, #12]
 2561 0050 02FB03F3 		mul	r3, r2, r3
 2562              		.loc 2 662 9
 2563 0054 C3F10202 		rsb	r2, r3, #2
 2564              		.loc 2 662 4
 2565 0058 FB68     		ldr	r3, [r7, #12]
 2566 005a 02FB03F3 		mul	r3, r2, r3
 2567 005e FB60     		str	r3, [r7, #12]
 663:keygen.c      **** 	return (uint32_t)0x7FFFFFFF & -y;
 2568              		.loc 2 663 32
 2569 0060 FB68     		ldr	r3, [r7, #12]
 2570 0062 5B42     		rsbs	r3, r3, #0
 2571              		.loc 2 663 30
 2572 0064 23F00043 		bic	r3, r3, #-2147483648
 664:keygen.c      **** }
 2573              		.loc 2 664 1
 2574 0068 1846     		mov	r0, r3
 2575 006a 1437     		adds	r7, r7, #20
 2576              	.LCFI48:
 2577              		.cfi_def_cfa_offset 4
 2578 006c BD46     		mov	sp, r7
 2579              	.LCFI49:
 2580              		.cfi_def_cfa_register 13
 2581              		@ sp needed
 2582 006e 80BC     		pop	{r7}
 2583              	.LCFI50:
 2584              		.cfi_restore 7
 2585              		.cfi_def_cfa_offset 0
 2586 0070 7047     		bx	lr
 2587              		.cfi_endproc
 2588              	.LFE20:
 2590              		.section	.text.modp_R,"ax",%progbits
 2591              		.align	1
 2592              		.syntax unified
 2593              		.thumb
 2594              		.thumb_func
 2595              		.fpu softvfp
 2597              	modp_R:
 2598              	.LFB21:
 665:keygen.c      **** 
 666:keygen.c      **** /*
 667:keygen.c      ****  * Compute R = 2^31 mod p.
 668:keygen.c      ****  */
 669:keygen.c      **** static inline uint32_t
 670:keygen.c      **** modp_R(uint32_t p)
 671:keygen.c      **** {
 2599              		.loc 2 671 1
 2600              		.cfi_startproc
 2601              		@ args = 0, pretend = 0, frame = 8
 2602              		@ frame_needed = 1, uses_anonymous_args = 0
 2603              		@ link register save eliminated.
 2604 0000 80B4     		push	{r7}
 2605              	.LCFI51:
 2606              		.cfi_def_cfa_offset 4
 2607              		.cfi_offset 7, -4
 2608 0002 83B0     		sub	sp, sp, #12
 2609              	.LCFI52:
 2610              		.cfi_def_cfa_offset 16
 2611 0004 00AF     		add	r7, sp, #0
 2612              	.LCFI53:
 2613              		.cfi_def_cfa_register 7
 2614 0006 7860     		str	r0, [r7, #4]
 672:keygen.c      **** 	/*
 673:keygen.c      **** 	 * Since 2^30 < p < 2^31, we know that 2^31 mod p is simply
 674:keygen.c      **** 	 * 2^31 - p.
 675:keygen.c      **** 	 */
 676:keygen.c      **** 	return ((uint32_t)1 << 31) - p;
 2615              		.loc 2 676 29
 2616 0008 7B68     		ldr	r3, [r7, #4]
 2617 000a C3F10043 		rsb	r3, r3, #-2147483648
 677:keygen.c      **** }
 2618              		.loc 2 677 1
 2619 000e 1846     		mov	r0, r3
 2620 0010 0C37     		adds	r7, r7, #12
 2621              	.LCFI54:
 2622              		.cfi_def_cfa_offset 4
 2623 0012 BD46     		mov	sp, r7
 2624              	.LCFI55:
 2625              		.cfi_def_cfa_register 13
 2626              		@ sp needed
 2627 0014 80BC     		pop	{r7}
 2628              	.LCFI56:
 2629              		.cfi_restore 7
 2630              		.cfi_def_cfa_offset 0
 2631 0016 7047     		bx	lr
 2632              		.cfi_endproc
 2633              	.LFE21:
 2635              		.section	.text.modp_add,"ax",%progbits
 2636              		.align	1
 2637              		.syntax unified
 2638              		.thumb
 2639              		.thumb_func
 2640              		.fpu softvfp
 2642              	modp_add:
 2643              	.LFB22:
 678:keygen.c      **** 
 679:keygen.c      **** /*
 680:keygen.c      ****  * Addition modulo p.
 681:keygen.c      ****  */
 682:keygen.c      **** static inline uint32_t
 683:keygen.c      **** modp_add(uint32_t a, uint32_t b, uint32_t p)
 684:keygen.c      **** {
 2644              		.loc 2 684 1
 2645              		.cfi_startproc
 2646              		@ args = 0, pretend = 0, frame = 24
 2647              		@ frame_needed = 1, uses_anonymous_args = 0
 2648              		@ link register save eliminated.
 2649 0000 80B4     		push	{r7}
 2650              	.LCFI57:
 2651              		.cfi_def_cfa_offset 4
 2652              		.cfi_offset 7, -4
 2653 0002 87B0     		sub	sp, sp, #28
 2654              	.LCFI58:
 2655              		.cfi_def_cfa_offset 32
 2656 0004 00AF     		add	r7, sp, #0
 2657              	.LCFI59:
 2658              		.cfi_def_cfa_register 7
 2659 0006 F860     		str	r0, [r7, #12]
 2660 0008 B960     		str	r1, [r7, #8]
 2661 000a 7A60     		str	r2, [r7, #4]
 685:keygen.c      **** 	uint32_t d;
 686:keygen.c      **** 
 687:keygen.c      **** 	d = a + b - p;
 2662              		.loc 2 687 8
 2663 000c FA68     		ldr	r2, [r7, #12]
 2664 000e BB68     		ldr	r3, [r7, #8]
 2665 0010 1A44     		add	r2, r2, r3
 2666              		.loc 2 687 4
 2667 0012 7B68     		ldr	r3, [r7, #4]
 2668 0014 D31A     		subs	r3, r2, r3
 2669 0016 7B61     		str	r3, [r7, #20]
 688:keygen.c      **** 	d += p & -(d >> 31);
 2670              		.loc 2 688 11
 2671 0018 7B69     		ldr	r3, [r7, #20]
 2672 001a DB17     		asrs	r3, r3, #31
 2673 001c 1A46     		mov	r2, r3
 2674              		.loc 2 688 9
 2675 001e 7B68     		ldr	r3, [r7, #4]
 2676 0020 1340     		ands	r3, r3, r2
 2677              		.loc 2 688 4
 2678 0022 7A69     		ldr	r2, [r7, #20]
 2679 0024 1344     		add	r3, r3, r2
 2680 0026 7B61     		str	r3, [r7, #20]
 689:keygen.c      **** 	return d;
 2681              		.loc 2 689 9
 2682 0028 7B69     		ldr	r3, [r7, #20]
 690:keygen.c      **** }
 2683              		.loc 2 690 1
 2684 002a 1846     		mov	r0, r3
 2685 002c 1C37     		adds	r7, r7, #28
 2686              	.LCFI60:
 2687              		.cfi_def_cfa_offset 4
 2688 002e BD46     		mov	sp, r7
 2689              	.LCFI61:
 2690              		.cfi_def_cfa_register 13
 2691              		@ sp needed
 2692 0030 80BC     		pop	{r7}
 2693              	.LCFI62:
 2694              		.cfi_restore 7
 2695              		.cfi_def_cfa_offset 0
 2696 0032 7047     		bx	lr
 2697              		.cfi_endproc
 2698              	.LFE22:
 2700              		.section	.text.modp_sub,"ax",%progbits
 2701              		.align	1
 2702              		.syntax unified
 2703              		.thumb
 2704              		.thumb_func
 2705              		.fpu softvfp
 2707              	modp_sub:
 2708              	.LFB23:
 691:keygen.c      **** 
 692:keygen.c      **** /*
 693:keygen.c      ****  * Subtraction modulo p.
 694:keygen.c      ****  */
 695:keygen.c      **** static inline uint32_t
 696:keygen.c      **** modp_sub(uint32_t a, uint32_t b, uint32_t p)
 697:keygen.c      **** {
 2709              		.loc 2 697 1
 2710              		.cfi_startproc
 2711              		@ args = 0, pretend = 0, frame = 24
 2712              		@ frame_needed = 1, uses_anonymous_args = 0
 2713              		@ link register save eliminated.
 2714 0000 80B4     		push	{r7}
 2715              	.LCFI63:
 2716              		.cfi_def_cfa_offset 4
 2717              		.cfi_offset 7, -4
 2718 0002 87B0     		sub	sp, sp, #28
 2719              	.LCFI64:
 2720              		.cfi_def_cfa_offset 32
 2721 0004 00AF     		add	r7, sp, #0
 2722              	.LCFI65:
 2723              		.cfi_def_cfa_register 7
 2724 0006 F860     		str	r0, [r7, #12]
 2725 0008 B960     		str	r1, [r7, #8]
 2726 000a 7A60     		str	r2, [r7, #4]
 698:keygen.c      **** 	uint32_t d;
 699:keygen.c      **** 
 700:keygen.c      **** 	d = a - b;
 2727              		.loc 2 700 4
 2728 000c FA68     		ldr	r2, [r7, #12]
 2729 000e BB68     		ldr	r3, [r7, #8]
 2730 0010 D31A     		subs	r3, r2, r3
 2731 0012 7B61     		str	r3, [r7, #20]
 701:keygen.c      **** 	d += p & -(d >> 31);
 2732              		.loc 2 701 11
 2733 0014 7B69     		ldr	r3, [r7, #20]
 2734 0016 DB17     		asrs	r3, r3, #31
 2735 0018 1A46     		mov	r2, r3
 2736              		.loc 2 701 9
 2737 001a 7B68     		ldr	r3, [r7, #4]
 2738 001c 1340     		ands	r3, r3, r2
 2739              		.loc 2 701 4
 2740 001e 7A69     		ldr	r2, [r7, #20]
 2741 0020 1344     		add	r3, r3, r2
 2742 0022 7B61     		str	r3, [r7, #20]
 702:keygen.c      **** 	return d;
 2743              		.loc 2 702 9
 2744 0024 7B69     		ldr	r3, [r7, #20]
 703:keygen.c      **** }
 2745              		.loc 2 703 1
 2746 0026 1846     		mov	r0, r3
 2747 0028 1C37     		adds	r7, r7, #28
 2748              	.LCFI66:
 2749              		.cfi_def_cfa_offset 4
 2750 002a BD46     		mov	sp, r7
 2751              	.LCFI67:
 2752              		.cfi_def_cfa_register 13
 2753              		@ sp needed
 2754 002c 80BC     		pop	{r7}
 2755              	.LCFI68:
 2756              		.cfi_restore 7
 2757              		.cfi_def_cfa_offset 0
 2758 002e 7047     		bx	lr
 2759              		.cfi_endproc
 2760              	.LFE23:
 2762              		.section	.text.modp_montymul,"ax",%progbits
 2763              		.align	1
 2764              		.syntax unified
 2765              		.thumb
 2766              		.thumb_func
 2767              		.fpu softvfp
 2769              	modp_montymul:
 2770              	.LFB24:
 704:keygen.c      **** 
 705:keygen.c      **** /*
 706:keygen.c      ****  * Halving modulo p.
 707:keygen.c      ****  */
 708:keygen.c      **** /* unused
 709:keygen.c      **** static inline uint32_t
 710:keygen.c      **** modp_half(uint32_t a, uint32_t p)
 711:keygen.c      **** {
 712:keygen.c      **** 	a += p & -(a & 1);
 713:keygen.c      **** 	return a >> 1;
 714:keygen.c      **** }
 715:keygen.c      **** */
 716:keygen.c      **** 
 717:keygen.c      **** /*
 718:keygen.c      ****  * Montgomery multiplication modulo p. The 'p0i' value is -1/p mod 2^31.
 719:keygen.c      ****  * It is required that p is an odd integer.
 720:keygen.c      ****  */
 721:keygen.c      **** static inline uint32_t
 722:keygen.c      **** modp_montymul(uint32_t a, uint32_t b, uint32_t p, uint32_t p0i)
 723:keygen.c      **** {
 2771              		.loc 2 723 1
 2772              		.cfi_startproc
 2773              		@ args = 0, pretend = 0, frame = 88
 2774              		@ frame_needed = 1, uses_anonymous_args = 0
 2775              		@ link register save eliminated.
 2776 0000 2DE9F00F 		push	{r4, r5, r6, r7, r8, r9, r10, fp}
 2777              	.LCFI69:
 2778              		.cfi_def_cfa_offset 32
 2779              		.cfi_offset 4, -32
 2780              		.cfi_offset 5, -28
 2781              		.cfi_offset 6, -24
 2782              		.cfi_offset 7, -20
 2783              		.cfi_offset 8, -16
 2784              		.cfi_offset 9, -12
 2785              		.cfi_offset 10, -8
 2786              		.cfi_offset 11, -4
 2787 0004 96B0     		sub	sp, sp, #88
 2788              	.LCFI70:
 2789              		.cfi_def_cfa_offset 120
 2790 0006 00AF     		add	r7, sp, #0
 2791              	.LCFI71:
 2792              		.cfi_def_cfa_register 7
 2793 0008 F863     		str	r0, [r7, #60]
 2794 000a B963     		str	r1, [r7, #56]
 2795 000c 7A63     		str	r2, [r7, #52]
 2796 000e 3B63     		str	r3, [r7, #48]
 724:keygen.c      **** 	uint64_t z, w;
 725:keygen.c      **** 	uint32_t d;
 726:keygen.c      **** 
 727:keygen.c      **** 	z = (uint64_t)a * (uint64_t)b;
 2797              		.loc 2 727 6
 2798 0010 FB6B     		ldr	r3, [r7, #60]
 2799 0012 0022     		movs	r2, #0
 2800 0014 BB61     		str	r3, [r7, #24]
 2801 0016 FA61     		str	r2, [r7, #28]
 2802              		.loc 2 727 20
 2803 0018 BB6B     		ldr	r3, [r7, #56]
 2804 001a 0022     		movs	r2, #0
 2805 001c BB62     		str	r3, [r7, #40]
 2806 001e FA62     		str	r2, [r7, #44]
 2807              		.loc 2 727 4
 2808 0020 D7E90601 		ldrd	r0, [r7, #24]
 2809 0024 0B46     		mov	r3, r1
 2810 0026 BA6A     		ldr	r2, [r7, #40]
 2811 0028 02FB03F2 		mul	r2, r2, r3
 2812 002c FB6A     		ldr	r3, [r7, #44]
 2813 002e 0646     		mov	r6, r0
 2814 0030 06FB03F3 		mul	r3, r6, r3
 2815 0034 1344     		add	r3, r3, r2
 2816 0036 0246     		mov	r2, r0
 2817 0038 B96A     		ldr	r1, [r7, #40]
 2818 003a A2FB0145 		umull	r4, r5, r2, r1
 2819 003e 2B44     		add	r3, r3, r5
 2820 0040 1D46     		mov	r5, r3
 2821 0042 C7E91445 		strd	r4, [r7, #80]
 2822 0046 C7E91445 		strd	r4, [r7, #80]
 728:keygen.c      **** 	w = ((z * p0i) & (uint64_t)0x7FFFFFFF) * p;
 2823              		.loc 2 728 10
 2824 004a 3B6B     		ldr	r3, [r7, #48]
 2825 004c 0022     		movs	r2, #0
 2826 004e 3B61     		str	r3, [r7, #16]
 2827 0050 7A61     		str	r2, [r7, #20]
 2828 0052 3B6D     		ldr	r3, [r7, #80]
 2829 0054 D7E90445 		ldrd	r4, [r7, #16]
 2830 0058 2A46     		mov	r2, r5
 2831 005a 02FB03F2 		mul	r2, r2, r3
 2832 005e 7B6D     		ldr	r3, [r7, #84]
 2833 0060 2146     		mov	r1, r4
 2834 0062 01FB03F3 		mul	r3, r1, r3
 2835 0066 1344     		add	r3, r3, r2
 2836 0068 3A6D     		ldr	r2, [r7, #80]
 2837 006a 2146     		mov	r1, r4
 2838 006c A2FB0121 		umull	r2, r1, r2, r1
 2839 0070 7962     		str	r1, [r7, #36]
 2840 0072 3A62     		str	r2, [r7, #32]
 2841 0074 7A6A     		ldr	r2, [r7, #36]
 2842 0076 1344     		add	r3, r3, r2
 2843 0078 7B62     		str	r3, [r7, #36]
 2844              		.loc 2 728 17
 2845 007a 3B6A     		ldr	r3, [r7, #32]
 2846 007c 23F00043 		bic	r3, r3, #-2147483648
 2847 0080 BB60     		str	r3, [r7, #8]
 2848 0082 0023     		movs	r3, #0
 2849 0084 FB60     		str	r3, [r7, #12]
 2850              		.loc 2 728 41
 2851 0086 7B6B     		ldr	r3, [r7, #52]
 2852 0088 0022     		movs	r2, #0
 2853 008a 3B60     		str	r3, [r7]
 2854 008c 7A60     		str	r2, [r7, #4]
 2855              		.loc 2 728 4
 2856 008e D7E90234 		ldrd	r3, [r7, #8]
 2857 0092 2246     		mov	r2, r4
 2858 0094 D7E90056 		ldrd	r5, [r7]
 2859 0098 2946     		mov	r1, r5
 2860 009a 01FB02F2 		mul	r2, r1, r2
 2861 009e B446     		mov	ip, r6
 2862 00a0 1846     		mov	r0, r3
 2863 00a2 2146     		mov	r1, r4
 2864 00a4 0346     		mov	r3, r0
 2865 00a6 03FB0CF3 		mul	r3, r3, ip
 2866 00aa 1344     		add	r3, r3, r2
 2867 00ac 0246     		mov	r2, r0
 2868 00ae 2946     		mov	r1, r5
 2869 00b0 A2FB0189 		umull	r8, r9, r2, r1
 2870 00b4 4B44     		add	r3, r3, r9
 2871 00b6 9946     		mov	r9, r3
 2872 00b8 C7E91289 		strd	r8, [r7, #72]
 2873 00bc C7E91289 		strd	r8, [r7, #72]
 729:keygen.c      **** 	d = (uint32_t)((z + w) >> 31) - p;
 2874              		.loc 2 729 20
 2875 00c0 D7E91401 		ldrd	r0, [r7, #80]
 2876 00c4 D7E91223 		ldrd	r2, [r7, #72]
 2877 00c8 10EB020A 		adds	r10, r0, r2
 2878 00cc 41EB030B 		adc	fp, r1, r3
 2879              		.loc 2 729 25
 2880 00d0 4FF00002 		mov	r2, #0
 2881 00d4 4FF00003 		mov	r3, #0
 2882 00d8 4FEADA72 		lsr	r2, r10, #31
 2883 00dc 42EA4B02 		orr	r2, r2, fp, lsl #1
 2884 00e0 4FEADB73 		lsr	r3, fp, #31
 2885              		.loc 2 729 4
 2886 00e4 7B6B     		ldr	r3, [r7, #52]
 2887 00e6 D31A     		subs	r3, r2, r3
 2888 00e8 7B64     		str	r3, [r7, #68]
 730:keygen.c      **** 	d += p & -(d >> 31);
 2889              		.loc 2 730 11
 2890 00ea 7B6C     		ldr	r3, [r7, #68]
 2891 00ec DB17     		asrs	r3, r3, #31
 2892 00ee 1A46     		mov	r2, r3
 2893              		.loc 2 730 9
 2894 00f0 7B6B     		ldr	r3, [r7, #52]
 2895 00f2 1340     		ands	r3, r3, r2
 2896              		.loc 2 730 4
 2897 00f4 7A6C     		ldr	r2, [r7, #68]
 2898 00f6 1344     		add	r3, r3, r2
 2899 00f8 7B64     		str	r3, [r7, #68]
 731:keygen.c      **** 	return d;
 2900              		.loc 2 731 9
 2901 00fa 7B6C     		ldr	r3, [r7, #68]
 732:keygen.c      **** }
 2902              		.loc 2 732 1
 2903 00fc 1846     		mov	r0, r3
 2904 00fe 5837     		adds	r7, r7, #88
 2905              	.LCFI72:
 2906              		.cfi_def_cfa_offset 32
 2907 0100 BD46     		mov	sp, r7
 2908              	.LCFI73:
 2909              		.cfi_def_cfa_register 13
 2910              		@ sp needed
 2911 0102 BDE8F00F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp}
 2912              	.LCFI74:
 2913              		.cfi_restore 11
 2914              		.cfi_restore 10
 2915              		.cfi_restore 9
 2916              		.cfi_restore 8
 2917              		.cfi_restore 7
 2918              		.cfi_restore 6
 2919              		.cfi_restore 5
 2920              		.cfi_restore 4
 2921              		.cfi_def_cfa_offset 0
 2922 0106 7047     		bx	lr
 2923              		.cfi_endproc
 2924              	.LFE24:
 2926              		.section	.text.modp_R2,"ax",%progbits
 2927              		.align	1
 2928              		.syntax unified
 2929              		.thumb
 2930              		.thumb_func
 2931              		.fpu softvfp
 2933              	modp_R2:
 2934              	.LFB25:
 733:keygen.c      **** 
 734:keygen.c      **** /*
 735:keygen.c      ****  * Compute R2 = 2^62 mod p.
 736:keygen.c      ****  */
 737:keygen.c      **** static uint32_t
 738:keygen.c      **** modp_R2(uint32_t p, uint32_t p0i)
 739:keygen.c      **** {
 2935              		.loc 2 739 1
 2936              		.cfi_startproc
 2937              		@ args = 0, pretend = 0, frame = 16
 2938              		@ frame_needed = 1, uses_anonymous_args = 0
 2939 0000 80B5     		push	{r7, lr}
 2940              	.LCFI75:
 2941              		.cfi_def_cfa_offset 8
 2942              		.cfi_offset 7, -8
 2943              		.cfi_offset 14, -4
 2944 0002 84B0     		sub	sp, sp, #16
 2945              	.LCFI76:
 2946              		.cfi_def_cfa_offset 24
 2947 0004 00AF     		add	r7, sp, #0
 2948              	.LCFI77:
 2949              		.cfi_def_cfa_register 7
 2950 0006 7860     		str	r0, [r7, #4]
 2951 0008 3960     		str	r1, [r7]
 740:keygen.c      **** 	uint32_t z;
 741:keygen.c      **** 
 742:keygen.c      **** 	/*
 743:keygen.c      **** 	 * Compute z = 2^31 mod p (this is the value 1 in Montgomery
 744:keygen.c      **** 	 * representation), then double it with an addition.
 745:keygen.c      **** 	 */
 746:keygen.c      **** 	z = modp_R(p);
 2952              		.loc 2 746 6
 2953 000a 7868     		ldr	r0, [r7, #4]
 2954 000c FFF7FEFF 		bl	modp_R
 2955 0010 F860     		str	r0, [r7, #12]
 747:keygen.c      **** 	z = modp_add(z, z, p);
 2956              		.loc 2 747 6
 2957 0012 7A68     		ldr	r2, [r7, #4]
 2958 0014 F968     		ldr	r1, [r7, #12]
 2959 0016 F868     		ldr	r0, [r7, #12]
 2960 0018 FFF7FEFF 		bl	modp_add
 2961 001c F860     		str	r0, [r7, #12]
 748:keygen.c      **** 
 749:keygen.c      **** 	/*
 750:keygen.c      **** 	 * Square it five times to obtain 2^32 in Montgomery representation
 751:keygen.c      **** 	 * (i.e. 2^63 mod p).
 752:keygen.c      **** 	 */
 753:keygen.c      **** 	z = modp_montymul(z, z, p, p0i);
 2962              		.loc 2 753 6
 2963 001e 3B68     		ldr	r3, [r7]
 2964 0020 7A68     		ldr	r2, [r7, #4]
 2965 0022 F968     		ldr	r1, [r7, #12]
 2966 0024 F868     		ldr	r0, [r7, #12]
 2967 0026 FFF7FEFF 		bl	modp_montymul
 2968 002a F860     		str	r0, [r7, #12]
 754:keygen.c      **** 	z = modp_montymul(z, z, p, p0i);
 2969              		.loc 2 754 6
 2970 002c 3B68     		ldr	r3, [r7]
 2971 002e 7A68     		ldr	r2, [r7, #4]
 2972 0030 F968     		ldr	r1, [r7, #12]
 2973 0032 F868     		ldr	r0, [r7, #12]
 2974 0034 FFF7FEFF 		bl	modp_montymul
 2975 0038 F860     		str	r0, [r7, #12]
 755:keygen.c      **** 	z = modp_montymul(z, z, p, p0i);
 2976              		.loc 2 755 6
 2977 003a 3B68     		ldr	r3, [r7]
 2978 003c 7A68     		ldr	r2, [r7, #4]
 2979 003e F968     		ldr	r1, [r7, #12]
 2980 0040 F868     		ldr	r0, [r7, #12]
 2981 0042 FFF7FEFF 		bl	modp_montymul
 2982 0046 F860     		str	r0, [r7, #12]
 756:keygen.c      **** 	z = modp_montymul(z, z, p, p0i);
 2983              		.loc 2 756 6
 2984 0048 3B68     		ldr	r3, [r7]
 2985 004a 7A68     		ldr	r2, [r7, #4]
 2986 004c F968     		ldr	r1, [r7, #12]
 2987 004e F868     		ldr	r0, [r7, #12]
 2988 0050 FFF7FEFF 		bl	modp_montymul
 2989 0054 F860     		str	r0, [r7, #12]
 757:keygen.c      **** 	z = modp_montymul(z, z, p, p0i);
 2990              		.loc 2 757 6
 2991 0056 3B68     		ldr	r3, [r7]
 2992 0058 7A68     		ldr	r2, [r7, #4]
 2993 005a F968     		ldr	r1, [r7, #12]
 2994 005c F868     		ldr	r0, [r7, #12]
 2995 005e FFF7FEFF 		bl	modp_montymul
 2996 0062 F860     		str	r0, [r7, #12]
 758:keygen.c      **** 
 759:keygen.c      **** 	/*
 760:keygen.c      **** 	 * Halve the value mod p to get 2^62.
 761:keygen.c      **** 	 */
 762:keygen.c      **** 	z = (z + (p & -(z & 1))) >> 1;
 2997              		.loc 2 762 20
 2998 0064 FB68     		ldr	r3, [r7, #12]
 2999 0066 03F00103 		and	r3, r3, #1
 3000              		.loc 2 762 16
 3001 006a 5A42     		rsbs	r2, r3, #0
 3002              		.loc 2 762 14
 3003 006c 7B68     		ldr	r3, [r7, #4]
 3004 006e 1A40     		ands	r2, r2, r3
 3005              		.loc 2 762 9
 3006 0070 FB68     		ldr	r3, [r7, #12]
 3007 0072 1344     		add	r3, r3, r2
 3008              		.loc 2 762 4
 3009 0074 5B08     		lsrs	r3, r3, #1
 3010 0076 FB60     		str	r3, [r7, #12]
 763:keygen.c      **** 	return z;
 3011              		.loc 2 763 9
 3012 0078 FB68     		ldr	r3, [r7, #12]
 764:keygen.c      **** }
 3013              		.loc 2 764 1
 3014 007a 1846     		mov	r0, r3
 3015 007c 1037     		adds	r7, r7, #16
 3016              	.LCFI78:
 3017              		.cfi_def_cfa_offset 8
 3018 007e BD46     		mov	sp, r7
 3019              	.LCFI79:
 3020              		.cfi_def_cfa_register 13
 3021              		@ sp needed
 3022 0080 80BD     		pop	{r7, pc}
 3023              		.cfi_endproc
 3024              	.LFE25:
 3026              		.section	.text.modp_Rx,"ax",%progbits
 3027              		.align	1
 3028              		.syntax unified
 3029              		.thumb
 3030              		.thumb_func
 3031              		.fpu softvfp
 3033              	modp_Rx:
 3034              	.LFB26:
 765:keygen.c      **** 
 766:keygen.c      **** /*
 767:keygen.c      ****  * Compute 2^(31*x) modulo p. This works for integers x up to 2^11.
 768:keygen.c      ****  * p must be prime such that 2^30 < p < 2^31; p0i must be equal to
 769:keygen.c      ****  * -1/p mod 2^31; R2 must be equal to 2^62 mod p.
 770:keygen.c      ****  */
 771:keygen.c      **** static inline uint32_t
 772:keygen.c      **** modp_Rx(unsigned x, uint32_t p, uint32_t p0i, uint32_t R2)
 773:keygen.c      **** {
 3035              		.loc 2 773 1
 3036              		.cfi_startproc
 3037              		@ args = 0, pretend = 0, frame = 32
 3038              		@ frame_needed = 1, uses_anonymous_args = 0
 3039 0000 80B5     		push	{r7, lr}
 3040              	.LCFI80:
 3041              		.cfi_def_cfa_offset 8
 3042              		.cfi_offset 7, -8
 3043              		.cfi_offset 14, -4
 3044 0002 88B0     		sub	sp, sp, #32
 3045              	.LCFI81:
 3046              		.cfi_def_cfa_offset 40
 3047 0004 00AF     		add	r7, sp, #0
 3048              	.LCFI82:
 3049              		.cfi_def_cfa_register 7
 3050 0006 F860     		str	r0, [r7, #12]
 3051 0008 B960     		str	r1, [r7, #8]
 3052 000a 7A60     		str	r2, [r7, #4]
 3053 000c 3B60     		str	r3, [r7]
 774:keygen.c      **** 	int i;
 775:keygen.c      **** 	uint32_t r, z;
 776:keygen.c      **** 
 777:keygen.c      **** 	/*
 778:keygen.c      **** 	 * 2^(31*x) = (2^31)*(2^(31*(x-1))); i.e. we want the Montgomery
 779:keygen.c      **** 	 * representation of (2^31)^e mod p, where e = x-1.
 780:keygen.c      **** 	 * R2 is 2^31 in Montgomery representation.
 781:keygen.c      **** 	 */
 782:keygen.c      **** 	x --;
 3054              		.loc 2 782 4
 3055 000e FB68     		ldr	r3, [r7, #12]
 3056 0010 013B     		subs	r3, r3, #1
 3057 0012 FB60     		str	r3, [r7, #12]
 783:keygen.c      **** 	r = R2;
 3058              		.loc 2 783 4
 3059 0014 3B68     		ldr	r3, [r7]
 3060 0016 BB61     		str	r3, [r7, #24]
 784:keygen.c      **** 	z = modp_R(p);
 3061              		.loc 2 784 6
 3062 0018 B868     		ldr	r0, [r7, #8]
 3063 001a FFF7FEFF 		bl	modp_R
 3064 001e 7861     		str	r0, [r7, #20]
 785:keygen.c      **** 	for (i = 0; (1U << i) <= x; i ++) {
 3065              		.loc 2 785 9
 3066 0020 0023     		movs	r3, #0
 3067 0022 FB61     		str	r3, [r7, #28]
 3068              		.loc 2 785 2
 3069 0024 18E0     		b	.L30
 3070              	.L32:
 786:keygen.c      **** 		if ((x & (1U << i)) != 0) {
 3071              		.loc 2 786 23
 3072 0026 FA68     		ldr	r2, [r7, #12]
 3073 0028 FB69     		ldr	r3, [r7, #28]
 3074 002a 22FA03F3 		lsr	r3, r2, r3
 3075 002e 03F00103 		and	r3, r3, #1
 3076              		.loc 2 786 6
 3077 0032 002B     		cmp	r3, #0
 3078 0034 06D0     		beq	.L31
 787:keygen.c      **** 			z = modp_montymul(z, r, p, p0i);
 3079              		.loc 2 787 8
 3080 0036 7B68     		ldr	r3, [r7, #4]
 3081 0038 BA68     		ldr	r2, [r7, #8]
 3082 003a B969     		ldr	r1, [r7, #24]
 3083 003c 7869     		ldr	r0, [r7, #20]
 3084 003e FFF7FEFF 		bl	modp_montymul
 3085 0042 7861     		str	r0, [r7, #20]
 3086              	.L31:
 788:keygen.c      **** 		}
 789:keygen.c      **** 		r = modp_montymul(r, r, p, p0i);
 3087              		.loc 2 789 7 discriminator 2
 3088 0044 7B68     		ldr	r3, [r7, #4]
 3089 0046 BA68     		ldr	r2, [r7, #8]
 3090 0048 B969     		ldr	r1, [r7, #24]
 3091 004a B869     		ldr	r0, [r7, #24]
 3092 004c FFF7FEFF 		bl	modp_montymul
 3093 0050 B861     		str	r0, [r7, #24]
 785:keygen.c      **** 		if ((x & (1U << i)) != 0) {
 3094              		.loc 2 785 32 discriminator 2
 3095 0052 FB69     		ldr	r3, [r7, #28]
 3096 0054 0133     		adds	r3, r3, #1
 3097 0056 FB61     		str	r3, [r7, #28]
 3098              	.L30:
 785:keygen.c      **** 		if ((x & (1U << i)) != 0) {
 3099              		.loc 2 785 18 discriminator 1
 3100 0058 0122     		movs	r2, #1
 3101 005a FB69     		ldr	r3, [r7, #28]
 3102 005c 02FA03F3 		lsl	r3, r2, r3
 785:keygen.c      **** 		if ((x & (1U << i)) != 0) {
 3103              		.loc 2 785 2 discriminator 1
 3104 0060 FA68     		ldr	r2, [r7, #12]
 3105 0062 9A42     		cmp	r2, r3
 3106 0064 DFD2     		bcs	.L32
 790:keygen.c      **** 	}
 791:keygen.c      **** 	return z;
 3107              		.loc 2 791 9
 3108 0066 7B69     		ldr	r3, [r7, #20]
 792:keygen.c      **** }
 3109              		.loc 2 792 1
 3110 0068 1846     		mov	r0, r3
 3111 006a 2037     		adds	r7, r7, #32
 3112              	.LCFI83:
 3113              		.cfi_def_cfa_offset 8
 3114 006c BD46     		mov	sp, r7
 3115              	.LCFI84:
 3116              		.cfi_def_cfa_register 13
 3117              		@ sp needed
 3118 006e 80BD     		pop	{r7, pc}
 3119              		.cfi_endproc
 3120              	.LFE26:
 3122              		.section	.text.modp_div,"ax",%progbits
 3123              		.align	1
 3124              		.syntax unified
 3125              		.thumb
 3126              		.thumb_func
 3127              		.fpu softvfp
 3129              	modp_div:
 3130              	.LFB27:
 793:keygen.c      **** 
 794:keygen.c      **** /*
 795:keygen.c      ****  * Division modulo p. If the divisor (b) is 0, then 0 is returned.
 796:keygen.c      ****  * This function computes proper results only when p is prime.
 797:keygen.c      ****  * Parameters:
 798:keygen.c      ****  *   a     dividend
 799:keygen.c      ****  *   b     divisor
 800:keygen.c      ****  *   p     odd prime modulus
 801:keygen.c      ****  *   p0i   -1/p mod 2^31
 802:keygen.c      ****  *   R     2^31 mod R
 803:keygen.c      ****  */
 804:keygen.c      **** static uint32_t
 805:keygen.c      **** modp_div(uint32_t a, uint32_t b, uint32_t p, uint32_t p0i, uint32_t R)
 806:keygen.c      **** {
 3131              		.loc 2 806 1
 3132              		.cfi_startproc
 3133              		@ args = 4, pretend = 0, frame = 32
 3134              		@ frame_needed = 1, uses_anonymous_args = 0
 3135 0000 80B5     		push	{r7, lr}
 3136              	.LCFI85:
 3137              		.cfi_def_cfa_offset 8
 3138              		.cfi_offset 7, -8
 3139              		.cfi_offset 14, -4
 3140 0002 88B0     		sub	sp, sp, #32
 3141              	.LCFI86:
 3142              		.cfi_def_cfa_offset 40
 3143 0004 00AF     		add	r7, sp, #0
 3144              	.LCFI87:
 3145              		.cfi_def_cfa_register 7
 3146 0006 F860     		str	r0, [r7, #12]
 3147 0008 B960     		str	r1, [r7, #8]
 3148 000a 7A60     		str	r2, [r7, #4]
 3149 000c 3B60     		str	r3, [r7]
 807:keygen.c      **** 	uint32_t z, e;
 808:keygen.c      **** 	int i;
 809:keygen.c      **** 
 810:keygen.c      **** 	e = p - 2;
 3150              		.loc 2 810 4
 3151 000e 7B68     		ldr	r3, [r7, #4]
 3152 0010 023B     		subs	r3, r3, #2
 3153 0012 7B61     		str	r3, [r7, #20]
 811:keygen.c      **** 	z = R;
 3154              		.loc 2 811 4
 3155 0014 BB6A     		ldr	r3, [r7, #40]
 3156 0016 FB61     		str	r3, [r7, #28]
 812:keygen.c      **** 	for (i = 30; i >= 0; i --) {
 3157              		.loc 2 812 9
 3158 0018 1E23     		movs	r3, #30
 3159 001a BB61     		str	r3, [r7, #24]
 3160              		.loc 2 812 2
 3161 001c 1EE0     		b	.L35
 3162              	.L36:
 3163              	.LBB2:
 813:keygen.c      **** 		uint32_t z2;
 814:keygen.c      **** 
 815:keygen.c      **** 		z = modp_montymul(z, z, p, p0i);
 3164              		.loc 2 815 7 discriminator 3
 3165 001e 3B68     		ldr	r3, [r7]
 3166 0020 7A68     		ldr	r2, [r7, #4]
 3167 0022 F969     		ldr	r1, [r7, #28]
 3168 0024 F869     		ldr	r0, [r7, #28]
 3169 0026 FFF7FEFF 		bl	modp_montymul
 3170 002a F861     		str	r0, [r7, #28]
 816:keygen.c      **** 		z2 = modp_montymul(z, b, p, p0i);
 3171              		.loc 2 816 8 discriminator 3
 3172 002c 3B68     		ldr	r3, [r7]
 3173 002e 7A68     		ldr	r2, [r7, #4]
 3174 0030 B968     		ldr	r1, [r7, #8]
 3175 0032 F869     		ldr	r0, [r7, #28]
 3176 0034 FFF7FEFF 		bl	modp_montymul
 3177 0038 3861     		str	r0, [r7, #16]
 817:keygen.c      **** 		z ^= (z ^ z2) & -(uint32_t)((e >> i) & 1);
 3178              		.loc 2 817 11 discriminator 3
 3179 003a FA69     		ldr	r2, [r7, #28]
 3180 003c 3B69     		ldr	r3, [r7, #16]
 3181 003e 5A40     		eors	r2, r2, r3
 3182              		.loc 2 817 34 discriminator 3
 3183 0040 7969     		ldr	r1, [r7, #20]
 3184 0042 BB69     		ldr	r3, [r7, #24]
 3185 0044 21FA03F3 		lsr	r3, r1, r3
 3186              		.loc 2 817 20 discriminator 3
 3187 0048 03F00103 		and	r3, r3, #1
 3188              		.loc 2 817 19 discriminator 3
 3189 004c 5B42     		rsbs	r3, r3, #0
 3190              		.loc 2 817 17 discriminator 3
 3191 004e 1340     		ands	r3, r3, r2
 3192              		.loc 2 817 5 discriminator 3
 3193 0050 FA69     		ldr	r2, [r7, #28]
 3194 0052 5340     		eors	r3, r3, r2
 3195 0054 FB61     		str	r3, [r7, #28]
 3196              	.LBE2:
 812:keygen.c      **** 		uint32_t z2;
 3197              		.loc 2 812 25 discriminator 3
 3198 0056 BB69     		ldr	r3, [r7, #24]
 3199 0058 013B     		subs	r3, r3, #1
 3200 005a BB61     		str	r3, [r7, #24]
 3201              	.L35:
 812:keygen.c      **** 		uint32_t z2;
 3202              		.loc 2 812 2 discriminator 1
 3203 005c BB69     		ldr	r3, [r7, #24]
 3204 005e 002B     		cmp	r3, #0
 3205 0060 DDDA     		bge	.L36
 818:keygen.c      **** 	}
 819:keygen.c      **** 
 820:keygen.c      **** 	/*
 821:keygen.c      **** 	 * The loop above just assumed that b was in Montgomery
 822:keygen.c      **** 	 * representation, i.e. really contained b*R; under that
 823:keygen.c      **** 	 * assumption, it returns 1/b in Montgomery representation,
 824:keygen.c      **** 	 * which is R/b. But we gave it b in normal representation,
 825:keygen.c      **** 	 * so the loop really returned R/(b/R) = R^2/b.
 826:keygen.c      **** 	 *
 827:keygen.c      **** 	 * We want a/b, so we need one Montgomery multiplication with a,
 828:keygen.c      **** 	 * which also remove one of the R factors, and another such
 829:keygen.c      **** 	 * multiplication to remove the second R factor.
 830:keygen.c      **** 	 */
 831:keygen.c      **** 	z = modp_montymul(z, 1, p, p0i);
 3206              		.loc 2 831 6
 3207 0062 3B68     		ldr	r3, [r7]
 3208 0064 7A68     		ldr	r2, [r7, #4]
 3209 0066 0121     		movs	r1, #1
 3210 0068 F869     		ldr	r0, [r7, #28]
 3211 006a FFF7FEFF 		bl	modp_montymul
 3212 006e F861     		str	r0, [r7, #28]
 832:keygen.c      **** 	return modp_montymul(a, z, p, p0i);
 3213              		.loc 2 832 9
 3214 0070 3B68     		ldr	r3, [r7]
 3215 0072 7A68     		ldr	r2, [r7, #4]
 3216 0074 F969     		ldr	r1, [r7, #28]
 3217 0076 F868     		ldr	r0, [r7, #12]
 3218 0078 FFF7FEFF 		bl	modp_montymul
 3219 007c 0346     		mov	r3, r0
 833:keygen.c      **** }
 3220              		.loc 2 833 1
 3221 007e 1846     		mov	r0, r3
 3222 0080 2037     		adds	r7, r7, #32
 3223              	.LCFI88:
 3224              		.cfi_def_cfa_offset 8
 3225 0082 BD46     		mov	sp, r7
 3226              	.LCFI89:
 3227              		.cfi_def_cfa_register 13
 3228              		@ sp needed
 3229 0084 80BD     		pop	{r7, pc}
 3230              		.cfi_endproc
 3231              	.LFE27:
 3233              		.section	.rodata
 3234              		.align	2
 3237              	REV10:
 3238 19b8 0000     		.short	0
 3239 19ba 0002     		.short	512
 3240 19bc 0001     		.short	256
 3241 19be 0003     		.short	768
 3242 19c0 8000     		.short	128
 3243 19c2 8002     		.short	640
 3244 19c4 8001     		.short	384
 3245 19c6 8003     		.short	896
 3246 19c8 4000     		.short	64
 3247 19ca 4002     		.short	576
 3248 19cc 4001     		.short	320
 3249 19ce 4003     		.short	832
 3250 19d0 C000     		.short	192
 3251 19d2 C002     		.short	704
 3252 19d4 C001     		.short	448
 3253 19d6 C003     		.short	960
 3254 19d8 2000     		.short	32
 3255 19da 2002     		.short	544
 3256 19dc 2001     		.short	288
 3257 19de 2003     		.short	800
 3258 19e0 A000     		.short	160
 3259 19e2 A002     		.short	672
 3260 19e4 A001     		.short	416
 3261 19e6 A003     		.short	928
 3262 19e8 6000     		.short	96
 3263 19ea 6002     		.short	608
 3264 19ec 6001     		.short	352
 3265 19ee 6003     		.short	864
 3266 19f0 E000     		.short	224
 3267 19f2 E002     		.short	736
 3268 19f4 E001     		.short	480
 3269 19f6 E003     		.short	992
 3270 19f8 1000     		.short	16
 3271 19fa 1002     		.short	528
 3272 19fc 1001     		.short	272
 3273 19fe 1003     		.short	784
 3274 1a00 9000     		.short	144
 3275 1a02 9002     		.short	656
 3276 1a04 9001     		.short	400
 3277 1a06 9003     		.short	912
 3278 1a08 5000     		.short	80
 3279 1a0a 5002     		.short	592
 3280 1a0c 5001     		.short	336
 3281 1a0e 5003     		.short	848
 3282 1a10 D000     		.short	208
 3283 1a12 D002     		.short	720
 3284 1a14 D001     		.short	464
 3285 1a16 D003     		.short	976
 3286 1a18 3000     		.short	48
 3287 1a1a 3002     		.short	560
 3288 1a1c 3001     		.short	304
 3289 1a1e 3003     		.short	816
 3290 1a20 B000     		.short	176
 3291 1a22 B002     		.short	688
 3292 1a24 B001     		.short	432
 3293 1a26 B003     		.short	944
 3294 1a28 7000     		.short	112
 3295 1a2a 7002     		.short	624
 3296 1a2c 7001     		.short	368
 3297 1a2e 7003     		.short	880
 3298 1a30 F000     		.short	240
 3299 1a32 F002     		.short	752
 3300 1a34 F001     		.short	496
 3301 1a36 F003     		.short	1008
 3302 1a38 0800     		.short	8
 3303 1a3a 0802     		.short	520
 3304 1a3c 0801     		.short	264
 3305 1a3e 0803     		.short	776
 3306 1a40 8800     		.short	136
 3307 1a42 8802     		.short	648
 3308 1a44 8801     		.short	392
 3309 1a46 8803     		.short	904
 3310 1a48 4800     		.short	72
 3311 1a4a 4802     		.short	584
 3312 1a4c 4801     		.short	328
 3313 1a4e 4803     		.short	840
 3314 1a50 C800     		.short	200
 3315 1a52 C802     		.short	712
 3316 1a54 C801     		.short	456
 3317 1a56 C803     		.short	968
 3318 1a58 2800     		.short	40
 3319 1a5a 2802     		.short	552
 3320 1a5c 2801     		.short	296
 3321 1a5e 2803     		.short	808
 3322 1a60 A800     		.short	168
 3323 1a62 A802     		.short	680
 3324 1a64 A801     		.short	424
 3325 1a66 A803     		.short	936
 3326 1a68 6800     		.short	104
 3327 1a6a 6802     		.short	616
 3328 1a6c 6801     		.short	360
 3329 1a6e 6803     		.short	872
 3330 1a70 E800     		.short	232
 3331 1a72 E802     		.short	744
 3332 1a74 E801     		.short	488
 3333 1a76 E803     		.short	1000
 3334 1a78 1800     		.short	24
 3335 1a7a 1802     		.short	536
 3336 1a7c 1801     		.short	280
 3337 1a7e 1803     		.short	792
 3338 1a80 9800     		.short	152
 3339 1a82 9802     		.short	664
 3340 1a84 9801     		.short	408
 3341 1a86 9803     		.short	920
 3342 1a88 5800     		.short	88
 3343 1a8a 5802     		.short	600
 3344 1a8c 5801     		.short	344
 3345 1a8e 5803     		.short	856
 3346 1a90 D800     		.short	216
 3347 1a92 D802     		.short	728
 3348 1a94 D801     		.short	472
 3349 1a96 D803     		.short	984
 3350 1a98 3800     		.short	56
 3351 1a9a 3802     		.short	568
 3352 1a9c 3801     		.short	312
 3353 1a9e 3803     		.short	824
 3354 1aa0 B800     		.short	184
 3355 1aa2 B802     		.short	696
 3356 1aa4 B801     		.short	440
 3357 1aa6 B803     		.short	952
 3358 1aa8 7800     		.short	120
 3359 1aaa 7802     		.short	632
 3360 1aac 7801     		.short	376
 3361 1aae 7803     		.short	888
 3362 1ab0 F800     		.short	248
 3363 1ab2 F802     		.short	760
 3364 1ab4 F801     		.short	504
 3365 1ab6 F803     		.short	1016
 3366 1ab8 0400     		.short	4
 3367 1aba 0402     		.short	516
 3368 1abc 0401     		.short	260
 3369 1abe 0403     		.short	772
 3370 1ac0 8400     		.short	132
 3371 1ac2 8402     		.short	644
 3372 1ac4 8401     		.short	388
 3373 1ac6 8403     		.short	900
 3374 1ac8 4400     		.short	68
 3375 1aca 4402     		.short	580
 3376 1acc 4401     		.short	324
 3377 1ace 4403     		.short	836
 3378 1ad0 C400     		.short	196
 3379 1ad2 C402     		.short	708
 3380 1ad4 C401     		.short	452
 3381 1ad6 C403     		.short	964
 3382 1ad8 2400     		.short	36
 3383 1ada 2402     		.short	548
 3384 1adc 2401     		.short	292
 3385 1ade 2403     		.short	804
 3386 1ae0 A400     		.short	164
 3387 1ae2 A402     		.short	676
 3388 1ae4 A401     		.short	420
 3389 1ae6 A403     		.short	932
 3390 1ae8 6400     		.short	100
 3391 1aea 6402     		.short	612
 3392 1aec 6401     		.short	356
 3393 1aee 6403     		.short	868
 3394 1af0 E400     		.short	228
 3395 1af2 E402     		.short	740
 3396 1af4 E401     		.short	484
 3397 1af6 E403     		.short	996
 3398 1af8 1400     		.short	20
 3399 1afa 1402     		.short	532
 3400 1afc 1401     		.short	276
 3401 1afe 1403     		.short	788
 3402 1b00 9400     		.short	148
 3403 1b02 9402     		.short	660
 3404 1b04 9401     		.short	404
 3405 1b06 9403     		.short	916
 3406 1b08 5400     		.short	84
 3407 1b0a 5402     		.short	596
 3408 1b0c 5401     		.short	340
 3409 1b0e 5403     		.short	852
 3410 1b10 D400     		.short	212
 3411 1b12 D402     		.short	724
 3412 1b14 D401     		.short	468
 3413 1b16 D403     		.short	980
 3414 1b18 3400     		.short	52
 3415 1b1a 3402     		.short	564
 3416 1b1c 3401     		.short	308
 3417 1b1e 3403     		.short	820
 3418 1b20 B400     		.short	180
 3419 1b22 B402     		.short	692
 3420 1b24 B401     		.short	436
 3421 1b26 B403     		.short	948
 3422 1b28 7400     		.short	116
 3423 1b2a 7402     		.short	628
 3424 1b2c 7401     		.short	372
 3425 1b2e 7403     		.short	884
 3426 1b30 F400     		.short	244
 3427 1b32 F402     		.short	756
 3428 1b34 F401     		.short	500
 3429 1b36 F403     		.short	1012
 3430 1b38 0C00     		.short	12
 3431 1b3a 0C02     		.short	524
 3432 1b3c 0C01     		.short	268
 3433 1b3e 0C03     		.short	780
 3434 1b40 8C00     		.short	140
 3435 1b42 8C02     		.short	652
 3436 1b44 8C01     		.short	396
 3437 1b46 8C03     		.short	908
 3438 1b48 4C00     		.short	76
 3439 1b4a 4C02     		.short	588
 3440 1b4c 4C01     		.short	332
 3441 1b4e 4C03     		.short	844
 3442 1b50 CC00     		.short	204
 3443 1b52 CC02     		.short	716
 3444 1b54 CC01     		.short	460
 3445 1b56 CC03     		.short	972
 3446 1b58 2C00     		.short	44
 3447 1b5a 2C02     		.short	556
 3448 1b5c 2C01     		.short	300
 3449 1b5e 2C03     		.short	812
 3450 1b60 AC00     		.short	172
 3451 1b62 AC02     		.short	684
 3452 1b64 AC01     		.short	428
 3453 1b66 AC03     		.short	940
 3454 1b68 6C00     		.short	108
 3455 1b6a 6C02     		.short	620
 3456 1b6c 6C01     		.short	364
 3457 1b6e 6C03     		.short	876
 3458 1b70 EC00     		.short	236
 3459 1b72 EC02     		.short	748
 3460 1b74 EC01     		.short	492
 3461 1b76 EC03     		.short	1004
 3462 1b78 1C00     		.short	28
 3463 1b7a 1C02     		.short	540
 3464 1b7c 1C01     		.short	284
 3465 1b7e 1C03     		.short	796
 3466 1b80 9C00     		.short	156
 3467 1b82 9C02     		.short	668
 3468 1b84 9C01     		.short	412
 3469 1b86 9C03     		.short	924
 3470 1b88 5C00     		.short	92
 3471 1b8a 5C02     		.short	604
 3472 1b8c 5C01     		.short	348
 3473 1b8e 5C03     		.short	860
 3474 1b90 DC00     		.short	220
 3475 1b92 DC02     		.short	732
 3476 1b94 DC01     		.short	476
 3477 1b96 DC03     		.short	988
 3478 1b98 3C00     		.short	60
 3479 1b9a 3C02     		.short	572
 3480 1b9c 3C01     		.short	316
 3481 1b9e 3C03     		.short	828
 3482 1ba0 BC00     		.short	188
 3483 1ba2 BC02     		.short	700
 3484 1ba4 BC01     		.short	444
 3485 1ba6 BC03     		.short	956
 3486 1ba8 7C00     		.short	124
 3487 1baa 7C02     		.short	636
 3488 1bac 7C01     		.short	380
 3489 1bae 7C03     		.short	892
 3490 1bb0 FC00     		.short	252
 3491 1bb2 FC02     		.short	764
 3492 1bb4 FC01     		.short	508
 3493 1bb6 FC03     		.short	1020
 3494 1bb8 0200     		.short	2
 3495 1bba 0202     		.short	514
 3496 1bbc 0201     		.short	258
 3497 1bbe 0203     		.short	770
 3498 1bc0 8200     		.short	130
 3499 1bc2 8202     		.short	642
 3500 1bc4 8201     		.short	386
 3501 1bc6 8203     		.short	898
 3502 1bc8 4200     		.short	66
 3503 1bca 4202     		.short	578
 3504 1bcc 4201     		.short	322
 3505 1bce 4203     		.short	834
 3506 1bd0 C200     		.short	194
 3507 1bd2 C202     		.short	706
 3508 1bd4 C201     		.short	450
 3509 1bd6 C203     		.short	962
 3510 1bd8 2200     		.short	34
 3511 1bda 2202     		.short	546
 3512 1bdc 2201     		.short	290
 3513 1bde 2203     		.short	802
 3514 1be0 A200     		.short	162
 3515 1be2 A202     		.short	674
 3516 1be4 A201     		.short	418
 3517 1be6 A203     		.short	930
 3518 1be8 6200     		.short	98
 3519 1bea 6202     		.short	610
 3520 1bec 6201     		.short	354
 3521 1bee 6203     		.short	866
 3522 1bf0 E200     		.short	226
 3523 1bf2 E202     		.short	738
 3524 1bf4 E201     		.short	482
 3525 1bf6 E203     		.short	994
 3526 1bf8 1200     		.short	18
 3527 1bfa 1202     		.short	530
 3528 1bfc 1201     		.short	274
 3529 1bfe 1203     		.short	786
 3530 1c00 9200     		.short	146
 3531 1c02 9202     		.short	658
 3532 1c04 9201     		.short	402
 3533 1c06 9203     		.short	914
 3534 1c08 5200     		.short	82
 3535 1c0a 5202     		.short	594
 3536 1c0c 5201     		.short	338
 3537 1c0e 5203     		.short	850
 3538 1c10 D200     		.short	210
 3539 1c12 D202     		.short	722
 3540 1c14 D201     		.short	466
 3541 1c16 D203     		.short	978
 3542 1c18 3200     		.short	50
 3543 1c1a 3202     		.short	562
 3544 1c1c 3201     		.short	306
 3545 1c1e 3203     		.short	818
 3546 1c20 B200     		.short	178
 3547 1c22 B202     		.short	690
 3548 1c24 B201     		.short	434
 3549 1c26 B203     		.short	946
 3550 1c28 7200     		.short	114
 3551 1c2a 7202     		.short	626
 3552 1c2c 7201     		.short	370
 3553 1c2e 7203     		.short	882
 3554 1c30 F200     		.short	242
 3555 1c32 F202     		.short	754
 3556 1c34 F201     		.short	498
 3557 1c36 F203     		.short	1010
 3558 1c38 0A00     		.short	10
 3559 1c3a 0A02     		.short	522
 3560 1c3c 0A01     		.short	266
 3561 1c3e 0A03     		.short	778
 3562 1c40 8A00     		.short	138
 3563 1c42 8A02     		.short	650
 3564 1c44 8A01     		.short	394
 3565 1c46 8A03     		.short	906
 3566 1c48 4A00     		.short	74
 3567 1c4a 4A02     		.short	586
 3568 1c4c 4A01     		.short	330
 3569 1c4e 4A03     		.short	842
 3570 1c50 CA00     		.short	202
 3571 1c52 CA02     		.short	714
 3572 1c54 CA01     		.short	458
 3573 1c56 CA03     		.short	970
 3574 1c58 2A00     		.short	42
 3575 1c5a 2A02     		.short	554
 3576 1c5c 2A01     		.short	298
 3577 1c5e 2A03     		.short	810
 3578 1c60 AA00     		.short	170
 3579 1c62 AA02     		.short	682
 3580 1c64 AA01     		.short	426
 3581 1c66 AA03     		.short	938
 3582 1c68 6A00     		.short	106
 3583 1c6a 6A02     		.short	618
 3584 1c6c 6A01     		.short	362
 3585 1c6e 6A03     		.short	874
 3586 1c70 EA00     		.short	234
 3587 1c72 EA02     		.short	746
 3588 1c74 EA01     		.short	490
 3589 1c76 EA03     		.short	1002
 3590 1c78 1A00     		.short	26
 3591 1c7a 1A02     		.short	538
 3592 1c7c 1A01     		.short	282
 3593 1c7e 1A03     		.short	794
 3594 1c80 9A00     		.short	154
 3595 1c82 9A02     		.short	666
 3596 1c84 9A01     		.short	410
 3597 1c86 9A03     		.short	922
 3598 1c88 5A00     		.short	90
 3599 1c8a 5A02     		.short	602
 3600 1c8c 5A01     		.short	346
 3601 1c8e 5A03     		.short	858
 3602 1c90 DA00     		.short	218
 3603 1c92 DA02     		.short	730
 3604 1c94 DA01     		.short	474
 3605 1c96 DA03     		.short	986
 3606 1c98 3A00     		.short	58
 3607 1c9a 3A02     		.short	570
 3608 1c9c 3A01     		.short	314
 3609 1c9e 3A03     		.short	826
 3610 1ca0 BA00     		.short	186
 3611 1ca2 BA02     		.short	698
 3612 1ca4 BA01     		.short	442
 3613 1ca6 BA03     		.short	954
 3614 1ca8 7A00     		.short	122
 3615 1caa 7A02     		.short	634
 3616 1cac 7A01     		.short	378
 3617 1cae 7A03     		.short	890
 3618 1cb0 FA00     		.short	250
 3619 1cb2 FA02     		.short	762
 3620 1cb4 FA01     		.short	506
 3621 1cb6 FA03     		.short	1018
 3622 1cb8 0600     		.short	6
 3623 1cba 0602     		.short	518
 3624 1cbc 0601     		.short	262
 3625 1cbe 0603     		.short	774
 3626 1cc0 8600     		.short	134
 3627 1cc2 8602     		.short	646
 3628 1cc4 8601     		.short	390
 3629 1cc6 8603     		.short	902
 3630 1cc8 4600     		.short	70
 3631 1cca 4602     		.short	582
 3632 1ccc 4601     		.short	326
 3633 1cce 4603     		.short	838
 3634 1cd0 C600     		.short	198
 3635 1cd2 C602     		.short	710
 3636 1cd4 C601     		.short	454
 3637 1cd6 C603     		.short	966
 3638 1cd8 2600     		.short	38
 3639 1cda 2602     		.short	550
 3640 1cdc 2601     		.short	294
 3641 1cde 2603     		.short	806
 3642 1ce0 A600     		.short	166
 3643 1ce2 A602     		.short	678
 3644 1ce4 A601     		.short	422
 3645 1ce6 A603     		.short	934
 3646 1ce8 6600     		.short	102
 3647 1cea 6602     		.short	614
 3648 1cec 6601     		.short	358
 3649 1cee 6603     		.short	870
 3650 1cf0 E600     		.short	230
 3651 1cf2 E602     		.short	742
 3652 1cf4 E601     		.short	486
 3653 1cf6 E603     		.short	998
 3654 1cf8 1600     		.short	22
 3655 1cfa 1602     		.short	534
 3656 1cfc 1601     		.short	278
 3657 1cfe 1603     		.short	790
 3658 1d00 9600     		.short	150
 3659 1d02 9602     		.short	662
 3660 1d04 9601     		.short	406
 3661 1d06 9603     		.short	918
 3662 1d08 5600     		.short	86
 3663 1d0a 5602     		.short	598
 3664 1d0c 5601     		.short	342
 3665 1d0e 5603     		.short	854
 3666 1d10 D600     		.short	214
 3667 1d12 D602     		.short	726
 3668 1d14 D601     		.short	470
 3669 1d16 D603     		.short	982
 3670 1d18 3600     		.short	54
 3671 1d1a 3602     		.short	566
 3672 1d1c 3601     		.short	310
 3673 1d1e 3603     		.short	822
 3674 1d20 B600     		.short	182
 3675 1d22 B602     		.short	694
 3676 1d24 B601     		.short	438
 3677 1d26 B603     		.short	950
 3678 1d28 7600     		.short	118
 3679 1d2a 7602     		.short	630
 3680 1d2c 7601     		.short	374
 3681 1d2e 7603     		.short	886
 3682 1d30 F600     		.short	246
 3683 1d32 F602     		.short	758
 3684 1d34 F601     		.short	502
 3685 1d36 F603     		.short	1014
 3686 1d38 0E00     		.short	14
 3687 1d3a 0E02     		.short	526
 3688 1d3c 0E01     		.short	270
 3689 1d3e 0E03     		.short	782
 3690 1d40 8E00     		.short	142
 3691 1d42 8E02     		.short	654
 3692 1d44 8E01     		.short	398
 3693 1d46 8E03     		.short	910
 3694 1d48 4E00     		.short	78
 3695 1d4a 4E02     		.short	590
 3696 1d4c 4E01     		.short	334
 3697 1d4e 4E03     		.short	846
 3698 1d50 CE00     		.short	206
 3699 1d52 CE02     		.short	718
 3700 1d54 CE01     		.short	462
 3701 1d56 CE03     		.short	974
 3702 1d58 2E00     		.short	46
 3703 1d5a 2E02     		.short	558
 3704 1d5c 2E01     		.short	302
 3705 1d5e 2E03     		.short	814
 3706 1d60 AE00     		.short	174
 3707 1d62 AE02     		.short	686
 3708 1d64 AE01     		.short	430
 3709 1d66 AE03     		.short	942
 3710 1d68 6E00     		.short	110
 3711 1d6a 6E02     		.short	622
 3712 1d6c 6E01     		.short	366
 3713 1d6e 6E03     		.short	878
 3714 1d70 EE00     		.short	238
 3715 1d72 EE02     		.short	750
 3716 1d74 EE01     		.short	494
 3717 1d76 EE03     		.short	1006
 3718 1d78 1E00     		.short	30
 3719 1d7a 1E02     		.short	542
 3720 1d7c 1E01     		.short	286
 3721 1d7e 1E03     		.short	798
 3722 1d80 9E00     		.short	158
 3723 1d82 9E02     		.short	670
 3724 1d84 9E01     		.short	414
 3725 1d86 9E03     		.short	926
 3726 1d88 5E00     		.short	94
 3727 1d8a 5E02     		.short	606
 3728 1d8c 5E01     		.short	350
 3729 1d8e 5E03     		.short	862
 3730 1d90 DE00     		.short	222
 3731 1d92 DE02     		.short	734
 3732 1d94 DE01     		.short	478
 3733 1d96 DE03     		.short	990
 3734 1d98 3E00     		.short	62
 3735 1d9a 3E02     		.short	574
 3736 1d9c 3E01     		.short	318
 3737 1d9e 3E03     		.short	830
 3738 1da0 BE00     		.short	190
 3739 1da2 BE02     		.short	702
 3740 1da4 BE01     		.short	446
 3741 1da6 BE03     		.short	958
 3742 1da8 7E00     		.short	126
 3743 1daa 7E02     		.short	638
 3744 1dac 7E01     		.short	382
 3745 1dae 7E03     		.short	894
 3746 1db0 FE00     		.short	254
 3747 1db2 FE02     		.short	766
 3748 1db4 FE01     		.short	510
 3749 1db6 FE03     		.short	1022
 3750 1db8 0100     		.short	1
 3751 1dba 0102     		.short	513
 3752 1dbc 0101     		.short	257
 3753 1dbe 0103     		.short	769
 3754 1dc0 8100     		.short	129
 3755 1dc2 8102     		.short	641
 3756 1dc4 8101     		.short	385
 3757 1dc6 8103     		.short	897
 3758 1dc8 4100     		.short	65
 3759 1dca 4102     		.short	577
 3760 1dcc 4101     		.short	321
 3761 1dce 4103     		.short	833
 3762 1dd0 C100     		.short	193
 3763 1dd2 C102     		.short	705
 3764 1dd4 C101     		.short	449
 3765 1dd6 C103     		.short	961
 3766 1dd8 2100     		.short	33
 3767 1dda 2102     		.short	545
 3768 1ddc 2101     		.short	289
 3769 1dde 2103     		.short	801
 3770 1de0 A100     		.short	161
 3771 1de2 A102     		.short	673
 3772 1de4 A101     		.short	417
 3773 1de6 A103     		.short	929
 3774 1de8 6100     		.short	97
 3775 1dea 6102     		.short	609
 3776 1dec 6101     		.short	353
 3777 1dee 6103     		.short	865
 3778 1df0 E100     		.short	225
 3779 1df2 E102     		.short	737
 3780 1df4 E101     		.short	481
 3781 1df6 E103     		.short	993
 3782 1df8 1100     		.short	17
 3783 1dfa 1102     		.short	529
 3784 1dfc 1101     		.short	273
 3785 1dfe 1103     		.short	785
 3786 1e00 9100     		.short	145
 3787 1e02 9102     		.short	657
 3788 1e04 9101     		.short	401
 3789 1e06 9103     		.short	913
 3790 1e08 5100     		.short	81
 3791 1e0a 5102     		.short	593
 3792 1e0c 5101     		.short	337
 3793 1e0e 5103     		.short	849
 3794 1e10 D100     		.short	209
 3795 1e12 D102     		.short	721
 3796 1e14 D101     		.short	465
 3797 1e16 D103     		.short	977
 3798 1e18 3100     		.short	49
 3799 1e1a 3102     		.short	561
 3800 1e1c 3101     		.short	305
 3801 1e1e 3103     		.short	817
 3802 1e20 B100     		.short	177
 3803 1e22 B102     		.short	689
 3804 1e24 B101     		.short	433
 3805 1e26 B103     		.short	945
 3806 1e28 7100     		.short	113
 3807 1e2a 7102     		.short	625
 3808 1e2c 7101     		.short	369
 3809 1e2e 7103     		.short	881
 3810 1e30 F100     		.short	241
 3811 1e32 F102     		.short	753
 3812 1e34 F101     		.short	497
 3813 1e36 F103     		.short	1009
 3814 1e38 0900     		.short	9
 3815 1e3a 0902     		.short	521
 3816 1e3c 0901     		.short	265
 3817 1e3e 0903     		.short	777
 3818 1e40 8900     		.short	137
 3819 1e42 8902     		.short	649
 3820 1e44 8901     		.short	393
 3821 1e46 8903     		.short	905
 3822 1e48 4900     		.short	73
 3823 1e4a 4902     		.short	585
 3824 1e4c 4901     		.short	329
 3825 1e4e 4903     		.short	841
 3826 1e50 C900     		.short	201
 3827 1e52 C902     		.short	713
 3828 1e54 C901     		.short	457
 3829 1e56 C903     		.short	969
 3830 1e58 2900     		.short	41
 3831 1e5a 2902     		.short	553
 3832 1e5c 2901     		.short	297
 3833 1e5e 2903     		.short	809
 3834 1e60 A900     		.short	169
 3835 1e62 A902     		.short	681
 3836 1e64 A901     		.short	425
 3837 1e66 A903     		.short	937
 3838 1e68 6900     		.short	105
 3839 1e6a 6902     		.short	617
 3840 1e6c 6901     		.short	361
 3841 1e6e 6903     		.short	873
 3842 1e70 E900     		.short	233
 3843 1e72 E902     		.short	745
 3844 1e74 E901     		.short	489
 3845 1e76 E903     		.short	1001
 3846 1e78 1900     		.short	25
 3847 1e7a 1902     		.short	537
 3848 1e7c 1901     		.short	281
 3849 1e7e 1903     		.short	793
 3850 1e80 9900     		.short	153
 3851 1e82 9902     		.short	665
 3852 1e84 9901     		.short	409
 3853 1e86 9903     		.short	921
 3854 1e88 5900     		.short	89
 3855 1e8a 5902     		.short	601
 3856 1e8c 5901     		.short	345
 3857 1e8e 5903     		.short	857
 3858 1e90 D900     		.short	217
 3859 1e92 D902     		.short	729
 3860 1e94 D901     		.short	473
 3861 1e96 D903     		.short	985
 3862 1e98 3900     		.short	57
 3863 1e9a 3902     		.short	569
 3864 1e9c 3901     		.short	313
 3865 1e9e 3903     		.short	825
 3866 1ea0 B900     		.short	185
 3867 1ea2 B902     		.short	697
 3868 1ea4 B901     		.short	441
 3869 1ea6 B903     		.short	953
 3870 1ea8 7900     		.short	121
 3871 1eaa 7902     		.short	633
 3872 1eac 7901     		.short	377
 3873 1eae 7903     		.short	889
 3874 1eb0 F900     		.short	249
 3875 1eb2 F902     		.short	761
 3876 1eb4 F901     		.short	505
 3877 1eb6 F903     		.short	1017
 3878 1eb8 0500     		.short	5
 3879 1eba 0502     		.short	517
 3880 1ebc 0501     		.short	261
 3881 1ebe 0503     		.short	773
 3882 1ec0 8500     		.short	133
 3883 1ec2 8502     		.short	645
 3884 1ec4 8501     		.short	389
 3885 1ec6 8503     		.short	901
 3886 1ec8 4500     		.short	69
 3887 1eca 4502     		.short	581
 3888 1ecc 4501     		.short	325
 3889 1ece 4503     		.short	837
 3890 1ed0 C500     		.short	197
 3891 1ed2 C502     		.short	709
 3892 1ed4 C501     		.short	453
 3893 1ed6 C503     		.short	965
 3894 1ed8 2500     		.short	37
 3895 1eda 2502     		.short	549
 3896 1edc 2501     		.short	293
 3897 1ede 2503     		.short	805
 3898 1ee0 A500     		.short	165
 3899 1ee2 A502     		.short	677
 3900 1ee4 A501     		.short	421
 3901 1ee6 A503     		.short	933
 3902 1ee8 6500     		.short	101
 3903 1eea 6502     		.short	613
 3904 1eec 6501     		.short	357
 3905 1eee 6503     		.short	869
 3906 1ef0 E500     		.short	229
 3907 1ef2 E502     		.short	741
 3908 1ef4 E501     		.short	485
 3909 1ef6 E503     		.short	997
 3910 1ef8 1500     		.short	21
 3911 1efa 1502     		.short	533
 3912 1efc 1501     		.short	277
 3913 1efe 1503     		.short	789
 3914 1f00 9500     		.short	149
 3915 1f02 9502     		.short	661
 3916 1f04 9501     		.short	405
 3917 1f06 9503     		.short	917
 3918 1f08 5500     		.short	85
 3919 1f0a 5502     		.short	597
 3920 1f0c 5501     		.short	341
 3921 1f0e 5503     		.short	853
 3922 1f10 D500     		.short	213
 3923 1f12 D502     		.short	725
 3924 1f14 D501     		.short	469
 3925 1f16 D503     		.short	981
 3926 1f18 3500     		.short	53
 3927 1f1a 3502     		.short	565
 3928 1f1c 3501     		.short	309
 3929 1f1e 3503     		.short	821
 3930 1f20 B500     		.short	181
 3931 1f22 B502     		.short	693
 3932 1f24 B501     		.short	437
 3933 1f26 B503     		.short	949
 3934 1f28 7500     		.short	117
 3935 1f2a 7502     		.short	629
 3936 1f2c 7501     		.short	373
 3937 1f2e 7503     		.short	885
 3938 1f30 F500     		.short	245
 3939 1f32 F502     		.short	757
 3940 1f34 F501     		.short	501
 3941 1f36 F503     		.short	1013
 3942 1f38 0D00     		.short	13
 3943 1f3a 0D02     		.short	525
 3944 1f3c 0D01     		.short	269
 3945 1f3e 0D03     		.short	781
 3946 1f40 8D00     		.short	141
 3947 1f42 8D02     		.short	653
 3948 1f44 8D01     		.short	397
 3949 1f46 8D03     		.short	909
 3950 1f48 4D00     		.short	77
 3951 1f4a 4D02     		.short	589
 3952 1f4c 4D01     		.short	333
 3953 1f4e 4D03     		.short	845
 3954 1f50 CD00     		.short	205
 3955 1f52 CD02     		.short	717
 3956 1f54 CD01     		.short	461
 3957 1f56 CD03     		.short	973
 3958 1f58 2D00     		.short	45
 3959 1f5a 2D02     		.short	557
 3960 1f5c 2D01     		.short	301
 3961 1f5e 2D03     		.short	813
 3962 1f60 AD00     		.short	173
 3963 1f62 AD02     		.short	685
 3964 1f64 AD01     		.short	429
 3965 1f66 AD03     		.short	941
 3966 1f68 6D00     		.short	109
 3967 1f6a 6D02     		.short	621
 3968 1f6c 6D01     		.short	365
 3969 1f6e 6D03     		.short	877
 3970 1f70 ED00     		.short	237
 3971 1f72 ED02     		.short	749
 3972 1f74 ED01     		.short	493
 3973 1f76 ED03     		.short	1005
 3974 1f78 1D00     		.short	29
 3975 1f7a 1D02     		.short	541
 3976 1f7c 1D01     		.short	285
 3977 1f7e 1D03     		.short	797
 3978 1f80 9D00     		.short	157
 3979 1f82 9D02     		.short	669
 3980 1f84 9D01     		.short	413
 3981 1f86 9D03     		.short	925
 3982 1f88 5D00     		.short	93
 3983 1f8a 5D02     		.short	605
 3984 1f8c 5D01     		.short	349
 3985 1f8e 5D03     		.short	861
 3986 1f90 DD00     		.short	221
 3987 1f92 DD02     		.short	733
 3988 1f94 DD01     		.short	477
 3989 1f96 DD03     		.short	989
 3990 1f98 3D00     		.short	61
 3991 1f9a 3D02     		.short	573
 3992 1f9c 3D01     		.short	317
 3993 1f9e 3D03     		.short	829
 3994 1fa0 BD00     		.short	189
 3995 1fa2 BD02     		.short	701
 3996 1fa4 BD01     		.short	445
 3997 1fa6 BD03     		.short	957
 3998 1fa8 7D00     		.short	125
 3999 1faa 7D02     		.short	637
 4000 1fac 7D01     		.short	381
 4001 1fae 7D03     		.short	893
 4002 1fb0 FD00     		.short	253
 4003 1fb2 FD02     		.short	765
 4004 1fb4 FD01     		.short	509
 4005 1fb6 FD03     		.short	1021
 4006 1fb8 0300     		.short	3
 4007 1fba 0302     		.short	515
 4008 1fbc 0301     		.short	259
 4009 1fbe 0303     		.short	771
 4010 1fc0 8300     		.short	131
 4011 1fc2 8302     		.short	643
 4012 1fc4 8301     		.short	387
 4013 1fc6 8303     		.short	899
 4014 1fc8 4300     		.short	67
 4015 1fca 4302     		.short	579
 4016 1fcc 4301     		.short	323
 4017 1fce 4303     		.short	835
 4018 1fd0 C300     		.short	195
 4019 1fd2 C302     		.short	707
 4020 1fd4 C301     		.short	451
 4021 1fd6 C303     		.short	963
 4022 1fd8 2300     		.short	35
 4023 1fda 2302     		.short	547
 4024 1fdc 2301     		.short	291
 4025 1fde 2303     		.short	803
 4026 1fe0 A300     		.short	163
 4027 1fe2 A302     		.short	675
 4028 1fe4 A301     		.short	419
 4029 1fe6 A303     		.short	931
 4030 1fe8 6300     		.short	99
 4031 1fea 6302     		.short	611
 4032 1fec 6301     		.short	355
 4033 1fee 6303     		.short	867
 4034 1ff0 E300     		.short	227
 4035 1ff2 E302     		.short	739
 4036 1ff4 E301     		.short	483
 4037 1ff6 E303     		.short	995
 4038 1ff8 1300     		.short	19
 4039 1ffa 1302     		.short	531
 4040 1ffc 1301     		.short	275
 4041 1ffe 1303     		.short	787
 4042 2000 9300     		.short	147
 4043 2002 9302     		.short	659
 4044 2004 9301     		.short	403
 4045 2006 9303     		.short	915
 4046 2008 5300     		.short	83
 4047 200a 5302     		.short	595
 4048 200c 5301     		.short	339
 4049 200e 5303     		.short	851
 4050 2010 D300     		.short	211
 4051 2012 D302     		.short	723
 4052 2014 D301     		.short	467
 4053 2016 D303     		.short	979
 4054 2018 3300     		.short	51
 4055 201a 3302     		.short	563
 4056 201c 3301     		.short	307
 4057 201e 3303     		.short	819
 4058 2020 B300     		.short	179
 4059 2022 B302     		.short	691
 4060 2024 B301     		.short	435
 4061 2026 B303     		.short	947
 4062 2028 7300     		.short	115
 4063 202a 7302     		.short	627
 4064 202c 7301     		.short	371
 4065 202e 7303     		.short	883
 4066 2030 F300     		.short	243
 4067 2032 F302     		.short	755
 4068 2034 F301     		.short	499
 4069 2036 F303     		.short	1011
 4070 2038 0B00     		.short	11
 4071 203a 0B02     		.short	523
 4072 203c 0B01     		.short	267
 4073 203e 0B03     		.short	779
 4074 2040 8B00     		.short	139
 4075 2042 8B02     		.short	651
 4076 2044 8B01     		.short	395
 4077 2046 8B03     		.short	907
 4078 2048 4B00     		.short	75
 4079 204a 4B02     		.short	587
 4080 204c 4B01     		.short	331
 4081 204e 4B03     		.short	843
 4082 2050 CB00     		.short	203
 4083 2052 CB02     		.short	715
 4084 2054 CB01     		.short	459
 4085 2056 CB03     		.short	971
 4086 2058 2B00     		.short	43
 4087 205a 2B02     		.short	555
 4088 205c 2B01     		.short	299
 4089 205e 2B03     		.short	811
 4090 2060 AB00     		.short	171
 4091 2062 AB02     		.short	683
 4092 2064 AB01     		.short	427
 4093 2066 AB03     		.short	939
 4094 2068 6B00     		.short	107
 4095 206a 6B02     		.short	619
 4096 206c 6B01     		.short	363
 4097 206e 6B03     		.short	875
 4098 2070 EB00     		.short	235
 4099 2072 EB02     		.short	747
 4100 2074 EB01     		.short	491
 4101 2076 EB03     		.short	1003
 4102 2078 1B00     		.short	27
 4103 207a 1B02     		.short	539
 4104 207c 1B01     		.short	283
 4105 207e 1B03     		.short	795
 4106 2080 9B00     		.short	155
 4107 2082 9B02     		.short	667
 4108 2084 9B01     		.short	411
 4109 2086 9B03     		.short	923
 4110 2088 5B00     		.short	91
 4111 208a 5B02     		.short	603
 4112 208c 5B01     		.short	347
 4113 208e 5B03     		.short	859
 4114 2090 DB00     		.short	219
 4115 2092 DB02     		.short	731
 4116 2094 DB01     		.short	475
 4117 2096 DB03     		.short	987
 4118 2098 3B00     		.short	59
 4119 209a 3B02     		.short	571
 4120 209c 3B01     		.short	315
 4121 209e 3B03     		.short	827
 4122 20a0 BB00     		.short	187
 4123 20a2 BB02     		.short	699
 4124 20a4 BB01     		.short	443
 4125 20a6 BB03     		.short	955
 4126 20a8 7B00     		.short	123
 4127 20aa 7B02     		.short	635
 4128 20ac 7B01     		.short	379
 4129 20ae 7B03     		.short	891
 4130 20b0 FB00     		.short	251
 4131 20b2 FB02     		.short	763
 4132 20b4 FB01     		.short	507
 4133 20b6 FB03     		.short	1019
 4134 20b8 0700     		.short	7
 4135 20ba 0702     		.short	519
 4136 20bc 0701     		.short	263
 4137 20be 0703     		.short	775
 4138 20c0 8700     		.short	135
 4139 20c2 8702     		.short	647
 4140 20c4 8701     		.short	391
 4141 20c6 8703     		.short	903
 4142 20c8 4700     		.short	71
 4143 20ca 4702     		.short	583
 4144 20cc 4701     		.short	327
 4145 20ce 4703     		.short	839
 4146 20d0 C700     		.short	199
 4147 20d2 C702     		.short	711
 4148 20d4 C701     		.short	455
 4149 20d6 C703     		.short	967
 4150 20d8 2700     		.short	39
 4151 20da 2702     		.short	551
 4152 20dc 2701     		.short	295
 4153 20de 2703     		.short	807
 4154 20e0 A700     		.short	167
 4155 20e2 A702     		.short	679
 4156 20e4 A701     		.short	423
 4157 20e6 A703     		.short	935
 4158 20e8 6700     		.short	103
 4159 20ea 6702     		.short	615
 4160 20ec 6701     		.short	359
 4161 20ee 6703     		.short	871
 4162 20f0 E700     		.short	231
 4163 20f2 E702     		.short	743
 4164 20f4 E701     		.short	487
 4165 20f6 E703     		.short	999
 4166 20f8 1700     		.short	23
 4167 20fa 1702     		.short	535
 4168 20fc 1701     		.short	279
 4169 20fe 1703     		.short	791
 4170 2100 9700     		.short	151
 4171 2102 9702     		.short	663
 4172 2104 9701     		.short	407
 4173 2106 9703     		.short	919
 4174 2108 5700     		.short	87
 4175 210a 5702     		.short	599
 4176 210c 5701     		.short	343
 4177 210e 5703     		.short	855
 4178 2110 D700     		.short	215
 4179 2112 D702     		.short	727
 4180 2114 D701     		.short	471
 4181 2116 D703     		.short	983
 4182 2118 3700     		.short	55
 4183 211a 3702     		.short	567
 4184 211c 3701     		.short	311
 4185 211e 3703     		.short	823
 4186 2120 B700     		.short	183
 4187 2122 B702     		.short	695
 4188 2124 B701     		.short	439
 4189 2126 B703     		.short	951
 4190 2128 7700     		.short	119
 4191 212a 7702     		.short	631
 4192 212c 7701     		.short	375
 4193 212e 7703     		.short	887
 4194 2130 F700     		.short	247
 4195 2132 F702     		.short	759
 4196 2134 F701     		.short	503
 4197 2136 F703     		.short	1015
 4198 2138 0F00     		.short	15
 4199 213a 0F02     		.short	527
 4200 213c 0F01     		.short	271
 4201 213e 0F03     		.short	783
 4202 2140 8F00     		.short	143
 4203 2142 8F02     		.short	655
 4204 2144 8F01     		.short	399
 4205 2146 8F03     		.short	911
 4206 2148 4F00     		.short	79
 4207 214a 4F02     		.short	591
 4208 214c 4F01     		.short	335
 4209 214e 4F03     		.short	847
 4210 2150 CF00     		.short	207
 4211 2152 CF02     		.short	719
 4212 2154 CF01     		.short	463
 4213 2156 CF03     		.short	975
 4214 2158 2F00     		.short	47
 4215 215a 2F02     		.short	559
 4216 215c 2F01     		.short	303
 4217 215e 2F03     		.short	815
 4218 2160 AF00     		.short	175
 4219 2162 AF02     		.short	687
 4220 2164 AF01     		.short	431
 4221 2166 AF03     		.short	943
 4222 2168 6F00     		.short	111
 4223 216a 6F02     		.short	623
 4224 216c 6F01     		.short	367
 4225 216e 6F03     		.short	879
 4226 2170 EF00     		.short	239
 4227 2172 EF02     		.short	751
 4228 2174 EF01     		.short	495
 4229 2176 EF03     		.short	1007
 4230 2178 1F00     		.short	31
 4231 217a 1F02     		.short	543
 4232 217c 1F01     		.short	287
 4233 217e 1F03     		.short	799
 4234 2180 9F00     		.short	159
 4235 2182 9F02     		.short	671
 4236 2184 9F01     		.short	415
 4237 2186 9F03     		.short	927
 4238 2188 5F00     		.short	95
 4239 218a 5F02     		.short	607
 4240 218c 5F01     		.short	351
 4241 218e 5F03     		.short	863
 4242 2190 DF00     		.short	223
 4243 2192 DF02     		.short	735
 4244 2194 DF01     		.short	479
 4245 2196 DF03     		.short	991
 4246 2198 3F00     		.short	63
 4247 219a 3F02     		.short	575
 4248 219c 3F01     		.short	319
 4249 219e 3F03     		.short	831
 4250 21a0 BF00     		.short	191
 4251 21a2 BF02     		.short	703
 4252 21a4 BF01     		.short	447
 4253 21a6 BF03     		.short	959
 4254 21a8 7F00     		.short	127
 4255 21aa 7F02     		.short	639
 4256 21ac 7F01     		.short	383
 4257 21ae 7F03     		.short	895
 4258 21b0 FF00     		.short	255
 4259 21b2 FF02     		.short	767
 4260 21b4 FF01     		.short	511
 4261 21b6 FF03     		.short	1023
 4262              		.section	.text.modp_mkgm2,"ax",%progbits
 4263              		.align	1
 4264              		.syntax unified
 4265              		.thumb
 4266              		.thumb_func
 4267              		.fpu softvfp
 4269              	modp_mkgm2:
 4270              	.LFB28:
 834:keygen.c      **** 
 835:keygen.c      **** /*
 836:keygen.c      ****  * Bit-reversal index table.
 837:keygen.c      ****  */
 838:keygen.c      **** static const uint16_t REV10[] = {
 839:keygen.c      **** 	   0,  512,  256,  768,  128,  640,  384,  896,   64,  576,  320,  832,
 840:keygen.c      **** 	 192,  704,  448,  960,   32,  544,  288,  800,  160,  672,  416,  928,
 841:keygen.c      **** 	  96,  608,  352,  864,  224,  736,  480,  992,   16,  528,  272,  784,
 842:keygen.c      **** 	 144,  656,  400,  912,   80,  592,  336,  848,  208,  720,  464,  976,
 843:keygen.c      **** 	  48,  560,  304,  816,  176,  688,  432,  944,  112,  624,  368,  880,
 844:keygen.c      **** 	 240,  752,  496, 1008,    8,  520,  264,  776,  136,  648,  392,  904,
 845:keygen.c      **** 	  72,  584,  328,  840,  200,  712,  456,  968,   40,  552,  296,  808,
 846:keygen.c      **** 	 168,  680,  424,  936,  104,  616,  360,  872,  232,  744,  488, 1000,
 847:keygen.c      **** 	  24,  536,  280,  792,  152,  664,  408,  920,   88,  600,  344,  856,
 848:keygen.c      **** 	 216,  728,  472,  984,   56,  568,  312,  824,  184,  696,  440,  952,
 849:keygen.c      **** 	 120,  632,  376,  888,  248,  760,  504, 1016,    4,  516,  260,  772,
 850:keygen.c      **** 	 132,  644,  388,  900,   68,  580,  324,  836,  196,  708,  452,  964,
 851:keygen.c      **** 	  36,  548,  292,  804,  164,  676,  420,  932,  100,  612,  356,  868,
 852:keygen.c      **** 	 228,  740,  484,  996,   20,  532,  276,  788,  148,  660,  404,  916,
 853:keygen.c      **** 	  84,  596,  340,  852,  212,  724,  468,  980,   52,  564,  308,  820,
 854:keygen.c      **** 	 180,  692,  436,  948,  116,  628,  372,  884,  244,  756,  500, 1012,
 855:keygen.c      **** 	  12,  524,  268,  780,  140,  652,  396,  908,   76,  588,  332,  844,
 856:keygen.c      **** 	 204,  716,  460,  972,   44,  556,  300,  812,  172,  684,  428,  940,
 857:keygen.c      **** 	 108,  620,  364,  876,  236,  748,  492, 1004,   28,  540,  284,  796,
 858:keygen.c      **** 	 156,  668,  412,  924,   92,  604,  348,  860,  220,  732,  476,  988,
 859:keygen.c      **** 	  60,  572,  316,  828,  188,  700,  444,  956,  124,  636,  380,  892,
 860:keygen.c      **** 	 252,  764,  508, 1020,    2,  514,  258,  770,  130,  642,  386,  898,
 861:keygen.c      **** 	  66,  578,  322,  834,  194,  706,  450,  962,   34,  546,  290,  802,
 862:keygen.c      **** 	 162,  674,  418,  930,   98,  610,  354,  866,  226,  738,  482,  994,
 863:keygen.c      **** 	  18,  530,  274,  786,  146,  658,  402,  914,   82,  594,  338,  850,
 864:keygen.c      **** 	 210,  722,  466,  978,   50,  562,  306,  818,  178,  690,  434,  946,
 865:keygen.c      **** 	 114,  626,  370,  882,  242,  754,  498, 1010,   10,  522,  266,  778,
 866:keygen.c      **** 	 138,  650,  394,  906,   74,  586,  330,  842,  202,  714,  458,  970,
 867:keygen.c      **** 	  42,  554,  298,  810,  170,  682,  426,  938,  106,  618,  362,  874,
 868:keygen.c      **** 	 234,  746,  490, 1002,   26,  538,  282,  794,  154,  666,  410,  922,
 869:keygen.c      **** 	  90,  602,  346,  858,  218,  730,  474,  986,   58,  570,  314,  826,
 870:keygen.c      **** 	 186,  698,  442,  954,  122,  634,  378,  890,  250,  762,  506, 1018,
 871:keygen.c      **** 	   6,  518,  262,  774,  134,  646,  390,  902,   70,  582,  326,  838,
 872:keygen.c      **** 	 198,  710,  454,  966,   38,  550,  294,  806,  166,  678,  422,  934,
 873:keygen.c      **** 	 102,  614,  358,  870,  230,  742,  486,  998,   22,  534,  278,  790,
 874:keygen.c      **** 	 150,  662,  406,  918,   86,  598,  342,  854,  214,  726,  470,  982,
 875:keygen.c      **** 	  54,  566,  310,  822,  182,  694,  438,  950,  118,  630,  374,  886,
 876:keygen.c      **** 	 246,  758,  502, 1014,   14,  526,  270,  782,  142,  654,  398,  910,
 877:keygen.c      **** 	  78,  590,  334,  846,  206,  718,  462,  974,   46,  558,  302,  814,
 878:keygen.c      **** 	 174,  686,  430,  942,  110,  622,  366,  878,  238,  750,  494, 1006,
 879:keygen.c      **** 	  30,  542,  286,  798,  158,  670,  414,  926,   94,  606,  350,  862,
 880:keygen.c      **** 	 222,  734,  478,  990,   62,  574,  318,  830,  190,  702,  446,  958,
 881:keygen.c      **** 	 126,  638,  382,  894,  254,  766,  510, 1022,    1,  513,  257,  769,
 882:keygen.c      **** 	 129,  641,  385,  897,   65,  577,  321,  833,  193,  705,  449,  961,
 883:keygen.c      **** 	  33,  545,  289,  801,  161,  673,  417,  929,   97,  609,  353,  865,
 884:keygen.c      **** 	 225,  737,  481,  993,   17,  529,  273,  785,  145,  657,  401,  913,
 885:keygen.c      **** 	  81,  593,  337,  849,  209,  721,  465,  977,   49,  561,  305,  817,
 886:keygen.c      **** 	 177,  689,  433,  945,  113,  625,  369,  881,  241,  753,  497, 1009,
 887:keygen.c      **** 	   9,  521,  265,  777,  137,  649,  393,  905,   73,  585,  329,  841,
 888:keygen.c      **** 	 201,  713,  457,  969,   41,  553,  297,  809,  169,  681,  425,  937,
 889:keygen.c      **** 	 105,  617,  361,  873,  233,  745,  489, 1001,   25,  537,  281,  793,
 890:keygen.c      **** 	 153,  665,  409,  921,   89,  601,  345,  857,  217,  729,  473,  985,
 891:keygen.c      **** 	  57,  569,  313,  825,  185,  697,  441,  953,  121,  633,  377,  889,
 892:keygen.c      **** 	 249,  761,  505, 1017,    5,  517,  261,  773,  133,  645,  389,  901,
 893:keygen.c      **** 	  69,  581,  325,  837,  197,  709,  453,  965,   37,  549,  293,  805,
 894:keygen.c      **** 	 165,  677,  421,  933,  101,  613,  357,  869,  229,  741,  485,  997,
 895:keygen.c      **** 	  21,  533,  277,  789,  149,  661,  405,  917,   85,  597,  341,  853,
 896:keygen.c      **** 	 213,  725,  469,  981,   53,  565,  309,  821,  181,  693,  437,  949,
 897:keygen.c      **** 	 117,  629,  373,  885,  245,  757,  501, 1013,   13,  525,  269,  781,
 898:keygen.c      **** 	 141,  653,  397,  909,   77,  589,  333,  845,  205,  717,  461,  973,
 899:keygen.c      **** 	  45,  557,  301,  813,  173,  685,  429,  941,  109,  621,  365,  877,
 900:keygen.c      **** 	 237,  749,  493, 1005,   29,  541,  285,  797,  157,  669,  413,  925,
 901:keygen.c      **** 	  93,  605,  349,  861,  221,  733,  477,  989,   61,  573,  317,  829,
 902:keygen.c      **** 	 189,  701,  445,  957,  125,  637,  381,  893,  253,  765,  509, 1021,
 903:keygen.c      **** 	   3,  515,  259,  771,  131,  643,  387,  899,   67,  579,  323,  835,
 904:keygen.c      **** 	 195,  707,  451,  963,   35,  547,  291,  803,  163,  675,  419,  931,
 905:keygen.c      **** 	  99,  611,  355,  867,  227,  739,  483,  995,   19,  531,  275,  787,
 906:keygen.c      **** 	 147,  659,  403,  915,   83,  595,  339,  851,  211,  723,  467,  979,
 907:keygen.c      **** 	  51,  563,  307,  819,  179,  691,  435,  947,  115,  627,  371,  883,
 908:keygen.c      **** 	 243,  755,  499, 1011,   11,  523,  267,  779,  139,  651,  395,  907,
 909:keygen.c      **** 	  75,  587,  331,  843,  203,  715,  459,  971,   43,  555,  299,  811,
 910:keygen.c      **** 	 171,  683,  427,  939,  107,  619,  363,  875,  235,  747,  491, 1003,
 911:keygen.c      **** 	  27,  539,  283,  795,  155,  667,  411,  923,   91,  603,  347,  859,
 912:keygen.c      **** 	 219,  731,  475,  987,   59,  571,  315,  827,  187,  699,  443,  955,
 913:keygen.c      **** 	 123,  635,  379,  891,  251,  763,  507, 1019,    7,  519,  263,  775,
 914:keygen.c      **** 	 135,  647,  391,  903,   71,  583,  327,  839,  199,  711,  455,  967,
 915:keygen.c      **** 	  39,  551,  295,  807,  167,  679,  423,  935,  103,  615,  359,  871,
 916:keygen.c      **** 	 231,  743,  487,  999,   23,  535,  279,  791,  151,  663,  407,  919,
 917:keygen.c      **** 	  87,  599,  343,  855,  215,  727,  471,  983,   55,  567,  311,  823,
 918:keygen.c      **** 	 183,  695,  439,  951,  119,  631,  375,  887,  247,  759,  503, 1015,
 919:keygen.c      **** 	  15,  527,  271,  783,  143,  655,  399,  911,   79,  591,  335,  847,
 920:keygen.c      **** 	 207,  719,  463,  975,   47,  559,  303,  815,  175,  687,  431,  943,
 921:keygen.c      **** 	 111,  623,  367,  879,  239,  751,  495, 1007,   31,  543,  287,  799,
 922:keygen.c      **** 	 159,  671,  415,  927,   95,  607,  351,  863,  223,  735,  479,  991,
 923:keygen.c      **** 	  63,  575,  319,  831,  191,  703,  447,  959,  127,  639,  383,  895,
 924:keygen.c      **** 	 255,  767,  511, 1023
 925:keygen.c      **** };
 926:keygen.c      **** 
 927:keygen.c      **** /*
 928:keygen.c      ****  * Compute the roots for NTT and inverse NTT (binary case). Input
 929:keygen.c      ****  * parameter g is a primitive 2048-th root of 1 modulo p (i.e. g^1024 =
 930:keygen.c      ****  * -1 mod p). This fills gm[] and igm[] with powers of g and 1/g:
 931:keygen.c      ****  *   gm[rev(i)] = g^i mod p
 932:keygen.c      ****  *   igm[rev(i)] = (1/g)^i mod p
 933:keygen.c      ****  * where rev() is the "bit reversal" function over 10 bits. It fills
 934:keygen.c      ****  * the arrays only up to N = 2^logn values.
 935:keygen.c      ****  *
 936:keygen.c      ****  * The values stored in gm[] and igm[] are in Montgomery representation.
 937:keygen.c      ****  *
 938:keygen.c      ****  * p must be a prime such that p = 1 mod 2048.
 939:keygen.c      ****  */
 940:keygen.c      **** static void
 941:keygen.c      **** modp_mkgm2(uint32_t *restrict gm, uint32_t *restrict igm, unsigned logn,
 942:keygen.c      **** 	uint32_t g, uint32_t p, uint32_t p0i)
 943:keygen.c      **** {
 4271              		.loc 2 943 1
 4272              		.cfi_startproc
 4273              		@ args = 8, pretend = 0, frame = 48
 4274              		@ frame_needed = 1, uses_anonymous_args = 0
 4275 0000 80B5     		push	{r7, lr}
 4276              	.LCFI90:
 4277              		.cfi_def_cfa_offset 8
 4278              		.cfi_offset 7, -8
 4279              		.cfi_offset 14, -4
 4280 0002 8EB0     		sub	sp, sp, #56
 4281              	.LCFI91:
 4282              		.cfi_def_cfa_offset 64
 4283 0004 02AF     		add	r7, sp, #8
 4284              	.LCFI92:
 4285              		.cfi_def_cfa 7, 56
 4286 0006 F860     		str	r0, [r7, #12]
 4287 0008 B960     		str	r1, [r7, #8]
 4288 000a 7A60     		str	r2, [r7, #4]
 4289 000c 3B60     		str	r3, [r7]
 944:keygen.c      **** 	size_t u, n;
 945:keygen.c      **** 	unsigned k;
 946:keygen.c      **** 	uint32_t ig, x1, x2, R2;
 947:keygen.c      **** 
 948:keygen.c      **** 	n = (size_t)1 << logn;
 4290              		.loc 2 948 4
 4291 000e 0122     		movs	r2, #1
 4292 0010 7B68     		ldr	r3, [r7, #4]
 4293 0012 02FA03F3 		lsl	r3, r2, r3
 4294 0016 FB61     		str	r3, [r7, #28]
 949:keygen.c      **** 
 950:keygen.c      **** 	/*
 951:keygen.c      **** 	 * We want g such that g^(2N) = 1 mod p, but the provided
 952:keygen.c      **** 	 * generator has order 2048. We must square it a few times.
 953:keygen.c      **** 	 */
 954:keygen.c      **** 	R2 = modp_R2(p, p0i);
 4295              		.loc 2 954 7
 4296 0018 F96B     		ldr	r1, [r7, #60]
 4297 001a B86B     		ldr	r0, [r7, #56]
 4298 001c FFF7FEFF 		bl	modp_R2
 4299 0020 B861     		str	r0, [r7, #24]
 955:keygen.c      **** 	g = modp_montymul(g, R2, p, p0i);
 4300              		.loc 2 955 6
 4301 0022 FB6B     		ldr	r3, [r7, #60]
 4302 0024 BA6B     		ldr	r2, [r7, #56]
 4303 0026 B969     		ldr	r1, [r7, #24]
 4304 0028 3868     		ldr	r0, [r7]
 4305 002a FFF7FEFF 		bl	modp_montymul
 4306 002e 3860     		str	r0, [r7]
 956:keygen.c      **** 	for (k = logn; k < 10; k ++) {
 4307              		.loc 2 956 9
 4308 0030 7B68     		ldr	r3, [r7, #4]
 4309 0032 BB62     		str	r3, [r7, #40]
 4310              		.loc 2 956 2
 4311 0034 09E0     		b	.L39
 4312              	.L40:
 957:keygen.c      **** 		g = modp_montymul(g, g, p, p0i);
 4313              		.loc 2 957 7 discriminator 3
 4314 0036 FB6B     		ldr	r3, [r7, #60]
 4315 0038 BA6B     		ldr	r2, [r7, #56]
 4316 003a 3968     		ldr	r1, [r7]
 4317 003c 3868     		ldr	r0, [r7]
 4318 003e FFF7FEFF 		bl	modp_montymul
 4319 0042 3860     		str	r0, [r7]
 956:keygen.c      **** 	for (k = logn; k < 10; k ++) {
 4320              		.loc 2 956 27 discriminator 3
 4321 0044 BB6A     		ldr	r3, [r7, #40]
 4322 0046 0133     		adds	r3, r3, #1
 4323 0048 BB62     		str	r3, [r7, #40]
 4324              	.L39:
 956:keygen.c      **** 	for (k = logn; k < 10; k ++) {
 4325              		.loc 2 956 2 discriminator 1
 4326 004a BB6A     		ldr	r3, [r7, #40]
 4327 004c 092B     		cmp	r3, #9
 4328 004e F2D9     		bls	.L40
 958:keygen.c      **** 	}
 959:keygen.c      **** 
 960:keygen.c      **** 	ig = modp_div(R2, g, p, p0i, modp_R(p));
 4329              		.loc 2 960 7
 4330 0050 B86B     		ldr	r0, [r7, #56]
 4331 0052 FFF7FEFF 		bl	modp_R
 4332 0056 0346     		mov	r3, r0
 4333 0058 0093     		str	r3, [sp]
 4334 005a FB6B     		ldr	r3, [r7, #60]
 4335 005c BA6B     		ldr	r2, [r7, #56]
 4336 005e 3968     		ldr	r1, [r7]
 4337 0060 B869     		ldr	r0, [r7, #24]
 4338 0062 FFF7FEFF 		bl	modp_div
 4339 0066 7861     		str	r0, [r7, #20]
 961:keygen.c      **** 	k = 10 - logn;
 4340              		.loc 2 961 4
 4341 0068 7B68     		ldr	r3, [r7, #4]
 4342 006a C3F10A03 		rsb	r3, r3, #10
 4343 006e BB62     		str	r3, [r7, #40]
 962:keygen.c      **** 	x1 = x2 = modp_R(p);
 4344              		.loc 2 962 12
 4345 0070 B86B     		ldr	r0, [r7, #56]
 4346 0072 FFF7FEFF 		bl	modp_R
 4347 0076 3862     		str	r0, [r7, #32]
 4348              		.loc 2 962 5
 4349 0078 3B6A     		ldr	r3, [r7, #32]
 4350 007a 7B62     		str	r3, [r7, #36]
 963:keygen.c      **** 	for (u = 0; u < n; u ++) {
 4351              		.loc 2 963 9
 4352 007c 0023     		movs	r3, #0
 4353 007e FB62     		str	r3, [r7, #44]
 4354              		.loc 2 963 2
 4355 0080 24E0     		b	.L41
 4356              	.L42:
 4357              	.LBB3:
 964:keygen.c      **** 		size_t v;
 965:keygen.c      **** 
 966:keygen.c      **** 		v = REV10[u << k];
 4358              		.loc 2 966 15 discriminator 3
 4359 0082 FA6A     		ldr	r2, [r7, #44]
 4360 0084 BB6A     		ldr	r3, [r7, #40]
 4361 0086 02FA03F3 		lsl	r3, r2, r3
 4362              		.loc 2 966 12 discriminator 3
 4363 008a 154A     		ldr	r2, .L43
 4364 008c 32F81330 		ldrh	r3, [r2, r3, lsl #1]
 4365              		.loc 2 966 5 discriminator 3
 4366 0090 3B61     		str	r3, [r7, #16]
 967:keygen.c      **** 		gm[v] = x1;
 4367              		.loc 2 967 5 discriminator 3
 4368 0092 3B69     		ldr	r3, [r7, #16]
 4369 0094 9B00     		lsls	r3, r3, #2
 4370 0096 FA68     		ldr	r2, [r7, #12]
 4371 0098 1344     		add	r3, r3, r2
 4372              		.loc 2 967 9 discriminator 3
 4373 009a 7A6A     		ldr	r2, [r7, #36]
 4374 009c 1A60     		str	r2, [r3]
 968:keygen.c      **** 		igm[v] = x2;
 4375              		.loc 2 968 6 discriminator 3
 4376 009e 3B69     		ldr	r3, [r7, #16]
 4377 00a0 9B00     		lsls	r3, r3, #2
 4378 00a2 BA68     		ldr	r2, [r7, #8]
 4379 00a4 1344     		add	r3, r3, r2
 4380              		.loc 2 968 10 discriminator 3
 4381 00a6 3A6A     		ldr	r2, [r7, #32]
 4382 00a8 1A60     		str	r2, [r3]
 969:keygen.c      **** 		x1 = modp_montymul(x1, g, p, p0i);
 4383              		.loc 2 969 8 discriminator 3
 4384 00aa FB6B     		ldr	r3, [r7, #60]
 4385 00ac BA6B     		ldr	r2, [r7, #56]
 4386 00ae 3968     		ldr	r1, [r7]
 4387 00b0 786A     		ldr	r0, [r7, #36]
 4388 00b2 FFF7FEFF 		bl	modp_montymul
 4389 00b6 7862     		str	r0, [r7, #36]
 970:keygen.c      **** 		x2 = modp_montymul(x2, ig, p, p0i);
 4390              		.loc 2 970 8 discriminator 3
 4391 00b8 FB6B     		ldr	r3, [r7, #60]
 4392 00ba BA6B     		ldr	r2, [r7, #56]
 4393 00bc 7969     		ldr	r1, [r7, #20]
 4394 00be 386A     		ldr	r0, [r7, #32]
 4395 00c0 FFF7FEFF 		bl	modp_montymul
 4396 00c4 3862     		str	r0, [r7, #32]
 4397              	.LBE3:
 963:keygen.c      **** 		size_t v;
 4398              		.loc 2 963 23 discriminator 3
 4399 00c6 FB6A     		ldr	r3, [r7, #44]
 4400 00c8 0133     		adds	r3, r3, #1
 4401 00ca FB62     		str	r3, [r7, #44]
 4402              	.L41:
 963:keygen.c      **** 		size_t v;
 4403              		.loc 2 963 2 discriminator 1
 4404 00cc FA6A     		ldr	r2, [r7, #44]
 4405 00ce FB69     		ldr	r3, [r7, #28]
 4406 00d0 9A42     		cmp	r2, r3
 4407 00d2 D6D3     		bcc	.L42
 971:keygen.c      **** 	}
 972:keygen.c      **** }
 4408              		.loc 2 972 1
 4409 00d4 00BF     		nop
 4410 00d6 00BF     		nop
 4411 00d8 3037     		adds	r7, r7, #48
 4412              	.LCFI93:
 4413              		.cfi_def_cfa_offset 8
 4414 00da BD46     		mov	sp, r7
 4415              	.LCFI94:
 4416              		.cfi_def_cfa_register 13
 4417              		@ sp needed
 4418 00dc 80BD     		pop	{r7, pc}
 4419              	.L44:
 4420 00de 00BF     		.align	2
 4421              	.L43:
 4422 00e0 B8190000 		.word	REV10
 4423              		.cfi_endproc
 4424              	.LFE28:
 4426              		.section	.text.modp_NTT2_ext,"ax",%progbits
 4427              		.align	1
 4428              		.syntax unified
 4429              		.thumb
 4430              		.thumb_func
 4431              		.fpu softvfp
 4433              	modp_NTT2_ext:
 4434              	.LFB29:
 973:keygen.c      **** 
 974:keygen.c      **** /*
 975:keygen.c      ****  * Compute the NTT over a polynomial (binary case). Polynomial elements
 976:keygen.c      ****  * are a[0], a[stride], a[2 * stride]...
 977:keygen.c      ****  */
 978:keygen.c      **** static void
 979:keygen.c      **** modp_NTT2_ext(uint32_t *a, size_t stride, const uint32_t *gm, unsigned logn,
 980:keygen.c      **** 	uint32_t p, uint32_t p0i)
 981:keygen.c      **** {
 4435              		.loc 2 981 1
 4436              		.cfi_startproc
 4437              		@ args = 8, pretend = 0, frame = 64
 4438              		@ frame_needed = 1, uses_anonymous_args = 0
 4439 0000 80B5     		push	{r7, lr}
 4440              	.LCFI95:
 4441              		.cfi_def_cfa_offset 8
 4442              		.cfi_offset 7, -8
 4443              		.cfi_offset 14, -4
 4444 0002 90B0     		sub	sp, sp, #64
 4445              	.LCFI96:
 4446              		.cfi_def_cfa_offset 72
 4447 0004 00AF     		add	r7, sp, #0
 4448              	.LCFI97:
 4449              		.cfi_def_cfa_register 7
 4450 0006 F860     		str	r0, [r7, #12]
 4451 0008 B960     		str	r1, [r7, #8]
 4452 000a 7A60     		str	r2, [r7, #4]
 4453 000c 3B60     		str	r3, [r7]
 982:keygen.c      **** 	size_t t, m, n;
 983:keygen.c      **** 
 984:keygen.c      **** 	if (logn == 0) {
 4454              		.loc 2 984 5
 4455 000e 3B68     		ldr	r3, [r7]
 4456 0010 002B     		cmp	r3, #0
 4457 0012 6DD0     		beq	.L54
 985:keygen.c      **** 		return;
 986:keygen.c      **** 	}
 987:keygen.c      **** 	n = (size_t)1 << logn;
 4458              		.loc 2 987 4
 4459 0014 0122     		movs	r2, #1
 4460 0016 3B68     		ldr	r3, [r7]
 4461 0018 02FA03F3 		lsl	r3, r2, r3
 4462 001c 3B62     		str	r3, [r7, #32]
 988:keygen.c      **** 	t = n;
 4463              		.loc 2 988 4
 4464 001e 3B6A     		ldr	r3, [r7, #32]
 4465 0020 FB63     		str	r3, [r7, #60]
 989:keygen.c      **** 	for (m = 1; m < n; m <<= 1) {
 4466              		.loc 2 989 9
 4467 0022 0123     		movs	r3, #1
 4468 0024 BB63     		str	r3, [r7, #56]
 4469              		.loc 2 989 2
 4470 0026 5EE0     		b	.L48
 4471              	.L53:
 4472              	.LBB4:
 990:keygen.c      **** 		size_t ht, u, v1;
 991:keygen.c      **** 
 992:keygen.c      **** 		ht = t >> 1;
 4473              		.loc 2 992 6
 4474 0028 FB6B     		ldr	r3, [r7, #60]
 4475 002a 5B08     		lsrs	r3, r3, #1
 4476 002c FB61     		str	r3, [r7, #28]
 993:keygen.c      **** 		for (u = 0, v1 = 0; u < m; u ++, v1 += t) {
 4477              		.loc 2 993 10
 4478 002e 0023     		movs	r3, #0
 4479 0030 7B63     		str	r3, [r7, #52]
 4480              		.loc 2 993 18
 4481 0032 0023     		movs	r3, #0
 4482 0034 3B63     		str	r3, [r7, #48]
 4483              		.loc 2 993 3
 4484 0036 4DE0     		b	.L49
 4485              	.L52:
 4486              	.LBB5:
 994:keygen.c      **** 			uint32_t s;
 995:keygen.c      **** 			size_t v;
 996:keygen.c      **** 			uint32_t *r1, *r2;
 997:keygen.c      **** 
 998:keygen.c      **** 			s = gm[m + u];
 4487              		.loc 2 998 13
 4488 0038 BA6B     		ldr	r2, [r7, #56]
 4489 003a 7B6B     		ldr	r3, [r7, #52]
 4490 003c 1344     		add	r3, r3, r2
 4491              		.loc 2 998 10
 4492 003e 9B00     		lsls	r3, r3, #2
 4493 0040 7A68     		ldr	r2, [r7, #4]
 4494 0042 1344     		add	r3, r3, r2
 4495              		.loc 2 998 6
 4496 0044 1B68     		ldr	r3, [r3]
 4497 0046 BB61     		str	r3, [r7, #24]
 999:keygen.c      **** 			r1 = a + v1 * stride;
 4498              		.loc 2 999 16
 4499 0048 3B6B     		ldr	r3, [r7, #48]
 4500 004a BA68     		ldr	r2, [r7, #8]
 4501 004c 02FB03F3 		mul	r3, r2, r3
 4502              		.loc 2 999 11
 4503 0050 9B00     		lsls	r3, r3, #2
 4504              		.loc 2 999 7
 4505 0052 FA68     		ldr	r2, [r7, #12]
 4506 0054 1344     		add	r3, r3, r2
 4507 0056 BB62     		str	r3, [r7, #40]
1000:keygen.c      **** 			r2 = r1 + ht * stride;
 4508              		.loc 2 1000 17
 4509 0058 FB69     		ldr	r3, [r7, #28]
 4510 005a BA68     		ldr	r2, [r7, #8]
 4511 005c 02FB03F3 		mul	r3, r2, r3
 4512              		.loc 2 1000 12
 4513 0060 9B00     		lsls	r3, r3, #2
 4514              		.loc 2 1000 7
 4515 0062 BA6A     		ldr	r2, [r7, #40]
 4516 0064 1344     		add	r3, r3, r2
 4517 0066 7B62     		str	r3, [r7, #36]
1001:keygen.c      **** 			for (v = 0; v < ht; v ++, r1 += stride, r2 += stride) {
 4518              		.loc 2 1001 11
 4519 0068 0023     		movs	r3, #0
 4520 006a FB62     		str	r3, [r7, #44]
 4521              		.loc 2 1001 4
 4522 006c 27E0     		b	.L50
 4523              	.L51:
 4524              	.LBB6:
1002:keygen.c      **** 				uint32_t x, y;
1003:keygen.c      **** 
1004:keygen.c      **** 				x = *r1;
 4525              		.loc 2 1004 7 discriminator 3
 4526 006e BB6A     		ldr	r3, [r7, #40]
 4527 0070 1B68     		ldr	r3, [r3]
 4528 0072 7B61     		str	r3, [r7, #20]
1005:keygen.c      **** 				y = modp_montymul(*r2, s, p, p0i);
 4529              		.loc 2 1005 9 discriminator 3
 4530 0074 7B6A     		ldr	r3, [r7, #36]
 4531 0076 1868     		ldr	r0, [r3]
 4532 0078 FB6C     		ldr	r3, [r7, #76]
 4533 007a BA6C     		ldr	r2, [r7, #72]
 4534 007c B969     		ldr	r1, [r7, #24]
 4535 007e FFF7FEFF 		bl	modp_montymul
 4536 0082 3861     		str	r0, [r7, #16]
1006:keygen.c      **** 				*r1 = modp_add(x, y, p);
 4537              		.loc 2 1006 11 discriminator 3
 4538 0084 BA6C     		ldr	r2, [r7, #72]
 4539 0086 3969     		ldr	r1, [r7, #16]
 4540 0088 7869     		ldr	r0, [r7, #20]
 4541 008a FFF7FEFF 		bl	modp_add
 4542 008e 0246     		mov	r2, r0
 4543              		.loc 2 1006 9 discriminator 3
 4544 0090 BB6A     		ldr	r3, [r7, #40]
 4545 0092 1A60     		str	r2, [r3]
1007:keygen.c      **** 				*r2 = modp_sub(x, y, p);
 4546              		.loc 2 1007 11 discriminator 3
 4547 0094 BA6C     		ldr	r2, [r7, #72]
 4548 0096 3969     		ldr	r1, [r7, #16]
 4549 0098 7869     		ldr	r0, [r7, #20]
 4550 009a FFF7FEFF 		bl	modp_sub
 4551 009e 0246     		mov	r2, r0
 4552              		.loc 2 1007 9 discriminator 3
 4553 00a0 7B6A     		ldr	r3, [r7, #36]
 4554 00a2 1A60     		str	r2, [r3]
 4555              	.LBE6:
1001:keygen.c      **** 				uint32_t x, y;
 4556              		.loc 2 1001 26 discriminator 3
 4557 00a4 FB6A     		ldr	r3, [r7, #44]
 4558 00a6 0133     		adds	r3, r3, #1
 4559 00a8 FB62     		str	r3, [r7, #44]
1001:keygen.c      **** 				uint32_t x, y;
 4560              		.loc 2 1001 33 discriminator 3
 4561 00aa BB68     		ldr	r3, [r7, #8]
 4562 00ac 9B00     		lsls	r3, r3, #2
 4563 00ae BA6A     		ldr	r2, [r7, #40]
 4564 00b0 1344     		add	r3, r3, r2
 4565 00b2 BB62     		str	r3, [r7, #40]
1001:keygen.c      **** 				uint32_t x, y;
 4566              		.loc 2 1001 47 discriminator 3
 4567 00b4 BB68     		ldr	r3, [r7, #8]
 4568 00b6 9B00     		lsls	r3, r3, #2
 4569 00b8 7A6A     		ldr	r2, [r7, #36]
 4570 00ba 1344     		add	r3, r3, r2
 4571 00bc 7B62     		str	r3, [r7, #36]
 4572              	.L50:
1001:keygen.c      **** 				uint32_t x, y;
 4573              		.loc 2 1001 4 discriminator 1
 4574 00be FA6A     		ldr	r2, [r7, #44]
 4575 00c0 FB69     		ldr	r3, [r7, #28]
 4576 00c2 9A42     		cmp	r2, r3
 4577 00c4 D3D3     		bcc	.L51
 4578              	.LBE5:
 993:keygen.c      **** 			uint32_t s;
 4579              		.loc 2 993 32 discriminator 2
 4580 00c6 7B6B     		ldr	r3, [r7, #52]
 4581 00c8 0133     		adds	r3, r3, #1
 4582 00ca 7B63     		str	r3, [r7, #52]
 993:keygen.c      **** 			uint32_t s;
 4583              		.loc 2 993 39 discriminator 2
 4584 00cc 3A6B     		ldr	r2, [r7, #48]
 4585 00ce FB6B     		ldr	r3, [r7, #60]
 4586 00d0 1344     		add	r3, r3, r2
 4587 00d2 3B63     		str	r3, [r7, #48]
 4588              	.L49:
 993:keygen.c      **** 			uint32_t s;
 4589              		.loc 2 993 3 discriminator 1
 4590 00d4 7A6B     		ldr	r2, [r7, #52]
 4591 00d6 BB6B     		ldr	r3, [r7, #56]
 4592 00d8 9A42     		cmp	r2, r3
 4593 00da ADD3     		bcc	.L52
1008:keygen.c      **** 			}
1009:keygen.c      **** 		}
1010:keygen.c      **** 		t = ht;
 4594              		.loc 2 1010 5 discriminator 2
 4595 00dc FB69     		ldr	r3, [r7, #28]
 4596 00de FB63     		str	r3, [r7, #60]
 4597              	.LBE4:
 989:keygen.c      **** 		size_t ht, u, v1;
 4598              		.loc 2 989 23 discriminator 2
 4599 00e0 BB6B     		ldr	r3, [r7, #56]
 4600 00e2 5B00     		lsls	r3, r3, #1
 4601 00e4 BB63     		str	r3, [r7, #56]
 4602              	.L48:
 989:keygen.c      **** 		size_t ht, u, v1;
 4603              		.loc 2 989 2 discriminator 1
 4604 00e6 BA6B     		ldr	r2, [r7, #56]
 4605 00e8 3B6A     		ldr	r3, [r7, #32]
 4606 00ea 9A42     		cmp	r2, r3
 4607 00ec 9CD3     		bcc	.L53
 4608 00ee 00E0     		b	.L45
 4609              	.L54:
 985:keygen.c      **** 	}
 4610              		.loc 2 985 3
 4611 00f0 00BF     		nop
 4612              	.L45:
1011:keygen.c      **** 	}
1012:keygen.c      **** }
 4613              		.loc 2 1012 1
 4614 00f2 4037     		adds	r7, r7, #64
 4615              	.LCFI98:
 4616              		.cfi_def_cfa_offset 8
 4617 00f4 BD46     		mov	sp, r7
 4618              	.LCFI99:
 4619              		.cfi_def_cfa_register 13
 4620              		@ sp needed
 4621 00f6 80BD     		pop	{r7, pc}
 4622              		.cfi_endproc
 4623              	.LFE29:
 4625              		.section	.text.modp_iNTT2_ext,"ax",%progbits
 4626              		.align	1
 4627              		.syntax unified
 4628              		.thumb
 4629              		.thumb_func
 4630              		.fpu softvfp
 4632              	modp_iNTT2_ext:
 4633              	.LFB30:
1013:keygen.c      **** 
1014:keygen.c      **** /*
1015:keygen.c      ****  * Compute the inverse NTT over a polynomial (binary case).
1016:keygen.c      ****  */
1017:keygen.c      **** static void
1018:keygen.c      **** modp_iNTT2_ext(uint32_t *a, size_t stride, const uint32_t *igm, unsigned logn,
1019:keygen.c      **** 	uint32_t p, uint32_t p0i)
1020:keygen.c      **** {
 4634              		.loc 2 1020 1
 4635              		.cfi_startproc
 4636              		@ args = 8, pretend = 0, frame = 80
 4637              		@ frame_needed = 1, uses_anonymous_args = 0
 4638 0000 80B5     		push	{r7, lr}
 4639              	.LCFI100:
 4640              		.cfi_def_cfa_offset 8
 4641              		.cfi_offset 7, -8
 4642              		.cfi_offset 14, -4
 4643 0002 94B0     		sub	sp, sp, #80
 4644              	.LCFI101:
 4645              		.cfi_def_cfa_offset 88
 4646 0004 00AF     		add	r7, sp, #0
 4647              	.LCFI102:
 4648              		.cfi_def_cfa_register 7
 4649 0006 F860     		str	r0, [r7, #12]
 4650 0008 B960     		str	r1, [r7, #8]
 4651 000a 7A60     		str	r2, [r7, #4]
 4652 000c 3B60     		str	r3, [r7]
1021:keygen.c      **** 	size_t t, m, n, k;
1022:keygen.c      **** 	uint32_t ni;
1023:keygen.c      **** 	uint32_t *r;
1024:keygen.c      **** 
1025:keygen.c      **** 	if (logn == 0) {
 4653              		.loc 2 1025 5
 4654 000e 3B68     		ldr	r3, [r7]
 4655 0010 002B     		cmp	r3, #0
 4656 0012 00F09180 		beq	.L66
1026:keygen.c      **** 		return;
1027:keygen.c      **** 	}
1028:keygen.c      **** 	n = (size_t)1 << logn;
 4657              		.loc 2 1028 4
 4658 0016 0122     		movs	r2, #1
 4659 0018 3B68     		ldr	r3, [r7]
 4660 001a 02FA03F3 		lsl	r3, r2, r3
 4661 001e BB62     		str	r3, [r7, #40]
1029:keygen.c      **** 	t = 1;
 4662              		.loc 2 1029 4
 4663 0020 0123     		movs	r3, #1
 4664 0022 FB64     		str	r3, [r7, #76]
1030:keygen.c      **** 	for (m = n; m > 1; m >>= 1) {
 4665              		.loc 2 1030 9
 4666 0024 BB6A     		ldr	r3, [r7, #40]
 4667 0026 BB64     		str	r3, [r7, #72]
 4668              		.loc 2 1030 2
 4669 0028 61E0     		b	.L58
 4670              	.L63:
 4671              	.LBB7:
1031:keygen.c      **** 		size_t hm, dt, u, v1;
1032:keygen.c      **** 
1033:keygen.c      **** 		hm = m >> 1;
 4672              		.loc 2 1033 6
 4673 002a BB6C     		ldr	r3, [r7, #72]
 4674 002c 5B08     		lsrs	r3, r3, #1
 4675 002e 3B62     		str	r3, [r7, #32]
1034:keygen.c      **** 		dt = t << 1;
 4676              		.loc 2 1034 6
 4677 0030 FB6C     		ldr	r3, [r7, #76]
 4678 0032 5B00     		lsls	r3, r3, #1
 4679 0034 FB61     		str	r3, [r7, #28]
1035:keygen.c      **** 		for (u = 0, v1 = 0; u < hm; u ++, v1 += dt) {
 4680              		.loc 2 1035 10
 4681 0036 0023     		movs	r3, #0
 4682 0038 FB63     		str	r3, [r7, #60]
 4683              		.loc 2 1035 18
 4684 003a 0023     		movs	r3, #0
 4685 003c BB63     		str	r3, [r7, #56]
 4686              		.loc 2 1035 3
 4687 003e 4DE0     		b	.L59
 4688              	.L62:
 4689              	.LBB8:
1036:keygen.c      **** 			uint32_t s;
1037:keygen.c      **** 			size_t v;
1038:keygen.c      **** 			uint32_t *r1, *r2;
1039:keygen.c      **** 
1040:keygen.c      **** 			s = igm[hm + u];
 4690              		.loc 2 1040 15
 4691 0040 3A6A     		ldr	r2, [r7, #32]
 4692 0042 FB6B     		ldr	r3, [r7, #60]
 4693 0044 1344     		add	r3, r3, r2
 4694              		.loc 2 1040 11
 4695 0046 9B00     		lsls	r3, r3, #2
 4696 0048 7A68     		ldr	r2, [r7, #4]
 4697 004a 1344     		add	r3, r3, r2
 4698              		.loc 2 1040 6
 4699 004c 1B68     		ldr	r3, [r3]
 4700 004e BB61     		str	r3, [r7, #24]
1041:keygen.c      **** 			r1 = a + v1 * stride;
 4701              		.loc 2 1041 16
 4702 0050 BB6B     		ldr	r3, [r7, #56]
 4703 0052 BA68     		ldr	r2, [r7, #8]
 4704 0054 02FB03F3 		mul	r3, r2, r3
 4705              		.loc 2 1041 11
 4706 0058 9B00     		lsls	r3, r3, #2
 4707              		.loc 2 1041 7
 4708 005a FA68     		ldr	r2, [r7, #12]
 4709 005c 1344     		add	r3, r3, r2
 4710 005e 3B63     		str	r3, [r7, #48]
1042:keygen.c      **** 			r2 = r1 + t * stride;
 4711              		.loc 2 1042 16
 4712 0060 FB6C     		ldr	r3, [r7, #76]
 4713 0062 BA68     		ldr	r2, [r7, #8]
 4714 0064 02FB03F3 		mul	r3, r2, r3
 4715              		.loc 2 1042 12
 4716 0068 9B00     		lsls	r3, r3, #2
 4717              		.loc 2 1042 7
 4718 006a 3A6B     		ldr	r2, [r7, #48]
 4719 006c 1344     		add	r3, r3, r2
 4720 006e FB62     		str	r3, [r7, #44]
1043:keygen.c      **** 			for (v = 0; v < t; v ++, r1 += stride, r2 += stride) {
 4721              		.loc 2 1043 11
 4722 0070 0023     		movs	r3, #0
 4723 0072 7B63     		str	r3, [r7, #52]
 4724              		.loc 2 1043 4
 4725 0074 27E0     		b	.L60
 4726              	.L61:
 4727              	.LBB9:
1044:keygen.c      **** 				uint32_t x, y;
1045:keygen.c      **** 
1046:keygen.c      **** 				x = *r1;
 4728              		.loc 2 1046 7 discriminator 3
 4729 0076 3B6B     		ldr	r3, [r7, #48]
 4730 0078 1B68     		ldr	r3, [r3]
 4731 007a 7B61     		str	r3, [r7, #20]
1047:keygen.c      **** 				y = *r2;
 4732              		.loc 2 1047 7 discriminator 3
 4733 007c FB6A     		ldr	r3, [r7, #44]
 4734 007e 1B68     		ldr	r3, [r3]
 4735 0080 3B61     		str	r3, [r7, #16]
1048:keygen.c      **** 				*r1 = modp_add(x, y, p);
 4736              		.loc 2 1048 11 discriminator 3
 4737 0082 BA6D     		ldr	r2, [r7, #88]
 4738 0084 3969     		ldr	r1, [r7, #16]
 4739 0086 7869     		ldr	r0, [r7, #20]
 4740 0088 FFF7FEFF 		bl	modp_add
 4741 008c 0246     		mov	r2, r0
 4742              		.loc 2 1048 9 discriminator 3
 4743 008e 3B6B     		ldr	r3, [r7, #48]
 4744 0090 1A60     		str	r2, [r3]
1049:keygen.c      **** 				*r2 = modp_montymul(
 4745              		.loc 2 1049 11 discriminator 3
 4746 0092 BA6D     		ldr	r2, [r7, #88]
 4747 0094 3969     		ldr	r1, [r7, #16]
 4748 0096 7869     		ldr	r0, [r7, #20]
 4749 0098 FFF7FEFF 		bl	modp_sub
 4750 009c FB6D     		ldr	r3, [r7, #92]
 4751 009e BA6D     		ldr	r2, [r7, #88]
 4752 00a0 B969     		ldr	r1, [r7, #24]
 4753 00a2 FFF7FEFF 		bl	modp_montymul
 4754 00a6 0246     		mov	r2, r0
 4755              		.loc 2 1049 9 discriminator 3
 4756 00a8 FB6A     		ldr	r3, [r7, #44]
 4757 00aa 1A60     		str	r2, [r3]
 4758              	.LBE9:
1043:keygen.c      **** 				uint32_t x, y;
 4759              		.loc 2 1043 25 discriminator 3
 4760 00ac 7B6B     		ldr	r3, [r7, #52]
 4761 00ae 0133     		adds	r3, r3, #1
 4762 00b0 7B63     		str	r3, [r7, #52]
1043:keygen.c      **** 				uint32_t x, y;
 4763              		.loc 2 1043 32 discriminator 3
 4764 00b2 BB68     		ldr	r3, [r7, #8]
 4765 00b4 9B00     		lsls	r3, r3, #2
 4766 00b6 3A6B     		ldr	r2, [r7, #48]
 4767 00b8 1344     		add	r3, r3, r2
 4768 00ba 3B63     		str	r3, [r7, #48]
1043:keygen.c      **** 				uint32_t x, y;
 4769              		.loc 2 1043 46 discriminator 3
 4770 00bc BB68     		ldr	r3, [r7, #8]
 4771 00be 9B00     		lsls	r3, r3, #2
 4772 00c0 FA6A     		ldr	r2, [r7, #44]
 4773 00c2 1344     		add	r3, r3, r2
 4774 00c4 FB62     		str	r3, [r7, #44]
 4775              	.L60:
1043:keygen.c      **** 				uint32_t x, y;
 4776              		.loc 2 1043 4 discriminator 1
 4777 00c6 7A6B     		ldr	r2, [r7, #52]
 4778 00c8 FB6C     		ldr	r3, [r7, #76]
 4779 00ca 9A42     		cmp	r2, r3
 4780 00cc D3D3     		bcc	.L61
 4781              	.LBE8:
1035:keygen.c      **** 			uint32_t s;
 4782              		.loc 2 1035 33 discriminator 2
 4783 00ce FB6B     		ldr	r3, [r7, #60]
 4784 00d0 0133     		adds	r3, r3, #1
 4785 00d2 FB63     		str	r3, [r7, #60]
1035:keygen.c      **** 			uint32_t s;
 4786              		.loc 2 1035 40 discriminator 2
 4787 00d4 BA6B     		ldr	r2, [r7, #56]
 4788 00d6 FB69     		ldr	r3, [r7, #28]
 4789 00d8 1344     		add	r3, r3, r2
 4790 00da BB63     		str	r3, [r7, #56]
 4791              	.L59:
1035:keygen.c      **** 			uint32_t s;
 4792              		.loc 2 1035 3 discriminator 1
 4793 00dc FA6B     		ldr	r2, [r7, #60]
 4794 00de 3B6A     		ldr	r3, [r7, #32]
 4795 00e0 9A42     		cmp	r2, r3
 4796 00e2 ADD3     		bcc	.L62
1050:keygen.c      **** 					modp_sub(x, y, p), s, p, p0i);;
1051:keygen.c      **** 			}
1052:keygen.c      **** 		}
1053:keygen.c      **** 		t = dt;
 4797              		.loc 2 1053 5 discriminator 2
 4798 00e4 FB69     		ldr	r3, [r7, #28]
 4799 00e6 FB64     		str	r3, [r7, #76]
 4800              	.LBE7:
1030:keygen.c      **** 		size_t hm, dt, u, v1;
 4801              		.loc 2 1030 23 discriminator 2
 4802 00e8 BB6C     		ldr	r3, [r7, #72]
 4803 00ea 5B08     		lsrs	r3, r3, #1
 4804 00ec BB64     		str	r3, [r7, #72]
 4805              	.L58:
1030:keygen.c      **** 		size_t hm, dt, u, v1;
 4806              		.loc 2 1030 2 discriminator 1
 4807 00ee BB6C     		ldr	r3, [r7, #72]
 4808 00f0 012B     		cmp	r3, #1
 4809 00f2 9AD8     		bhi	.L63
1054:keygen.c      **** 	}
1055:keygen.c      **** 
1056:keygen.c      **** 	/*
1057:keygen.c      **** 	 * We need 1/n in Montgomery representation, i.e. R/n. Since
1058:keygen.c      **** 	 * 1 <= logn <= 10, R/n is an integer; morever, R/n <= 2^30 < p,
1059:keygen.c      **** 	 * thus a simple shift will do.
1060:keygen.c      **** 	 */
1061:keygen.c      **** 	ni = (uint32_t)1 << (31 - logn);
 4810              		.loc 2 1061 5
 4811 00f4 4FF00042 		mov	r2, #-2147483648
 4812 00f8 3B68     		ldr	r3, [r7]
 4813 00fa 22FA03F3 		lsr	r3, r2, r3
 4814 00fe 7B62     		str	r3, [r7, #36]
1062:keygen.c      **** 	for (k = 0, r = a; k < n; k ++, r += stride) {
 4815              		.loc 2 1062 9
 4816 0100 0023     		movs	r3, #0
 4817 0102 7B64     		str	r3, [r7, #68]
 4818              		.loc 2 1062 16
 4819 0104 FB68     		ldr	r3, [r7, #12]
 4820 0106 3B64     		str	r3, [r7, #64]
 4821              		.loc 2 1062 2
 4822 0108 11E0     		b	.L64
 4823              	.L65:
1063:keygen.c      **** 		*r = modp_montymul(*r, ni, p, p0i);
 4824              		.loc 2 1063 8 discriminator 3
 4825 010a 3B6C     		ldr	r3, [r7, #64]
 4826 010c 1868     		ldr	r0, [r3]
 4827 010e FB6D     		ldr	r3, [r7, #92]
 4828 0110 BA6D     		ldr	r2, [r7, #88]
 4829 0112 796A     		ldr	r1, [r7, #36]
 4830 0114 FFF7FEFF 		bl	modp_montymul
 4831 0118 0246     		mov	r2, r0
 4832              		.loc 2 1063 6 discriminator 3
 4833 011a 3B6C     		ldr	r3, [r7, #64]
 4834 011c 1A60     		str	r2, [r3]
1062:keygen.c      **** 	for (k = 0, r = a; k < n; k ++, r += stride) {
 4835              		.loc 2 1062 30 discriminator 3
 4836 011e 7B6C     		ldr	r3, [r7, #68]
 4837 0120 0133     		adds	r3, r3, #1
 4838 0122 7B64     		str	r3, [r7, #68]
1062:keygen.c      **** 	for (k = 0, r = a; k < n; k ++, r += stride) {
 4839              		.loc 2 1062 36 discriminator 3
 4840 0124 BB68     		ldr	r3, [r7, #8]
 4841 0126 9B00     		lsls	r3, r3, #2
 4842 0128 3A6C     		ldr	r2, [r7, #64]
 4843 012a 1344     		add	r3, r3, r2
 4844 012c 3B64     		str	r3, [r7, #64]
 4845              	.L64:
1062:keygen.c      **** 	for (k = 0, r = a; k < n; k ++, r += stride) {
 4846              		.loc 2 1062 2 discriminator 1
 4847 012e 7A6C     		ldr	r2, [r7, #68]
 4848 0130 BB6A     		ldr	r3, [r7, #40]
 4849 0132 9A42     		cmp	r2, r3
 4850 0134 E9D3     		bcc	.L65
 4851 0136 00E0     		b	.L55
 4852              	.L66:
1026:keygen.c      **** 	}
 4853              		.loc 2 1026 3
 4854 0138 00BF     		nop
 4855              	.L55:
1064:keygen.c      **** 	}
1065:keygen.c      **** }
 4856              		.loc 2 1065 1
 4857 013a 5037     		adds	r7, r7, #80
 4858              	.LCFI103:
 4859              		.cfi_def_cfa_offset 8
 4860 013c BD46     		mov	sp, r7
 4861              	.LCFI104:
 4862              		.cfi_def_cfa_register 13
 4863              		@ sp needed
 4864 013e 80BD     		pop	{r7, pc}
 4865              		.cfi_endproc
 4866              	.LFE30:
 4868              		.section	.text.modp_poly_rec_res,"ax",%progbits
 4869              		.align	1
 4870              		.syntax unified
 4871              		.thumb
 4872              		.thumb_func
 4873              		.fpu softvfp
 4875              	modp_poly_rec_res:
 4876              	.LFB31:
1066:keygen.c      **** 
1067:keygen.c      **** /*
1068:keygen.c      ****  * Simplified macros for NTT and iNTT (binary case) when the elements
1069:keygen.c      ****  * are consecutive in RAM.
1070:keygen.c      ****  */
1071:keygen.c      **** #define modp_NTT2(a, gm, logn, p, p0i)   modp_NTT2_ext(a, 1, gm, logn, p, p0i)
1072:keygen.c      **** #define modp_iNTT2(a, igm, logn, p, p0i) modp_iNTT2_ext(a, 1, igm, logn, p, p0i)
1073:keygen.c      **** 
1074:keygen.c      **** /*
1075:keygen.c      ****  * Given polynomial f in NTT representation modulo p, compute f' of degree
1076:keygen.c      ****  * less than N/2 such that f' = f0^2 - X*f1^2, where f0 and f1 are
1077:keygen.c      ****  * polynomials of degree less than N/2 such that f = f0(X^2) + X*f1(X^2).
1078:keygen.c      ****  *
1079:keygen.c      ****  * The new polynomial is written "in place" over the first N/2 elements
1080:keygen.c      ****  * of f.
1081:keygen.c      ****  *
1082:keygen.c      ****  * If applied logn times successively on a given polynomial, the resulting
1083:keygen.c      ****  * degree-0 polynomial is the resultant of f and X^N+1 modulo p.
1084:keygen.c      ****  *
1085:keygen.c      ****  * This function applies only to the binary case; it is invoked from
1086:keygen.c      ****  * solve_NTRU_binary_depth1().
1087:keygen.c      ****  */
1088:keygen.c      **** static void
1089:keygen.c      **** modp_poly_rec_res(uint32_t *f, unsigned logn,
1090:keygen.c      **** 	uint32_t p, uint32_t p0i, uint32_t R2)
1091:keygen.c      **** {
 4877              		.loc 2 1091 1
 4878              		.cfi_startproc
 4879              		@ args = 4, pretend = 0, frame = 32
 4880              		@ frame_needed = 1, uses_anonymous_args = 0
 4881 0000 90B5     		push	{r4, r7, lr}
 4882              	.LCFI105:
 4883              		.cfi_def_cfa_offset 12
 4884              		.cfi_offset 4, -12
 4885              		.cfi_offset 7, -8
 4886              		.cfi_offset 14, -4
 4887 0002 89B0     		sub	sp, sp, #36
 4888              	.LCFI106:
 4889              		.cfi_def_cfa_offset 48
 4890 0004 00AF     		add	r7, sp, #0
 4891              	.LCFI107:
 4892              		.cfi_def_cfa_register 7
 4893 0006 F860     		str	r0, [r7, #12]
 4894 0008 B960     		str	r1, [r7, #8]
 4895 000a 7A60     		str	r2, [r7, #4]
 4896 000c 3B60     		str	r3, [r7]
1092:keygen.c      **** 	size_t hn, u;
1093:keygen.c      **** 
1094:keygen.c      **** 	hn = (size_t)1 << (logn - 1);
 4897              		.loc 2 1094 26
 4898 000e BB68     		ldr	r3, [r7, #8]
 4899 0010 013B     		subs	r3, r3, #1
 4900              		.loc 2 1094 5
 4901 0012 0122     		movs	r2, #1
 4902 0014 02FA03F3 		lsl	r3, r2, r3
 4903 0018 BB61     		str	r3, [r7, #24]
1095:keygen.c      **** 	for (u = 0; u < hn; u ++) {
 4904              		.loc 2 1095 9
 4905 001a 0023     		movs	r3, #0
 4906 001c FB61     		str	r3, [r7, #28]
 4907              		.loc 2 1095 2
 4908 001e 20E0     		b	.L68
 4909              	.L69:
 4910              	.LBB10:
1096:keygen.c      **** 		uint32_t w0, w1;
1097:keygen.c      **** 
1098:keygen.c      **** 		w0 = f[(u << 1) + 0];
 4911              		.loc 2 1098 9 discriminator 3
 4912 0020 FB69     		ldr	r3, [r7, #28]
 4913 0022 DB00     		lsls	r3, r3, #3
 4914 0024 FA68     		ldr	r2, [r7, #12]
 4915 0026 1344     		add	r3, r3, r2
 4916              		.loc 2 1098 6 discriminator 3
 4917 0028 1B68     		ldr	r3, [r3]
 4918 002a 7B61     		str	r3, [r7, #20]
1099:keygen.c      **** 		w1 = f[(u << 1) + 1];
 4919              		.loc 2 1099 9 discriminator 3
 4920 002c FB69     		ldr	r3, [r7, #28]
 4921 002e DB00     		lsls	r3, r3, #3
 4922 0030 0433     		adds	r3, r3, #4
 4923 0032 FA68     		ldr	r2, [r7, #12]
 4924 0034 1344     		add	r3, r3, r2
 4925              		.loc 2 1099 6 discriminator 3
 4926 0036 1B68     		ldr	r3, [r3]
 4927 0038 3B61     		str	r3, [r7, #16]
1100:keygen.c      **** 		f[u] = modp_montymul(modp_montymul(w0, w1, p, p0i), R2, p, p0i);
 4928              		.loc 2 1100 10 discriminator 3
 4929 003a 3B68     		ldr	r3, [r7]
 4930 003c 7A68     		ldr	r2, [r7, #4]
 4931 003e 3969     		ldr	r1, [r7, #16]
 4932 0040 7869     		ldr	r0, [r7, #20]
 4933 0042 FFF7FEFF 		bl	modp_montymul
 4934              		.loc 2 1100 4 discriminator 3
 4935 0046 FB69     		ldr	r3, [r7, #28]
 4936 0048 9B00     		lsls	r3, r3, #2
 4937 004a FA68     		ldr	r2, [r7, #12]
 4938 004c D418     		adds	r4, r2, r3
 4939              		.loc 2 1100 10 discriminator 3
 4940 004e 3B68     		ldr	r3, [r7]
 4941 0050 7A68     		ldr	r2, [r7, #4]
 4942 0052 396B     		ldr	r1, [r7, #48]
 4943 0054 FFF7FEFF 		bl	modp_montymul
 4944 0058 0346     		mov	r3, r0
 4945              		.loc 2 1100 8 discriminator 3
 4946 005a 2360     		str	r3, [r4]
 4947              	.LBE10:
1095:keygen.c      **** 		uint32_t w0, w1;
 4948              		.loc 2 1095 24 discriminator 3
 4949 005c FB69     		ldr	r3, [r7, #28]
 4950 005e 0133     		adds	r3, r3, #1
 4951 0060 FB61     		str	r3, [r7, #28]
 4952              	.L68:
1095:keygen.c      **** 		uint32_t w0, w1;
 4953              		.loc 2 1095 2 discriminator 1
 4954 0062 FA69     		ldr	r2, [r7, #28]
 4955 0064 BB69     		ldr	r3, [r7, #24]
 4956 0066 9A42     		cmp	r2, r3
 4957 0068 DAD3     		bcc	.L69
1101:keygen.c      **** 	}
1102:keygen.c      **** }
 4958              		.loc 2 1102 1
 4959 006a 00BF     		nop
 4960 006c 00BF     		nop
 4961 006e 2437     		adds	r7, r7, #36
 4962              	.LCFI108:
 4963              		.cfi_def_cfa_offset 12
 4964 0070 BD46     		mov	sp, r7
 4965              	.LCFI109:
 4966              		.cfi_def_cfa_register 13
 4967              		@ sp needed
 4968 0072 90BD     		pop	{r4, r7, pc}
 4969              		.cfi_endproc
 4970              	.LFE31:
 4972              		.section	.text.zint_sub,"ax",%progbits
 4973              		.align	1
 4974              		.syntax unified
 4975              		.thumb
 4976              		.thumb_func
 4977              		.fpu softvfp
 4979              	zint_sub:
 4980              	.LFB32:
1103:keygen.c      **** 
1104:keygen.c      **** /* ==================================================================== */
1105:keygen.c      **** /*
1106:keygen.c      ****  * Custom bignum implementation.
1107:keygen.c      ****  *
1108:keygen.c      ****  * This is a very reduced set of functionalities. We need to do the
1109:keygen.c      ****  * following operations:
1110:keygen.c      ****  *
1111:keygen.c      ****  *  - Rebuild the resultant and the polynomial coefficients from their
1112:keygen.c      ****  *    values modulo small primes (of length 31 bits each).
1113:keygen.c      ****  *
1114:keygen.c      ****  *  - Compute an extended GCD between the two computed resultants.
1115:keygen.c      ****  *
1116:keygen.c      ****  *  - Extract top bits and add scaled values during the successive steps
1117:keygen.c      ****  *    of Babai rounding.
1118:keygen.c      ****  *
1119:keygen.c      ****  * When rebuilding values using CRT, we must also recompute the product
1120:keygen.c      ****  * of the small prime factors. We always do it one small factor at a
1121:keygen.c      ****  * time, so the "complicated" operations can be done modulo the small
1122:keygen.c      ****  * prime with the modp_* functions. CRT coefficients (inverses) are
1123:keygen.c      ****  * precomputed.
1124:keygen.c      ****  *
1125:keygen.c      ****  * All values are positive until the last step: when the polynomial
1126:keygen.c      ****  * coefficients have been rebuilt, we normalize them around 0. But then,
1127:keygen.c      ****  * only additions and subtractions on the upper few bits are needed
1128:keygen.c      ****  * afterwards.
1129:keygen.c      ****  *
1130:keygen.c      ****  * We keep big integers as arrays of 31-bit words (in uint32_t values);
1131:keygen.c      ****  * the top bit of each uint32_t is kept equal to 0. Using 31-bit words
1132:keygen.c      ****  * makes it easier to keep track of carries. When negative values are
1133:keygen.c      ****  * used, two's complement is used.
1134:keygen.c      ****  */
1135:keygen.c      **** 
1136:keygen.c      **** /*
1137:keygen.c      ****  * Subtract integer b from integer a. Both integers are supposed to have
1138:keygen.c      ****  * the same size. The carry (0 or 1) is returned. Source arrays a and b
1139:keygen.c      ****  * MUST be distinct.
1140:keygen.c      ****  *
1141:keygen.c      ****  * The operation is performed as described above if ctr = 1. If
1142:keygen.c      ****  * ctl = 0, the value a[] is unmodified, but all memory accesses are
1143:keygen.c      ****  * still performed, and the carry is computed and returned.
1144:keygen.c      ****  */
1145:keygen.c      **** static uint32_t
1146:keygen.c      **** zint_sub(uint32_t *restrict a, const uint32_t *restrict b, size_t len,
1147:keygen.c      **** 	uint32_t ctl)
1148:keygen.c      **** {
 4981              		.loc 2 1148 1
 4982              		.cfi_startproc
 4983              		@ args = 0, pretend = 0, frame = 40
 4984              		@ frame_needed = 1, uses_anonymous_args = 0
 4985              		@ link register save eliminated.
 4986 0000 80B4     		push	{r7}
 4987              	.LCFI110:
 4988              		.cfi_def_cfa_offset 4
 4989              		.cfi_offset 7, -4
 4990 0002 8BB0     		sub	sp, sp, #44
 4991              	.LCFI111:
 4992              		.cfi_def_cfa_offset 48
 4993 0004 00AF     		add	r7, sp, #0
 4994              	.LCFI112:
 4995              		.cfi_def_cfa_register 7
 4996 0006 F860     		str	r0, [r7, #12]
 4997 0008 B960     		str	r1, [r7, #8]
 4998 000a 7A60     		str	r2, [r7, #4]
 4999 000c 3B60     		str	r3, [r7]
1149:keygen.c      **** 	size_t u;
1150:keygen.c      **** 	uint32_t cc, m;
1151:keygen.c      **** 
1152:keygen.c      **** 	cc = 0;
 5000              		.loc 2 1152 5
 5001 000e 0023     		movs	r3, #0
 5002 0010 3B62     		str	r3, [r7, #32]
1153:keygen.c      **** 	m = -ctl;
 5003              		.loc 2 1153 4
 5004 0012 3B68     		ldr	r3, [r7]
 5005 0014 5B42     		rsbs	r3, r3, #0
 5006 0016 FB61     		str	r3, [r7, #28]
1154:keygen.c      **** 	for (u = 0; u < len; u ++) {
 5007              		.loc 2 1154 9
 5008 0018 0023     		movs	r3, #0
 5009 001a 7B62     		str	r3, [r7, #36]
 5010              		.loc 2 1154 2
 5011 001c 25E0     		b	.L71
 5012              	.L72:
 5013              	.LBB11:
1155:keygen.c      **** 		uint32_t aw, w;
1156:keygen.c      **** 
1157:keygen.c      **** 		aw = a[u];
 5014              		.loc 2 1157 9 discriminator 3
 5015 001e 7B6A     		ldr	r3, [r7, #36]
 5016 0020 9B00     		lsls	r3, r3, #2
 5017 0022 FA68     		ldr	r2, [r7, #12]
 5018 0024 1344     		add	r3, r3, r2
 5019              		.loc 2 1157 6 discriminator 3
 5020 0026 1B68     		ldr	r3, [r3]
 5021 0028 BB61     		str	r3, [r7, #24]
1158:keygen.c      **** 		w = aw - b[u] - cc;
 5022              		.loc 2 1158 13 discriminator 3
 5023 002a 7B6A     		ldr	r3, [r7, #36]
 5024 002c 9B00     		lsls	r3, r3, #2
 5025 002e BA68     		ldr	r2, [r7, #8]
 5026 0030 1344     		add	r3, r3, r2
 5027 0032 1B68     		ldr	r3, [r3]
 5028              		.loc 2 1158 10 discriminator 3
 5029 0034 BA69     		ldr	r2, [r7, #24]
 5030 0036 D21A     		subs	r2, r2, r3
 5031              		.loc 2 1158 5 discriminator 3
 5032 0038 3B6A     		ldr	r3, [r7, #32]
 5033 003a D31A     		subs	r3, r2, r3
 5034 003c 7B61     		str	r3, [r7, #20]
1159:keygen.c      **** 		cc = w >> 31;
 5035              		.loc 2 1159 6 discriminator 3
 5036 003e 7B69     		ldr	r3, [r7, #20]
 5037 0040 DB0F     		lsrs	r3, r3, #31
 5038 0042 3B62     		str	r3, [r7, #32]
1160:keygen.c      **** 		aw ^= ((w & 0x7FFFFFFF) ^ aw) & m;
 5039              		.loc 2 1160 13 discriminator 3
 5040 0044 7B69     		ldr	r3, [r7, #20]
 5041 0046 23F00042 		bic	r2, r3, #-2147483648
 5042              		.loc 2 1160 27 discriminator 3
 5043 004a BB69     		ldr	r3, [r7, #24]
 5044 004c 5A40     		eors	r2, r2, r3
 5045              		.loc 2 1160 33 discriminator 3
 5046 004e FB69     		ldr	r3, [r7, #28]
 5047 0050 1340     		ands	r3, r3, r2
 5048              		.loc 2 1160 6 discriminator 3
 5049 0052 BA69     		ldr	r2, [r7, #24]
 5050 0054 5340     		eors	r3, r3, r2
 5051 0056 BB61     		str	r3, [r7, #24]
1161:keygen.c      **** 		a[u] = aw;
 5052              		.loc 2 1161 4 discriminator 3
 5053 0058 7B6A     		ldr	r3, [r7, #36]
 5054 005a 9B00     		lsls	r3, r3, #2
 5055 005c FA68     		ldr	r2, [r7, #12]
 5056 005e 1344     		add	r3, r3, r2
 5057              		.loc 2 1161 8 discriminator 3
 5058 0060 BA69     		ldr	r2, [r7, #24]
 5059 0062 1A60     		str	r2, [r3]
 5060              	.LBE11:
1154:keygen.c      **** 		uint32_t aw, w;
 5061              		.loc 2 1154 25 discriminator 3
 5062 0064 7B6A     		ldr	r3, [r7, #36]
 5063 0066 0133     		adds	r3, r3, #1
 5064 0068 7B62     		str	r3, [r7, #36]
 5065              	.L71:
1154:keygen.c      **** 		uint32_t aw, w;
 5066              		.loc 2 1154 2 discriminator 1
 5067 006a 7A6A     		ldr	r2, [r7, #36]
 5068 006c 7B68     		ldr	r3, [r7, #4]
 5069 006e 9A42     		cmp	r2, r3
 5070 0070 D5D3     		bcc	.L72
1162:keygen.c      **** 	}
1163:keygen.c      **** 	return cc;
 5071              		.loc 2 1163 9
 5072 0072 3B6A     		ldr	r3, [r7, #32]
1164:keygen.c      **** }
 5073              		.loc 2 1164 1
 5074 0074 1846     		mov	r0, r3
 5075 0076 2C37     		adds	r7, r7, #44
 5076              	.LCFI113:
 5077              		.cfi_def_cfa_offset 4
 5078 0078 BD46     		mov	sp, r7
 5079              	.LCFI114:
 5080              		.cfi_def_cfa_register 13
 5081              		@ sp needed
 5082 007a 80BC     		pop	{r7}
 5083              	.LCFI115:
 5084              		.cfi_restore 7
 5085              		.cfi_def_cfa_offset 0
 5086 007c 7047     		bx	lr
 5087              		.cfi_endproc
 5088              	.LFE32:
 5090              		.section	.text.zint_mul_small,"ax",%progbits
 5091              		.align	1
 5092              		.syntax unified
 5093              		.thumb
 5094              		.thumb_func
 5095              		.fpu softvfp
 5097              	zint_mul_small:
 5098              	.LFB33:
1165:keygen.c      **** 
1166:keygen.c      **** /*
1167:keygen.c      ****  * Mutiply the provided big integer m with a small value x.
1168:keygen.c      ****  * This function assumes that x < 2^31. The carry word is returned.
1169:keygen.c      ****  */
1170:keygen.c      **** static uint32_t
1171:keygen.c      **** zint_mul_small(uint32_t *m, size_t mlen, uint32_t x)
1172:keygen.c      **** {
 5099              		.loc 2 1172 1
 5100              		.cfi_startproc
 5101              		@ args = 0, pretend = 0, frame = 48
 5102              		@ frame_needed = 1, uses_anonymous_args = 0
 5103              		@ link register save eliminated.
 5104 0000 2DE9B00F 		push	{r4, r5, r7, r8, r9, r10, fp}
 5105              	.LCFI116:
 5106              		.cfi_def_cfa_offset 28
 5107              		.cfi_offset 4, -28
 5108              		.cfi_offset 5, -24
 5109              		.cfi_offset 7, -20
 5110              		.cfi_offset 8, -16
 5111              		.cfi_offset 9, -12
 5112              		.cfi_offset 10, -8
 5113              		.cfi_offset 11, -4
 5114 0004 8DB0     		sub	sp, sp, #52
 5115              	.LCFI117:
 5116              		.cfi_def_cfa_offset 80
 5117 0006 00AF     		add	r7, sp, #0
 5118              	.LCFI118:
 5119              		.cfi_def_cfa_register 7
 5120 0008 F861     		str	r0, [r7, #28]
 5121 000a B961     		str	r1, [r7, #24]
 5122 000c 7A61     		str	r2, [r7, #20]
1173:keygen.c      **** 	size_t u;
1174:keygen.c      **** 	uint32_t cc;
1175:keygen.c      **** 
1176:keygen.c      **** 	cc = 0;
 5123              		.loc 2 1176 5
 5124 000e 0023     		movs	r3, #0
 5125 0010 BB62     		str	r3, [r7, #40]
1177:keygen.c      **** 	for (u = 0; u < mlen; u ++) {
 5126              		.loc 2 1177 9
 5127 0012 0023     		movs	r3, #0
 5128 0014 FB62     		str	r3, [r7, #44]
 5129              		.loc 2 1177 2
 5130 0016 3CE0     		b	.L75
 5131              	.L76:
 5132              	.LBB12:
1178:keygen.c      **** 		uint64_t z;
1179:keygen.c      **** 
1180:keygen.c      **** 		z = (uint64_t)m[u] * (uint64_t)x + cc;
 5133              		.loc 2 1180 18 discriminator 3
 5134 0018 FB6A     		ldr	r3, [r7, #44]
 5135 001a 9B00     		lsls	r3, r3, #2
 5136 001c FA69     		ldr	r2, [r7, #28]
 5137 001e 1344     		add	r3, r3, r2
 5138 0020 1B68     		ldr	r3, [r3]
 5139              		.loc 2 1180 7 discriminator 3
 5140 0022 0022     		movs	r2, #0
 5141 0024 9846     		mov	r8, r3
 5142 0026 9146     		mov	r9, r2
 5143              		.loc 2 1180 24 discriminator 3
 5144 0028 7B69     		ldr	r3, [r7, #20]
 5145 002a 0022     		movs	r2, #0
 5146 002c 9A46     		mov	r10, r3
 5147 002e 9346     		mov	fp, r2
 5148              		.loc 2 1180 22 discriminator 3
 5149 0030 0AFB09F2 		mul	r2, r10, r9
 5150 0034 08FB0BF3 		mul	r3, r8, fp
 5151 0038 1344     		add	r3, r3, r2
 5152 003a A8FB0A45 		umull	r4, r5, r8, r10
 5153 003e 2B44     		add	r3, r3, r5
 5154 0040 1D46     		mov	r5, r3
 5155              		.loc 2 1180 36 discriminator 3
 5156 0042 BB6A     		ldr	r3, [r7, #40]
 5157 0044 0022     		movs	r2, #0
 5158 0046 BB60     		str	r3, [r7, #8]
 5159 0048 FA60     		str	r2, [r7, #12]
 5160              		.loc 2 1180 5 discriminator 3
 5161 004a D7E90212 		ldrd	r1, [r7, #8]
 5162 004e 0B46     		mov	r3, r1
 5163 0050 E318     		adds	r3, r4, r3
 5164 0052 3B60     		str	r3, [r7]
 5165 0054 1346     		mov	r3, r2
 5166 0056 45EB0303 		adc	r3, r5, r3
 5167 005a 7B60     		str	r3, [r7, #4]
 5168 005c D7E90023 		ldrd	r2, [r7]
 5169 0060 C7E90823 		strd	r2, [r7, #32]
1181:keygen.c      **** 		m[u] = (uint32_t)z & 0x7FFFFFFF;
 5170              		.loc 2 1181 10 discriminator 3
 5171 0064 3A6A     		ldr	r2, [r7, #32]
 5172              		.loc 2 1181 4 discriminator 3
 5173 0066 FB6A     		ldr	r3, [r7, #44]
 5174 0068 9B00     		lsls	r3, r3, #2
 5175 006a F969     		ldr	r1, [r7, #28]
 5176 006c 0B44     		add	r3, r3, r1
 5177              		.loc 2 1181 22 discriminator 3
 5178 006e 22F00042 		bic	r2, r2, #-2147483648
 5179              		.loc 2 1181 8 discriminator 3
 5180 0072 1A60     		str	r2, [r3]
1182:keygen.c      **** 		cc = (uint32_t)(z >> 31);
 5181              		.loc 2 1182 21 discriminator 3
 5182 0074 D7E90801 		ldrd	r0, [r7, #32]
 5183 0078 4FF00002 		mov	r2, #0
 5184 007c 4FF00003 		mov	r3, #0
 5185 0080 C20F     		lsrs	r2, r0, #31
 5186 0082 42EA4102 		orr	r2, r2, r1, lsl #1
 5187 0086 CB0F     		lsrs	r3, r1, #31
 5188              		.loc 2 1182 6 discriminator 3
 5189 0088 1346     		mov	r3, r2
 5190 008a BB62     		str	r3, [r7, #40]
 5191              	.LBE12:
1177:keygen.c      **** 		uint64_t z;
 5192              		.loc 2 1177 26 discriminator 3
 5193 008c FB6A     		ldr	r3, [r7, #44]
 5194 008e 0133     		adds	r3, r3, #1
 5195 0090 FB62     		str	r3, [r7, #44]
 5196              	.L75:
1177:keygen.c      **** 		uint64_t z;
 5197              		.loc 2 1177 2 discriminator 1
 5198 0092 FA6A     		ldr	r2, [r7, #44]
 5199 0094 BB69     		ldr	r3, [r7, #24]
 5200 0096 9A42     		cmp	r2, r3
 5201 0098 BED3     		bcc	.L76
1183:keygen.c      **** 	}
1184:keygen.c      **** 	return cc;
 5202              		.loc 2 1184 9
 5203 009a BB6A     		ldr	r3, [r7, #40]
1185:keygen.c      **** }
 5204              		.loc 2 1185 1
 5205 009c 1846     		mov	r0, r3
 5206 009e 3437     		adds	r7, r7, #52
 5207              	.LCFI119:
 5208              		.cfi_def_cfa_offset 28
 5209 00a0 BD46     		mov	sp, r7
 5210              	.LCFI120:
 5211              		.cfi_def_cfa_register 13
 5212              		@ sp needed
 5213 00a2 BDE8B00F 		pop	{r4, r5, r7, r8, r9, r10, fp}
 5214              	.LCFI121:
 5215              		.cfi_restore 11
 5216              		.cfi_restore 10
 5217              		.cfi_restore 9
 5218              		.cfi_restore 8
 5219              		.cfi_restore 7
 5220              		.cfi_restore 5
 5221              		.cfi_restore 4
 5222              		.cfi_def_cfa_offset 0
 5223 00a6 7047     		bx	lr
 5224              		.cfi_endproc
 5225              	.LFE33:
 5227              		.section	.text.zint_mod_small_unsigned,"ax",%progbits
 5228              		.align	1
 5229              		.syntax unified
 5230              		.thumb
 5231              		.thumb_func
 5232              		.fpu softvfp
 5234              	zint_mod_small_unsigned:
 5235              	.LFB34:
1186:keygen.c      **** 
1187:keygen.c      **** /*
1188:keygen.c      ****  * Reduce a big integer d modulo a small integer p.
1189:keygen.c      ****  * Rules:
1190:keygen.c      ****  *  d is unsigned
1191:keygen.c      ****  *  p is prime
1192:keygen.c      ****  *  2^30 < p < 2^31
1193:keygen.c      ****  *  p0i = -(1/p) mod 2^31
1194:keygen.c      ****  *  R2 = 2^62 mod p
1195:keygen.c      ****  */
1196:keygen.c      **** static uint32_t
1197:keygen.c      **** zint_mod_small_unsigned(const uint32_t *d, size_t dlen,
1198:keygen.c      **** 	uint32_t p, uint32_t p0i, uint32_t R2)
1199:keygen.c      **** {
 5236              		.loc 2 1199 1
 5237              		.cfi_startproc
 5238              		@ args = 4, pretend = 0, frame = 32
 5239              		@ frame_needed = 1, uses_anonymous_args = 0
 5240 0000 80B5     		push	{r7, lr}
 5241              	.LCFI122:
 5242              		.cfi_def_cfa_offset 8
 5243              		.cfi_offset 7, -8
 5244              		.cfi_offset 14, -4
 5245 0002 88B0     		sub	sp, sp, #32
 5246              	.LCFI123:
 5247              		.cfi_def_cfa_offset 40
 5248 0004 00AF     		add	r7, sp, #0
 5249              	.LCFI124:
 5250              		.cfi_def_cfa_register 7
 5251 0006 F860     		str	r0, [r7, #12]
 5252 0008 B960     		str	r1, [r7, #8]
 5253 000a 7A60     		str	r2, [r7, #4]
 5254 000c 3B60     		str	r3, [r7]
1200:keygen.c      **** 	uint32_t x;
1201:keygen.c      **** 	size_t u;
1202:keygen.c      **** 
1203:keygen.c      **** 	/*
1204:keygen.c      **** 	 * Algorithm: we inject words one by one, starting with the high
1205:keygen.c      **** 	 * word. Each step is:
1206:keygen.c      **** 	 *  - multiply x by 2^31
1207:keygen.c      **** 	 *  - add new word
1208:keygen.c      **** 	 */
1209:keygen.c      **** 	x = 0;
 5255              		.loc 2 1209 4
 5256 000e 0023     		movs	r3, #0
 5257 0010 FB61     		str	r3, [r7, #28]
1210:keygen.c      **** 	u = dlen;
 5258              		.loc 2 1210 4
 5259 0012 BB68     		ldr	r3, [r7, #8]
 5260 0014 BB61     		str	r3, [r7, #24]
1211:keygen.c      **** 	while (u -- > 0) {
 5261              		.loc 2 1211 8
 5262 0016 1CE0     		b	.L79
 5263              	.L80:
 5264              	.LBB13:
1212:keygen.c      **** 		uint32_t w;
1213:keygen.c      **** 
1214:keygen.c      **** 		x = modp_montymul(x, R2, p, p0i);
 5265              		.loc 2 1214 7
 5266 0018 3B68     		ldr	r3, [r7]
 5267 001a 7A68     		ldr	r2, [r7, #4]
 5268 001c B96A     		ldr	r1, [r7, #40]
 5269 001e F869     		ldr	r0, [r7, #28]
 5270 0020 FFF7FEFF 		bl	modp_montymul
 5271 0024 F861     		str	r0, [r7, #28]
1215:keygen.c      **** 		w = d[u] - p;
 5272              		.loc 2 1215 8
 5273 0026 BB69     		ldr	r3, [r7, #24]
 5274 0028 9B00     		lsls	r3, r3, #2
 5275 002a FA68     		ldr	r2, [r7, #12]
 5276 002c 1344     		add	r3, r3, r2
 5277 002e 1A68     		ldr	r2, [r3]
 5278              		.loc 2 1215 5
 5279 0030 7B68     		ldr	r3, [r7, #4]
 5280 0032 D31A     		subs	r3, r2, r3
 5281 0034 7B61     		str	r3, [r7, #20]
1216:keygen.c      **** 		w += p & -(w >> 31);
 5282              		.loc 2 1216 12
 5283 0036 7B69     		ldr	r3, [r7, #20]
 5284 0038 DB17     		asrs	r3, r3, #31
 5285 003a 1A46     		mov	r2, r3
 5286              		.loc 2 1216 10
 5287 003c 7B68     		ldr	r3, [r7, #4]
 5288 003e 1340     		ands	r3, r3, r2
 5289              		.loc 2 1216 5
 5290 0040 7A69     		ldr	r2, [r7, #20]
 5291 0042 1344     		add	r3, r3, r2
 5292 0044 7B61     		str	r3, [r7, #20]
1217:keygen.c      **** 		x = modp_add(x, w, p);
 5293              		.loc 2 1217 7
 5294 0046 7A68     		ldr	r2, [r7, #4]
 5295 0048 7969     		ldr	r1, [r7, #20]
 5296 004a F869     		ldr	r0, [r7, #28]
 5297 004c FFF7FEFF 		bl	modp_add
 5298 0050 F861     		str	r0, [r7, #28]
 5299              	.L79:
 5300              	.LBE13:
1211:keygen.c      **** 		uint32_t w;
 5301              		.loc 2 1211 11
 5302 0052 BB69     		ldr	r3, [r7, #24]
 5303 0054 5A1E     		subs	r2, r3, #1
 5304 0056 BA61     		str	r2, [r7, #24]
1211:keygen.c      **** 		uint32_t w;
 5305              		.loc 2 1211 8
 5306 0058 002B     		cmp	r3, #0
 5307 005a DDD1     		bne	.L80
1218:keygen.c      **** 	}
1219:keygen.c      **** 	return x;
 5308              		.loc 2 1219 9
 5309 005c FB69     		ldr	r3, [r7, #28]
1220:keygen.c      **** }
 5310              		.loc 2 1220 1
 5311 005e 1846     		mov	r0, r3
 5312 0060 2037     		adds	r7, r7, #32
 5313              	.LCFI125:
 5314              		.cfi_def_cfa_offset 8
 5315 0062 BD46     		mov	sp, r7
 5316              	.LCFI126:
 5317              		.cfi_def_cfa_register 13
 5318              		@ sp needed
 5319 0064 80BD     		pop	{r7, pc}
 5320              		.cfi_endproc
 5321              	.LFE34:
 5323              		.section	.text.zint_mod_small_signed,"ax",%progbits
 5324              		.align	1
 5325              		.syntax unified
 5326              		.thumb
 5327              		.thumb_func
 5328              		.fpu softvfp
 5330              	zint_mod_small_signed:
 5331              	.LFB35:
1221:keygen.c      **** 
1222:keygen.c      **** /*
1223:keygen.c      ****  * Similar to zint_mod_small_unsigned(), except that d may be signed.
1224:keygen.c      ****  * Extra parameter is Rx = 2^(31*dlen) mod p.
1225:keygen.c      ****  */
1226:keygen.c      **** static uint32_t
1227:keygen.c      **** zint_mod_small_signed(const uint32_t *d, size_t dlen,
1228:keygen.c      **** 	uint32_t p, uint32_t p0i, uint32_t R2, uint32_t Rx)
1229:keygen.c      **** {
 5332              		.loc 2 1229 1
 5333              		.cfi_startproc
 5334              		@ args = 8, pretend = 0, frame = 24
 5335              		@ frame_needed = 1, uses_anonymous_args = 0
 5336 0000 80B5     		push	{r7, lr}
 5337              	.LCFI127:
 5338              		.cfi_def_cfa_offset 8
 5339              		.cfi_offset 7, -8
 5340              		.cfi_offset 14, -4
 5341 0002 88B0     		sub	sp, sp, #32
 5342              	.LCFI128:
 5343              		.cfi_def_cfa_offset 40
 5344 0004 02AF     		add	r7, sp, #8
 5345              	.LCFI129:
 5346              		.cfi_def_cfa 7, 32
 5347 0006 F860     		str	r0, [r7, #12]
 5348 0008 B960     		str	r1, [r7, #8]
 5349 000a 7A60     		str	r2, [r7, #4]
 5350 000c 3B60     		str	r3, [r7]
1230:keygen.c      **** 	uint32_t z;
1231:keygen.c      **** 
1232:keygen.c      **** 	if (dlen == 0) {
 5351              		.loc 2 1232 5
 5352 000e BB68     		ldr	r3, [r7, #8]
 5353 0010 002B     		cmp	r3, #0
 5354 0012 01D1     		bne	.L83
1233:keygen.c      **** 		return 0;
 5355              		.loc 2 1233 10
 5356 0014 0023     		movs	r3, #0
 5357 0016 1BE0     		b	.L84
 5358              	.L83:
1234:keygen.c      **** 	}
1235:keygen.c      **** 	z = zint_mod_small_unsigned(d, dlen, p, p0i, R2);
 5359              		.loc 2 1235 6
 5360 0018 3B6A     		ldr	r3, [r7, #32]
 5361 001a 0093     		str	r3, [sp]
 5362 001c 3B68     		ldr	r3, [r7]
 5363 001e 7A68     		ldr	r2, [r7, #4]
 5364 0020 B968     		ldr	r1, [r7, #8]
 5365 0022 F868     		ldr	r0, [r7, #12]
 5366 0024 FFF7FEFF 		bl	zint_mod_small_unsigned
 5367 0028 7861     		str	r0, [r7, #20]
1236:keygen.c      **** 	z = modp_sub(z, Rx & -(d[dlen - 1] >> 30), p);
 5368              		.loc 2 1236 26
 5369 002a BB68     		ldr	r3, [r7, #8]
 5370 002c 03F18043 		add	r3, r3, #1073741824
 5371 0030 013B     		subs	r3, r3, #1
 5372 0032 9B00     		lsls	r3, r3, #2
 5373 0034 FA68     		ldr	r2, [r7, #12]
 5374 0036 1344     		add	r3, r3, r2
 5375 0038 1B68     		ldr	r3, [r3]
 5376              		.loc 2 1236 37
 5377 003a 9B0F     		lsrs	r3, r3, #30
 5378              		.loc 2 1236 23
 5379 003c 5A42     		rsbs	r2, r3, #0
 5380              		.loc 2 1236 6
 5381 003e 7B6A     		ldr	r3, [r7, #36]
 5382 0040 1340     		ands	r3, r3, r2
 5383 0042 7A68     		ldr	r2, [r7, #4]
 5384 0044 1946     		mov	r1, r3
 5385 0046 7869     		ldr	r0, [r7, #20]
 5386 0048 FFF7FEFF 		bl	modp_sub
 5387 004c 7861     		str	r0, [r7, #20]
1237:keygen.c      **** 	return z;
 5388              		.loc 2 1237 9
 5389 004e 7B69     		ldr	r3, [r7, #20]
 5390              	.L84:
1238:keygen.c      **** }
 5391              		.loc 2 1238 1
 5392 0050 1846     		mov	r0, r3
 5393 0052 1837     		adds	r7, r7, #24
 5394              	.LCFI130:
 5395              		.cfi_def_cfa_offset 8
 5396 0054 BD46     		mov	sp, r7
 5397              	.LCFI131:
 5398              		.cfi_def_cfa_register 13
 5399              		@ sp needed
 5400 0056 80BD     		pop	{r7, pc}
 5401              		.cfi_endproc
 5402              	.LFE35:
 5404              		.section	.text.zint_add_mul_small,"ax",%progbits
 5405              		.align	1
 5406              		.syntax unified
 5407              		.thumb
 5408              		.thumb_func
 5409              		.fpu softvfp
 5411              	zint_add_mul_small:
 5412              	.LFB36:
1239:keygen.c      **** 
1240:keygen.c      **** /*
1241:keygen.c      ****  * Add y*s to x. x and y initially have length 'len' words; the new x
1242:keygen.c      ****  * has length 'len+1' words. 's' must fit on 31 bits. x[] and y[] must
1243:keygen.c      ****  * not overlap.
1244:keygen.c      ****  */
1245:keygen.c      **** static void
1246:keygen.c      **** zint_add_mul_small(uint32_t *restrict x,
1247:keygen.c      **** 	const uint32_t *restrict y, size_t len, uint32_t s)
1248:keygen.c      **** {
 5413              		.loc 2 1248 1
 5414              		.cfi_startproc
 5415              		@ args = 0, pretend = 0, frame = 72
 5416              		@ frame_needed = 1, uses_anonymous_args = 0
 5417              		@ link register save eliminated.
 5418 0000 2DE9B00F 		push	{r4, r5, r7, r8, r9, r10, fp}
 5419              	.LCFI132:
 5420              		.cfi_def_cfa_offset 28
 5421              		.cfi_offset 4, -28
 5422              		.cfi_offset 5, -24
 5423              		.cfi_offset 7, -20
 5424              		.cfi_offset 8, -16
 5425              		.cfi_offset 9, -12
 5426              		.cfi_offset 10, -8
 5427              		.cfi_offset 11, -4
 5428 0004 93B0     		sub	sp, sp, #76
 5429              	.LCFI133:
 5430              		.cfi_def_cfa_offset 104
 5431 0006 00AF     		add	r7, sp, #0
 5432              	.LCFI134:
 5433              		.cfi_def_cfa_register 7
 5434 0008 F862     		str	r0, [r7, #44]
 5435 000a B962     		str	r1, [r7, #40]
 5436 000c 7A62     		str	r2, [r7, #36]
 5437 000e 3B62     		str	r3, [r7, #32]
1249:keygen.c      **** 	size_t u;
1250:keygen.c      **** 	uint32_t cc;
1251:keygen.c      **** 
1252:keygen.c      **** 	cc = 0;
 5438              		.loc 2 1252 5
 5439 0010 0023     		movs	r3, #0
 5440 0012 3B64     		str	r3, [r7, #64]
1253:keygen.c      **** 	for (u = 0; u < len; u ++) {
 5441              		.loc 2 1253 9
 5442 0014 0023     		movs	r3, #0
 5443 0016 7B64     		str	r3, [r7, #68]
 5444              		.loc 2 1253 2
 5445 0018 54E0     		b	.L86
 5446              	.L87:
 5447              	.LBB14:
1254:keygen.c      **** 		uint32_t xw, yw;
1255:keygen.c      **** 		uint64_t z;
1256:keygen.c      **** 
1257:keygen.c      **** 		xw = x[u];
 5448              		.loc 2 1257 9 discriminator 3
 5449 001a 7B6C     		ldr	r3, [r7, #68]
 5450 001c 9A00     		lsls	r2, r3, #2
 5451 001e FB6A     		ldr	r3, [r7, #44]
 5452 0020 1344     		add	r3, r3, r2
 5453              		.loc 2 1257 6 discriminator 3
 5454 0022 1B68     		ldr	r3, [r3]
 5455 0024 FB63     		str	r3, [r7, #60]
1258:keygen.c      **** 		yw = y[u];
 5456              		.loc 2 1258 9 discriminator 3
 5457 0026 7B6C     		ldr	r3, [r7, #68]
 5458 0028 9A00     		lsls	r2, r3, #2
 5459 002a BB6A     		ldr	r3, [r7, #40]
 5460 002c 1344     		add	r3, r3, r2
 5461              		.loc 2 1258 6 discriminator 3
 5462 002e 1B68     		ldr	r3, [r3]
 5463 0030 BB63     		str	r3, [r7, #56]
1259:keygen.c      **** 		z = (uint64_t)yw * (uint64_t)s + (uint64_t)xw + (uint64_t)cc;
 5464              		.loc 2 1259 7 discriminator 3
 5465 0032 BB6B     		ldr	r3, [r7, #56]
 5466 0034 0022     		movs	r2, #0
 5467 0036 9A46     		mov	r10, r3
 5468 0038 9346     		mov	fp, r2
 5469              		.loc 2 1259 22 discriminator 3
 5470 003a 3B6A     		ldr	r3, [r7, #32]
 5471 003c 0022     		movs	r2, #0
 5472 003e BB61     		str	r3, [r7, #24]
 5473 0040 FA61     		str	r2, [r7, #28]
 5474              		.loc 2 1259 20 discriminator 3
 5475 0042 D7E90601 		ldrd	r0, [r7, #24]
 5476 0046 0346     		mov	r3, r0
 5477 0048 03FB0BF2 		mul	r2, r3, fp
 5478 004c 0B46     		mov	r3, r1
 5479 004e 0AFB03F3 		mul	r3, r10, r3
 5480 0052 1344     		add	r3, r3, r2
 5481 0054 0246     		mov	r2, r0
 5482 0056 AAFB0245 		umull	r4, r5, r10, r2
 5483 005a 2B44     		add	r3, r3, r5
 5484 005c 1D46     		mov	r5, r3
 5485              		.loc 2 1259 36 discriminator 3
 5486 005e FB6B     		ldr	r3, [r7, #60]
 5487 0060 0022     		movs	r2, #0
 5488 0062 3B61     		str	r3, [r7, #16]
 5489 0064 7A61     		str	r2, [r7, #20]
 5490              		.loc 2 1259 34 discriminator 3
 5491 0066 D7E90423 		ldrd	r2, [r7, #16]
 5492 006a 1146     		mov	r1, r2
 5493 006c 14EB0108 		adds	r8, r4, r1
 5494 0070 45EB0309 		adc	r9, r5, r3
 5495              		.loc 2 1259 51 discriminator 3
 5496 0074 3B6C     		ldr	r3, [r7, #64]
 5497 0076 0022     		movs	r2, #0
 5498 0078 BB60     		str	r3, [r7, #8]
 5499 007a FA60     		str	r2, [r7, #12]
 5500              		.loc 2 1259 5 discriminator 3
 5501 007c D7E90223 		ldrd	r2, [r7, #8]
 5502 0080 1146     		mov	r1, r2
 5503 0082 18EB0101 		adds	r1, r8, r1
 5504 0086 3960     		str	r1, [r7]
 5505 0088 49EB0303 		adc	r3, r9, r3
 5506 008c 7B60     		str	r3, [r7, #4]
 5507 008e D7E90023 		ldrd	r2, [r7]
 5508 0092 C7E90C23 		strd	r2, [r7, #48]
1260:keygen.c      **** 		x[u] = (uint32_t)z & 0x7FFFFFFF;
 5509              		.loc 2 1260 10 discriminator 3
 5510 0096 396B     		ldr	r1, [r7, #48]
 5511              		.loc 2 1260 4 discriminator 3
 5512 0098 7B6C     		ldr	r3, [r7, #68]
 5513 009a 9A00     		lsls	r2, r3, #2
 5514 009c FB6A     		ldr	r3, [r7, #44]
 5515 009e 1A44     		add	r2, r2, r3
 5516              		.loc 2 1260 22 discriminator 3
 5517 00a0 21F00043 		bic	r3, r1, #-2147483648
 5518              		.loc 2 1260 8 discriminator 3
 5519 00a4 1360     		str	r3, [r2]
1261:keygen.c      **** 		cc = (uint32_t)(z >> 31);
 5520              		.loc 2 1261 21 discriminator 3
 5521 00a6 D7E90C23 		ldrd	r2, [r7, #48]
 5522 00aa 4FF00000 		mov	r0, #0
 5523 00ae 4FF00001 		mov	r1, #0
 5524 00b2 D00F     		lsrs	r0, r2, #31
 5525 00b4 40EA4300 		orr	r0, r0, r3, lsl #1
 5526 00b8 D90F     		lsrs	r1, r3, #31
 5527              		.loc 2 1261 6 discriminator 3
 5528 00ba 0346     		mov	r3, r0
 5529 00bc 3B64     		str	r3, [r7, #64]
 5530              	.LBE14:
1253:keygen.c      **** 		uint32_t xw, yw;
 5531              		.loc 2 1253 25 discriminator 3
 5532 00be 7B6C     		ldr	r3, [r7, #68]
 5533 00c0 0133     		adds	r3, r3, #1
 5534 00c2 7B64     		str	r3, [r7, #68]
 5535              	.L86:
1253:keygen.c      **** 		uint32_t xw, yw;
 5536              		.loc 2 1253 2 discriminator 1
 5537 00c4 7A6C     		ldr	r2, [r7, #68]
 5538 00c6 7B6A     		ldr	r3, [r7, #36]
 5539 00c8 9A42     		cmp	r2, r3
 5540 00ca A6D3     		bcc	.L87
1262:keygen.c      **** 	}
1263:keygen.c      **** 	x[len] = cc;
 5541              		.loc 2 1263 3
 5542 00cc 7B6A     		ldr	r3, [r7, #36]
 5543 00ce 9B00     		lsls	r3, r3, #2
 5544 00d0 FA6A     		ldr	r2, [r7, #44]
 5545 00d2 1344     		add	r3, r3, r2
 5546              		.loc 2 1263 9
 5547 00d4 3A6C     		ldr	r2, [r7, #64]
 5548 00d6 1A60     		str	r2, [r3]
1264:keygen.c      **** }
 5549              		.loc 2 1264 1
 5550 00d8 00BF     		nop
 5551 00da 4C37     		adds	r7, r7, #76
 5552              	.LCFI135:
 5553              		.cfi_def_cfa_offset 28
 5554 00dc BD46     		mov	sp, r7
 5555              	.LCFI136:
 5556              		.cfi_def_cfa_register 13
 5557              		@ sp needed
 5558 00de BDE8B00F 		pop	{r4, r5, r7, r8, r9, r10, fp}
 5559              	.LCFI137:
 5560              		.cfi_restore 11
 5561              		.cfi_restore 10
 5562              		.cfi_restore 9
 5563              		.cfi_restore 8
 5564              		.cfi_restore 7
 5565              		.cfi_restore 5
 5566              		.cfi_restore 4
 5567              		.cfi_def_cfa_offset 0
 5568 00e2 7047     		bx	lr
 5569              		.cfi_endproc
 5570              	.LFE36:
 5572              		.section	.text.zint_norm_zero,"ax",%progbits
 5573              		.align	1
 5574              		.syntax unified
 5575              		.thumb
 5576              		.thumb_func
 5577              		.fpu softvfp
 5579              	zint_norm_zero:
 5580              	.LFB37:
1265:keygen.c      **** 
1266:keygen.c      **** /*
1267:keygen.c      ****  * Normalize a modular integer around 0: if x > p/2, then x is replaced
1268:keygen.c      ****  * with x - p (signed encoding with two's complement); otherwise, x is
1269:keygen.c      ****  * untouched. The two integers x and p are encoded over the same length.
1270:keygen.c      ****  */
1271:keygen.c      **** static void
1272:keygen.c      **** zint_norm_zero(uint32_t *restrict x, const uint32_t *restrict p, size_t len)
1273:keygen.c      **** {
 5581              		.loc 2 1273 1
 5582              		.cfi_startproc
 5583              		@ args = 0, pretend = 0, frame = 40
 5584              		@ frame_needed = 1, uses_anonymous_args = 0
 5585 0000 80B5     		push	{r7, lr}
 5586              	.LCFI138:
 5587              		.cfi_def_cfa_offset 8
 5588              		.cfi_offset 7, -8
 5589              		.cfi_offset 14, -4
 5590 0002 8AB0     		sub	sp, sp, #40
 5591              	.LCFI139:
 5592              		.cfi_def_cfa_offset 48
 5593 0004 00AF     		add	r7, sp, #0
 5594              	.LCFI140:
 5595              		.cfi_def_cfa_register 7
 5596 0006 F860     		str	r0, [r7, #12]
 5597 0008 B960     		str	r1, [r7, #8]
 5598 000a 7A60     		str	r2, [r7, #4]
1274:keygen.c      **** 	size_t u;
1275:keygen.c      **** 	uint32_t r, bb;
1276:keygen.c      **** 
1277:keygen.c      **** 	/*
1278:keygen.c      **** 	 * Compare x with p/2. We use the shifted version of p, and p
1279:keygen.c      **** 	 * is odd, so we really compare with (p-1)/2; we want to perform
1280:keygen.c      **** 	 * the subtraction if and only if x > (p-1)/2.
1281:keygen.c      **** 	 */
1282:keygen.c      **** 	r = 0;
 5599              		.loc 2 1282 4
 5600 000c 0023     		movs	r3, #0
 5601 000e 3B62     		str	r3, [r7, #32]
1283:keygen.c      **** 	bb = 0;
 5602              		.loc 2 1283 5
 5603 0010 0023     		movs	r3, #0
 5604 0012 FB61     		str	r3, [r7, #28]
1284:keygen.c      **** 	u = len;
 5605              		.loc 2 1284 4
 5606 0014 7B68     		ldr	r3, [r7, #4]
 5607 0016 7B62     		str	r3, [r7, #36]
1285:keygen.c      **** 	while (u -- > 0) {
 5608              		.loc 2 1285 8
 5609 0018 2BE0     		b	.L89
 5610              	.L90:
 5611              	.LBB15:
1286:keygen.c      **** 		uint32_t wx, wp, cc;
1287:keygen.c      **** 
1288:keygen.c      **** 		/*
1289:keygen.c      **** 		 * Get the two words to compare in wx and wp (both over
1290:keygen.c      **** 		 * 31 bits exactly).
1291:keygen.c      **** 		 */
1292:keygen.c      **** 		wx = x[u];
 5612              		.loc 2 1292 9
 5613 001a 7B6A     		ldr	r3, [r7, #36]
 5614 001c 9B00     		lsls	r3, r3, #2
 5615 001e FA68     		ldr	r2, [r7, #12]
 5616 0020 1344     		add	r3, r3, r2
 5617              		.loc 2 1292 6
 5618 0022 1B68     		ldr	r3, [r3]
 5619 0024 BB61     		str	r3, [r7, #24]
1293:keygen.c      **** 		wp = (p[u] >> 1) | (bb << 30);
 5620              		.loc 2 1293 10
 5621 0026 7B6A     		ldr	r3, [r7, #36]
 5622 0028 9B00     		lsls	r3, r3, #2
 5623 002a BA68     		ldr	r2, [r7, #8]
 5624 002c 1344     		add	r3, r3, r2
 5625 002e 1B68     		ldr	r3, [r3]
 5626              		.loc 2 1293 14
 5627 0030 5A08     		lsrs	r2, r3, #1
 5628              		.loc 2 1293 26
 5629 0032 FB69     		ldr	r3, [r7, #28]
 5630 0034 9B07     		lsls	r3, r3, #30
 5631              		.loc 2 1293 6
 5632 0036 1343     		orrs	r3, r3, r2
 5633 0038 7B61     		str	r3, [r7, #20]
1294:keygen.c      **** 		bb = p[u] & 1;
 5634              		.loc 2 1294 9
 5635 003a 7B6A     		ldr	r3, [r7, #36]
 5636 003c 9B00     		lsls	r3, r3, #2
 5637 003e BA68     		ldr	r2, [r7, #8]
 5638 0040 1344     		add	r3, r3, r2
 5639 0042 1B68     		ldr	r3, [r3]
 5640              		.loc 2 1294 6
 5641 0044 03F00103 		and	r3, r3, #1
 5642 0048 FB61     		str	r3, [r7, #28]
1295:keygen.c      **** 
1296:keygen.c      **** 		/*
1297:keygen.c      **** 		 * We set cc to -1, 0 or 1, depending on whether wp is
1298:keygen.c      **** 		 * lower than, equal to, or greater than wx.
1299:keygen.c      **** 		 */
1300:keygen.c      **** 		cc = wp - wx;
 5643              		.loc 2 1300 6
 5644 004a 7A69     		ldr	r2, [r7, #20]
 5645 004c BB69     		ldr	r3, [r7, #24]
 5646 004e D31A     		subs	r3, r2, r3
 5647 0050 3B61     		str	r3, [r7, #16]
1301:keygen.c      **** 		cc = ((-cc) >> 31) | -(cc >> 31);
 5648              		.loc 2 1301 10
 5649 0052 3B69     		ldr	r3, [r7, #16]
 5650 0054 5B42     		rsbs	r3, r3, #0
 5651              		.loc 2 1301 15
 5652 0056 DB0F     		lsrs	r3, r3, #31
 5653              		.loc 2 1301 24
 5654 0058 3A69     		ldr	r2, [r7, #16]
 5655 005a D217     		asrs	r2, r2, #31
 5656              		.loc 2 1301 6
 5657 005c 1343     		orrs	r3, r3, r2
 5658 005e 3B61     		str	r3, [r7, #16]
1302:keygen.c      **** 
1303:keygen.c      **** 		/*
1304:keygen.c      **** 		 * If r != 0 then it is either 1 or -1, and we keep its
1305:keygen.c      **** 		 * value. Otherwise, if r = 0, then we replace it with cc.
1306:keygen.c      **** 		 */
1307:keygen.c      **** 		r |= cc & ((r & 1) - 1);
 5659              		.loc 2 1307 17
 5660 0060 3B6A     		ldr	r3, [r7, #32]
 5661 0062 03F00103 		and	r3, r3, #1
 5662              		.loc 2 1307 22
 5663 0066 5A1E     		subs	r2, r3, #1
 5664              		.loc 2 1307 11
 5665 0068 3B69     		ldr	r3, [r7, #16]
 5666 006a 1340     		ands	r3, r3, r2
 5667              		.loc 2 1307 5
 5668 006c 3A6A     		ldr	r2, [r7, #32]
 5669 006e 1343     		orrs	r3, r3, r2
 5670 0070 3B62     		str	r3, [r7, #32]
 5671              	.L89:
 5672              	.LBE15:
1285:keygen.c      **** 		uint32_t wx, wp, cc;
 5673              		.loc 2 1285 11
 5674 0072 7B6A     		ldr	r3, [r7, #36]
 5675 0074 5A1E     		subs	r2, r3, #1
 5676 0076 7A62     		str	r2, [r7, #36]
1285:keygen.c      **** 		uint32_t wx, wp, cc;
 5677              		.loc 2 1285 8
 5678 0078 002B     		cmp	r3, #0
 5679 007a CED1     		bne	.L90
1308:keygen.c      **** 	}
1309:keygen.c      **** 
1310:keygen.c      **** 	/*
1311:keygen.c      **** 	 * At this point, r = -1, 0 or 1, depending on whether (p-1)/2
1312:keygen.c      **** 	 * is lower than, equal to, or greater than x. We thus want to
1313:keygen.c      **** 	 * do the subtraction only if r = -1.
1314:keygen.c      **** 	 */
1315:keygen.c      **** 	zint_sub(x, p, len, r >> 31);
 5680              		.loc 2 1315 2
 5681 007c 3B6A     		ldr	r3, [r7, #32]
 5682 007e DB0F     		lsrs	r3, r3, #31
 5683 0080 7A68     		ldr	r2, [r7, #4]
 5684 0082 B968     		ldr	r1, [r7, #8]
 5685 0084 F868     		ldr	r0, [r7, #12]
 5686 0086 FFF7FEFF 		bl	zint_sub
1316:keygen.c      **** }
 5687              		.loc 2 1316 1
 5688 008a 00BF     		nop
 5689 008c 2837     		adds	r7, r7, #40
 5690              	.LCFI141:
 5691              		.cfi_def_cfa_offset 8
 5692 008e BD46     		mov	sp, r7
 5693              	.LCFI142:
 5694              		.cfi_def_cfa_register 13
 5695              		@ sp needed
 5696 0090 80BD     		pop	{r7, pc}
 5697              		.cfi_endproc
 5698              	.LFE37:
 5700              		.section	.text.zint_rebuild_CRT,"ax",%progbits
 5701              		.align	1
 5702              		.syntax unified
 5703              		.thumb
 5704              		.thumb_func
 5705              		.fpu softvfp
 5707              	zint_rebuild_CRT:
 5708              	.LFB38:
1317:keygen.c      **** 
1318:keygen.c      **** /*
1319:keygen.c      ****  * Rebuild integers from their RNS representation. There are 'num'
1320:keygen.c      ****  * integers, and each consists in 'xlen' words. 'xx' points at that
1321:keygen.c      ****  * first word of the first integer; subsequent integers are accessed
1322:keygen.c      ****  * by adding 'xstride' repeatedly.
1323:keygen.c      ****  *
1324:keygen.c      ****  * The words of an integer are the RNS representation of that integer,
1325:keygen.c      ****  * using the provided 'primes' are moduli. This function replaces
1326:keygen.c      ****  * each integer with its multi-word value (little-endian order).
1327:keygen.c      ****  *
1328:keygen.c      ****  * If "normalize_signed" is non-zero, then the returned value is
1329:keygen.c      ****  * normalized to the -m/2..m/2 interval (where m is the product of all
1330:keygen.c      ****  * small prime moduli); two's complement is used for negative values.
1331:keygen.c      ****  */
1332:keygen.c      **** static void
1333:keygen.c      **** zint_rebuild_CRT(uint32_t *restrict xx, size_t xlen, size_t xstride,
1334:keygen.c      **** 	size_t num, const small_prime *primes, int normalize_signed,
1335:keygen.c      **** 	uint32_t *restrict tmp)
1336:keygen.c      **** {
 5709              		.loc 2 1336 1
 5710              		.cfi_startproc
 5711              		@ args = 12, pretend = 0, frame = 56
 5712              		@ frame_needed = 1, uses_anonymous_args = 0
 5713 0000 90B5     		push	{r4, r7, lr}
 5714              	.LCFI143:
 5715              		.cfi_def_cfa_offset 12
 5716              		.cfi_offset 4, -12
 5717              		.cfi_offset 7, -8
 5718              		.cfi_offset 14, -4
 5719 0002 91B0     		sub	sp, sp, #68
 5720              	.LCFI144:
 5721              		.cfi_def_cfa_offset 80
 5722 0004 02AF     		add	r7, sp, #8
 5723              	.LCFI145:
 5724              		.cfi_def_cfa 7, 72
 5725 0006 F860     		str	r0, [r7, #12]
 5726 0008 B960     		str	r1, [r7, #8]
 5727 000a 7A60     		str	r2, [r7, #4]
 5728 000c 3B60     		str	r3, [r7]
1337:keygen.c      **** 	size_t u;
1338:keygen.c      **** 	uint32_t *x;
1339:keygen.c      **** 
1340:keygen.c      **** 	tmp[0] = primes[0].p;
 5729              		.loc 2 1340 20
 5730 000e BB6C     		ldr	r3, [r7, #72]
 5731 0010 1A68     		ldr	r2, [r3]
 5732              		.loc 2 1340 9
 5733 0012 3B6D     		ldr	r3, [r7, #80]
 5734 0014 1A60     		str	r2, [r3]
1341:keygen.c      **** 	for (u = 1; u < xlen; u ++) {
 5735              		.loc 2 1341 9
 5736 0016 0123     		movs	r3, #1
 5737 0018 7B63     		str	r3, [r7, #52]
 5738              		.loc 2 1341 2
 5739 001a 5CE0     		b	.L92
 5740              	.L95:
 5741              	.LBB16:
1342:keygen.c      **** 		/*
1343:keygen.c      **** 		 * At the entry of each loop iteration:
1344:keygen.c      **** 		 *  - the first u words of each array have been
1345:keygen.c      **** 		 *    reassembled;
1346:keygen.c      **** 		 *  - the first u words of tmp[] contains the
1347:keygen.c      **** 		 * product of the prime moduli processed so far.
1348:keygen.c      **** 		 *
1349:keygen.c      **** 		 * We call 'q' the product of all previous primes.
1350:keygen.c      **** 		 */
1351:keygen.c      **** 		uint32_t p, p0i, s, R2;
1352:keygen.c      **** 		size_t v;
1353:keygen.c      **** 
1354:keygen.c      **** 		p = primes[u].p;
 5742              		.loc 2 1354 13
 5743 001c 7A6B     		ldr	r2, [r7, #52]
 5744 001e 1346     		mov	r3, r2
 5745 0020 5B00     		lsls	r3, r3, #1
 5746 0022 1344     		add	r3, r3, r2
 5747 0024 9B00     		lsls	r3, r3, #2
 5748 0026 1A46     		mov	r2, r3
 5749 0028 BB6C     		ldr	r3, [r7, #72]
 5750 002a 1344     		add	r3, r3, r2
 5751              		.loc 2 1354 5
 5752 002c 1B68     		ldr	r3, [r3]
 5753 002e BB62     		str	r3, [r7, #40]
1355:keygen.c      **** 		s = primes[u].s;
 5754              		.loc 2 1355 13
 5755 0030 7A6B     		ldr	r2, [r7, #52]
 5756 0032 1346     		mov	r3, r2
 5757 0034 5B00     		lsls	r3, r3, #1
 5758 0036 1344     		add	r3, r3, r2
 5759 0038 9B00     		lsls	r3, r3, #2
 5760 003a 1A46     		mov	r2, r3
 5761 003c BB6C     		ldr	r3, [r7, #72]
 5762 003e 1344     		add	r3, r3, r2
 5763              		.loc 2 1355 5
 5764 0040 9B68     		ldr	r3, [r3, #8]
 5765 0042 7B62     		str	r3, [r7, #36]
1356:keygen.c      **** 		p0i = modp_ninv31(p);
 5766              		.loc 2 1356 9
 5767 0044 B86A     		ldr	r0, [r7, #40]
 5768 0046 FFF7FEFF 		bl	modp_ninv31
 5769 004a 3862     		str	r0, [r7, #32]
1357:keygen.c      **** 		R2 = modp_R2(p, p0i);
 5770              		.loc 2 1357 8
 5771 004c 396A     		ldr	r1, [r7, #32]
 5772 004e B86A     		ldr	r0, [r7, #40]
 5773 0050 FFF7FEFF 		bl	modp_R2
 5774 0054 F861     		str	r0, [r7, #28]
1358:keygen.c      **** 
1359:keygen.c      **** 		for (v = 0, x = xx; v < num; v ++, x += xstride) {
 5775              		.loc 2 1359 10
 5776 0056 0023     		movs	r3, #0
 5777 0058 FB62     		str	r3, [r7, #44]
 5778              		.loc 2 1359 17
 5779 005a FB68     		ldr	r3, [r7, #12]
 5780 005c 3B63     		str	r3, [r7, #48]
 5781              		.loc 2 1359 3
 5782 005e 28E0     		b	.L93
 5783              	.L94:
 5784              	.LBB17:
1360:keygen.c      **** 			uint32_t xp, xq, xr;
1361:keygen.c      **** 			/*
1362:keygen.c      **** 			 * xp = the integer x modulo the prime p for this
1363:keygen.c      **** 			 *      iteration
1364:keygen.c      **** 			 * xq = (x mod q) mod p
1365:keygen.c      **** 			 */
1366:keygen.c      **** 			xp = x[u];
 5785              		.loc 2 1366 10 discriminator 3
 5786 0060 7B6B     		ldr	r3, [r7, #52]
 5787 0062 9B00     		lsls	r3, r3, #2
 5788 0064 3A6B     		ldr	r2, [r7, #48]
 5789 0066 1344     		add	r3, r3, r2
 5790              		.loc 2 1366 7 discriminator 3
 5791 0068 1B68     		ldr	r3, [r3]
 5792 006a BB61     		str	r3, [r7, #24]
1367:keygen.c      **** 			xq = zint_mod_small_unsigned(x, u, p, p0i, R2);
 5793              		.loc 2 1367 9 discriminator 3
 5794 006c FB69     		ldr	r3, [r7, #28]
 5795 006e 0093     		str	r3, [sp]
 5796 0070 3B6A     		ldr	r3, [r7, #32]
 5797 0072 BA6A     		ldr	r2, [r7, #40]
 5798 0074 796B     		ldr	r1, [r7, #52]
 5799 0076 386B     		ldr	r0, [r7, #48]
 5800 0078 FFF7FEFF 		bl	zint_mod_small_unsigned
 5801 007c 7861     		str	r0, [r7, #20]
1368:keygen.c      **** 
1369:keygen.c      **** 			/*
1370:keygen.c      **** 			 * New value is (x mod q) + q * (s * (xp - xq) mod p)
1371:keygen.c      **** 			 */
1372:keygen.c      **** 			xr = modp_montymul(s, modp_sub(xp, xq, p), p, p0i);
 5802              		.loc 2 1372 9 discriminator 3
 5803 007e BA6A     		ldr	r2, [r7, #40]
 5804 0080 7969     		ldr	r1, [r7, #20]
 5805 0082 B869     		ldr	r0, [r7, #24]
 5806 0084 FFF7FEFF 		bl	modp_sub
 5807 0088 0146     		mov	r1, r0
 5808 008a 3B6A     		ldr	r3, [r7, #32]
 5809 008c BA6A     		ldr	r2, [r7, #40]
 5810 008e 786A     		ldr	r0, [r7, #36]
 5811 0090 FFF7FEFF 		bl	modp_montymul
 5812 0094 3861     		str	r0, [r7, #16]
1373:keygen.c      **** 			zint_add_mul_small(x, tmp, u, xr);
 5813              		.loc 2 1373 4 discriminator 3
 5814 0096 3B69     		ldr	r3, [r7, #16]
 5815 0098 7A6B     		ldr	r2, [r7, #52]
 5816 009a 396D     		ldr	r1, [r7, #80]
 5817 009c 386B     		ldr	r0, [r7, #48]
 5818 009e FFF7FEFF 		bl	zint_add_mul_small
 5819              	.LBE17:
1359:keygen.c      **** 			uint32_t xp, xq, xr;
 5820              		.loc 2 1359 34 discriminator 3
 5821 00a2 FB6A     		ldr	r3, [r7, #44]
 5822 00a4 0133     		adds	r3, r3, #1
 5823 00a6 FB62     		str	r3, [r7, #44]
1359:keygen.c      **** 			uint32_t xp, xq, xr;
 5824              		.loc 2 1359 40 discriminator 3
 5825 00a8 7B68     		ldr	r3, [r7, #4]
 5826 00aa 9B00     		lsls	r3, r3, #2
 5827 00ac 3A6B     		ldr	r2, [r7, #48]
 5828 00ae 1344     		add	r3, r3, r2
 5829 00b0 3B63     		str	r3, [r7, #48]
 5830              	.L93:
1359:keygen.c      **** 			uint32_t xp, xq, xr;
 5831              		.loc 2 1359 3 discriminator 1
 5832 00b2 FA6A     		ldr	r2, [r7, #44]
 5833 00b4 3B68     		ldr	r3, [r7]
 5834 00b6 9A42     		cmp	r2, r3
 5835 00b8 D2D3     		bcc	.L94
1374:keygen.c      **** 		}
1375:keygen.c      **** 
1376:keygen.c      **** 		/*
1377:keygen.c      **** 		 * Update product of primes in tmp[].
1378:keygen.c      **** 		 */
1379:keygen.c      **** 		tmp[u] = zint_mul_small(tmp, u, p);
 5836              		.loc 2 1379 6 discriminator 2
 5837 00ba 7B6B     		ldr	r3, [r7, #52]
 5838 00bc 9B00     		lsls	r3, r3, #2
 5839 00be 3A6D     		ldr	r2, [r7, #80]
 5840 00c0 D418     		adds	r4, r2, r3
 5841              		.loc 2 1379 12 discriminator 2
 5842 00c2 BA6A     		ldr	r2, [r7, #40]
 5843 00c4 796B     		ldr	r1, [r7, #52]
 5844 00c6 386D     		ldr	r0, [r7, #80]
 5845 00c8 FFF7FEFF 		bl	zint_mul_small
 5846 00cc 0346     		mov	r3, r0
 5847              		.loc 2 1379 10 discriminator 2
 5848 00ce 2360     		str	r3, [r4]
 5849              	.LBE16:
1341:keygen.c      **** 		/*
 5850              		.loc 2 1341 26 discriminator 2
 5851 00d0 7B6B     		ldr	r3, [r7, #52]
 5852 00d2 0133     		adds	r3, r3, #1
 5853 00d4 7B63     		str	r3, [r7, #52]
 5854              	.L92:
1341:keygen.c      **** 		/*
 5855              		.loc 2 1341 2 discriminator 1
 5856 00d6 7A6B     		ldr	r2, [r7, #52]
 5857 00d8 BB68     		ldr	r3, [r7, #8]
 5858 00da 9A42     		cmp	r2, r3
 5859 00dc 9ED3     		bcc	.L95
1380:keygen.c      **** 	}
1381:keygen.c      **** 
1382:keygen.c      **** 	/*
1383:keygen.c      **** 	 * Normalize the reconstructed values around 0.
1384:keygen.c      **** 	 */
1385:keygen.c      **** 	if (normalize_signed) {
 5860              		.loc 2 1385 5
 5861 00de FB6C     		ldr	r3, [r7, #76]
 5862 00e0 002B     		cmp	r3, #0
 5863 00e2 15D0     		beq	.L99
1386:keygen.c      **** 		for (u = 0, x = xx; u < num; u ++, x += xstride) {
 5864              		.loc 2 1386 10
 5865 00e4 0023     		movs	r3, #0
 5866 00e6 7B63     		str	r3, [r7, #52]
 5867              		.loc 2 1386 17
 5868 00e8 FB68     		ldr	r3, [r7, #12]
 5869 00ea 3B63     		str	r3, [r7, #48]
 5870              		.loc 2 1386 3
 5871 00ec 0CE0     		b	.L97
 5872              	.L98:
1387:keygen.c      **** 			zint_norm_zero(x, tmp, xlen);
 5873              		.loc 2 1387 4 discriminator 3
 5874 00ee BA68     		ldr	r2, [r7, #8]
 5875 00f0 396D     		ldr	r1, [r7, #80]
 5876 00f2 386B     		ldr	r0, [r7, #48]
 5877 00f4 FFF7FEFF 		bl	zint_norm_zero
1386:keygen.c      **** 		for (u = 0, x = xx; u < num; u ++, x += xstride) {
 5878              		.loc 2 1386 34 discriminator 3
 5879 00f8 7B6B     		ldr	r3, [r7, #52]
 5880 00fa 0133     		adds	r3, r3, #1
 5881 00fc 7B63     		str	r3, [r7, #52]
1386:keygen.c      **** 		for (u = 0, x = xx; u < num; u ++, x += xstride) {
 5882              		.loc 2 1386 40 discriminator 3
 5883 00fe 7B68     		ldr	r3, [r7, #4]
 5884 0100 9B00     		lsls	r3, r3, #2
 5885 0102 3A6B     		ldr	r2, [r7, #48]
 5886 0104 1344     		add	r3, r3, r2
 5887 0106 3B63     		str	r3, [r7, #48]
 5888              	.L97:
1386:keygen.c      **** 		for (u = 0, x = xx; u < num; u ++, x += xstride) {
 5889              		.loc 2 1386 3 discriminator 1
 5890 0108 7A6B     		ldr	r2, [r7, #52]
 5891 010a 3B68     		ldr	r3, [r7]
 5892 010c 9A42     		cmp	r2, r3
 5893 010e EED3     		bcc	.L98
 5894              	.L99:
1388:keygen.c      **** 		}
1389:keygen.c      **** 	}
1390:keygen.c      **** }
 5895              		.loc 2 1390 1
 5896 0110 00BF     		nop
 5897 0112 3C37     		adds	r7, r7, #60
 5898              	.LCFI146:
 5899              		.cfi_def_cfa_offset 12
 5900 0114 BD46     		mov	sp, r7
 5901              	.LCFI147:
 5902              		.cfi_def_cfa_register 13
 5903              		@ sp needed
 5904 0116 90BD     		pop	{r4, r7, pc}
 5905              		.cfi_endproc
 5906              	.LFE38:
 5908              		.section	.text.zint_negate,"ax",%progbits
 5909              		.align	1
 5910              		.syntax unified
 5911              		.thumb
 5912              		.thumb_func
 5913              		.fpu softvfp
 5915              	zint_negate:
 5916              	.LFB39:
1391:keygen.c      **** 
1392:keygen.c      **** /*
1393:keygen.c      ****  * Negate a big integer conditionally: value a is replaced with -a if
1394:keygen.c      ****  * and only if ctl = 1. Control value ctl must be 0 or 1.
1395:keygen.c      ****  */
1396:keygen.c      **** static void
1397:keygen.c      **** zint_negate(uint32_t *a, size_t len, uint32_t ctl)
1398:keygen.c      **** {
 5917              		.loc 2 1398 1
 5918              		.cfi_startproc
 5919              		@ args = 0, pretend = 0, frame = 32
 5920              		@ frame_needed = 1, uses_anonymous_args = 0
 5921              		@ link register save eliminated.
 5922 0000 80B4     		push	{r7}
 5923              	.LCFI148:
 5924              		.cfi_def_cfa_offset 4
 5925              		.cfi_offset 7, -4
 5926 0002 89B0     		sub	sp, sp, #36
 5927              	.LCFI149:
 5928              		.cfi_def_cfa_offset 40
 5929 0004 00AF     		add	r7, sp, #0
 5930              	.LCFI150:
 5931              		.cfi_def_cfa_register 7
 5932 0006 F860     		str	r0, [r7, #12]
 5933 0008 B960     		str	r1, [r7, #8]
 5934 000a 7A60     		str	r2, [r7, #4]
1399:keygen.c      **** 	size_t u;
1400:keygen.c      **** 	uint32_t cc, m;
1401:keygen.c      **** 
1402:keygen.c      **** 	/*
1403:keygen.c      **** 	 * If ctl = 1 then we flip the bits of a by XORing with
1404:keygen.c      **** 	 * 0x7FFFFFFF, and we add 1 to the value. If ctl = 0 then we XOR
1405:keygen.c      **** 	 * with 0 and add 0, which leaves the value unchanged.
1406:keygen.c      **** 	 */
1407:keygen.c      **** 	cc = ctl;
 5935              		.loc 2 1407 5
 5936 000c 7B68     		ldr	r3, [r7, #4]
 5937 000e BB61     		str	r3, [r7, #24]
1408:keygen.c      **** 	m = -ctl >> 1;
 5938              		.loc 2 1408 6
 5939 0010 7B68     		ldr	r3, [r7, #4]
 5940 0012 5B42     		rsbs	r3, r3, #0
 5941              		.loc 2 1408 4
 5942 0014 5B08     		lsrs	r3, r3, #1
 5943 0016 7B61     		str	r3, [r7, #20]
1409:keygen.c      **** 	for (u = 0; u < len; u ++) {
 5944              		.loc 2 1409 9
 5945 0018 0023     		movs	r3, #0
 5946 001a FB61     		str	r3, [r7, #28]
 5947              		.loc 2 1409 2
 5948 001c 19E0     		b	.L101
 5949              	.L102:
 5950              	.LBB18:
1410:keygen.c      **** 		uint32_t aw;
1411:keygen.c      **** 
1412:keygen.c      **** 		aw = a[u];
 5951              		.loc 2 1412 9 discriminator 3
 5952 001e FB69     		ldr	r3, [r7, #28]
 5953 0020 9B00     		lsls	r3, r3, #2
 5954 0022 FA68     		ldr	r2, [r7, #12]
 5955 0024 1344     		add	r3, r3, r2
 5956              		.loc 2 1412 6 discriminator 3
 5957 0026 1B68     		ldr	r3, [r3]
 5958 0028 3B61     		str	r3, [r7, #16]
1413:keygen.c      **** 		aw = (aw ^ m) + cc;
 5959              		.loc 2 1413 12 discriminator 3
 5960 002a 3A69     		ldr	r2, [r7, #16]
 5961 002c 7B69     		ldr	r3, [r7, #20]
 5962 002e 5340     		eors	r3, r3, r2
 5963              		.loc 2 1413 6 discriminator 3
 5964 0030 BA69     		ldr	r2, [r7, #24]
 5965 0032 1344     		add	r3, r3, r2
 5966 0034 3B61     		str	r3, [r7, #16]
1414:keygen.c      **** 		a[u] = aw & 0x7FFFFFFF;
 5967              		.loc 2 1414 4 discriminator 3
 5968 0036 FB69     		ldr	r3, [r7, #28]
 5969 0038 9B00     		lsls	r3, r3, #2
 5970 003a FA68     		ldr	r2, [r7, #12]
 5971 003c 1344     		add	r3, r3, r2
 5972              		.loc 2 1414 13 discriminator 3
 5973 003e 3A69     		ldr	r2, [r7, #16]
 5974 0040 22F00042 		bic	r2, r2, #-2147483648
 5975              		.loc 2 1414 8 discriminator 3
 5976 0044 1A60     		str	r2, [r3]
1415:keygen.c      **** 		cc = aw >> 31;
 5977              		.loc 2 1415 6 discriminator 3
 5978 0046 3B69     		ldr	r3, [r7, #16]
 5979 0048 DB0F     		lsrs	r3, r3, #31
 5980 004a BB61     		str	r3, [r7, #24]
 5981              	.LBE18:
1409:keygen.c      **** 		uint32_t aw;
 5982              		.loc 2 1409 25 discriminator 3
 5983 004c FB69     		ldr	r3, [r7, #28]
 5984 004e 0133     		adds	r3, r3, #1
 5985 0050 FB61     		str	r3, [r7, #28]
 5986              	.L101:
1409:keygen.c      **** 		uint32_t aw;
 5987              		.loc 2 1409 2 discriminator 1
 5988 0052 FA69     		ldr	r2, [r7, #28]
 5989 0054 BB68     		ldr	r3, [r7, #8]
 5990 0056 9A42     		cmp	r2, r3
 5991 0058 E1D3     		bcc	.L102
1416:keygen.c      **** 	}
1417:keygen.c      **** }
 5992              		.loc 2 1417 1
 5993 005a 00BF     		nop
 5994 005c 00BF     		nop
 5995 005e 2437     		adds	r7, r7, #36
 5996              	.LCFI151:
 5997              		.cfi_def_cfa_offset 4
 5998 0060 BD46     		mov	sp, r7
 5999              	.LCFI152:
 6000              		.cfi_def_cfa_register 13
 6001              		@ sp needed
 6002 0062 80BC     		pop	{r7}
 6003              	.LCFI153:
 6004              		.cfi_restore 7
 6005              		.cfi_def_cfa_offset 0
 6006 0064 7047     		bx	lr
 6007              		.cfi_endproc
 6008              	.LFE39:
 6010              		.section	.text.zint_co_reduce,"ax",%progbits
 6011              		.align	1
 6012              		.syntax unified
 6013              		.thumb
 6014              		.thumb_func
 6015              		.fpu softvfp
 6017              	zint_co_reduce:
 6018              	.LFB40:
1418:keygen.c      **** 
1419:keygen.c      **** /*
1420:keygen.c      ****  * Replace a with (a*xa+b*xb)/(2^31) and b with (a*ya+b*yb)/(2^31).
1421:keygen.c      ****  * The low bits are dropped (the caller should compute the coefficients
1422:keygen.c      ****  * such that these dropped bits are all zeros). If either or both
1423:keygen.c      ****  * yields a negative value, then the value is negated.
1424:keygen.c      ****  *
1425:keygen.c      ****  * Returned value is:
1426:keygen.c      ****  *  0  both values were positive
1427:keygen.c      ****  *  1  new a had to be negated
1428:keygen.c      ****  *  2  new b had to be negated
1429:keygen.c      ****  *  3  both new a and new b had to be negated
1430:keygen.c      ****  *
1431:keygen.c      ****  * Coefficients xa, xb, ya and yb may use the full signed 32-bit range.
1432:keygen.c      ****  */
1433:keygen.c      **** static uint32_t
1434:keygen.c      **** zint_co_reduce(uint32_t *a, uint32_t *b, size_t len,
1435:keygen.c      **** 	int64_t xa, int64_t xb, int64_t ya, int64_t yb)
1436:keygen.c      **** {
 6019              		.loc 2 1436 1
 6020              		.cfi_startproc
 6021              		@ args = 32, pretend = 0, frame = 144
 6022              		@ frame_needed = 1, uses_anonymous_args = 0
 6023 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 6024              	.LCFI154:
 6025              		.cfi_def_cfa_offset 32
 6026              		.cfi_offset 4, -32
 6027              		.cfi_offset 5, -28
 6028              		.cfi_offset 7, -24
 6029              		.cfi_offset 8, -20
 6030              		.cfi_offset 9, -16
 6031              		.cfi_offset 10, -12
 6032              		.cfi_offset 11, -8
 6033              		.cfi_offset 14, -4
 6034 0004 A4B0     		sub	sp, sp, #144
 6035              	.LCFI155:
 6036              		.cfi_def_cfa_offset 176
 6037 0006 00AF     		add	r7, sp, #0
 6038              	.LCFI156:
 6039              		.cfi_def_cfa_register 7
 6040 0008 7865     		str	r0, [r7, #84]
 6041 000a 3965     		str	r1, [r7, #80]
 6042 000c FA64     		str	r2, [r7, #76]
1437:keygen.c      **** 	size_t u;
1438:keygen.c      **** 	int64_t cca, ccb;
1439:keygen.c      **** 	uint32_t nega, negb;
1440:keygen.c      **** 
1441:keygen.c      **** 	cca = 0;
 6043              		.loc 2 1441 6
 6044 000e 4FF00002 		mov	r2, #0
 6045 0012 4FF00003 		mov	r3, #0
 6046 0016 C7E92023 		strd	r2, [r7, #128]
1442:keygen.c      **** 	ccb = 0;
 6047              		.loc 2 1442 6
 6048 001a 4FF00002 		mov	r2, #0
 6049 001e 4FF00003 		mov	r3, #0
 6050 0022 C7E91E23 		strd	r2, [r7, #120]
1443:keygen.c      **** 	for (u = 0; u < len; u ++) {
 6051              		.loc 2 1443 9
 6052 0026 0023     		movs	r3, #0
 6053 0028 C7F88C30 		str	r3, [r7, #140]
 6054              		.loc 2 1443 2
 6055 002c C4E0     		b	.L104
 6056              	.L106:
 6057              	.LBB19:
1444:keygen.c      **** 		uint32_t wa, wb;
1445:keygen.c      **** 		uint64_t za, zb;
1446:keygen.c      **** 
1447:keygen.c      **** 		wa = a[u];
 6058              		.loc 2 1447 9
 6059 002e D7F88C30 		ldr	r3, [r7, #140]
 6060 0032 9A00     		lsls	r2, r3, #2
 6061 0034 7B6D     		ldr	r3, [r7, #84]
 6062 0036 1344     		add	r3, r3, r2
 6063              		.loc 2 1447 6
 6064 0038 1B68     		ldr	r3, [r3]
 6065 003a FB66     		str	r3, [r7, #108]
1448:keygen.c      **** 		wb = b[u];
 6066              		.loc 2 1448 9
 6067 003c D7F88C30 		ldr	r3, [r7, #140]
 6068 0040 9A00     		lsls	r2, r3, #2
 6069 0042 3B6D     		ldr	r3, [r7, #80]
 6070 0044 1344     		add	r3, r3, r2
 6071              		.loc 2 1448 6
 6072 0046 1B68     		ldr	r3, [r3]
 6073 0048 BB66     		str	r3, [r7, #104]
1449:keygen.c      **** 		za = wa * (uint64_t)xa + wb * (uint64_t)xb + (uint64_t)cca;
 6074              		.loc 2 1449 11
 6075 004a FB6E     		ldr	r3, [r7, #108]
 6076 004c 0022     		movs	r2, #0
 6077 004e 3B64     		str	r3, [r7, #64]
 6078 0050 7A64     		str	r2, [r7, #68]
 6079              		.loc 2 1449 13
 6080 0052 D7E92C23 		ldrd	r2, [r7, #176]
 6081              		.loc 2 1449 11
 6082 0056 796C     		ldr	r1, [r7, #68]
 6083 0058 02FB01F0 		mul	r0, r2, r1
 6084 005c 396C     		ldr	r1, [r7, #64]
 6085 005e 01FB03F1 		mul	r1, r1, r3
 6086 0062 0144     		add	r1, r1, r0
 6087 0064 386C     		ldr	r0, [r7, #64]
 6088 0066 A0FB02AB 		umull	r10, fp, r0, r2
 6089 006a 01EB0B03 		add	r3, r1, fp
 6090 006e 9B46     		mov	fp, r3
 6091              		.loc 2 1449 31
 6092 0070 BB6E     		ldr	r3, [r7, #104]
 6093 0072 0022     		movs	r2, #0
 6094 0074 BB63     		str	r3, [r7, #56]
 6095 0076 FA63     		str	r2, [r7, #60]
 6096              		.loc 2 1449 33
 6097 0078 D7E92E23 		ldrd	r2, [r7, #184]
 6098              		.loc 2 1449 31
 6099 007c F96B     		ldr	r1, [r7, #60]
 6100 007e 02FB01F0 		mul	r0, r2, r1
 6101 0082 B96B     		ldr	r1, [r7, #56]
 6102 0084 01FB03F1 		mul	r1, r1, r3
 6103 0088 0144     		add	r1, r1, r0
 6104 008a B86B     		ldr	r0, [r7, #56]
 6105 008c A0FB0232 		umull	r3, r2, r0, r2
 6106 0090 7A63     		str	r2, [r7, #52]
 6107 0092 3B63     		str	r3, [r7, #48]
 6108 0094 7B6B     		ldr	r3, [r7, #52]
 6109 0096 CB18     		adds	r3, r1, r3
 6110 0098 7B63     		str	r3, [r7, #52]
 6111              		.loc 2 1449 26
 6112 009a D7E90C23 		ldrd	r2, [r7, #48]
 6113 009e 1146     		mov	r1, r2
 6114 00a0 1AEB0101 		adds	r1, r10, r1
 6115 00a4 B961     		str	r1, [r7, #24]
 6116 00a6 4BEB0303 		adc	r3, fp, r3
 6117 00aa FB61     		str	r3, [r7, #28]
 6118              		.loc 2 1449 48
 6119 00ac D7E92023 		ldrd	r2, [r7, #128]
 6120              		.loc 2 1449 46
 6121 00b0 B969     		ldr	r1, [r7, #24]
 6122 00b2 8918     		adds	r1, r1, r2
 6123 00b4 B960     		str	r1, [r7, #8]
 6124 00b6 F969     		ldr	r1, [r7, #28]
 6125 00b8 41EB0303 		adc	r3, r1, r3
 6126 00bc FB60     		str	r3, [r7, #12]
 6127              		.loc 2 1449 6
 6128 00be D7E90223 		ldrd	r2, [r7, #8]
 6129 00c2 C7E91823 		strd	r2, [r7, #96]
1450:keygen.c      **** 		zb = wa * (uint64_t)ya + wb * (uint64_t)yb + (uint64_t)ccb;
 6130              		.loc 2 1450 11
 6131 00c6 FB6E     		ldr	r3, [r7, #108]
 6132 00c8 0022     		movs	r2, #0
 6133 00ca BB62     		str	r3, [r7, #40]
 6134 00cc FA62     		str	r2, [r7, #44]
 6135              		.loc 2 1450 13
 6136 00ce D7E93023 		ldrd	r2, [r7, #192]
 6137              		.loc 2 1450 11
 6138 00d2 F96A     		ldr	r1, [r7, #44]
 6139 00d4 02FB01F0 		mul	r0, r2, r1
 6140 00d8 B96A     		ldr	r1, [r7, #40]
 6141 00da 01FB03F1 		mul	r1, r1, r3
 6142 00de 0144     		add	r1, r1, r0
 6143 00e0 B86A     		ldr	r0, [r7, #40]
 6144 00e2 A0FB0245 		umull	r4, r5, r0, r2
 6145 00e6 4B19     		adds	r3, r1, r5
 6146 00e8 1D46     		mov	r5, r3
 6147              		.loc 2 1450 31
 6148 00ea BB6E     		ldr	r3, [r7, #104]
 6149 00ec 0022     		movs	r2, #0
 6150 00ee 3B62     		str	r3, [r7, #32]
 6151 00f0 7A62     		str	r2, [r7, #36]
 6152              		.loc 2 1450 33
 6153 00f2 D7E93223 		ldrd	r2, [r7, #200]
 6154              		.loc 2 1450 31
 6155 00f6 796A     		ldr	r1, [r7, #36]
 6156 00f8 02FB01F0 		mul	r0, r2, r1
 6157 00fc 396A     		ldr	r1, [r7, #32]
 6158 00fe 01FB03F1 		mul	r1, r1, r3
 6159 0102 0144     		add	r1, r1, r0
 6160 0104 386A     		ldr	r0, [r7, #32]
 6161 0106 A0FB0289 		umull	r8, r9, r0, r2
 6162 010a 01EB0903 		add	r3, r1, r9
 6163 010e 9946     		mov	r9, r3
 6164              		.loc 2 1450 26
 6165 0110 14EB0803 		adds	r3, r4, r8
 6166 0114 3B61     		str	r3, [r7, #16]
 6167 0116 45EB0903 		adc	r3, r5, r9
 6168 011a 7B61     		str	r3, [r7, #20]
 6169              		.loc 2 1450 48
 6170 011c D7E91E23 		ldrd	r2, [r7, #120]
 6171              		.loc 2 1450 46
 6172 0120 3969     		ldr	r1, [r7, #16]
 6173 0122 8918     		adds	r1, r1, r2
 6174 0124 3960     		str	r1, [r7]
 6175 0126 7969     		ldr	r1, [r7, #20]
 6176 0128 41EB0303 		adc	r3, r1, r3
 6177 012c 7B60     		str	r3, [r7, #4]
 6178              		.loc 2 1450 6
 6179 012e D7E90023 		ldrd	r2, [r7]
 6180 0132 C7E91623 		strd	r2, [r7, #88]
1451:keygen.c      **** 		if (u > 0) {
 6181              		.loc 2 1451 6
 6182 0136 D7F88C30 		ldr	r3, [r7, #140]
 6183 013a 002B     		cmp	r3, #0
 6184 013c 1BD0     		beq	.L105
1452:keygen.c      **** 			a[u - 1] = (uint32_t)za & 0x7FFFFFFF;
 6185              		.loc 2 1452 15
 6186 013e D7E91823 		ldrd	r2, [r7, #96]
 6187 0142 1146     		mov	r1, r2
 6188              		.loc 2 1452 5
 6189 0144 D7F88C30 		ldr	r3, [r7, #140]
 6190 0148 03F18043 		add	r3, r3, #1073741824
 6191 014c 013B     		subs	r3, r3, #1
 6192 014e 9A00     		lsls	r2, r3, #2
 6193 0150 7B6D     		ldr	r3, [r7, #84]
 6194 0152 1A44     		add	r2, r2, r3
 6195              		.loc 2 1452 28
 6196 0154 21F00043 		bic	r3, r1, #-2147483648
 6197              		.loc 2 1452 13
 6198 0158 1360     		str	r3, [r2]
1453:keygen.c      **** 			b[u - 1] = (uint32_t)zb & 0x7FFFFFFF;
 6199              		.loc 2 1453 15
 6200 015a D7E91623 		ldrd	r2, [r7, #88]
 6201 015e 1146     		mov	r1, r2
 6202              		.loc 2 1453 5
 6203 0160 D7F88C30 		ldr	r3, [r7, #140]
 6204 0164 03F18043 		add	r3, r3, #1073741824
 6205 0168 013B     		subs	r3, r3, #1
 6206 016a 9A00     		lsls	r2, r3, #2
 6207 016c 3B6D     		ldr	r3, [r7, #80]
 6208 016e 1A44     		add	r2, r2, r3
 6209              		.loc 2 1453 28
 6210 0170 21F00043 		bic	r3, r1, #-2147483648
 6211              		.loc 2 1453 13
 6212 0174 1360     		str	r3, [r2]
 6213              	.L105:
1454:keygen.c      **** 		}
1455:keygen.c      **** 		cca = *(int64_t *)&za >> 31;
 6214              		.loc 2 1455 21 discriminator 2
 6215 0176 07F16003 		add	r3, r7, #96
 6216              		.loc 2 1455 9 discriminator 2
 6217 017a D3E90023 		ldrd	r2, [r3]
 6218              		.loc 2 1455 7 discriminator 2
 6219 017e 4FF00000 		mov	r0, #0
 6220 0182 4FF00001 		mov	r1, #0
 6221 0186 D00F     		lsrs	r0, r2, #31
 6222 0188 40EA4300 		orr	r0, r0, r3, lsl #1
 6223 018c D917     		asrs	r1, r3, #31
 6224 018e C7E92001 		strd	r0, [r7, #128]
1456:keygen.c      **** 		ccb = *(int64_t *)&zb >> 31;
 6225              		.loc 2 1456 21 discriminator 2
 6226 0192 07F15803 		add	r3, r7, #88
 6227              		.loc 2 1456 9 discriminator 2
 6228 0196 D3E90023 		ldrd	r2, [r3]
 6229              		.loc 2 1456 7 discriminator 2
 6230 019a 4FF00000 		mov	r0, #0
 6231 019e 4FF00001 		mov	r1, #0
 6232 01a2 D00F     		lsrs	r0, r2, #31
 6233 01a4 40EA4300 		orr	r0, r0, r3, lsl #1
 6234 01a8 D917     		asrs	r1, r3, #31
 6235 01aa C7E91E01 		strd	r0, [r7, #120]
 6236              	.LBE19:
1443:keygen.c      **** 		uint32_t wa, wb;
 6237              		.loc 2 1443 25 discriminator 2
 6238 01ae D7F88C30 		ldr	r3, [r7, #140]
 6239 01b2 0133     		adds	r3, r3, #1
 6240 01b4 C7F88C30 		str	r3, [r7, #140]
 6241              	.L104:
1443:keygen.c      **** 		uint32_t wa, wb;
 6242              		.loc 2 1443 2 discriminator 1
 6243 01b8 D7F88C20 		ldr	r2, [r7, #140]
 6244 01bc FB6C     		ldr	r3, [r7, #76]
 6245 01be 9A42     		cmp	r2, r3
 6246 01c0 FFF435AF 		bcc	.L106
1457:keygen.c      **** 	}
1458:keygen.c      **** 	a[len - 1] = (uint32_t)cca;
 6247              		.loc 2 1458 3
 6248 01c4 FB6C     		ldr	r3, [r7, #76]
 6249 01c6 03F18043 		add	r3, r3, #1073741824
 6250 01ca 013B     		subs	r3, r3, #1
 6251 01cc 9B00     		lsls	r3, r3, #2
 6252 01ce 7A6D     		ldr	r2, [r7, #84]
 6253 01d0 1344     		add	r3, r3, r2
 6254              		.loc 2 1458 15
 6255 01d2 D7F88020 		ldr	r2, [r7, #128]
 6256              		.loc 2 1458 13
 6257 01d6 1A60     		str	r2, [r3]
1459:keygen.c      **** 	b[len - 1] = (uint32_t)ccb;
 6258              		.loc 2 1459 3
 6259 01d8 FB6C     		ldr	r3, [r7, #76]
 6260 01da 03F18043 		add	r3, r3, #1073741824
 6261 01de 013B     		subs	r3, r3, #1
 6262 01e0 9B00     		lsls	r3, r3, #2
 6263 01e2 3A6D     		ldr	r2, [r7, #80]
 6264 01e4 1344     		add	r3, r3, r2
 6265              		.loc 2 1459 15
 6266 01e6 BA6F     		ldr	r2, [r7, #120]
 6267              		.loc 2 1459 13
 6268 01e8 1A60     		str	r2, [r3]
1460:keygen.c      **** 
1461:keygen.c      **** 	nega = (uint32_t)((uint64_t)cca >> 63);
 6269              		.loc 2 1461 20
 6270 01ea D7E92001 		ldrd	r0, [r7, #128]
 6271              		.loc 2 1461 34
 6272 01ee 4FF00002 		mov	r2, #0
 6273 01f2 4FF00003 		mov	r3, #0
 6274 01f6 CA0F     		lsrs	r2, r1, #31
 6275 01f8 0023     		movs	r3, #0
 6276              		.loc 2 1461 7
 6277 01fa 1346     		mov	r3, r2
 6278 01fc 7B67     		str	r3, [r7, #116]
1462:keygen.c      **** 	negb = (uint32_t)((uint64_t)ccb >> 63);
 6279              		.loc 2 1462 20
 6280 01fe D7E91E01 		ldrd	r0, [r7, #120]
 6281              		.loc 2 1462 34
 6282 0202 4FF00002 		mov	r2, #0
 6283 0206 4FF00003 		mov	r3, #0
 6284 020a CA0F     		lsrs	r2, r1, #31
 6285 020c 0023     		movs	r3, #0
 6286              		.loc 2 1462 7
 6287 020e 1346     		mov	r3, r2
 6288 0210 3B67     		str	r3, [r7, #112]
1463:keygen.c      **** 	zint_negate(a, len, nega);
 6289              		.loc 2 1463 2
 6290 0212 7A6F     		ldr	r2, [r7, #116]
 6291 0214 F96C     		ldr	r1, [r7, #76]
 6292 0216 786D     		ldr	r0, [r7, #84]
 6293 0218 FFF7FEFF 		bl	zint_negate
1464:keygen.c      **** 	zint_negate(b, len, negb);
 6294              		.loc 2 1464 2
 6295 021c 3A6F     		ldr	r2, [r7, #112]
 6296 021e F96C     		ldr	r1, [r7, #76]
 6297 0220 386D     		ldr	r0, [r7, #80]
 6298 0222 FFF7FEFF 		bl	zint_negate
1465:keygen.c      **** 	return nega | (negb << 1);
 6299              		.loc 2 1465 22
 6300 0226 3B6F     		ldr	r3, [r7, #112]
 6301 0228 5A00     		lsls	r2, r3, #1
 6302              		.loc 2 1465 14
 6303 022a 7B6F     		ldr	r3, [r7, #116]
 6304 022c 1343     		orrs	r3, r3, r2
1466:keygen.c      **** }
 6305              		.loc 2 1466 1
 6306 022e 1846     		mov	r0, r3
 6307 0230 9037     		adds	r7, r7, #144
 6308              	.LCFI157:
 6309              		.cfi_def_cfa_offset 32
 6310 0232 BD46     		mov	sp, r7
 6311              	.LCFI158:
 6312              		.cfi_def_cfa_register 13
 6313              		@ sp needed
 6314 0234 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 6315              		.cfi_endproc
 6316              	.LFE40:
 6318              		.section	.text.zint_finish_mod,"ax",%progbits
 6319              		.align	1
 6320              		.syntax unified
 6321              		.thumb
 6322              		.thumb_func
 6323              		.fpu softvfp
 6325              	zint_finish_mod:
 6326              	.LFB41:
1467:keygen.c      **** 
1468:keygen.c      **** /*
1469:keygen.c      ****  * Finish modular reduction. Rules on input parameters:
1470:keygen.c      ****  *
1471:keygen.c      ****  *   if neg = 1, then -m <= a < 0
1472:keygen.c      ****  *   if neg = 0, then 0 <= a < 2*m
1473:keygen.c      ****  *
1474:keygen.c      ****  * If neg = 0, then the top word of a[] is allowed to use 32 bits.
1475:keygen.c      ****  *
1476:keygen.c      ****  * Modulus m must be odd.
1477:keygen.c      ****  */
1478:keygen.c      **** static void
1479:keygen.c      **** zint_finish_mod(uint32_t *a, size_t len, const uint32_t *m, uint32_t neg)
1480:keygen.c      **** {
 6327              		.loc 2 1480 1
 6328              		.cfi_startproc
 6329              		@ args = 0, pretend = 0, frame = 40
 6330              		@ frame_needed = 1, uses_anonymous_args = 0
 6331              		@ link register save eliminated.
 6332 0000 80B4     		push	{r7}
 6333              	.LCFI159:
 6334              		.cfi_def_cfa_offset 4
 6335              		.cfi_offset 7, -4
 6336 0002 8BB0     		sub	sp, sp, #44
 6337              	.LCFI160:
 6338              		.cfi_def_cfa_offset 48
 6339 0004 00AF     		add	r7, sp, #0
 6340              	.LCFI161:
 6341              		.cfi_def_cfa_register 7
 6342 0006 F860     		str	r0, [r7, #12]
 6343 0008 B960     		str	r1, [r7, #8]
 6344 000a 7A60     		str	r2, [r7, #4]
 6345 000c 3B60     		str	r3, [r7]
1481:keygen.c      **** 	size_t u;
1482:keygen.c      **** 	uint32_t cc, xm, ym;
1483:keygen.c      **** 
1484:keygen.c      **** 	/*
1485:keygen.c      **** 	 * First pass: compare a (assumed nonnegative) with m. Note that
1486:keygen.c      **** 	 * if the top word uses 32 bits, subtracting m must yield a
1487:keygen.c      **** 	 * value less than 2^31 since a < 2*m.
1488:keygen.c      **** 	 */
1489:keygen.c      **** 	cc = 0;
 6346              		.loc 2 1489 5
 6347 000e 0023     		movs	r3, #0
 6348 0010 3B62     		str	r3, [r7, #32]
1490:keygen.c      **** 	for (u = 0; u < len; u ++) {
 6349              		.loc 2 1490 9
 6350 0012 0023     		movs	r3, #0
 6351 0014 7B62     		str	r3, [r7, #36]
 6352              		.loc 2 1490 2
 6353 0016 11E0     		b	.L109
 6354              	.L110:
1491:keygen.c      **** 		cc = (a[u] - m[u] - cc) >> 31;
 6355              		.loc 2 1491 10 discriminator 3
 6356 0018 7B6A     		ldr	r3, [r7, #36]
 6357 001a 9B00     		lsls	r3, r3, #2
 6358 001c FA68     		ldr	r2, [r7, #12]
 6359 001e 1344     		add	r3, r3, r2
 6360 0020 1A68     		ldr	r2, [r3]
 6361              		.loc 2 1491 17 discriminator 3
 6362 0022 7B6A     		ldr	r3, [r7, #36]
 6363 0024 9B00     		lsls	r3, r3, #2
 6364 0026 7968     		ldr	r1, [r7, #4]
 6365 0028 0B44     		add	r3, r3, r1
 6366 002a 1B68     		ldr	r3, [r3]
 6367              		.loc 2 1491 14 discriminator 3
 6368 002c D21A     		subs	r2, r2, r3
 6369              		.loc 2 1491 21 discriminator 3
 6370 002e 3B6A     		ldr	r3, [r7, #32]
 6371 0030 D31A     		subs	r3, r2, r3
 6372              		.loc 2 1491 6 discriminator 3
 6373 0032 DB0F     		lsrs	r3, r3, #31
 6374 0034 3B62     		str	r3, [r7, #32]
1490:keygen.c      **** 	for (u = 0; u < len; u ++) {
 6375              		.loc 2 1490 25 discriminator 3
 6376 0036 7B6A     		ldr	r3, [r7, #36]
 6377 0038 0133     		adds	r3, r3, #1
 6378 003a 7B62     		str	r3, [r7, #36]
 6379              	.L109:
1490:keygen.c      **** 	for (u = 0; u < len; u ++) {
 6380              		.loc 2 1490 2 discriminator 1
 6381 003c 7A6A     		ldr	r2, [r7, #36]
 6382 003e BB68     		ldr	r3, [r7, #8]
 6383 0040 9A42     		cmp	r2, r3
 6384 0042 E9D3     		bcc	.L110
1492:keygen.c      **** 	}
1493:keygen.c      **** 
1494:keygen.c      **** 	/*
1495:keygen.c      **** 	 * If neg = 1 then we must add m (regardless of cc)
1496:keygen.c      **** 	 * If neg = 0 and cc = 0 then we must subtract m
1497:keygen.c      **** 	 * If neg = 0 and cc = 1 then we must do nothing
1498:keygen.c      **** 	 *
1499:keygen.c      **** 	 * In the loop below, we conditionally subtract either m or -m
1500:keygen.c      **** 	 * from a. Word xm is a word of m (if neg = 0) or -m (if neg = 1);
1501:keygen.c      **** 	 * but if neg = 0 and cc = 1, then ym = 0 and it forces mw to 0.
1502:keygen.c      **** 	 */
1503:keygen.c      **** 	xm = -neg >> 1;
 6385              		.loc 2 1503 7
 6386 0044 3B68     		ldr	r3, [r7]
 6387 0046 5B42     		rsbs	r3, r3, #0
 6388              		.loc 2 1503 5
 6389 0048 5B08     		lsrs	r3, r3, #1
 6390 004a FB61     		str	r3, [r7, #28]
1504:keygen.c      **** 	ym = -(neg | (1 - cc));
 6391              		.loc 2 1504 18
 6392 004c 3B6A     		ldr	r3, [r7, #32]
 6393 004e C3F10102 		rsb	r2, r3, #1
 6394              		.loc 2 1504 13
 6395 0052 3B68     		ldr	r3, [r7]
 6396 0054 1343     		orrs	r3, r3, r2
 6397              		.loc 2 1504 5
 6398 0056 5B42     		rsbs	r3, r3, #0
 6399 0058 BB61     		str	r3, [r7, #24]
1505:keygen.c      **** 	cc = neg;
 6400              		.loc 2 1505 5
 6401 005a 3B68     		ldr	r3, [r7]
 6402 005c 3B62     		str	r3, [r7, #32]
1506:keygen.c      **** 	for (u = 0; u < len; u ++) {
 6403              		.loc 2 1506 9
 6404 005e 0023     		movs	r3, #0
 6405 0060 7B62     		str	r3, [r7, #36]
 6406              		.loc 2 1506 2
 6407 0062 23E0     		b	.L111
 6408              	.L112:
 6409              	.LBB20:
1507:keygen.c      **** 		uint32_t aw, mw;
1508:keygen.c      **** 
1509:keygen.c      **** 		aw = a[u];
 6410              		.loc 2 1509 9 discriminator 3
 6411 0064 7B6A     		ldr	r3, [r7, #36]
 6412 0066 9B00     		lsls	r3, r3, #2
 6413 0068 FA68     		ldr	r2, [r7, #12]
 6414 006a 1344     		add	r3, r3, r2
 6415              		.loc 2 1509 6 discriminator 3
 6416 006c 1B68     		ldr	r3, [r3]
 6417 006e 7B61     		str	r3, [r7, #20]
1510:keygen.c      **** 		mw = (m[u] ^ xm) & ym;
 6418              		.loc 2 1510 10 discriminator 3
 6419 0070 7B6A     		ldr	r3, [r7, #36]
 6420 0072 9B00     		lsls	r3, r3, #2
 6421 0074 7A68     		ldr	r2, [r7, #4]
 6422 0076 1344     		add	r3, r3, r2
 6423 0078 1A68     		ldr	r2, [r3]
 6424              		.loc 2 1510 14 discriminator 3
 6425 007a FB69     		ldr	r3, [r7, #28]
 6426 007c 5340     		eors	r3, r3, r2
 6427              		.loc 2 1510 6 discriminator 3
 6428 007e BA69     		ldr	r2, [r7, #24]
 6429 0080 1340     		ands	r3, r3, r2
 6430 0082 3B61     		str	r3, [r7, #16]
1511:keygen.c      **** 		aw = aw - mw - cc;
 6431              		.loc 2 1511 11 discriminator 3
 6432 0084 7A69     		ldr	r2, [r7, #20]
 6433 0086 3B69     		ldr	r3, [r7, #16]
 6434 0088 D21A     		subs	r2, r2, r3
 6435              		.loc 2 1511 6 discriminator 3
 6436 008a 3B6A     		ldr	r3, [r7, #32]
 6437 008c D31A     		subs	r3, r2, r3
 6438 008e 7B61     		str	r3, [r7, #20]
1512:keygen.c      **** 		a[u] = aw & 0x7FFFFFFF;
 6439              		.loc 2 1512 4 discriminator 3
 6440 0090 7B6A     		ldr	r3, [r7, #36]
 6441 0092 9B00     		lsls	r3, r3, #2
 6442 0094 FA68     		ldr	r2, [r7, #12]
 6443 0096 1344     		add	r3, r3, r2
 6444              		.loc 2 1512 13 discriminator 3
 6445 0098 7A69     		ldr	r2, [r7, #20]
 6446 009a 22F00042 		bic	r2, r2, #-2147483648
 6447              		.loc 2 1512 8 discriminator 3
 6448 009e 1A60     		str	r2, [r3]
1513:keygen.c      **** 		cc = aw >> 31;
 6449              		.loc 2 1513 6 discriminator 3
 6450 00a0 7B69     		ldr	r3, [r7, #20]
 6451 00a2 DB0F     		lsrs	r3, r3, #31
 6452 00a4 3B62     		str	r3, [r7, #32]
 6453              	.LBE20:
1506:keygen.c      **** 		uint32_t aw, mw;
 6454              		.loc 2 1506 25 discriminator 3
 6455 00a6 7B6A     		ldr	r3, [r7, #36]
 6456 00a8 0133     		adds	r3, r3, #1
 6457 00aa 7B62     		str	r3, [r7, #36]
 6458              	.L111:
1506:keygen.c      **** 		uint32_t aw, mw;
 6459              		.loc 2 1506 2 discriminator 1
 6460 00ac 7A6A     		ldr	r2, [r7, #36]
 6461 00ae BB68     		ldr	r3, [r7, #8]
 6462 00b0 9A42     		cmp	r2, r3
 6463 00b2 D7D3     		bcc	.L112
1514:keygen.c      **** 	}
1515:keygen.c      **** }
 6464              		.loc 2 1515 1
 6465 00b4 00BF     		nop
 6466 00b6 00BF     		nop
 6467 00b8 2C37     		adds	r7, r7, #44
 6468              	.LCFI162:
 6469              		.cfi_def_cfa_offset 4
 6470 00ba BD46     		mov	sp, r7
 6471              	.LCFI163:
 6472              		.cfi_def_cfa_register 13
 6473              		@ sp needed
 6474 00bc 80BC     		pop	{r7}
 6475              	.LCFI164:
 6476              		.cfi_restore 7
 6477              		.cfi_def_cfa_offset 0
 6478 00be 7047     		bx	lr
 6479              		.cfi_endproc
 6480              	.LFE41:
 6482              		.section	.text.zint_co_reduce_mod,"ax",%progbits
 6483              		.align	1
 6484              		.syntax unified
 6485              		.thumb
 6486              		.thumb_func
 6487              		.fpu softvfp
 6489              	zint_co_reduce_mod:
 6490              	.LFB42:
1516:keygen.c      **** 
1517:keygen.c      **** /*
1518:keygen.c      ****  * Replace a with (a*xa+b*xb)/(2^31) mod m, and b with
1519:keygen.c      ****  * (a*ya+b*yb)/(2^31) mod m. Modulus m must be odd; m0i = -1/m[0] mod 2^31.
1520:keygen.c      ****  */
1521:keygen.c      **** static void
1522:keygen.c      **** zint_co_reduce_mod(uint32_t *a, uint32_t *b, const uint32_t *m, size_t len,
1523:keygen.c      **** 	uint32_t m0i, int64_t xa, int64_t xb, int64_t ya, int64_t yb)
1524:keygen.c      **** {
 6491              		.loc 2 1524 1
 6492              		.cfi_startproc
 6493              		@ args = 40, pretend = 0, frame = 208
 6494              		@ frame_needed = 1, uses_anonymous_args = 0
 6495 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 6496              	.LCFI165:
 6497              		.cfi_def_cfa_offset 32
 6498              		.cfi_offset 4, -32
 6499              		.cfi_offset 5, -28
 6500              		.cfi_offset 7, -24
 6501              		.cfi_offset 8, -20
 6502              		.cfi_offset 9, -16
 6503              		.cfi_offset 10, -12
 6504              		.cfi_offset 11, -8
 6505              		.cfi_offset 14, -4
 6506 0004 B4B0     		sub	sp, sp, #208
 6507              	.LCFI166:
 6508              		.cfi_def_cfa_offset 240
 6509 0006 00AF     		add	r7, sp, #0
 6510              	.LCFI167:
 6511              		.cfi_def_cfa_register 7
 6512 0008 C7F89400 		str	r0, [r7, #148]
 6513 000c C7F89010 		str	r1, [r7, #144]
 6514 0010 C7F88C20 		str	r2, [r7, #140]
 6515 0014 C7F88830 		str	r3, [r7, #136]
1525:keygen.c      **** 	size_t u;
1526:keygen.c      **** 	int64_t cca, ccb;
1527:keygen.c      **** 	uint32_t fa, fb;
1528:keygen.c      **** 
1529:keygen.c      **** 	/*
1530:keygen.c      **** 	 * These are actually four combined Montgomery multiplications.
1531:keygen.c      **** 	 */
1532:keygen.c      **** 	cca = 0;
 6516              		.loc 2 1532 6
 6517 0018 4FF00002 		mov	r2, #0
 6518 001c 4FF00003 		mov	r3, #0
 6519 0020 C7E93023 		strd	r2, [r7, #192]
1533:keygen.c      **** 	ccb = 0;
 6520              		.loc 2 1533 6
 6521 0024 4FF00002 		mov	r2, #0
 6522 0028 4FF00003 		mov	r3, #0
 6523 002c C7E92E23 		strd	r2, [r7, #184]
1534:keygen.c      **** 	fa = ((a[0] * (uint32_t)xa + b[0] * (uint32_t)xb) * m0i) & 0x7FFFFFFF;
 6524              		.loc 2 1534 10
 6525 0030 D7F89430 		ldr	r3, [r7, #148]
 6526 0034 1A68     		ldr	r2, [r3]
 6527              		.loc 2 1534 16
 6528 0036 D7F8F830 		ldr	r3, [r7, #248]
 6529              		.loc 2 1534 14
 6530 003a 03FB02F1 		mul	r1, r3, r2
 6531              		.loc 2 1534 32
 6532 003e D7F89030 		ldr	r3, [r7, #144]
 6533 0042 1A68     		ldr	r2, [r3]
 6534              		.loc 2 1534 38
 6535 0044 D7F80031 		ldr	r3, [r7, #256]
 6536              		.loc 2 1534 36
 6537 0048 02FB03F3 		mul	r3, r2, r3
 6538              		.loc 2 1534 29
 6539 004c CA18     		adds	r2, r1, r3
 6540              		.loc 2 1534 52
 6541 004e D7F8F030 		ldr	r3, [r7, #240]
 6542 0052 02FB03F3 		mul	r3, r2, r3
 6543              		.loc 2 1534 5
 6544 0056 23F00043 		bic	r3, r3, #-2147483648
 6545 005a C7F8B430 		str	r3, [r7, #180]
1535:keygen.c      **** 	fb = ((a[0] * (uint32_t)ya + b[0] * (uint32_t)yb) * m0i) & 0x7FFFFFFF;
 6546              		.loc 2 1535 10
 6547 005e D7F89430 		ldr	r3, [r7, #148]
 6548 0062 1A68     		ldr	r2, [r3]
 6549              		.loc 2 1535 16
 6550 0064 D7F80831 		ldr	r3, [r7, #264]
 6551              		.loc 2 1535 14
 6552 0068 03FB02F1 		mul	r1, r3, r2
 6553              		.loc 2 1535 32
 6554 006c D7F89030 		ldr	r3, [r7, #144]
 6555 0070 1A68     		ldr	r2, [r3]
 6556              		.loc 2 1535 38
 6557 0072 D7F81031 		ldr	r3, [r7, #272]
 6558              		.loc 2 1535 36
 6559 0076 02FB03F3 		mul	r3, r2, r3
 6560              		.loc 2 1535 29
 6561 007a CA18     		adds	r2, r1, r3
 6562              		.loc 2 1535 52
 6563 007c D7F8F030 		ldr	r3, [r7, #240]
 6564 0080 02FB03F3 		mul	r3, r2, r3
 6565              		.loc 2 1535 5
 6566 0084 23F00043 		bic	r3, r3, #-2147483648
 6567 0088 C7F8B030 		str	r3, [r7, #176]
1536:keygen.c      **** 	for (u = 0; u < len; u ++) {
 6568              		.loc 2 1536 9
 6569 008c 0023     		movs	r3, #0
 6570 008e C7F8CC30 		str	r3, [r7, #204]
 6571              		.loc 2 1536 2
 6572 0092 2DE1     		b	.L114
 6573              	.L116:
 6574              	.LBB21:
1537:keygen.c      **** 		uint32_t wa, wb;
1538:keygen.c      **** 		uint64_t za, zb;
1539:keygen.c      **** 
1540:keygen.c      **** 		wa = a[u];
 6575              		.loc 2 1540 9
 6576 0094 D7F8CC30 		ldr	r3, [r7, #204]
 6577 0098 9A00     		lsls	r2, r3, #2
 6578 009a D7F89430 		ldr	r3, [r7, #148]
 6579 009e 1344     		add	r3, r3, r2
 6580              		.loc 2 1540 6
 6581 00a0 1B68     		ldr	r3, [r3]
 6582 00a2 C7F8AC30 		str	r3, [r7, #172]
1541:keygen.c      **** 		wb = b[u];
 6583              		.loc 2 1541 9
 6584 00a6 D7F8CC30 		ldr	r3, [r7, #204]
 6585 00aa 9A00     		lsls	r2, r3, #2
 6586 00ac D7F89030 		ldr	r3, [r7, #144]
 6587 00b0 1344     		add	r3, r3, r2
 6588              		.loc 2 1541 6
 6589 00b2 1B68     		ldr	r3, [r3]
 6590 00b4 C7F8A830 		str	r3, [r7, #168]
1542:keygen.c      **** 		za = wa * (uint64_t)xa + wb * (uint64_t)xb
 6591              		.loc 2 1542 11
 6592 00b8 D7F8AC30 		ldr	r3, [r7, #172]
 6593 00bc 0022     		movs	r2, #0
 6594 00be BB67     		str	r3, [r7, #120]
 6595 00c0 FA67     		str	r2, [r7, #124]
 6596              		.loc 2 1542 13
 6597 00c2 D7E93E23 		ldrd	r2, [r7, #248]
 6598              		.loc 2 1542 11
 6599 00c6 F96F     		ldr	r1, [r7, #124]
 6600 00c8 02FB01F0 		mul	r0, r2, r1
 6601 00cc B96F     		ldr	r1, [r7, #120]
 6602 00ce 01FB03F1 		mul	r1, r1, r3
 6603 00d2 0144     		add	r1, r1, r0
 6604 00d4 B86F     		ldr	r0, [r7, #120]
 6605 00d6 A0FB0232 		umull	r3, r2, r0, r2
 6606 00da C7F88420 		str	r2, [r7, #132]
 6607 00de C7F88030 		str	r3, [r7, #128]
 6608 00e2 D7F88430 		ldr	r3, [r7, #132]
 6609 00e6 CB18     		adds	r3, r1, r3
 6610 00e8 C7F88430 		str	r3, [r7, #132]
 6611              		.loc 2 1542 31
 6612 00ec D7F8A830 		ldr	r3, [r7, #168]
 6613 00f0 0022     		movs	r2, #0
 6614 00f2 3B67     		str	r3, [r7, #112]
 6615 00f4 7A67     		str	r2, [r7, #116]
 6616              		.loc 2 1542 33
 6617 00f6 D7E94023 		ldrd	r2, [r7, #256]
 6618              		.loc 2 1542 31
 6619 00fa 796F     		ldr	r1, [r7, #116]
 6620 00fc 02FB01F0 		mul	r0, r2, r1
 6621 0100 396F     		ldr	r1, [r7, #112]
 6622 0102 01FB03F1 		mul	r1, r1, r3
 6623 0106 0144     		add	r1, r1, r0
 6624 0108 386F     		ldr	r0, [r7, #112]
 6625 010a A0FB0232 		umull	r3, r2, r0, r2
 6626 010e FA66     		str	r2, [r7, #108]
 6627 0110 BB66     		str	r3, [r7, #104]
 6628 0112 FB6E     		ldr	r3, [r7, #108]
 6629 0114 CB18     		adds	r3, r1, r3
 6630 0116 FB66     		str	r3, [r7, #108]
 6631              		.loc 2 1542 26
 6632 0118 D7F88030 		ldr	r3, [r7, #128]
 6633 011c D7E91A01 		ldrd	r0, [r7, #104]
 6634 0120 0246     		mov	r2, r0
 6635 0122 9B18     		adds	r3, r3, r2
 6636 0124 BB63     		str	r3, [r7, #56]
 6637 0126 D7F88430 		ldr	r3, [r7, #132]
 6638 012a 0A46     		mov	r2, r1
 6639 012c 5341     		adcs	r3, r3, r2
 6640 012e FB63     		str	r3, [r7, #60]
1543:keygen.c      **** 			+ m[u] * (uint64_t)fa + (uint64_t)cca;
 6641              		.loc 2 1543 7
 6642 0130 D7F8CC30 		ldr	r3, [r7, #204]
 6643 0134 9A00     		lsls	r2, r3, #2
 6644 0136 D7F88C30 		ldr	r3, [r7, #140]
 6645 013a 1344     		add	r3, r3, r2
 6646 013c 1B68     		ldr	r3, [r3]
 6647 013e 0022     		movs	r2, #0
 6648 0140 3B62     		str	r3, [r7, #32]
 6649 0142 7A62     		str	r2, [r7, #36]
 6650              		.loc 2 1543 13
 6651 0144 D7F8B430 		ldr	r3, [r7, #180]
 6652 0148 0022     		movs	r2, #0
 6653 014a 3B66     		str	r3, [r7, #96]
 6654 014c 7A66     		str	r2, [r7, #100]
 6655              		.loc 2 1543 11
 6656 014e D7E90801 		ldrd	r0, [r7, #32]
 6657 0152 0B46     		mov	r3, r1
 6658 0154 3A6E     		ldr	r2, [r7, #96]
 6659 0156 02FB03F2 		mul	r2, r2, r3
 6660 015a 7B6E     		ldr	r3, [r7, #100]
 6661 015c 8446     		mov	ip, r0
 6662 015e 0CFB03F3 		mul	r3, ip, r3
 6663 0162 1344     		add	r3, r3, r2
 6664 0164 0246     		mov	r2, r0
 6665 0166 396E     		ldr	r1, [r7, #96]
 6666 0168 A2FB0121 		umull	r2, r1, r2, r1
 6667 016c F965     		str	r1, [r7, #92]
 6668 016e BA65     		str	r2, [r7, #88]
 6669 0170 FA6D     		ldr	r2, [r7, #92]
 6670 0172 1344     		add	r3, r3, r2
 6671 0174 FB65     		str	r3, [r7, #92]
 6672              		.loc 2 1543 4
 6673 0176 BB6B     		ldr	r3, [r7, #56]
 6674 0178 D7E91601 		ldrd	r0, [r7, #88]
 6675 017c 0246     		mov	r2, r0
 6676 017e 9B18     		adds	r3, r3, r2
 6677 0180 3B63     		str	r3, [r7, #48]
 6678 0182 FB6B     		ldr	r3, [r7, #60]
 6679 0184 0A46     		mov	r2, r1
 6680 0186 5341     		adcs	r3, r3, r2
 6681 0188 7B63     		str	r3, [r7, #52]
 6682              		.loc 2 1543 28
 6683 018a D7E93023 		ldrd	r2, [r7, #192]
 6684              		.loc 2 1543 26
 6685 018e 396B     		ldr	r1, [r7, #48]
 6686 0190 8918     		adds	r1, r1, r2
 6687 0192 B961     		str	r1, [r7, #24]
 6688 0194 796B     		ldr	r1, [r7, #52]
 6689 0196 41EB0303 		adc	r3, r1, r3
 6690 019a FB61     		str	r3, [r7, #28]
1542:keygen.c      **** 		za = wa * (uint64_t)xa + wb * (uint64_t)xb
 6691              		.loc 2 1542 6
 6692 019c D7E90623 		ldrd	r2, [r7, #24]
 6693 01a0 C7E92823 		strd	r2, [r7, #160]
1544:keygen.c      **** 		zb = wa * (uint64_t)ya + wb * (uint64_t)yb
 6694              		.loc 2 1544 11
 6695 01a4 D7F8AC30 		ldr	r3, [r7, #172]
 6696 01a8 0022     		movs	r2, #0
 6697 01aa 3B65     		str	r3, [r7, #80]
 6698 01ac 7A65     		str	r2, [r7, #84]
 6699              		.loc 2 1544 13
 6700 01ae D7E94223 		ldrd	r2, [r7, #264]
 6701              		.loc 2 1544 11
 6702 01b2 796D     		ldr	r1, [r7, #84]
 6703 01b4 02FB01F0 		mul	r0, r2, r1
 6704 01b8 396D     		ldr	r1, [r7, #80]
 6705 01ba 01FB03F1 		mul	r1, r1, r3
 6706 01be 0144     		add	r1, r1, r0
 6707 01c0 386D     		ldr	r0, [r7, #80]
 6708 01c2 A0FB0245 		umull	r4, r5, r0, r2
 6709 01c6 4B19     		adds	r3, r1, r5
 6710 01c8 1D46     		mov	r5, r3
 6711              		.loc 2 1544 31
 6712 01ca D7F8A830 		ldr	r3, [r7, #168]
 6713 01ce 0022     		movs	r2, #0
 6714 01d0 BB64     		str	r3, [r7, #72]
 6715 01d2 FA64     		str	r2, [r7, #76]
 6716              		.loc 2 1544 33
 6717 01d4 D7E94423 		ldrd	r2, [r7, #272]
 6718              		.loc 2 1544 31
 6719 01d8 F96C     		ldr	r1, [r7, #76]
 6720 01da 02FB01F0 		mul	r0, r2, r1
 6721 01de B96C     		ldr	r1, [r7, #72]
 6722 01e0 01FB03F1 		mul	r1, r1, r3
 6723 01e4 0144     		add	r1, r1, r0
 6724 01e6 B86C     		ldr	r0, [r7, #72]
 6725 01e8 A0FB02AB 		umull	r10, fp, r0, r2
 6726 01ec 01EB0B03 		add	r3, r1, fp
 6727 01f0 9B46     		mov	fp, r3
 6728              		.loc 2 1544 26
 6729 01f2 14EB0A03 		adds	r3, r4, r10
 6730 01f6 3B61     		str	r3, [r7, #16]
 6731 01f8 45EB0B03 		adc	r3, r5, fp
 6732 01fc 7B61     		str	r3, [r7, #20]
1545:keygen.c      **** 			+ m[u] * (uint64_t)fb + (uint64_t)ccb;
 6733              		.loc 2 1545 7
 6734 01fe D7F8CC30 		ldr	r3, [r7, #204]
 6735 0202 9A00     		lsls	r2, r3, #2
 6736 0204 D7F88C30 		ldr	r3, [r7, #140]
 6737 0208 1344     		add	r3, r3, r2
 6738 020a 1B68     		ldr	r3, [r3]
 6739 020c 0022     		movs	r2, #0
 6740 020e BB60     		str	r3, [r7, #8]
 6741 0210 FA60     		str	r2, [r7, #12]
 6742              		.loc 2 1545 13
 6743 0212 D7F8B030 		ldr	r3, [r7, #176]
 6744 0216 0022     		movs	r2, #0
 6745 0218 3B64     		str	r3, [r7, #64]
 6746 021a 7A64     		str	r2, [r7, #68]
 6747              		.loc 2 1545 11
 6748 021c D7E90201 		ldrd	r0, [r7, #8]
 6749 0220 0B46     		mov	r3, r1
 6750 0222 3A6C     		ldr	r2, [r7, #64]
 6751 0224 02FB03F2 		mul	r2, r2, r3
 6752 0228 7B6C     		ldr	r3, [r7, #68]
 6753 022a 8446     		mov	ip, r0
 6754 022c 0CFB03F3 		mul	r3, ip, r3
 6755 0230 1344     		add	r3, r3, r2
 6756 0232 0246     		mov	r2, r0
 6757 0234 396C     		ldr	r1, [r7, #64]
 6758 0236 A2FB0189 		umull	r8, r9, r2, r1
 6759 023a 4B44     		add	r3, r3, r9
 6760 023c 9946     		mov	r9, r3
 6761              		.loc 2 1545 4
 6762 023e D7E90423 		ldrd	r2, [r7, #16]
 6763 0242 1146     		mov	r1, r2
 6764 0244 11EB0801 		adds	r1, r1, r8
 6765 0248 B962     		str	r1, [r7, #40]
 6766 024a 43EB0903 		adc	r3, r3, r9
 6767 024e FB62     		str	r3, [r7, #44]
 6768              		.loc 2 1545 28
 6769 0250 D7E92E23 		ldrd	r2, [r7, #184]
 6770              		.loc 2 1545 26
 6771 0254 B96A     		ldr	r1, [r7, #40]
 6772 0256 8918     		adds	r1, r1, r2
 6773 0258 3960     		str	r1, [r7]
 6774 025a F96A     		ldr	r1, [r7, #44]
 6775 025c 41EB0303 		adc	r3, r1, r3
 6776 0260 7B60     		str	r3, [r7, #4]
1544:keygen.c      **** 		zb = wa * (uint64_t)ya + wb * (uint64_t)yb
 6777              		.loc 2 1544 6
 6778 0262 D7E90023 		ldrd	r2, [r7]
 6779 0266 C7E92623 		strd	r2, [r7, #152]
1546:keygen.c      **** 		if (u > 0) {
 6780              		.loc 2 1546 6
 6781 026a D7F8CC30 		ldr	r3, [r7, #204]
 6782 026e 002B     		cmp	r3, #0
 6783 0270 1DD0     		beq	.L115
1547:keygen.c      **** 			a[u - 1] = (uint32_t)za & 0x7FFFFFFF;
 6784              		.loc 2 1547 15
 6785 0272 D7E92823 		ldrd	r2, [r7, #160]
 6786 0276 1146     		mov	r1, r2
 6787              		.loc 2 1547 5
 6788 0278 D7F8CC30 		ldr	r3, [r7, #204]
 6789 027c 03F18043 		add	r3, r3, #1073741824
 6790 0280 013B     		subs	r3, r3, #1
 6791 0282 9A00     		lsls	r2, r3, #2
 6792 0284 D7F89430 		ldr	r3, [r7, #148]
 6793 0288 1A44     		add	r2, r2, r3
 6794              		.loc 2 1547 28
 6795 028a 21F00043 		bic	r3, r1, #-2147483648
 6796              		.loc 2 1547 13
 6797 028e 1360     		str	r3, [r2]
1548:keygen.c      **** 			b[u - 1] = (uint32_t)zb & 0x7FFFFFFF;
 6798              		.loc 2 1548 15
 6799 0290 D7E92623 		ldrd	r2, [r7, #152]
 6800 0294 1146     		mov	r1, r2
 6801              		.loc 2 1548 5
 6802 0296 D7F8CC30 		ldr	r3, [r7, #204]
 6803 029a 03F18043 		add	r3, r3, #1073741824
 6804 029e 013B     		subs	r3, r3, #1
 6805 02a0 9A00     		lsls	r2, r3, #2
 6806 02a2 D7F89030 		ldr	r3, [r7, #144]
 6807 02a6 1A44     		add	r2, r2, r3
 6808              		.loc 2 1548 28
 6809 02a8 21F00043 		bic	r3, r1, #-2147483648
 6810              		.loc 2 1548 13
 6811 02ac 1360     		str	r3, [r2]
 6812              	.L115:
1549:keygen.c      **** 		}
1550:keygen.c      **** 		cca = *(int64_t *)&za >> 31;
 6813              		.loc 2 1550 21 discriminator 2
 6814 02ae 07F1A003 		add	r3, r7, #160
 6815              		.loc 2 1550 9 discriminator 2
 6816 02b2 D3E90023 		ldrd	r2, [r3]
 6817              		.loc 2 1550 7 discriminator 2
 6818 02b6 4FF00000 		mov	r0, #0
 6819 02ba 4FF00001 		mov	r1, #0
 6820 02be D00F     		lsrs	r0, r2, #31
 6821 02c0 40EA4300 		orr	r0, r0, r3, lsl #1
 6822 02c4 D917     		asrs	r1, r3, #31
 6823 02c6 C7E93001 		strd	r0, [r7, #192]
1551:keygen.c      **** 		ccb = *(int64_t *)&zb >> 31;
 6824              		.loc 2 1551 21 discriminator 2
 6825 02ca 07F19803 		add	r3, r7, #152
 6826              		.loc 2 1551 9 discriminator 2
 6827 02ce D3E90023 		ldrd	r2, [r3]
 6828              		.loc 2 1551 7 discriminator 2
 6829 02d2 4FF00000 		mov	r0, #0
 6830 02d6 4FF00001 		mov	r1, #0
 6831 02da D00F     		lsrs	r0, r2, #31
 6832 02dc 40EA4300 		orr	r0, r0, r3, lsl #1
 6833 02e0 D917     		asrs	r1, r3, #31
 6834 02e2 C7E92E01 		strd	r0, [r7, #184]
 6835              	.LBE21:
1536:keygen.c      **** 		uint32_t wa, wb;
 6836              		.loc 2 1536 25 discriminator 2
 6837 02e6 D7F8CC30 		ldr	r3, [r7, #204]
 6838 02ea 0133     		adds	r3, r3, #1
 6839 02ec C7F8CC30 		str	r3, [r7, #204]
 6840              	.L114:
1536:keygen.c      **** 		uint32_t wa, wb;
 6841              		.loc 2 1536 2 discriminator 1
 6842 02f0 D7F8CC20 		ldr	r2, [r7, #204]
 6843 02f4 D7F88830 		ldr	r3, [r7, #136]
 6844 02f8 9A42     		cmp	r2, r3
 6845 02fa FFF4CBAE 		bcc	.L116
1552:keygen.c      **** 	}
1553:keygen.c      **** 	a[len - 1] = (uint32_t)cca;
 6846              		.loc 2 1553 3
 6847 02fe D7F88830 		ldr	r3, [r7, #136]
 6848 0302 03F18043 		add	r3, r3, #1073741824
 6849 0306 013B     		subs	r3, r3, #1
 6850 0308 9B00     		lsls	r3, r3, #2
 6851 030a D7F89420 		ldr	r2, [r7, #148]
 6852 030e 1344     		add	r3, r3, r2
 6853              		.loc 2 1553 15
 6854 0310 D7F8C020 		ldr	r2, [r7, #192]
 6855              		.loc 2 1553 13
 6856 0314 1A60     		str	r2, [r3]
1554:keygen.c      **** 	b[len - 1] = (uint32_t)ccb;
 6857              		.loc 2 1554 3
 6858 0316 D7F88830 		ldr	r3, [r7, #136]
 6859 031a 03F18043 		add	r3, r3, #1073741824
 6860 031e 013B     		subs	r3, r3, #1
 6861 0320 9B00     		lsls	r3, r3, #2
 6862 0322 D7F89020 		ldr	r2, [r7, #144]
 6863 0326 1344     		add	r3, r3, r2
 6864              		.loc 2 1554 15
 6865 0328 D7F8B820 		ldr	r2, [r7, #184]
 6866              		.loc 2 1554 13
 6867 032c 1A60     		str	r2, [r3]
1555:keygen.c      **** 
1556:keygen.c      **** 	/*
1557:keygen.c      **** 	 * At this point:
1558:keygen.c      **** 	 *   -m <= a < 2*m
1559:keygen.c      **** 	 *   -m <= b < 2*m
1560:keygen.c      **** 	 * (this is a case of Montgomery reduction)
1561:keygen.c      **** 	 * The top words of 'a' and 'b' may have a 32-th bit set.
1562:keygen.c      **** 	 * We want to add or subtract the modulus, as required.
1563:keygen.c      **** 	 */
1564:keygen.c      **** 	zint_finish_mod(a, len, m, (uint32_t)((uint64_t)cca >> 63));
 6868              		.loc 2 1564 40
 6869 032e D7E93001 		ldrd	r0, [r7, #192]
 6870              		.loc 2 1564 54
 6871 0332 4FF00002 		mov	r2, #0
 6872 0336 4FF00003 		mov	r3, #0
 6873 033a CA0F     		lsrs	r2, r1, #31
 6874 033c 0023     		movs	r3, #0
 6875              		.loc 2 1564 2
 6876 033e 1346     		mov	r3, r2
 6877 0340 D7F88C20 		ldr	r2, [r7, #140]
 6878 0344 D7F88810 		ldr	r1, [r7, #136]
 6879 0348 D7F89400 		ldr	r0, [r7, #148]
 6880 034c FFF7FEFF 		bl	zint_finish_mod
1565:keygen.c      **** 	zint_finish_mod(b, len, m, (uint32_t)((uint64_t)ccb >> 63));
 6881              		.loc 2 1565 40
 6882 0350 D7E92E01 		ldrd	r0, [r7, #184]
 6883              		.loc 2 1565 54
 6884 0354 4FF00002 		mov	r2, #0
 6885 0358 4FF00003 		mov	r3, #0
 6886 035c CA0F     		lsrs	r2, r1, #31
 6887 035e 0023     		movs	r3, #0
 6888              		.loc 2 1565 2
 6889 0360 1346     		mov	r3, r2
 6890 0362 D7F88C20 		ldr	r2, [r7, #140]
 6891 0366 D7F88810 		ldr	r1, [r7, #136]
 6892 036a D7F89000 		ldr	r0, [r7, #144]
 6893 036e FFF7FEFF 		bl	zint_finish_mod
1566:keygen.c      **** }
 6894              		.loc 2 1566 1
 6895 0372 00BF     		nop
 6896 0374 D037     		adds	r7, r7, #208
 6897              	.LCFI168:
 6898              		.cfi_def_cfa_offset 32
 6899 0376 BD46     		mov	sp, r7
 6900              	.LCFI169:
 6901              		.cfi_def_cfa_register 13
 6902              		@ sp needed
 6903 0378 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 6904              		.cfi_endproc
 6905              	.LFE42:
 6907              		.section	.text.zint_bezout,"ax",%progbits
 6908              		.align	1
 6909              		.syntax unified
 6910              		.thumb
 6911              		.thumb_func
 6912              		.fpu softvfp
 6914              	zint_bezout:
 6915              	.LFB43:
1567:keygen.c      **** 
1568:keygen.c      **** /*
1569:keygen.c      ****  * Compute a GCD between two positive big integers x and y. The two
1570:keygen.c      ****  * integers must be odd. Returned value is 1 if the GCD is 1, 0
1571:keygen.c      ****  * otherwise. When 1 is returned, arrays u and v are filled with values
1572:keygen.c      ****  * such that:
1573:keygen.c      ****  *   0 <= u <= y
1574:keygen.c      ****  *   0 <= v <= x
1575:keygen.c      ****  *   x*u - y*v = 1
1576:keygen.c      ****  * x[] and y[] are unmodified. Both input values must have the same
1577:keygen.c      ****  * encoded length. Temporary array must be large enough to accommodate 4
1578:keygen.c      ****  * extra values of that length. Arrays u, v and tmp may not overlap with
1579:keygen.c      ****  * each other, or with either x or y.
1580:keygen.c      ****  */
1581:keygen.c      **** static int
1582:keygen.c      **** zint_bezout(uint32_t *restrict u, uint32_t *restrict v,
1583:keygen.c      **** 	const uint32_t *restrict x, const uint32_t *restrict y,
1584:keygen.c      **** 	size_t len, uint32_t *restrict tmp)
1585:keygen.c      **** {
 6916              		.loc 2 1585 1
 6917              		.cfi_startproc
 6918              		@ args = 8, pretend = 0, frame = 848
 6919              		@ frame_needed = 1, uses_anonymous_args = 0
 6920 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 6921              	.LCFI170:
 6922              		.cfi_def_cfa_offset 32
 6923              		.cfi_offset 4, -32
 6924              		.cfi_offset 5, -28
 6925              		.cfi_offset 7, -24
 6926              		.cfi_offset 8, -20
 6927              		.cfi_offset 9, -16
 6928              		.cfi_offset 10, -12
 6929              		.cfi_offset 11, -8
 6930              		.cfi_offset 14, -4
 6931 0004 ADF55E7D 		sub	sp, sp, #888
 6932              	.LCFI171:
 6933              		.cfi_def_cfa_offset 920
 6934 0008 0AAF     		add	r7, sp, #40
 6935              	.LCFI172:
 6936              		.cfi_def_cfa 7, 880
 6937 000a C7F89C02 		str	r0, [r7, #668]
 6938 000e C7F89812 		str	r1, [r7, #664]
 6939 0012 C7F89422 		str	r2, [r7, #660]
 6940 0016 C7F89032 		str	r3, [r7, #656]
1586:keygen.c      **** 	/*
1587:keygen.c      **** 	 * Algorithm is an extended binary GCD. We maintain 6 values
1588:keygen.c      **** 	 * a, b, u0, u1, v0 and v1 with the following invariants:
1589:keygen.c      **** 	 *
1590:keygen.c      **** 	 *  a = x*u0 - y*v0
1591:keygen.c      **** 	 *  b = x*u1 - y*v1
1592:keygen.c      **** 	 *  0 <= a <= x
1593:keygen.c      **** 	 *  0 <= b <= y
1594:keygen.c      **** 	 *  0 <= u0 < y
1595:keygen.c      **** 	 *  0 <= v0 < x
1596:keygen.c      **** 	 *  0 <= u1 <= y
1597:keygen.c      **** 	 *  0 <= v1 < x
1598:keygen.c      **** 	 *
1599:keygen.c      **** 	 * Initial values are:
1600:keygen.c      **** 	 *
1601:keygen.c      **** 	 *  a = x   u0 = 1   v0 = 0
1602:keygen.c      **** 	 *  b = y   u1 = y   v1 = x-1
1603:keygen.c      **** 	 *
1604:keygen.c      **** 	 * Each iteration reduces either a or b, and maintains the
1605:keygen.c      **** 	 * invariants. Algorithm stops when a = b, at which point their
1606:keygen.c      **** 	 * common value is GCD(a,b) and (u0,v0) (or (u1,v1)) contains
1607:keygen.c      **** 	 * the values (u,v) we want to return.
1608:keygen.c      **** 	 *
1609:keygen.c      **** 	 * The formal definition of the algorithm is a sequence of steps:
1610:keygen.c      **** 	 *
1611:keygen.c      **** 	 *  - If a is even, then:
1612:keygen.c      **** 	 *        a <- a/2
1613:keygen.c      **** 	 *        u0 <- u0/2 mod y
1614:keygen.c      **** 	 *        v0 <- v0/2 mod x
1615:keygen.c      **** 	 *
1616:keygen.c      **** 	 *  - Otherwise, if b is even, then:
1617:keygen.c      **** 	 *        b <- b/2
1618:keygen.c      **** 	 *        u1 <- u1/2 mod y
1619:keygen.c      **** 	 *        v1 <- v1/2 mod x
1620:keygen.c      **** 	 *
1621:keygen.c      **** 	 *  - Otherwise, if a > b, then:
1622:keygen.c      **** 	 *        a <- (a-b)/2
1623:keygen.c      **** 	 *        u0 <- (u0-u1)/2 mod y
1624:keygen.c      **** 	 *        v0 <- (v0-v1)/2 mod x
1625:keygen.c      **** 	 *
1626:keygen.c      **** 	 *  - Otherwise:
1627:keygen.c      **** 	 *        b <- (b-a)/2
1628:keygen.c      **** 	 *        u1 <- (u1-u0)/2 mod y
1629:keygen.c      **** 	 *        v1 <- (v1-v0)/2 mod y
1630:keygen.c      **** 	 *
1631:keygen.c      **** 	 * We can show that the operations above preserve the invariants:
1632:keygen.c      **** 	 *
1633:keygen.c      **** 	 *  - If a is even, then u0 and v0 are either both even or both
1634:keygen.c      **** 	 *    odd (since a = x*u0 - y*v0, and x and y are both odd).
1635:keygen.c      **** 	 *    If u0 and v0 are both even, then (u0,v0) <- (u0/2,v0/2).
1636:keygen.c      **** 	 *    Otherwise, (u0,v0) <- ((u0+y)/2,(v0+x)/2). Either way,
1637:keygen.c      **** 	 *    the a = x*u0 - y*v0 invariant is preserved.
1638:keygen.c      **** 	 *
1639:keygen.c      **** 	 *  - The same holds for the case where b is even.
1640:keygen.c      **** 	 *
1641:keygen.c      **** 	 *  - If a and b are odd, and a > b, then:
1642:keygen.c      **** 	 *
1643:keygen.c      **** 	 *      a-b = x*(u0-u1) - y*(v0-v1)
1644:keygen.c      **** 	 *
1645:keygen.c      **** 	 *    In that situation, if u0 < u1, then x*(u0-u1) < 0, but
1646:keygen.c      **** 	 *    a-b > 0; therefore, it must be that v0 < v1, and the
1647:keygen.c      **** 	 *    first part of the update is: (u0,v0) <- (u0-u1+y,v0-v1+x),
1648:keygen.c      **** 	 *    which preserves the invariants. Otherwise, if u0 > u1,
1649:keygen.c      **** 	 *    then u0-u1 >= 1, thus x*(u0-u1) >= x. But a <= x and
1650:keygen.c      **** 	 *    b >= 0, hence a-b <= x. It follows that, in that case,
1651:keygen.c      **** 	 *    v0-v1 >= 0. The first part of the update is then:
1652:keygen.c      **** 	 *    (u0,v0) <- (u0-u1,v0-v1), which again preserves the
1653:keygen.c      **** 	 *    invariants.
1654:keygen.c      **** 	 *
1655:keygen.c      **** 	 *    Either way, once the subtraction is done, the new value of
1656:keygen.c      **** 	 *    a, which is the difference of two odd values, is even,
1657:keygen.c      **** 	 *    and the remaining of this step is a subcase of the
1658:keygen.c      **** 	 *    first algorithm case (i.e. when a is even).
1659:keygen.c      **** 	 *
1660:keygen.c      **** 	 *  - If a and b are odd, and b > a, then the a similar
1661:keygen.c      **** 	 *    argument holds.
1662:keygen.c      **** 	 *
1663:keygen.c      **** 	 * The values a and b start at x and y, respectively. Since x
1664:keygen.c      **** 	 * and y are odd, their GCD is odd, and it is easily seen that
1665:keygen.c      **** 	 * all steps conserve the GCD (GCD(a-b,b) = GCD(a, b);
1666:keygen.c      **** 	 * GCD(a/2,b) = GCD(a,b) if GCD(a,b) is odd). Moreover, either a
1667:keygen.c      **** 	 * or b is reduced by at least one bit at each iteration, so
1668:keygen.c      **** 	 * the algorithm necessarily converges on the case a = b, at
1669:keygen.c      **** 	 * which point the common value is the GCD.
1670:keygen.c      **** 	 *
1671:keygen.c      **** 	 * In the algorithm expressed above, when a = b, the fourth case
1672:keygen.c      **** 	 * applies, and sets b = 0. Since a contains the GCD of x and y,
1673:keygen.c      **** 	 * which are both odd, a must be odd, and subsequent iterations
1674:keygen.c      **** 	 * (if any) will simply divide b by 2 repeatedly, which has no
1675:keygen.c      **** 	 * consequence. Thus, the algorithm can run for more iterations
1676:keygen.c      **** 	 * than necessary; the final GCD will be in a, and the (u,v)
1677:keygen.c      **** 	 * coefficients will be (u0,v0).
1678:keygen.c      **** 	 *
1679:keygen.c      **** 	 *
1680:keygen.c      **** 	 * The presentation above is bit-by-bit. It can be sped up by
1681:keygen.c      **** 	 * noticing that all decisions are taken based on the low bits
1682:keygen.c      **** 	 * and high bits of a and b. We can extract the two top words
1683:keygen.c      **** 	 * and low word of each of a and b, and compute reduction
1684:keygen.c      **** 	 * parameters pa, pb, qa and qb such that the new values for
1685:keygen.c      **** 	 * a and b are:
1686:keygen.c      **** 	 *    a' = (a*pa + b*pb) / (2^31)
1687:keygen.c      **** 	 *    b' = (a*qa + b*qb) / (2^31)
1688:keygen.c      **** 	 * the two divisions being exact. The coefficients are obtained
1689:keygen.c      **** 	 * just from the extracted words, and may be slightly off, requiring
1690:keygen.c      **** 	 * an optional correction: if a' < 0, then we replace pa with -pa
1691:keygen.c      **** 	 * and pb with -pb. Each such step will reduce the total length
1692:keygen.c      **** 	 * (sum of lengths of a and b) by at least 30 bits at each
1693:keygen.c      **** 	 * iteration.
1694:keygen.c      **** 	 */
1695:keygen.c      **** 	uint32_t *u0, *u1, *v0, *v1, *a, *b;
1696:keygen.c      **** 	uint32_t x0i, y0i;
1697:keygen.c      **** 	uint32_t num, rc;
1698:keygen.c      **** 	size_t j;
1699:keygen.c      **** 
1700:keygen.c      **** 	if (len == 0) {
 6941              		.loc 2 1700 5
 6942 001a D7F87033 		ldr	r3, [r7, #880]
 6943 001e 002B     		cmp	r3, #0
 6944 0020 02D1     		bne	.L118
1701:keygen.c      **** 		return 0;
 6945              		.loc 2 1701 10
 6946 0022 0023     		movs	r3, #0
 6947 0024 00F006BE 		b	.L119
 6948              	.L118:
1702:keygen.c      **** 	}
1703:keygen.c      **** 
1704:keygen.c      **** 	/*
1705:keygen.c      **** 	 * u0 and v0 are the u and v result buffers; the four other
1706:keygen.c      **** 	 * values (u1, v1, a and b) are taken from tmp[].
1707:keygen.c      **** 	 */
1708:keygen.c      **** 	u0 = u;
 6949              		.loc 2 1708 5
 6950 0028 D7F89C32 		ldr	r3, [r7, #668]
 6951 002c C7F8E832 		str	r3, [r7, #744]
1709:keygen.c      **** 	v0 = v;
 6952              		.loc 2 1709 5
 6953 0030 D7F89832 		ldr	r3, [r7, #664]
 6954 0034 C7F8E432 		str	r3, [r7, #740]
1710:keygen.c      **** 	u1 = tmp;
 6955              		.loc 2 1710 5
 6956 0038 D7F87433 		ldr	r3, [r7, #884]
 6957 003c C7F8E032 		str	r3, [r7, #736]
1711:keygen.c      **** 	v1 = u1 + len;
 6958              		.loc 2 1711 10
 6959 0040 D7F87033 		ldr	r3, [r7, #880]
 6960 0044 9A00     		lsls	r2, r3, #2
 6961              		.loc 2 1711 5
 6962 0046 D7F8E032 		ldr	r3, [r7, #736]
 6963 004a 1344     		add	r3, r3, r2
 6964 004c C7F8DC32 		str	r3, [r7, #732]
1712:keygen.c      **** 	a = v1 + len;
 6965              		.loc 2 1712 9
 6966 0050 D7F87033 		ldr	r3, [r7, #880]
 6967 0054 9A00     		lsls	r2, r3, #2
 6968              		.loc 2 1712 4
 6969 0056 D7F8DC32 		ldr	r3, [r7, #732]
 6970 005a 1344     		add	r3, r3, r2
 6971 005c C7F8D832 		str	r3, [r7, #728]
1713:keygen.c      **** 	b = a + len;
 6972              		.loc 2 1713 8
 6973 0060 D7F87033 		ldr	r3, [r7, #880]
 6974 0064 9A00     		lsls	r2, r3, #2
 6975              		.loc 2 1713 4
 6976 0066 D7F8D832 		ldr	r3, [r7, #728]
 6977 006a 1344     		add	r3, r3, r2
 6978 006c C7F8D432 		str	r3, [r7, #724]
1714:keygen.c      **** 
1715:keygen.c      **** 	/*
1716:keygen.c      **** 	 * We'll need the Montgomery reduction coefficients.
1717:keygen.c      **** 	 */
1718:keygen.c      **** 	x0i = modp_ninv31(x[0]);
 6979              		.loc 2 1718 8
 6980 0070 D7F89432 		ldr	r3, [r7, #660]
 6981 0074 1B68     		ldr	r3, [r3]
 6982 0076 1846     		mov	r0, r3
 6983 0078 FFF7FEFF 		bl	modp_ninv31
 6984 007c C7F8D002 		str	r0, [r7, #720]
1719:keygen.c      **** 	y0i = modp_ninv31(y[0]);
 6985              		.loc 2 1719 8
 6986 0080 D7F89032 		ldr	r3, [r7, #656]
 6987 0084 1B68     		ldr	r3, [r3]
 6988 0086 1846     		mov	r0, r3
 6989 0088 FFF7FEFF 		bl	modp_ninv31
 6990 008c C7F8CC02 		str	r0, [r7, #716]
1720:keygen.c      **** 
1721:keygen.c      **** 	/*
1722:keygen.c      **** 	 * Initialize a, b, u0, u1, v0 and v1.
1723:keygen.c      **** 	 *  a = x   u0 = 1   v0 = 0
1724:keygen.c      **** 	 *  b = y   u1 = y   v1 = x-1
1725:keygen.c      **** 	 * Note that x is odd, so computing x-1 is easy.
1726:keygen.c      **** 	 */
1727:keygen.c      **** 	memcpy(a, x, len * sizeof *x);
 6991              		.loc 2 1727 2
 6992 0090 D7F87033 		ldr	r3, [r7, #880]
 6993 0094 9B00     		lsls	r3, r3, #2
 6994 0096 1A46     		mov	r2, r3
 6995 0098 D7F89412 		ldr	r1, [r7, #660]
 6996 009c D7F8D802 		ldr	r0, [r7, #728]
 6997 00a0 FFF7FEFF 		bl	memcpy
1728:keygen.c      **** 	memcpy(b, y, len * sizeof *y);
 6998              		.loc 2 1728 2
 6999 00a4 D7F87033 		ldr	r3, [r7, #880]
 7000 00a8 9B00     		lsls	r3, r3, #2
 7001 00aa 1A46     		mov	r2, r3
 7002 00ac D7F89012 		ldr	r1, [r7, #656]
 7003 00b0 D7F8D402 		ldr	r0, [r7, #724]
 7004 00b4 FFF7FEFF 		bl	memcpy
1729:keygen.c      **** 	u0[0] = 1;
 7005              		.loc 2 1729 8
 7006 00b8 D7F8E822 		ldr	r2, [r7, #744]
 7007 00bc 0123     		movs	r3, #1
 7008 00be 1360     		str	r3, [r2]
1730:keygen.c      **** 	memset(u0 + 1, 0, (len - 1) * sizeof *u0);
 7009              		.loc 2 1730 12
 7010 00c0 D7F8E832 		ldr	r3, [r7, #744]
 7011 00c4 181D     		adds	r0, r3, #4
 7012              		.loc 2 1730 25
 7013 00c6 D7F87033 		ldr	r3, [r7, #880]
 7014 00ca 013B     		subs	r3, r3, #1
 7015              		.loc 2 1730 2
 7016 00cc 9B00     		lsls	r3, r3, #2
 7017 00ce 1A46     		mov	r2, r3
 7018 00d0 0021     		movs	r1, #0
 7019 00d2 FFF7FEFF 		bl	memset
1731:keygen.c      **** 	memset(v0, 0, len * sizeof *v0);
 7020              		.loc 2 1731 2
 7021 00d6 D7F87033 		ldr	r3, [r7, #880]
 7022 00da 9B00     		lsls	r3, r3, #2
 7023 00dc 1A46     		mov	r2, r3
 7024 00de 0021     		movs	r1, #0
 7025 00e0 D7F8E402 		ldr	r0, [r7, #740]
 7026 00e4 FFF7FEFF 		bl	memset
1732:keygen.c      **** 	memcpy(u1, y, len * sizeof *u1);
 7027              		.loc 2 1732 2
 7028 00e8 D7F87033 		ldr	r3, [r7, #880]
 7029 00ec 9B00     		lsls	r3, r3, #2
 7030 00ee 1A46     		mov	r2, r3
 7031 00f0 D7F89012 		ldr	r1, [r7, #656]
 7032 00f4 D7F8E002 		ldr	r0, [r7, #736]
 7033 00f8 FFF7FEFF 		bl	memcpy
1733:keygen.c      **** 	memcpy(v1, x, len * sizeof *v1);
 7034              		.loc 2 1733 2
 7035 00fc D7F87033 		ldr	r3, [r7, #880]
 7036 0100 9B00     		lsls	r3, r3, #2
 7037 0102 1A46     		mov	r2, r3
 7038 0104 D7F89412 		ldr	r1, [r7, #660]
 7039 0108 D7F8DC02 		ldr	r0, [r7, #732]
 7040 010c FFF7FEFF 		bl	memcpy
1734:keygen.c      **** 	v1[0] --;
 7041              		.loc 2 1734 4
 7042 0110 D7F8DC32 		ldr	r3, [r7, #732]
 7043 0114 1B68     		ldr	r3, [r3]
 7044              		.loc 2 1734 8
 7045 0116 5A1E     		subs	r2, r3, #1
 7046 0118 D7F8DC32 		ldr	r3, [r7, #732]
 7047 011c 1A60     		str	r2, [r3]
1735:keygen.c      **** 
1736:keygen.c      **** 	/*
1737:keygen.c      **** 	 * Each input operand may be as large as 31*len bits, and we
1738:keygen.c      **** 	 * reduce the total length by at least 30 bits at each iteration.
1739:keygen.c      **** 	 */
1740:keygen.c      **** 	for (num = 62 * (uint32_t)len + 30; num >= 30; num -= 30) {
 7048              		.loc 2 1740 16
 7049 011e D7F87023 		ldr	r2, [r7, #880]
 7050 0122 1346     		mov	r3, r2
 7051 0124 5B01     		lsls	r3, r3, #5
 7052 0126 9B1A     		subs	r3, r3, r2
 7053 0128 5B00     		lsls	r3, r3, #1
 7054              		.loc 2 1740 11
 7055 012a 1E33     		adds	r3, r3, #30
 7056 012c C7F84C33 		str	r3, [r7, #844]
 7057              		.loc 2 1740 2
 7058 0130 00F049BD 		b	.L120
 7059              	.L125:
 7060              	.LBB22:
1741:keygen.c      **** 		uint32_t c0, c1;
1742:keygen.c      **** 		uint32_t a0, a1, b0, b1;
1743:keygen.c      **** 		uint64_t a_hi, b_hi;
1744:keygen.c      **** 		uint32_t a_lo, b_lo;
1745:keygen.c      **** 		int64_t pa, pb, qa, qb;
1746:keygen.c      **** 		int i;
1747:keygen.c      **** 		uint32_t r;
1748:keygen.c      **** 
1749:keygen.c      **** 		/*
1750:keygen.c      **** 		 * Extract the top words of a and b. If j is the highest
1751:keygen.c      **** 		 * index >= 1 such that a[j] != 0 or b[j] != 0, then we
1752:keygen.c      **** 		 * want (a[j] << 31) + a[j-1] and (b[j] << 31) + b[j-1].
1753:keygen.c      **** 		 * If a and b are down to one word each, then we use
1754:keygen.c      **** 		 * a[0] and b[0].
1755:keygen.c      **** 		 */
1756:keygen.c      **** 		c0 = (uint32_t)-1;
 7061              		.loc 2 1756 6
 7062 0134 4FF0FF33 		mov	r3, #-1
 7063 0138 C7F84033 		str	r3, [r7, #832]
1757:keygen.c      **** 		c1 = (uint32_t)-1;
 7064              		.loc 2 1757 6
 7065 013c 4FF0FF33 		mov	r3, #-1
 7066 0140 C7F83C33 		str	r3, [r7, #828]
1758:keygen.c      **** 		a0 = 0;
 7067              		.loc 2 1758 6
 7068 0144 0023     		movs	r3, #0
 7069 0146 C7F83833 		str	r3, [r7, #824]
1759:keygen.c      **** 		a1 = 0;
 7070              		.loc 2 1759 6
 7071 014a 0023     		movs	r3, #0
 7072 014c C7F83433 		str	r3, [r7, #820]
1760:keygen.c      **** 		b0 = 0;
 7073              		.loc 2 1760 6
 7074 0150 0023     		movs	r3, #0
 7075 0152 C7F83033 		str	r3, [r7, #816]
1761:keygen.c      **** 		b1 = 0;
 7076              		.loc 2 1761 6
 7077 0156 0023     		movs	r3, #0
 7078 0158 C7F82C33 		str	r3, [r7, #812]
1762:keygen.c      **** 		j = len;
 7079              		.loc 2 1762 5
 7080 015c D7F87033 		ldr	r3, [r7, #880]
 7081 0160 C7F84433 		str	r3, [r7, #836]
1763:keygen.c      **** 		while (j -- > 0) {
 7082              		.loc 2 1763 9
 7083 0164 58E0     		b	.L121
 7084              	.L122:
 7085              	.LBB23:
1764:keygen.c      **** 			uint32_t aw, bw;
1765:keygen.c      **** 
1766:keygen.c      **** 			aw = a[j];
 7086              		.loc 2 1766 10
 7087 0166 D7F84433 		ldr	r3, [r7, #836]
 7088 016a 9A00     		lsls	r2, r3, #2
 7089 016c D7F8D832 		ldr	r3, [r7, #728]
 7090 0170 1344     		add	r3, r3, r2
 7091              		.loc 2 1766 7
 7092 0172 1B68     		ldr	r3, [r3]
 7093 0174 C7F8A432 		str	r3, [r7, #676]
1767:keygen.c      **** 			bw = b[j];
 7094              		.loc 2 1767 10
 7095 0178 D7F84433 		ldr	r3, [r7, #836]
 7096 017c 9A00     		lsls	r2, r3, #2
 7097 017e D7F8D432 		ldr	r3, [r7, #724]
 7098 0182 1344     		add	r3, r3, r2
 7099              		.loc 2 1767 7
 7100 0184 1B68     		ldr	r3, [r3]
 7101 0186 C7F8A032 		str	r3, [r7, #672]
1768:keygen.c      **** 			a0 ^= (a0 ^ aw) & c0;
 7102              		.loc 2 1768 14
 7103 018a D7F83823 		ldr	r2, [r7, #824]
 7104 018e D7F8A432 		ldr	r3, [r7, #676]
 7105 0192 5A40     		eors	r2, r2, r3
 7106              		.loc 2 1768 20
 7107 0194 D7F84033 		ldr	r3, [r7, #832]
 7108 0198 1A40     		ands	r2, r2, r3
 7109              		.loc 2 1768 7
 7110 019a D7F83833 		ldr	r3, [r7, #824]
 7111 019e 5340     		eors	r3, r3, r2
 7112 01a0 C7F83833 		str	r3, [r7, #824]
1769:keygen.c      **** 			a1 ^= (a1 ^ aw) & c1;
 7113              		.loc 2 1769 14
 7114 01a4 D7F83423 		ldr	r2, [r7, #820]
 7115 01a8 D7F8A432 		ldr	r3, [r7, #676]
 7116 01ac 5A40     		eors	r2, r2, r3
 7117              		.loc 2 1769 20
 7118 01ae D7F83C33 		ldr	r3, [r7, #828]
 7119 01b2 1A40     		ands	r2, r2, r3
 7120              		.loc 2 1769 7
 7121 01b4 D7F83433 		ldr	r3, [r7, #820]
 7122 01b8 5340     		eors	r3, r3, r2
 7123 01ba C7F83433 		str	r3, [r7, #820]
1770:keygen.c      **** 			b0 ^= (b0 ^ bw) & c0;
 7124              		.loc 2 1770 14
 7125 01be D7F83023 		ldr	r2, [r7, #816]
 7126 01c2 D7F8A032 		ldr	r3, [r7, #672]
 7127 01c6 5A40     		eors	r2, r2, r3
 7128              		.loc 2 1770 20
 7129 01c8 D7F84033 		ldr	r3, [r7, #832]
 7130 01cc 1A40     		ands	r2, r2, r3
 7131              		.loc 2 1770 7
 7132 01ce D7F83033 		ldr	r3, [r7, #816]
 7133 01d2 5340     		eors	r3, r3, r2
 7134 01d4 C7F83033 		str	r3, [r7, #816]
1771:keygen.c      **** 			b1 ^= (b1 ^ bw) & c1;
 7135              		.loc 2 1771 14
 7136 01d8 D7F82C23 		ldr	r2, [r7, #812]
 7137 01dc D7F8A032 		ldr	r3, [r7, #672]
 7138 01e0 5A40     		eors	r2, r2, r3
 7139              		.loc 2 1771 20
 7140 01e2 D7F83C33 		ldr	r3, [r7, #828]
 7141 01e6 1A40     		ands	r2, r2, r3
 7142              		.loc 2 1771 7
 7143 01e8 D7F82C33 		ldr	r3, [r7, #812]
 7144 01ec 5340     		eors	r3, r3, r2
 7145 01ee C7F82C33 		str	r3, [r7, #812]
1772:keygen.c      **** 			c1 = c0;
 7146              		.loc 2 1772 7
 7147 01f2 D7F84033 		ldr	r3, [r7, #832]
 7148 01f6 C7F83C33 		str	r3, [r7, #828]
1773:keygen.c      **** 			c0 &= (((aw | bw) + 0x7FFFFFFF) >> 31) - (uint32_t)1;
 7149              		.loc 2 1773 16
 7150 01fa D7F8A422 		ldr	r2, [r7, #676]
 7151 01fe D7F8A032 		ldr	r3, [r7, #672]
 7152 0202 1343     		orrs	r3, r3, r2
 7153              		.loc 2 1773 22
 7154 0204 03F10043 		add	r3, r3, #-2147483648
 7155 0208 013B     		subs	r3, r3, #1
 7156              		.loc 2 1773 36
 7157 020a DB0F     		lsrs	r3, r3, #31
 7158              		.loc 2 1773 43
 7159 020c 5A1E     		subs	r2, r3, #1
 7160              		.loc 2 1773 7
 7161 020e D7F84033 		ldr	r3, [r7, #832]
 7162 0212 1340     		ands	r3, r3, r2
 7163 0214 C7F84033 		str	r3, [r7, #832]
 7164              	.L121:
 7165              	.LBE23:
1763:keygen.c      **** 			uint32_t aw, bw;
 7166              		.loc 2 1763 12
 7167 0218 D7F84423 		ldr	r2, [r7, #836]
 7168 021c 531E     		subs	r3, r2, #1
 7169 021e C7F84433 		str	r3, [r7, #836]
1763:keygen.c      **** 			uint32_t aw, bw;
 7170              		.loc 2 1763 9
 7171 0222 002A     		cmp	r2, #0
 7172 0224 9FD1     		bne	.L122
1774:keygen.c      **** 		}
1775:keygen.c      **** 
1776:keygen.c      **** 		/*
1777:keygen.c      **** 		 * If c1 = 0, then we grabbed two words for a and b.
1778:keygen.c      **** 		 * If c1 != 0 but c0 = 0, then we grabbed one word. It
1779:keygen.c      **** 		 * is not possible that c1 != 0 and c0 != 0, because that
1780:keygen.c      **** 		 * would mean that both integers are zero.
1781:keygen.c      **** 		 */
1782:keygen.c      **** 		a1 |= a0 & c1;
 7173              		.loc 2 1782 12
 7174 0226 D7F83823 		ldr	r2, [r7, #824]
 7175 022a D7F83C33 		ldr	r3, [r7, #828]
 7176 022e 1A40     		ands	r2, r2, r3
 7177              		.loc 2 1782 6
 7178 0230 D7F83433 		ldr	r3, [r7, #820]
 7179 0234 1343     		orrs	r3, r3, r2
 7180 0236 C7F83433 		str	r3, [r7, #820]
1783:keygen.c      **** 		a0 &= ~c1;
 7181              		.loc 2 1783 9
 7182 023a D7F83C33 		ldr	r3, [r7, #828]
 7183 023e DA43     		mvns	r2, r3
 7184              		.loc 2 1783 6
 7185 0240 D7F83833 		ldr	r3, [r7, #824]
 7186 0244 1340     		ands	r3, r3, r2
 7187 0246 C7F83833 		str	r3, [r7, #824]
1784:keygen.c      **** 		b1 |= b0 & c1;
 7188              		.loc 2 1784 12
 7189 024a D7F83023 		ldr	r2, [r7, #816]
 7190 024e D7F83C33 		ldr	r3, [r7, #828]
 7191 0252 1A40     		ands	r2, r2, r3
 7192              		.loc 2 1784 6
 7193 0254 D7F82C33 		ldr	r3, [r7, #812]
 7194 0258 1343     		orrs	r3, r3, r2
 7195 025a C7F82C33 		str	r3, [r7, #812]
1785:keygen.c      **** 		b0 &= ~c1;
 7196              		.loc 2 1785 9
 7197 025e D7F83C33 		ldr	r3, [r7, #828]
 7198 0262 DA43     		mvns	r2, r3
 7199              		.loc 2 1785 6
 7200 0264 D7F83033 		ldr	r3, [r7, #816]
 7201 0268 1340     		ands	r3, r3, r2
 7202 026a C7F83033 		str	r3, [r7, #816]
1786:keygen.c      **** 		a_hi = ((uint64_t)a0 << 31) + a1;
 7203              		.loc 2 1786 11
 7204 026e D7F83833 		ldr	r3, [r7, #824]
 7205 0272 0022     		movs	r2, #0
 7206 0274 C7F83832 		str	r3, [r7, #568]
 7207 0278 C7F83C22 		str	r2, [r7, #572]
 7208              		.loc 2 1786 24
 7209 027c D7E98E12 		ldrd	r1, [r7, #568]
 7210 0280 0B46     		mov	r3, r1
 7211 0282 5B08     		lsrs	r3, r3, #1
 7212 0284 C7F88C32 		str	r3, [r7, #652]
 7213 0288 0B46     		mov	r3, r1
 7214 028a DB07     		lsls	r3, r3, #31
 7215 028c C7F88832 		str	r3, [r7, #648]
 7216              		.loc 2 1786 31
 7217 0290 D7F83433 		ldr	r3, [r7, #820]
 7218 0294 0022     		movs	r2, #0
 7219 0296 C7F83032 		str	r3, [r7, #560]
 7220 029a C7F83422 		str	r2, [r7, #564]
 7221              		.loc 2 1786 8
 7222 029e D7F88832 		ldr	r3, [r7, #648]
 7223 02a2 D7E98C01 		ldrd	r0, [r7, #560]
 7224 02a6 0246     		mov	r2, r0
 7225 02a8 9B18     		adds	r3, r3, r2
 7226 02aa C7F8B030 		str	r3, [r7, #176]
 7227 02ae D7F88C32 		ldr	r3, [r7, #652]
 7228 02b2 0A46     		mov	r2, r1
 7229 02b4 5341     		adcs	r3, r3, r2
 7230 02b6 C7F8B430 		str	r3, [r7, #180]
 7231 02ba D7E92C23 		ldrd	r2, [r7, #176]
 7232 02be C7E9C823 		strd	r2, [r7, #800]
1787:keygen.c      **** 		b_hi = ((uint64_t)b0 << 31) + b1;
 7233              		.loc 2 1787 11
 7234 02c2 D7F83033 		ldr	r3, [r7, #816]
 7235 02c6 0022     		movs	r2, #0
 7236 02c8 C7F82832 		str	r3, [r7, #552]
 7237 02cc C7F82C22 		str	r2, [r7, #556]
 7238              		.loc 2 1787 24
 7239 02d0 D7E98A12 		ldrd	r1, [r7, #552]
 7240 02d4 0B46     		mov	r3, r1
 7241 02d6 5B08     		lsrs	r3, r3, #1
 7242 02d8 C7F88432 		str	r3, [r7, #644]
 7243 02dc 0B46     		mov	r3, r1
 7244 02de DB07     		lsls	r3, r3, #31
 7245 02e0 C7F88032 		str	r3, [r7, #640]
 7246              		.loc 2 1787 31
 7247 02e4 D7F82C33 		ldr	r3, [r7, #812]
 7248 02e8 0022     		movs	r2, #0
 7249 02ea C7F82032 		str	r3, [r7, #544]
 7250 02ee C7F82422 		str	r2, [r7, #548]
 7251              		.loc 2 1787 8
 7252 02f2 D7F88032 		ldr	r3, [r7, #640]
 7253 02f6 D7E98801 		ldrd	r0, [r7, #544]
 7254 02fa 0246     		mov	r2, r0
 7255 02fc 9B18     		adds	r3, r3, r2
 7256 02fe C7F8A830 		str	r3, [r7, #168]
 7257 0302 D7F88432 		ldr	r3, [r7, #644]
 7258 0306 0A46     		mov	r2, r1
 7259 0308 5341     		adcs	r3, r3, r2
 7260 030a C7F8AC30 		str	r3, [r7, #172]
 7261 030e D7E92A23 		ldrd	r2, [r7, #168]
 7262 0312 C7E9C623 		strd	r2, [r7, #792]
1788:keygen.c      **** 		a_lo = a[0];
 7263              		.loc 2 1788 8
 7264 0316 D7F8D832 		ldr	r3, [r7, #728]
 7265 031a 1B68     		ldr	r3, [r3]
 7266 031c C7F81433 		str	r3, [r7, #788]
1789:keygen.c      **** 		b_lo = b[0];
 7267              		.loc 2 1789 8
 7268 0320 D7F8D432 		ldr	r3, [r7, #724]
 7269 0324 1B68     		ldr	r3, [r3]
 7270 0326 C7F81033 		str	r3, [r7, #784]
1790:keygen.c      **** 
1791:keygen.c      **** 		/*
1792:keygen.c      **** 		 * Compute reduction factors:
1793:keygen.c      **** 		 *
1794:keygen.c      **** 		 *   a' = a*pa + b*pb
1795:keygen.c      **** 		 *   b' = a*qa + b*qb
1796:keygen.c      **** 		 *
1797:keygen.c      **** 		 * such that a' and b' are both multiple of 2^31, but are
1798:keygen.c      **** 		 * only marginally larger than a and b.
1799:keygen.c      **** 		 */
1800:keygen.c      **** 		pa = 1;
 7271              		.loc 2 1800 6
 7272 032a 4FF00102 		mov	r2, #1
 7273 032e 4FF00003 		mov	r3, #0
 7274 0332 C7E9C223 		strd	r2, [r7, #776]
1801:keygen.c      **** 		pb = 0;
 7275              		.loc 2 1801 6
 7276 0336 4FF00002 		mov	r2, #0
 7277 033a 4FF00003 		mov	r3, #0
 7278 033e C7E9C023 		strd	r2, [r7, #768]
1802:keygen.c      **** 		qa = 0;
 7279              		.loc 2 1802 6
 7280 0342 4FF00002 		mov	r2, #0
 7281 0346 4FF00003 		mov	r3, #0
 7282 034a C7E9BE23 		strd	r2, [r7, #760]
1803:keygen.c      **** 		qb = 1;
 7283              		.loc 2 1803 6
 7284 034e 4FF00102 		mov	r2, #1
 7285 0352 4FF00003 		mov	r3, #0
 7286 0356 C7E9BC23 		strd	r2, [r7, #752]
1804:keygen.c      **** 		for (i = 0; i < 31; i ++) {
 7287              		.loc 2 1804 10
 7288 035a 0023     		movs	r3, #0
 7289 035c C7F8EC32 		str	r3, [r7, #748]
 7290              		.loc 2 1804 3
 7291 0360 EBE2     		b	.L123
 7292              	.L124:
 7293              	.LBB24:
1805:keygen.c      **** 			/*
1806:keygen.c      **** 			 * At each iteration:
1807:keygen.c      **** 			 *
1808:keygen.c      **** 			 *   a <- (a-b)/2 if: a is odd, b is odd, a_hi > b_hi
1809:keygen.c      **** 			 *   b <- (b-a)/2 if: a is odd, b is odd, a_hi <= b_hi
1810:keygen.c      **** 			 *   a <- a/2 if: a is even
1811:keygen.c      **** 			 *   b <- b/2 if: a is odd, b is even
1812:keygen.c      **** 			 *
1813:keygen.c      **** 			 * We multiply a_lo and b_lo by 2 at each
1814:keygen.c      **** 			 * iteration, thus a division by 2 really is a
1815:keygen.c      **** 			 * non-multiplication by 2.
1816:keygen.c      **** 			 */
1817:keygen.c      **** 			uint32_t rt, oa, ob, cAB, cBA, cA;
1818:keygen.c      **** 			uint64_t rz;
1819:keygen.c      **** 
1820:keygen.c      **** 			/*
1821:keygen.c      **** 			 * rt = 1 if a_hi > b_hi, 0 otherwise.
1822:keygen.c      **** 			 */
1823:keygen.c      **** 			rz = b_hi - a_hi;
 7294              		.loc 2 1823 7 discriminator 3
 7295 0362 D7E9C601 		ldrd	r0, [r7, #792]
 7296 0366 D7E9C823 		ldrd	r2, [r7, #800]
 7297 036a B0EB020C 		subs	ip, r0, r2
 7298 036e C7F8A0C0 		str	ip, [r7, #160]
 7299 0372 61EB0303 		sbc	r3, r1, r3
 7300 0376 C7F8A430 		str	r3, [r7, #164]
 7301 037a D7E92823 		ldrd	r2, [r7, #160]
 7302 037e C7E9B023 		strd	r2, [r7, #704]
1824:keygen.c      **** 			rt = (uint32_t)((rz ^ ((a_hi ^ b_hi)
 7303              		.loc 2 1824 33 discriminator 3
 7304 0382 D7E9C801 		ldrd	r0, [r7, #800]
 7305 0386 D7E9C623 		ldrd	r2, [r7, #792]
 7306 038a 80EA020C 		eor	ip, r0, r2
 7307 038e C7F818C2 		str	ip, [r7, #536]
 7308 0392 4B40     		eors	r3, r3, r1
 7309 0394 C7F81C32 		str	r3, [r7, #540]
1825:keygen.c      **** 				& (a_hi ^ rz))) >> 63);
 7310              		.loc 2 1825 13 discriminator 3
 7311 0398 D7E9C801 		ldrd	r0, [r7, #800]
 7312 039c D7E9B023 		ldrd	r2, [r7, #704]
 7313 03a0 80EA020C 		eor	ip, r0, r2
 7314 03a4 C7F810C2 		str	ip, [r7, #528]
 7315 03a8 4B40     		eors	r3, r3, r1
 7316 03aa C7F81432 		str	r3, [r7, #532]
 7317              		.loc 2 1825 5 discriminator 3
 7318 03ae D7E98601 		ldrd	r0, [r7, #536]
 7319 03b2 8446     		mov	ip, r0
 7320 03b4 D7E98423 		ldrd	r2, [r7, #528]
 7321 03b8 9646     		mov	lr, r2
 7322 03ba 0CEA0E0C 		and	ip, ip, lr
 7323 03be C7F808C2 		str	ip, [r7, #520]
 7324 03c2 0B40     		ands	r3, r3, r1
 7325 03c4 C7F80C32 		str	r3, [r7, #524]
1824:keygen.c      **** 			rt = (uint32_t)((rz ^ ((a_hi ^ b_hi)
 7326              		.loc 2 1824 24 discriminator 3
 7327 03c8 D7E9B023 		ldrd	r2, [r7, #704]
 7328 03cc D7E98201 		ldrd	r0, [r7, #520]
 7329 03d0 8446     		mov	ip, r0
 7330 03d2 8CEA020C 		eor	ip, ip, r2
 7331 03d6 C7F800C2 		str	ip, [r7, #512]
 7332 03da 4B40     		eors	r3, r3, r1
 7333 03dc C7F80432 		str	r3, [r7, #516]
 7334              		.loc 2 1825 21 discriminator 3
 7335 03e0 4FF00002 		mov	r2, #0
 7336 03e4 4FF00003 		mov	r3, #0
 7337 03e8 D7F80412 		ldr	r1, [r7, #516]
 7338 03ec CA0F     		lsrs	r2, r1, #31
 7339 03ee 0023     		movs	r3, #0
1824:keygen.c      **** 			rt = (uint32_t)((rz ^ ((a_hi ^ b_hi)
 7340              		.loc 2 1824 7 discriminator 3
 7341 03f0 1346     		mov	r3, r2
 7342 03f2 C7F8BC32 		str	r3, [r7, #700]
1826:keygen.c      **** 
1827:keygen.c      **** 			/*
1828:keygen.c      **** 			 * cAB = 1 if b must be subtracted from a
1829:keygen.c      **** 			 * cBA = 1 if a must be subtracted from b
1830:keygen.c      **** 			 * cA = 1 if a must be divided by 2
1831:keygen.c      **** 			 *
1832:keygen.c      **** 			 * Rules:
1833:keygen.c      **** 			 *
1834:keygen.c      **** 			 *   cAB and cBA cannot both be 1.
1835:keygen.c      **** 			 *   If a is not divided by 2, b is.
1836:keygen.c      **** 			 */
1837:keygen.c      **** 			oa = (a_lo >> i) & 1;
 7343              		.loc 2 1837 15 discriminator 3
 7344 03f6 D7F81423 		ldr	r2, [r7, #788]
 7345 03fa D7F8EC32 		ldr	r3, [r7, #748]
 7346 03fe 22FA03F3 		lsr	r3, r2, r3
 7347              		.loc 2 1837 7 discriminator 3
 7348 0402 03F00103 		and	r3, r3, #1
 7349 0406 C7F8B832 		str	r3, [r7, #696]
1838:keygen.c      **** 			ob = (b_lo >> i) & 1;
 7350              		.loc 2 1838 15 discriminator 3
 7351 040a D7F81023 		ldr	r2, [r7, #784]
 7352 040e D7F8EC32 		ldr	r3, [r7, #748]
 7353 0412 22FA03F3 		lsr	r3, r2, r3
 7354              		.loc 2 1838 7 discriminator 3
 7355 0416 03F00103 		and	r3, r3, #1
 7356 041a C7F8B432 		str	r3, [r7, #692]
1839:keygen.c      **** 			cAB = oa & ob & rt;
 7357              		.loc 2 1839 13 discriminator 3
 7358 041e D7F8B822 		ldr	r2, [r7, #696]
 7359 0422 D7F8B432 		ldr	r3, [r7, #692]
 7360 0426 1A40     		ands	r2, r2, r3
 7361              		.loc 2 1839 8 discriminator 3
 7362 0428 D7F8BC32 		ldr	r3, [r7, #700]
 7363 042c 1340     		ands	r3, r3, r2
 7364 042e C7F8B032 		str	r3, [r7, #688]
1840:keygen.c      **** 			cBA = oa & ob & ~rt;
 7365              		.loc 2 1840 13 discriminator 3
 7366 0432 D7F8B822 		ldr	r2, [r7, #696]
 7367 0436 D7F8B432 		ldr	r3, [r7, #692]
 7368 043a 1A40     		ands	r2, r2, r3
 7369              		.loc 2 1840 20 discriminator 3
 7370 043c D7F8BC32 		ldr	r3, [r7, #700]
 7371 0440 DB43     		mvns	r3, r3
 7372              		.loc 2 1840 8 discriminator 3
 7373 0442 1340     		ands	r3, r3, r2
 7374 0444 C7F8AC32 		str	r3, [r7, #684]
1841:keygen.c      **** 			cA = cAB | (oa ^ 1);
 7375              		.loc 2 1841 19 discriminator 3
 7376 0448 D7F8B832 		ldr	r3, [r7, #696]
 7377 044c 83F00102 		eor	r2, r3, #1
 7378              		.loc 2 1841 7 discriminator 3
 7379 0450 D7F8B032 		ldr	r3, [r7, #688]
 7380 0454 1343     		orrs	r3, r3, r2
 7381 0456 C7F8A832 		str	r3, [r7, #680]
1842:keygen.c      **** 
1843:keygen.c      **** 			/*
1844:keygen.c      **** 			 * Conditional subtractions.
1845:keygen.c      **** 			 */
1846:keygen.c      **** 			a_lo -= b_lo & -cAB;
 7382              		.loc 2 1846 19 discriminator 3
 7383 045a D7F8B032 		ldr	r3, [r7, #688]
 7384 045e 5A42     		rsbs	r2, r3, #0
 7385              		.loc 2 1846 17 discriminator 3
 7386 0460 D7F81033 		ldr	r3, [r7, #784]
 7387 0464 1A40     		ands	r2, r2, r3
 7388              		.loc 2 1846 9 discriminator 3
 7389 0466 D7F81433 		ldr	r3, [r7, #788]
 7390 046a 9B1A     		subs	r3, r3, r2
 7391 046c C7F81433 		str	r3, [r7, #788]
1847:keygen.c      **** 			a_hi -= b_hi & -(uint64_t)cAB;
 7392              		.loc 2 1847 20 discriminator 3
 7393 0470 D7F8B032 		ldr	r3, [r7, #688]
 7394 0474 0022     		movs	r2, #0
 7395 0476 C7F8F831 		str	r3, [r7, #504]
 7396 047a C7F8FC21 		str	r2, [r7, #508]
 7397              		.loc 2 1847 19 discriminator 3
 7398 047e 0023     		movs	r3, #0
 7399 0480 D7E97E01 		ldrd	r0, [r7, #504]
 7400 0484 0246     		mov	r2, r0
 7401 0486 5242     		negs	r2, r2
 7402 0488 C7F8F021 		str	r2, [r7, #496]
 7403 048c 0A46     		mov	r2, r1
 7404 048e 63EB0203 		sbc	r3, r3, r2
 7405 0492 C7F8F431 		str	r3, [r7, #500]
 7406              		.loc 2 1847 17 discriminator 3
 7407 0496 D7E9C623 		ldrd	r2, [r7, #792]
 7408 049a D7E97C01 		ldrd	r0, [r7, #496]
 7409 049e 8446     		mov	ip, r0
 7410 04a0 0CEA020C 		and	ip, ip, r2
 7411 04a4 C7F8E8C1 		str	ip, [r7, #488]
 7412 04a8 0B40     		ands	r3, r3, r1
 7413 04aa C7F8EC31 		str	r3, [r7, #492]
 7414              		.loc 2 1847 9 discriminator 3
 7415 04ae D7E9C823 		ldrd	r2, [r7, #800]
 7416 04b2 D7E97A01 		ldrd	r0, [r7, #488]
 7417 04b6 8446     		mov	ip, r0
 7418 04b8 B2EB0C0C 		subs	ip, r2, ip
 7419 04bc C7F898C0 		str	ip, [r7, #152]
 7420 04c0 63EB0103 		sbc	r3, r3, r1
 7421 04c4 C7F89C30 		str	r3, [r7, #156]
 7422 04c8 D7E92623 		ldrd	r2, [r7, #152]
 7423 04cc C7E9C823 		strd	r2, [r7, #800]
1848:keygen.c      **** 			pa -= qa & -(int64_t)cAB;
 7424              		.loc 2 1848 16 discriminator 3
 7425 04d0 D7F8B032 		ldr	r3, [r7, #688]
 7426 04d4 0022     		movs	r2, #0
 7427 04d6 C7F8E031 		str	r3, [r7, #480]
 7428 04da C7F8E421 		str	r2, [r7, #484]
 7429              		.loc 2 1848 15 discriminator 3
 7430 04de 0023     		movs	r3, #0
 7431 04e0 D7E97801 		ldrd	r0, [r7, #480]
 7432 04e4 0246     		mov	r2, r0
 7433 04e6 5242     		negs	r2, r2
 7434 04e8 C7F8D821 		str	r2, [r7, #472]
 7435 04ec 0A46     		mov	r2, r1
 7436 04ee 63EB0203 		sbc	r3, r3, r2
 7437 04f2 C7F8DC31 		str	r3, [r7, #476]
 7438              		.loc 2 1848 13 discriminator 3
 7439 04f6 D7E9BE23 		ldrd	r2, [r7, #760]
 7440 04fa D7E97601 		ldrd	r0, [r7, #472]
 7441 04fe 8446     		mov	ip, r0
 7442 0500 0CEA020C 		and	ip, ip, r2
 7443 0504 C7F8D0C1 		str	ip, [r7, #464]
 7444 0508 0B40     		ands	r3, r3, r1
 7445 050a C7F8D431 		str	r3, [r7, #468]
 7446              		.loc 2 1848 7 discriminator 3
 7447 050e D7E9C223 		ldrd	r2, [r7, #776]
 7448 0512 D7E97401 		ldrd	r0, [r7, #464]
 7449 0516 8446     		mov	ip, r0
 7450 0518 B2EB0C0C 		subs	ip, r2, ip
 7451 051c C7F890C0 		str	ip, [r7, #144]
 7452 0520 63EB0103 		sbc	r3, r3, r1
 7453 0524 C7F89430 		str	r3, [r7, #148]
 7454 0528 D7E92423 		ldrd	r2, [r7, #144]
 7455 052c C7E9C223 		strd	r2, [r7, #776]
1849:keygen.c      **** 			pb -= qb & -(int64_t)cAB;
 7456              		.loc 2 1849 16 discriminator 3
 7457 0530 D7F8B032 		ldr	r3, [r7, #688]
 7458 0534 0022     		movs	r2, #0
 7459 0536 C7F8C831 		str	r3, [r7, #456]
 7460 053a C7F8CC21 		str	r2, [r7, #460]
 7461              		.loc 2 1849 15 discriminator 3
 7462 053e 0023     		movs	r3, #0
 7463 0540 D7E97201 		ldrd	r0, [r7, #456]
 7464 0544 0246     		mov	r2, r0
 7465 0546 5242     		negs	r2, r2
 7466 0548 C7F8C021 		str	r2, [r7, #448]
 7467 054c 0A46     		mov	r2, r1
 7468 054e 63EB0203 		sbc	r3, r3, r2
 7469 0552 C7F8C431 		str	r3, [r7, #452]
 7470              		.loc 2 1849 13 discriminator 3
 7471 0556 D7E9BC23 		ldrd	r2, [r7, #752]
 7472 055a D7E97001 		ldrd	r0, [r7, #448]
 7473 055e 8446     		mov	ip, r0
 7474 0560 0CEA020C 		and	ip, ip, r2
 7475 0564 C7F8B8C1 		str	ip, [r7, #440]
 7476 0568 0B40     		ands	r3, r3, r1
 7477 056a C7F8BC31 		str	r3, [r7, #444]
 7478              		.loc 2 1849 7 discriminator 3
 7479 056e D7E9C023 		ldrd	r2, [r7, #768]
 7480 0572 D7E96E01 		ldrd	r0, [r7, #440]
 7481 0576 8446     		mov	ip, r0
 7482 0578 B2EB0C0C 		subs	ip, r2, ip
 7483 057c C7F888C0 		str	ip, [r7, #136]
 7484 0580 63EB0103 		sbc	r3, r3, r1
 7485 0584 C7F88C30 		str	r3, [r7, #140]
 7486 0588 D7E92223 		ldrd	r2, [r7, #136]
 7487 058c C7E9C023 		strd	r2, [r7, #768]
1850:keygen.c      **** 			b_lo -= a_lo & -cBA;
 7488              		.loc 2 1850 19 discriminator 3
 7489 0590 D7F8AC32 		ldr	r3, [r7, #684]
 7490 0594 5A42     		rsbs	r2, r3, #0
 7491              		.loc 2 1850 17 discriminator 3
 7492 0596 D7F81433 		ldr	r3, [r7, #788]
 7493 059a 1A40     		ands	r2, r2, r3
 7494              		.loc 2 1850 9 discriminator 3
 7495 059c D7F81033 		ldr	r3, [r7, #784]
 7496 05a0 9B1A     		subs	r3, r3, r2
 7497 05a2 C7F81033 		str	r3, [r7, #784]
1851:keygen.c      **** 			b_hi -= a_hi & -(uint64_t)cBA;
 7498              		.loc 2 1851 20 discriminator 3
 7499 05a6 D7F8AC32 		ldr	r3, [r7, #684]
 7500 05aa 0022     		movs	r2, #0
 7501 05ac C7F8B031 		str	r3, [r7, #432]
 7502 05b0 C7F8B421 		str	r2, [r7, #436]
 7503              		.loc 2 1851 19 discriminator 3
 7504 05b4 0023     		movs	r3, #0
 7505 05b6 D7E96C01 		ldrd	r0, [r7, #432]
 7506 05ba 0246     		mov	r2, r0
 7507 05bc 5242     		negs	r2, r2
 7508 05be C7F8A821 		str	r2, [r7, #424]
 7509 05c2 0A46     		mov	r2, r1
 7510 05c4 63EB0203 		sbc	r3, r3, r2
 7511 05c8 C7F8AC31 		str	r3, [r7, #428]
 7512              		.loc 2 1851 17 discriminator 3
 7513 05cc D7E9C823 		ldrd	r2, [r7, #800]
 7514 05d0 D7E96A01 		ldrd	r0, [r7, #424]
 7515 05d4 8446     		mov	ip, r0
 7516 05d6 0CEA020C 		and	ip, ip, r2
 7517 05da C7F8A0C1 		str	ip, [r7, #416]
 7518 05de 0B40     		ands	r3, r3, r1
 7519 05e0 C7F8A431 		str	r3, [r7, #420]
 7520              		.loc 2 1851 9 discriminator 3
 7521 05e4 D7E9C623 		ldrd	r2, [r7, #792]
 7522 05e8 D7E96801 		ldrd	r0, [r7, #416]
 7523 05ec 8446     		mov	ip, r0
 7524 05ee B2EB0C0C 		subs	ip, r2, ip
 7525 05f2 C7F880C0 		str	ip, [r7, #128]
 7526 05f6 63EB0103 		sbc	r3, r3, r1
 7527 05fa C7F88430 		str	r3, [r7, #132]
 7528 05fe D7E92023 		ldrd	r2, [r7, #128]
 7529 0602 C7E9C623 		strd	r2, [r7, #792]
1852:keygen.c      **** 			qa -= pa & -(int64_t)cBA;
 7530              		.loc 2 1852 16 discriminator 3
 7531 0606 D7F8AC32 		ldr	r3, [r7, #684]
 7532 060a 0022     		movs	r2, #0
 7533 060c C7F89831 		str	r3, [r7, #408]
 7534 0610 C7F89C21 		str	r2, [r7, #412]
 7535              		.loc 2 1852 15 discriminator 3
 7536 0614 0023     		movs	r3, #0
 7537 0616 D7E96601 		ldrd	r0, [r7, #408]
 7538 061a 0246     		mov	r2, r0
 7539 061c 5242     		negs	r2, r2
 7540 061e C7F89021 		str	r2, [r7, #400]
 7541 0622 0A46     		mov	r2, r1
 7542 0624 63EB0203 		sbc	r3, r3, r2
 7543 0628 C7F89431 		str	r3, [r7, #404]
 7544              		.loc 2 1852 13 discriminator 3
 7545 062c D7E9C223 		ldrd	r2, [r7, #776]
 7546 0630 D7E96401 		ldrd	r0, [r7, #400]
 7547 0634 8446     		mov	ip, r0
 7548 0636 0CEA020C 		and	ip, ip, r2
 7549 063a C7F888C1 		str	ip, [r7, #392]
 7550 063e 0B40     		ands	r3, r3, r1
 7551 0640 C7F88C31 		str	r3, [r7, #396]
 7552              		.loc 2 1852 7 discriminator 3
 7553 0644 D7E9BE23 		ldrd	r2, [r7, #760]
 7554 0648 D7E96201 		ldrd	r0, [r7, #392]
 7555 064c 8446     		mov	ip, r0
 7556 064e B2EB0C0C 		subs	ip, r2, ip
 7557 0652 C7F878C0 		str	ip, [r7, #120]
 7558 0656 63EB0103 		sbc	r3, r3, r1
 7559 065a FB67     		str	r3, [r7, #124]
 7560 065c D7E91E23 		ldrd	r2, [r7, #120]
 7561 0660 C7E9BE23 		strd	r2, [r7, #760]
1853:keygen.c      **** 			qb -= pb & -(int64_t)cBA;
 7562              		.loc 2 1853 16 discriminator 3
 7563 0664 D7F8AC32 		ldr	r3, [r7, #684]
 7564 0668 0022     		movs	r2, #0
 7565 066a C7F88031 		str	r3, [r7, #384]
 7566 066e C7F88421 		str	r2, [r7, #388]
 7567              		.loc 2 1853 15 discriminator 3
 7568 0672 0023     		movs	r3, #0
 7569 0674 D7E96001 		ldrd	r0, [r7, #384]
 7570 0678 0246     		mov	r2, r0
 7571 067a 5242     		negs	r2, r2
 7572 067c C7F87821 		str	r2, [r7, #376]
 7573 0680 0A46     		mov	r2, r1
 7574 0682 63EB0203 		sbc	r3, r3, r2
 7575 0686 C7F87C31 		str	r3, [r7, #380]
 7576              		.loc 2 1853 13 discriminator 3
 7577 068a D7E9C023 		ldrd	r2, [r7, #768]
 7578 068e D7E95E01 		ldrd	r0, [r7, #376]
 7579 0692 8446     		mov	ip, r0
 7580 0694 0CEA020C 		and	ip, ip, r2
 7581 0698 C7F870C1 		str	ip, [r7, #368]
 7582 069c 0B40     		ands	r3, r3, r1
 7583 069e C7F87431 		str	r3, [r7, #372]
 7584              		.loc 2 1853 7 discriminator 3
 7585 06a2 D7E9BC23 		ldrd	r2, [r7, #752]
 7586 06a6 D7E95C01 		ldrd	r0, [r7, #368]
 7587 06aa 8446     		mov	ip, r0
 7588 06ac B2EB0C0C 		subs	ip, r2, ip
 7589 06b0 C7F870C0 		str	ip, [r7, #112]
 7590 06b4 63EB0103 		sbc	r3, r3, r1
 7591 06b8 7B67     		str	r3, [r7, #116]
 7592 06ba D7E91C23 		ldrd	r2, [r7, #112]
 7593 06be C7E9BC23 		strd	r2, [r7, #752]
1854:keygen.c      **** 
1855:keygen.c      **** 			/*
1856:keygen.c      **** 			 * Shifting.
1857:keygen.c      **** 			 */
1858:keygen.c      **** 			a_lo += a_lo & (cA - 1);
 7594              		.loc 2 1858 23 discriminator 3
 7595 06c2 D7F8A832 		ldr	r3, [r7, #680]
 7596 06c6 5A1E     		subs	r2, r3, #1
 7597              		.loc 2 1858 17 discriminator 3
 7598 06c8 D7F81433 		ldr	r3, [r7, #788]
 7599 06cc 1A40     		ands	r2, r2, r3
 7600              		.loc 2 1858 9 discriminator 3
 7601 06ce D7F81433 		ldr	r3, [r7, #788]
 7602 06d2 1344     		add	r3, r3, r2
 7603 06d4 C7F81433 		str	r3, [r7, #788]
1859:keygen.c      **** 			pa += pa & ((int64_t)cA - 1);
 7604              		.loc 2 1859 16 discriminator 3
 7605 06d8 D7F8A832 		ldr	r3, [r7, #680]
 7606 06dc 0022     		movs	r2, #0
 7607 06de C7F86831 		str	r3, [r7, #360]
 7608 06e2 C7F86C21 		str	r2, [r7, #364]
 7609              		.loc 2 1859 28 discriminator 3
 7610 06e6 D7E95A12 		ldrd	r1, [r7, #360]
 7611 06ea 0B46     		mov	r3, r1
 7612 06ec 013B     		subs	r3, r3, #1
 7613 06ee C7F86031 		str	r3, [r7, #352]
 7614 06f2 1346     		mov	r3, r2
 7615 06f4 43F1FF33 		adc	r3, r3, #-1
 7616 06f8 C7F86431 		str	r3, [r7, #356]
 7617              		.loc 2 1859 13 discriminator 3
 7618 06fc D7E9C223 		ldrd	r2, [r7, #776]
 7619 0700 D7E95801 		ldrd	r0, [r7, #352]
 7620 0704 8446     		mov	ip, r0
 7621 0706 0CEA020C 		and	ip, ip, r2
 7622 070a C7F878C2 		str	ip, [r7, #632]
 7623 070e 0B40     		ands	r3, r3, r1
 7624 0710 C7F87C32 		str	r3, [r7, #636]
 7625              		.loc 2 1859 7 discriminator 3
 7626 0714 D7E9C223 		ldrd	r2, [r7, #776]
 7627 0718 D7F87812 		ldr	r1, [r7, #632]
 7628 071c 5118     		adds	r1, r2, r1
 7629 071e B966     		str	r1, [r7, #104]
 7630 0720 D7F87C12 		ldr	r1, [r7, #636]
 7631 0724 4B41     		adcs	r3, r3, r1
 7632 0726 FB66     		str	r3, [r7, #108]
 7633 0728 D7E91A23 		ldrd	r2, [r7, #104]
 7634 072c C7E9C223 		strd	r2, [r7, #776]
1860:keygen.c      **** 			pb += pb & ((int64_t)cA - 1);
 7635              		.loc 2 1860 16 discriminator 3
 7636 0730 D7F8A832 		ldr	r3, [r7, #680]
 7637 0734 0022     		movs	r2, #0
 7638 0736 C7F85831 		str	r3, [r7, #344]
 7639 073a C7F85C21 		str	r2, [r7, #348]
 7640              		.loc 2 1860 28 discriminator 3
 7641 073e D7E95612 		ldrd	r1, [r7, #344]
 7642 0742 0B46     		mov	r3, r1
 7643 0744 013B     		subs	r3, r3, #1
 7644 0746 C7F85031 		str	r3, [r7, #336]
 7645 074a 1346     		mov	r3, r2
 7646 074c 43F1FF33 		adc	r3, r3, #-1
 7647 0750 C7F85431 		str	r3, [r7, #340]
 7648              		.loc 2 1860 13 discriminator 3
 7649 0754 D7E9C023 		ldrd	r2, [r7, #768]
 7650 0758 D7E95401 		ldrd	r0, [r7, #336]
 7651 075c 8446     		mov	ip, r0
 7652 075e 0CEA020C 		and	ip, ip, r2
 7653 0762 C7F870C2 		str	ip, [r7, #624]
 7654 0766 0B40     		ands	r3, r3, r1
 7655 0768 C7F87432 		str	r3, [r7, #628]
 7656              		.loc 2 1860 7 discriminator 3
 7657 076c D7E9C023 		ldrd	r2, [r7, #768]
 7658 0770 D7F87012 		ldr	r1, [r7, #624]
 7659 0774 5118     		adds	r1, r2, r1
 7660 0776 3966     		str	r1, [r7, #96]
 7661 0778 D7F87412 		ldr	r1, [r7, #628]
 7662 077c 4B41     		adcs	r3, r3, r1
 7663 077e 7B66     		str	r3, [r7, #100]
 7664 0780 D7E91823 		ldrd	r2, [r7, #96]
 7665 0784 C7E9C023 		strd	r2, [r7, #768]
1861:keygen.c      **** 			a_hi ^= (a_hi ^ (a_hi >> 1)) & -(uint64_t)cA;
 7666              		.loc 2 1861 26 discriminator 3
 7667 0788 D7E9C823 		ldrd	r2, [r7, #800]
 7668 078c 4FF00000 		mov	r0, #0
 7669 0790 4FF00001 		mov	r1, #0
 7670 0794 5008     		lsrs	r0, r2, #1
 7671 0796 40EAC370 		orr	r0, r0, r3, lsl #31
 7672 079a 5908     		lsrs	r1, r3, #1
 7673              		.loc 2 1861 18 discriminator 3
 7674 079c D7E9C823 		ldrd	r2, [r7, #800]
 7675 07a0 80EA020C 		eor	ip, r0, r2
 7676 07a4 C7F848C1 		str	ip, [r7, #328]
 7677 07a8 4B40     		eors	r3, r3, r1
 7678 07aa C7F84C31 		str	r3, [r7, #332]
 7679              		.loc 2 1861 36 discriminator 3
 7680 07ae D7F8A832 		ldr	r3, [r7, #680]
 7681 07b2 0022     		movs	r2, #0
 7682 07b4 C7F84031 		str	r3, [r7, #320]
 7683 07b8 C7F84421 		str	r2, [r7, #324]
 7684              		.loc 2 1861 35 discriminator 3
 7685 07bc 0023     		movs	r3, #0
 7686 07be D7E95001 		ldrd	r0, [r7, #320]
 7687 07c2 0246     		mov	r2, r0
 7688 07c4 5242     		negs	r2, r2
 7689 07c6 C7F83821 		str	r2, [r7, #312]
 7690 07ca 0A46     		mov	r2, r1
 7691 07cc 63EB0203 		sbc	r3, r3, r2
 7692 07d0 C7F83C31 		str	r3, [r7, #316]
 7693              		.loc 2 1861 33 discriminator 3
 7694 07d4 D7E95201 		ldrd	r0, [r7, #328]
 7695 07d8 8446     		mov	ip, r0
 7696 07da D7E94E23 		ldrd	r2, [r7, #312]
 7697 07de 9646     		mov	lr, r2
 7698 07e0 0CEA0E0C 		and	ip, ip, lr
 7699 07e4 C7F830C1 		str	ip, [r7, #304]
 7700 07e8 0B40     		ands	r3, r3, r1
 7701 07ea C7F83431 		str	r3, [r7, #308]
 7702              		.loc 2 1861 9 discriminator 3
 7703 07ee D7E9C823 		ldrd	r2, [r7, #800]
 7704 07f2 D7E94C01 		ldrd	r0, [r7, #304]
 7705 07f6 8446     		mov	ip, r0
 7706 07f8 82EA0C0C 		eor	ip, r2, ip
 7707 07fc C7F858C0 		str	ip, [r7, #88]
 7708 0800 4B40     		eors	r3, r3, r1
 7709 0802 FB65     		str	r3, [r7, #92]
 7710 0804 D7E91623 		ldrd	r2, [r7, #88]
 7711 0808 C7E9C823 		strd	r2, [r7, #800]
1862:keygen.c      **** 			b_lo += b_lo & -cA;
 7712              		.loc 2 1862 19 discriminator 3
 7713 080c D7F8A832 		ldr	r3, [r7, #680]
 7714 0810 5A42     		rsbs	r2, r3, #0
 7715              		.loc 2 1862 17 discriminator 3
 7716 0812 D7F81033 		ldr	r3, [r7, #784]
 7717 0816 1A40     		ands	r2, r2, r3
 7718              		.loc 2 1862 9 discriminator 3
 7719 0818 D7F81033 		ldr	r3, [r7, #784]
 7720 081c 1344     		add	r3, r3, r2
 7721 081e C7F81033 		str	r3, [r7, #784]
1863:keygen.c      **** 			qa += qa & -(int64_t)cA;
 7722              		.loc 2 1863 16 discriminator 3
 7723 0822 D7F8A832 		ldr	r3, [r7, #680]
 7724 0826 0022     		movs	r2, #0
 7725 0828 C7F82831 		str	r3, [r7, #296]
 7726 082c C7F82C21 		str	r2, [r7, #300]
 7727              		.loc 2 1863 15 discriminator 3
 7728 0830 0023     		movs	r3, #0
 7729 0832 D7E94A01 		ldrd	r0, [r7, #296]
 7730 0836 0246     		mov	r2, r0
 7731 0838 5242     		negs	r2, r2
 7732 083a C7F82021 		str	r2, [r7, #288]
 7733 083e 0A46     		mov	r2, r1
 7734 0840 63EB0203 		sbc	r3, r3, r2
 7735 0844 C7F82431 		str	r3, [r7, #292]
 7736              		.loc 2 1863 13 discriminator 3
 7737 0848 D7E9BE23 		ldrd	r2, [r7, #760]
 7738 084c D7E94801 		ldrd	r0, [r7, #288]
 7739 0850 8446     		mov	ip, r0
 7740 0852 0CEA020C 		and	ip, ip, r2
 7741 0856 C7F868C2 		str	ip, [r7, #616]
 7742 085a 0B40     		ands	r3, r3, r1
 7743 085c C7F86C32 		str	r3, [r7, #620]
 7744              		.loc 2 1863 7 discriminator 3
 7745 0860 D7E9BE23 		ldrd	r2, [r7, #760]
 7746 0864 D7F86812 		ldr	r1, [r7, #616]
 7747 0868 5118     		adds	r1, r2, r1
 7748 086a 3965     		str	r1, [r7, #80]
 7749 086c D7F86C12 		ldr	r1, [r7, #620]
 7750 0870 4B41     		adcs	r3, r3, r1
 7751 0872 7B65     		str	r3, [r7, #84]
 7752 0874 D7E91423 		ldrd	r2, [r7, #80]
 7753 0878 C7E9BE23 		strd	r2, [r7, #760]
1864:keygen.c      **** 			qb += qb & -(int64_t)cA;
 7754              		.loc 2 1864 16 discriminator 3
 7755 087c D7F8A832 		ldr	r3, [r7, #680]
 7756 0880 0022     		movs	r2, #0
 7757 0882 C7F81831 		str	r3, [r7, #280]
 7758 0886 C7F81C21 		str	r2, [r7, #284]
 7759              		.loc 2 1864 15 discriminator 3
 7760 088a 0023     		movs	r3, #0
 7761 088c D7E94601 		ldrd	r0, [r7, #280]
 7762 0890 0246     		mov	r2, r0
 7763 0892 5242     		negs	r2, r2
 7764 0894 C7F81021 		str	r2, [r7, #272]
 7765 0898 0A46     		mov	r2, r1
 7766 089a 63EB0203 		sbc	r3, r3, r2
 7767 089e C7F81431 		str	r3, [r7, #276]
 7768              		.loc 2 1864 13 discriminator 3
 7769 08a2 D7E9BC23 		ldrd	r2, [r7, #752]
 7770 08a6 D7E94401 		ldrd	r0, [r7, #272]
 7771 08aa 8446     		mov	ip, r0
 7772 08ac 0CEA020C 		and	ip, ip, r2
 7773 08b0 C7F860C2 		str	ip, [r7, #608]
 7774 08b4 0B40     		ands	r3, r3, r1
 7775 08b6 C7F86432 		str	r3, [r7, #612]
 7776              		.loc 2 1864 7 discriminator 3
 7777 08ba D7E9BC23 		ldrd	r2, [r7, #752]
 7778 08be D7F86012 		ldr	r1, [r7, #608]
 7779 08c2 5118     		adds	r1, r2, r1
 7780 08c4 B964     		str	r1, [r7, #72]
 7781 08c6 D7F86412 		ldr	r1, [r7, #612]
 7782 08ca 4B41     		adcs	r3, r3, r1
 7783 08cc FB64     		str	r3, [r7, #76]
 7784 08ce D7E91223 		ldrd	r2, [r7, #72]
 7785 08d2 C7E9BC23 		strd	r2, [r7, #752]
1865:keygen.c      **** 			b_hi ^= (b_hi ^ (b_hi >> 1)) & ((uint64_t)cA - 1);
 7786              		.loc 2 1865 26 discriminator 3
 7787 08d6 D7E9C623 		ldrd	r2, [r7, #792]
 7788 08da 4FF00000 		mov	r0, #0
 7789 08de 4FF00001 		mov	r1, #0
 7790 08e2 5008     		lsrs	r0, r2, #1
 7791 08e4 40EAC370 		orr	r0, r0, r3, lsl #31
 7792 08e8 5908     		lsrs	r1, r3, #1
 7793              		.loc 2 1865 18 discriminator 3
 7794 08ea D7E9C623 		ldrd	r2, [r7, #792]
 7795 08ee 80EA020A 		eor	r10, r0, r2
 7796 08f2 81EA030B 		eor	fp, r1, r3
 7797              		.loc 2 1865 36 discriminator 3
 7798 08f6 D7F8A832 		ldr	r3, [r7, #680]
 7799 08fa 0022     		movs	r2, #0
 7800 08fc C7F80831 		str	r3, [r7, #264]
 7801 0900 C7F80C21 		str	r2, [r7, #268]
 7802              		.loc 2 1865 49 discriminator 3
 7803 0904 D7E94223 		ldrd	r2, [r7, #264]
 7804 0908 1146     		mov	r1, r2
 7805 090a 11F1FF38 		adds	r8, r1, #-1
 7806 090e 43F1FF39 		adc	r9, r3, #-1
 7807              		.loc 2 1865 33 discriminator 3
 7808 0912 0AEA0804 		and	r4, r10, r8
 7809 0916 0BEA0905 		and	r5, fp, r9
 7810              		.loc 2 1865 9 discriminator 3
 7811 091a D7E9C623 		ldrd	r2, [r7, #792]
 7812 091e 82EA0401 		eor	r1, r2, r4
 7813 0922 3964     		str	r1, [r7, #64]
 7814 0924 6B40     		eors	r3, r3, r5
 7815 0926 7B64     		str	r3, [r7, #68]
 7816 0928 D7E91023 		ldrd	r2, [r7, #64]
 7817 092c C7E9C623 		strd	r2, [r7, #792]
 7818              	.LBE24:
1804:keygen.c      **** 			/*
 7819              		.loc 2 1804 25 discriminator 3
 7820 0930 D7F8EC32 		ldr	r3, [r7, #748]
 7821 0934 0133     		adds	r3, r3, #1
 7822 0936 C7F8EC32 		str	r3, [r7, #748]
 7823              	.L123:
1804:keygen.c      **** 			/*
 7824              		.loc 2 1804 3 discriminator 1
 7825 093a D7F8EC32 		ldr	r3, [r7, #748]
 7826 093e 1E2B     		cmp	r3, #30
 7827 0940 7FF70FAD 		ble	.L124
1866:keygen.c      **** 		}
1867:keygen.c      **** 
1868:keygen.c      **** 		/*
1869:keygen.c      **** 		 * Apply the computed parameters to our values. We
1870:keygen.c      **** 		 * may have to correct pa and pb depending on the
1871:keygen.c      **** 		 * returned value of zint_co_reduce() (when a and/or b
1872:keygen.c      **** 		 * had to be negated).
1873:keygen.c      **** 		 */
1874:keygen.c      **** 		r = zint_co_reduce(a, b, len, pa, pb, qa, qb);
 7828              		.loc 2 1874 7 discriminator 2
 7829 0944 D7E9BC23 		ldrd	r2, [r7, #752]
 7830 0948 CDE90623 		strd	r2, [sp, #24]
 7831 094c D7E9BE23 		ldrd	r2, [r7, #760]
 7832 0950 CDE90423 		strd	r2, [sp, #16]
 7833 0954 D7E9C023 		ldrd	r2, [r7, #768]
 7834 0958 CDE90223 		strd	r2, [sp, #8]
 7835 095c D7E9C223 		ldrd	r2, [r7, #776]
 7836 0960 CDE90023 		strd	r2, [sp]
 7837 0964 D7F87023 		ldr	r2, [r7, #880]
 7838 0968 D7F8D412 		ldr	r1, [r7, #724]
 7839 096c D7F8D802 		ldr	r0, [r7, #728]
 7840 0970 FFF7FEFF 		bl	zint_co_reduce
 7841 0974 C7F8C802 		str	r0, [r7, #712]
1875:keygen.c      **** 		pa -= (pa + pa) & -(int64_t)(r & 1);
 7842              		.loc 2 1875 13 discriminator 2
 7843 0978 D7E9C223 		ldrd	r2, [r7, #776]
 7844 097c 9118     		adds	r1, r2, r2
 7845 097e B963     		str	r1, [r7, #56]
 7846 0980 5B41     		adcs	r3, r3, r3
 7847 0982 FB63     		str	r3, [r7, #60]
 7848 0984 D7E90E01 		ldrd	r0, [r7, #56]
 7849              		.loc 2 1875 34 discriminator 2
 7850 0988 D7F8C832 		ldr	r3, [r7, #712]
 7851 098c 0022     		movs	r2, #0
 7852 098e C7F80031 		str	r3, [r7, #256]
 7853 0992 C7F80421 		str	r2, [r7, #260]
 7854              		.loc 2 1875 22 discriminator 2
 7855 0996 D7F80031 		ldr	r3, [r7, #256]
 7856 099a 03F00103 		and	r3, r3, #1
 7857 099e C7F85832 		str	r3, [r7, #600]
 7858 09a2 4FF0000C 		mov	ip, #0
 7859 09a6 C7F85CC2 		str	ip, [r7, #604]
 7860              		.loc 2 1875 21 discriminator 2
 7861 09aa 0023     		movs	r3, #0
 7862 09ac D7F85822 		ldr	r2, [r7, #600]
 7863 09b0 5242     		negs	r2, r2
 7864 09b2 C7F8F820 		str	r2, [r7, #248]
 7865 09b6 D7F85C22 		ldr	r2, [r7, #604]
 7866 09ba 63EB0203 		sbc	r3, r3, r2
 7867 09be C7F8FC30 		str	r3, [r7, #252]
 7868              		.loc 2 1875 19 discriminator 2
 7869 09c2 D7E93E23 		ldrd	r2, [r7, #248]
 7870 09c6 9646     		mov	lr, r2
 7871 09c8 00EA0E0E 		and	lr, r0, lr
 7872 09cc C7F8F0E0 		str	lr, [r7, #240]
 7873 09d0 0B40     		ands	r3, r3, r1
 7874 09d2 C7F8F430 		str	r3, [r7, #244]
 7875              		.loc 2 1875 6 discriminator 2
 7876 09d6 D7E9C223 		ldrd	r2, [r7, #776]
 7877 09da D7E93C01 		ldrd	r0, [r7, #240]
 7878 09de 8646     		mov	lr, r0
 7879 09e0 B2EB0E0E 		subs	lr, r2, lr
 7880 09e4 C7F830E0 		str	lr, [r7, #48]
 7881 09e8 63EB0103 		sbc	r3, r3, r1
 7882 09ec 7B63     		str	r3, [r7, #52]
 7883 09ee D7E90C23 		ldrd	r2, [r7, #48]
 7884 09f2 C7E9C223 		strd	r2, [r7, #776]
1876:keygen.c      **** 		pb -= (pb + pb) & -(int64_t)(r & 1);
 7885              		.loc 2 1876 13 discriminator 2
 7886 09f6 D7E9C023 		ldrd	r2, [r7, #768]
 7887 09fa 9118     		adds	r1, r2, r2
 7888 09fc B962     		str	r1, [r7, #40]
 7889 09fe 5B41     		adcs	r3, r3, r3
 7890 0a00 FB62     		str	r3, [r7, #44]
 7891 0a02 D7E90A01 		ldrd	r0, [r7, #40]
 7892              		.loc 2 1876 34 discriminator 2
 7893 0a06 D7F8C832 		ldr	r3, [r7, #712]
 7894 0a0a 0022     		movs	r2, #0
 7895 0a0c C7F8E830 		str	r3, [r7, #232]
 7896 0a10 C7F8EC20 		str	r2, [r7, #236]
 7897              		.loc 2 1876 22 discriminator 2
 7898 0a14 D7F8E830 		ldr	r3, [r7, #232]
 7899 0a18 03F00103 		and	r3, r3, #1
 7900 0a1c C7F85032 		str	r3, [r7, #592]
 7901 0a20 C7F854C2 		str	ip, [r7, #596]
 7902              		.loc 2 1876 21 discriminator 2
 7903 0a24 0023     		movs	r3, #0
 7904 0a26 D7F85022 		ldr	r2, [r7, #592]
 7905 0a2a 5242     		negs	r2, r2
 7906 0a2c C7F8E020 		str	r2, [r7, #224]
 7907 0a30 D7F85422 		ldr	r2, [r7, #596]
 7908 0a34 63EB0203 		sbc	r3, r3, r2
 7909 0a38 C7F8E430 		str	r3, [r7, #228]
 7910              		.loc 2 1876 19 discriminator 2
 7911 0a3c D7E93823 		ldrd	r2, [r7, #224]
 7912 0a40 9446     		mov	ip, r2
 7913 0a42 00EA0C0C 		and	ip, r0, ip
 7914 0a46 C7F8D8C0 		str	ip, [r7, #216]
 7915 0a4a 0B40     		ands	r3, r3, r1
 7916 0a4c C7F8DC30 		str	r3, [r7, #220]
 7917              		.loc 2 1876 6 discriminator 2
 7918 0a50 D7E9C023 		ldrd	r2, [r7, #768]
 7919 0a54 D7E93601 		ldrd	r0, [r7, #216]
 7920 0a58 8446     		mov	ip, r0
 7921 0a5a B2EB0C0C 		subs	ip, r2, ip
 7922 0a5e C7F820C0 		str	ip, [r7, #32]
 7923 0a62 63EB0103 		sbc	r3, r3, r1
 7924 0a66 7B62     		str	r3, [r7, #36]
 7925 0a68 D7E90823 		ldrd	r2, [r7, #32]
 7926 0a6c C7E9C023 		strd	r2, [r7, #768]
1877:keygen.c      **** 		qa -= (qa + qa) & -(int64_t)(r >> 1);
 7927              		.loc 2 1877 13 discriminator 2
 7928 0a70 D7E9BE23 		ldrd	r2, [r7, #760]
 7929 0a74 9118     		adds	r1, r2, r2
 7930 0a76 B961     		str	r1, [r7, #24]
 7931 0a78 5B41     		adcs	r3, r3, r3
 7932 0a7a FB61     		str	r3, [r7, #28]
 7933 0a7c D7E90601 		ldrd	r0, [r7, #24]
 7934              		.loc 2 1877 34 discriminator 2
 7935 0a80 D7F8C832 		ldr	r3, [r7, #712]
 7936 0a84 5B08     		lsrs	r3, r3, #1
 7937              		.loc 2 1877 22 discriminator 2
 7938 0a86 0022     		movs	r2, #0
 7939 0a88 C7F84832 		str	r3, [r7, #584]
 7940 0a8c C7F84C22 		str	r2, [r7, #588]
 7941              		.loc 2 1877 21 discriminator 2
 7942 0a90 0023     		movs	r3, #0
 7943 0a92 D7F84822 		ldr	r2, [r7, #584]
 7944 0a96 5242     		negs	r2, r2
 7945 0a98 C7F8D020 		str	r2, [r7, #208]
 7946 0a9c D7F84C22 		ldr	r2, [r7, #588]
 7947 0aa0 63EB0203 		sbc	r3, r3, r2
 7948 0aa4 C7F8D430 		str	r3, [r7, #212]
 7949              		.loc 2 1877 19 discriminator 2
 7950 0aa8 D7E93423 		ldrd	r2, [r7, #208]
 7951 0aac 9446     		mov	ip, r2
 7952 0aae 00EA0C0C 		and	ip, r0, ip
 7953 0ab2 C7F8C8C0 		str	ip, [r7, #200]
 7954 0ab6 0B40     		ands	r3, r3, r1
 7955 0ab8 C7F8CC30 		str	r3, [r7, #204]
 7956              		.loc 2 1877 6 discriminator 2
 7957 0abc D7E9BE23 		ldrd	r2, [r7, #760]
 7958 0ac0 D7E93201 		ldrd	r0, [r7, #200]
 7959 0ac4 8446     		mov	ip, r0
 7960 0ac6 B2EB0C0C 		subs	ip, r2, ip
 7961 0aca C7F810C0 		str	ip, [r7, #16]
 7962 0ace 63EB0103 		sbc	r3, r3, r1
 7963 0ad2 7B61     		str	r3, [r7, #20]
 7964 0ad4 D7E90423 		ldrd	r2, [r7, #16]
 7965 0ad8 C7E9BE23 		strd	r2, [r7, #760]
1878:keygen.c      **** 		qb -= (qb + qb) & -(int64_t)(r >> 1);
 7966              		.loc 2 1878 13 discriminator 2
 7967 0adc D7E9BC23 		ldrd	r2, [r7, #752]
 7968 0ae0 9118     		adds	r1, r2, r2
 7969 0ae2 B960     		str	r1, [r7, #8]
 7970 0ae4 5B41     		adcs	r3, r3, r3
 7971 0ae6 FB60     		str	r3, [r7, #12]
 7972 0ae8 D7E90201 		ldrd	r0, [r7, #8]
 7973              		.loc 2 1878 34 discriminator 2
 7974 0aec D7F8C832 		ldr	r3, [r7, #712]
 7975 0af0 5B08     		lsrs	r3, r3, #1
 7976              		.loc 2 1878 22 discriminator 2
 7977 0af2 0022     		movs	r2, #0
 7978 0af4 C7F84032 		str	r3, [r7, #576]
 7979 0af8 C7F84422 		str	r2, [r7, #580]
 7980              		.loc 2 1878 21 discriminator 2
 7981 0afc 0023     		movs	r3, #0
 7982 0afe D7F84022 		ldr	r2, [r7, #576]
 7983 0b02 5242     		negs	r2, r2
 7984 0b04 C7F8C020 		str	r2, [r7, #192]
 7985 0b08 D7F84422 		ldr	r2, [r7, #580]
 7986 0b0c 63EB0203 		sbc	r3, r3, r2
 7987 0b10 C7F8C430 		str	r3, [r7, #196]
 7988              		.loc 2 1878 19 discriminator 2
 7989 0b14 D7E93023 		ldrd	r2, [r7, #192]
 7990 0b18 9446     		mov	ip, r2
 7991 0b1a 00EA0C0C 		and	ip, r0, ip
 7992 0b1e C7F8B8C0 		str	ip, [r7, #184]
 7993 0b22 0B40     		ands	r3, r3, r1
 7994 0b24 C7F8BC30 		str	r3, [r7, #188]
 7995              		.loc 2 1878 6 discriminator 2
 7996 0b28 D7E9BC23 		ldrd	r2, [r7, #752]
 7997 0b2c D7E92E01 		ldrd	r0, [r7, #184]
 7998 0b30 8446     		mov	ip, r0
 7999 0b32 B2EB0C0C 		subs	ip, r2, ip
 8000 0b36 C7F800C0 		str	ip, [r7]
 8001 0b3a 63EB0103 		sbc	r3, r3, r1
 8002 0b3e 7B60     		str	r3, [r7, #4]
 8003 0b40 D7E90023 		ldrd	r2, [r7]
 8004 0b44 C7E9BC23 		strd	r2, [r7, #752]
1879:keygen.c      **** 		zint_co_reduce_mod(u0, u1, y, len, y0i, pa, pb, qa, qb);
 8005              		.loc 2 1879 3 discriminator 2
 8006 0b48 D7E9BC23 		ldrd	r2, [r7, #752]
 8007 0b4c CDE90823 		strd	r2, [sp, #32]
 8008 0b50 D7E9BE23 		ldrd	r2, [r7, #760]
 8009 0b54 CDE90623 		strd	r2, [sp, #24]
 8010 0b58 D7E9C023 		ldrd	r2, [r7, #768]
 8011 0b5c CDE90423 		strd	r2, [sp, #16]
 8012 0b60 D7E9C223 		ldrd	r2, [r7, #776]
 8013 0b64 CDE90223 		strd	r2, [sp, #8]
 8014 0b68 D7F8CC32 		ldr	r3, [r7, #716]
 8015 0b6c 0093     		str	r3, [sp]
 8016 0b6e D7F87033 		ldr	r3, [r7, #880]
 8017 0b72 D7F89022 		ldr	r2, [r7, #656]
 8018 0b76 D7F8E012 		ldr	r1, [r7, #736]
 8019 0b7a D7F8E802 		ldr	r0, [r7, #744]
 8020 0b7e FFF7FEFF 		bl	zint_co_reduce_mod
1880:keygen.c      **** 		zint_co_reduce_mod(v0, v1, x, len, x0i, pa, pb, qa, qb);
 8021              		.loc 2 1880 3 discriminator 2
 8022 0b82 D7E9BC23 		ldrd	r2, [r7, #752]
 8023 0b86 CDE90823 		strd	r2, [sp, #32]
 8024 0b8a D7E9BE23 		ldrd	r2, [r7, #760]
 8025 0b8e CDE90623 		strd	r2, [sp, #24]
 8026 0b92 D7E9C023 		ldrd	r2, [r7, #768]
 8027 0b96 CDE90423 		strd	r2, [sp, #16]
 8028 0b9a D7E9C223 		ldrd	r2, [r7, #776]
 8029 0b9e CDE90223 		strd	r2, [sp, #8]
 8030 0ba2 D7F8D032 		ldr	r3, [r7, #720]
 8031 0ba6 0093     		str	r3, [sp]
 8032 0ba8 D7F87033 		ldr	r3, [r7, #880]
 8033 0bac D7F89422 		ldr	r2, [r7, #660]
 8034 0bb0 D7F8DC12 		ldr	r1, [r7, #732]
 8035 0bb4 D7F8E402 		ldr	r0, [r7, #740]
 8036 0bb8 FFF7FEFF 		bl	zint_co_reduce_mod
 8037              	.LBE22:
1740:keygen.c      **** 		uint32_t c0, c1;
 8038              		.loc 2 1740 53 discriminator 2
 8039 0bbc D7F84C33 		ldr	r3, [r7, #844]
 8040 0bc0 1E3B     		subs	r3, r3, #30
 8041 0bc2 C7F84C33 		str	r3, [r7, #844]
 8042              	.L120:
1740:keygen.c      **** 		uint32_t c0, c1;
 8043              		.loc 2 1740 2 discriminator 1
 8044 0bc6 D7F84C33 		ldr	r3, [r7, #844]
 8045 0bca 1D2B     		cmp	r3, #29
 8046 0bcc 3FF6B2AA 		bhi	.L125
1881:keygen.c      **** 	}
1882:keygen.c      **** 
1883:keygen.c      **** 	/*
1884:keygen.c      **** 	 * At that point, array a[] should contain the GCD, and the
1885:keygen.c      **** 	 * results (u,v) should already be set. We check that the GCD
1886:keygen.c      **** 	 * is indeed 1. We also check that the two operands x and y
1887:keygen.c      **** 	 * are odd.
1888:keygen.c      **** 	 */
1889:keygen.c      **** 	rc = a[0] ^ 1;
 8047              		.loc 2 1889 8
 8048 0bd0 D7F8D832 		ldr	r3, [r7, #728]
 8049 0bd4 1B68     		ldr	r3, [r3]
 8050              		.loc 2 1889 5
 8051 0bd6 83F00103 		eor	r3, r3, #1
 8052 0bda C7F84833 		str	r3, [r7, #840]
1890:keygen.c      **** 	for (j = 1; j < len; j ++) {
 8053              		.loc 2 1890 9
 8054 0bde 0123     		movs	r3, #1
 8055 0be0 C7F84433 		str	r3, [r7, #836]
 8056              		.loc 2 1890 2
 8057 0be4 10E0     		b	.L126
 8058              	.L127:
1891:keygen.c      **** 		rc |= a[j];
 8059              		.loc 2 1891 10 discriminator 3
 8060 0be6 D7F84433 		ldr	r3, [r7, #836]
 8061 0bea 9B00     		lsls	r3, r3, #2
 8062 0bec D7F8D822 		ldr	r2, [r7, #728]
 8063 0bf0 1344     		add	r3, r3, r2
 8064 0bf2 1B68     		ldr	r3, [r3]
 8065              		.loc 2 1891 6 discriminator 3
 8066 0bf4 D7F84823 		ldr	r2, [r7, #840]
 8067 0bf8 1343     		orrs	r3, r3, r2
 8068 0bfa C7F84833 		str	r3, [r7, #840]
1890:keygen.c      **** 	for (j = 1; j < len; j ++) {
 8069              		.loc 2 1890 25 discriminator 3
 8070 0bfe D7F84433 		ldr	r3, [r7, #836]
 8071 0c02 0133     		adds	r3, r3, #1
 8072 0c04 C7F84433 		str	r3, [r7, #836]
 8073              	.L126:
1890:keygen.c      **** 	for (j = 1; j < len; j ++) {
 8074              		.loc 2 1890 2 discriminator 1
 8075 0c08 D7F84423 		ldr	r2, [r7, #836]
 8076 0c0c D7F87033 		ldr	r3, [r7, #880]
 8077 0c10 9A42     		cmp	r2, r3
 8078 0c12 E8D3     		bcc	.L127
1892:keygen.c      **** 	}
1893:keygen.c      **** 	return (int)((1 - ((rc | -rc) >> 31)) & x[0] & y[0]);
 8079              		.loc 2 1893 27
 8080 0c14 D7F84833 		ldr	r3, [r7, #840]
 8081 0c18 5A42     		rsbs	r2, r3, #0
 8082              		.loc 2 1893 25
 8083 0c1a D7F84833 		ldr	r3, [r7, #840]
 8084 0c1e 1343     		orrs	r3, r3, r2
 8085              		.loc 2 1893 32
 8086 0c20 DB17     		asrs	r3, r3, #31
 8087              		.loc 2 1893 18
 8088 0c22 5A1C     		adds	r2, r3, #1
 8089              		.loc 2 1893 43
 8090 0c24 D7F89432 		ldr	r3, [r7, #660]
 8091 0c28 1B68     		ldr	r3, [r3]
 8092              		.loc 2 1893 40
 8093 0c2a 1A40     		ands	r2, r2, r3
 8094              		.loc 2 1893 50
 8095 0c2c D7F89032 		ldr	r3, [r7, #656]
 8096 0c30 1B68     		ldr	r3, [r3]
 8097              		.loc 2 1893 47
 8098 0c32 1340     		ands	r3, r3, r2
 8099              	.L119:
1894:keygen.c      **** }
 8100              		.loc 2 1894 1
 8101 0c34 1846     		mov	r0, r3
 8102 0c36 07F55477 		add	r7, r7, #848
 8103              	.LCFI173:
 8104              		.cfi_def_cfa_offset 32
 8105 0c3a BD46     		mov	sp, r7
 8106              	.LCFI174:
 8107              		.cfi_def_cfa_register 13
 8108              		@ sp needed
 8109 0c3c BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 8110              		.cfi_endproc
 8111              	.LFE43:
 8113              		.section	.text.zint_add_scaled_mul_small,"ax",%progbits
 8114              		.align	1
 8115              		.syntax unified
 8116              		.thumb
 8117              		.thumb_func
 8118              		.fpu softvfp
 8120              	zint_add_scaled_mul_small:
 8121              	.LFB44:
1895:keygen.c      **** 
1896:keygen.c      **** /*
1897:keygen.c      ****  * Add k*y*2^sc to x. The result is assumed to fit in the array of
1898:keygen.c      ****  * size xlen (truncation is applied if necessary).
1899:keygen.c      ****  * Scale factor 'sc' is provided as sch and scl, such that:
1900:keygen.c      ****  *   sch = sc / 31
1901:keygen.c      ****  *   scl = sc % 31
1902:keygen.c      ****  * xlen MUST NOT be lower than ylen.
1903:keygen.c      ****  *
1904:keygen.c      ****  * x[] and y[] are both signed integers, using two's complement for
1905:keygen.c      ****  * negative values.
1906:keygen.c      ****  */
1907:keygen.c      **** static void
1908:keygen.c      **** zint_add_scaled_mul_small(uint32_t *restrict x, size_t xlen,
1909:keygen.c      **** 	const uint32_t *restrict y, size_t ylen, int32_t k,
1910:keygen.c      **** 	uint32_t sch, uint32_t scl)
1911:keygen.c      **** {
 8122              		.loc 2 1911 1
 8123              		.cfi_startproc
 8124              		@ args = 12, pretend = 0, frame = 96
 8125              		@ frame_needed = 1, uses_anonymous_args = 0
 8126              		@ link register save eliminated.
 8127 0000 2DE9B00F 		push	{r4, r5, r7, r8, r9, r10, fp}
 8128              	.LCFI175:
 8129              		.cfi_def_cfa_offset 28
 8130              		.cfi_offset 4, -28
 8131              		.cfi_offset 5, -24
 8132              		.cfi_offset 7, -20
 8133              		.cfi_offset 8, -16
 8134              		.cfi_offset 9, -12
 8135              		.cfi_offset 10, -8
 8136              		.cfi_offset 11, -4
 8137 0004 99B0     		sub	sp, sp, #100
 8138              	.LCFI176:
 8139              		.cfi_def_cfa_offset 128
 8140 0006 00AF     		add	r7, sp, #0
 8141              	.LCFI177:
 8142              		.cfi_def_cfa_register 7
 8143 0008 F862     		str	r0, [r7, #44]
 8144 000a B962     		str	r1, [r7, #40]
 8145 000c 7A62     		str	r2, [r7, #36]
 8146 000e 3B62     		str	r3, [r7, #32]
1912:keygen.c      **** 	size_t u;
1913:keygen.c      **** 	uint32_t ysign, tw;
1914:keygen.c      **** 	int32_t cc;
1915:keygen.c      **** 
1916:keygen.c      **** 	if (ylen == 0) {
 8147              		.loc 2 1916 5
 8148 0010 3B6A     		ldr	r3, [r7, #32]
 8149 0012 002B     		cmp	r3, #0
 8150 0014 00F08D80 		beq	.L135
1917:keygen.c      **** 		return;
1918:keygen.c      **** 	}
1919:keygen.c      **** 
1920:keygen.c      **** 	ysign = -(y[ylen - 1] >> 30) >> 1;
 8151              		.loc 2 1920 13
 8152 0018 3B6A     		ldr	r3, [r7, #32]
 8153 001a 03F18043 		add	r3, r3, #1073741824
 8154 001e 013B     		subs	r3, r3, #1
 8155 0020 9A00     		lsls	r2, r3, #2
 8156 0022 7B6A     		ldr	r3, [r7, #36]
 8157 0024 1344     		add	r3, r3, r2
 8158 0026 1B68     		ldr	r3, [r3]
 8159              		.loc 2 1920 24
 8160 0028 9B0F     		lsrs	r3, r3, #30
 8161              		.loc 2 1920 10
 8162 002a 5B42     		rsbs	r3, r3, #0
 8163              		.loc 2 1920 8
 8164 002c 5B08     		lsrs	r3, r3, #1
 8165 002e 3B65     		str	r3, [r7, #80]
1921:keygen.c      **** 	tw = 0;
 8166              		.loc 2 1921 5
 8167 0030 0023     		movs	r3, #0
 8168 0032 BB65     		str	r3, [r7, #88]
1922:keygen.c      **** 	cc = 0;
 8169              		.loc 2 1922 5
 8170 0034 0023     		movs	r3, #0
 8171 0036 7B65     		str	r3, [r7, #84]
1923:keygen.c      **** 	for (u = sch; u < xlen; u ++) {
 8172              		.loc 2 1923 9
 8173 0038 D7F88430 		ldr	r3, [r7, #132]
 8174 003c FB65     		str	r3, [r7, #92]
 8175              		.loc 2 1923 2
 8176 003e 73E0     		b	.L131
 8177              	.L134:
 8178              	.LBB25:
1924:keygen.c      **** 		size_t v;
1925:keygen.c      **** 		uint32_t wy, wys, ccu;
1926:keygen.c      **** 		uint64_t z;
1927:keygen.c      **** 
1928:keygen.c      **** 		/*
1929:keygen.c      **** 		 * Get the next word of y (scaled).
1930:keygen.c      **** 		 */
1931:keygen.c      **** 		v = u - sch;
 8179              		.loc 2 1931 5
 8180 0040 FA6D     		ldr	r2, [r7, #92]
 8181 0042 D7F88430 		ldr	r3, [r7, #132]
 8182 0046 D31A     		subs	r3, r2, r3
 8183 0048 FB64     		str	r3, [r7, #76]
1932:keygen.c      **** 		wy = v < ylen ? y[v] : ysign;
 8184              		.loc 2 1932 24
 8185 004a FA6C     		ldr	r2, [r7, #76]
 8186 004c 3B6A     		ldr	r3, [r7, #32]
 8187 004e 9A42     		cmp	r2, r3
 8188 0050 05D2     		bcs	.L132
 8189              		.loc 2 1932 20 discriminator 1
 8190 0052 FB6C     		ldr	r3, [r7, #76]
 8191 0054 9A00     		lsls	r2, r3, #2
 8192 0056 7B6A     		ldr	r3, [r7, #36]
 8193 0058 1344     		add	r3, r3, r2
 8194              		.loc 2 1932 24 discriminator 1
 8195 005a 1B68     		ldr	r3, [r3]
 8196 005c 00E0     		b	.L133
 8197              	.L132:
 8198              		.loc 2 1932 24 is_stmt 0 discriminator 2
 8199 005e 3B6D     		ldr	r3, [r7, #80]
 8200              	.L133:
 8201              		.loc 2 1932 6 is_stmt 1 discriminator 4
 8202 0060 BB64     		str	r3, [r7, #72]
1933:keygen.c      **** 		wys = ((wy << scl) & 0x7FFFFFFF) | tw;
 8203              		.loc 2 1933 14 discriminator 4
 8204 0062 BA6C     		ldr	r2, [r7, #72]
 8205 0064 D7F88830 		ldr	r3, [r7, #136]
 8206 0068 02FA03F3 		lsl	r3, r2, r3
 8207              		.loc 2 1933 22 discriminator 4
 8208 006c 23F00042 		bic	r2, r3, #-2147483648
 8209              		.loc 2 1933 7 discriminator 4
 8210 0070 BB6D     		ldr	r3, [r7, #88]
 8211 0072 1343     		orrs	r3, r3, r2
 8212 0074 7B64     		str	r3, [r7, #68]
1934:keygen.c      **** 		tw = wy >> (31 - scl);
 8213              		.loc 2 1934 18 discriminator 4
 8214 0076 D7F88830 		ldr	r3, [r7, #136]
 8215 007a C3F11F02 		rsb	r2, r3, #31
 8216              		.loc 2 1934 6 discriminator 4
 8217 007e BB6C     		ldr	r3, [r7, #72]
 8218 0080 D340     		lsrs	r3, r3, r2
 8219 0082 BB65     		str	r3, [r7, #88]
1935:keygen.c      **** 
1936:keygen.c      **** 		/*
1937:keygen.c      **** 		 * The expression below does not overflow.
1938:keygen.c      **** 		 */
1939:keygen.c      **** 		z = (uint64_t)((int64_t)wys * (int64_t)k + (int64_t)x[u] + cc);
 8220              		.loc 2 1939 18 discriminator 4
 8221 0084 7B6C     		ldr	r3, [r7, #68]
 8222 0086 0022     		movs	r2, #0
 8223 0088 9A46     		mov	r10, r3
 8224 008a 9346     		mov	fp, r2
 8225              		.loc 2 1939 33 discriminator 4
 8226 008c D7F88030 		ldr	r3, [r7, #128]
 8227 0090 DA17     		asrs	r2, r3, #31
 8228 0092 BB61     		str	r3, [r7, #24]
 8229 0094 FA61     		str	r2, [r7, #28]
 8230              		.loc 2 1939 31 discriminator 4
 8231 0096 D7E90601 		ldrd	r0, [r7, #24]
 8232 009a 0346     		mov	r3, r0
 8233 009c 03FB0BF2 		mul	r2, r3, fp
 8234 00a0 0B46     		mov	r3, r1
 8235 00a2 0AFB03F3 		mul	r3, r10, r3
 8236 00a6 1344     		add	r3, r3, r2
 8237 00a8 0246     		mov	r2, r0
 8238 00aa AAFB0245 		umull	r4, r5, r10, r2
 8239 00ae 2B44     		add	r3, r3, r5
 8240 00b0 1D46     		mov	r5, r3
 8241              		.loc 2 1939 56 discriminator 4
 8242 00b2 FB6D     		ldr	r3, [r7, #92]
 8243 00b4 9A00     		lsls	r2, r3, #2
 8244 00b6 FB6A     		ldr	r3, [r7, #44]
 8245 00b8 1344     		add	r3, r3, r2
 8246 00ba 1B68     		ldr	r3, [r3]
 8247              		.loc 2 1939 46 discriminator 4
 8248 00bc 0022     		movs	r2, #0
 8249 00be 3B61     		str	r3, [r7, #16]
 8250 00c0 7A61     		str	r2, [r7, #20]
 8251              		.loc 2 1939 44 discriminator 4
 8252 00c2 D7E90423 		ldrd	r2, [r7, #16]
 8253 00c6 1146     		mov	r1, r2
 8254 00c8 14EB0108 		adds	r8, r4, r1
 8255 00cc 45EB0309 		adc	r9, r5, r3
 8256              		.loc 2 1939 60 discriminator 4
 8257 00d0 7B6D     		ldr	r3, [r7, #84]
 8258 00d2 DA17     		asrs	r2, r3, #31
 8259 00d4 BB60     		str	r3, [r7, #8]
 8260 00d6 FA60     		str	r2, [r7, #12]
 8261 00d8 D7E90223 		ldrd	r2, [r7, #8]
 8262 00dc 1146     		mov	r1, r2
 8263 00de 18EB0101 		adds	r1, r8, r1
 8264 00e2 3960     		str	r1, [r7]
 8265 00e4 49EB0303 		adc	r3, r9, r3
 8266 00e8 7B60     		str	r3, [r7, #4]
 8267              		.loc 2 1939 5 discriminator 4
 8268 00ea D7E90023 		ldrd	r2, [r7]
 8269 00ee C7E90E23 		strd	r2, [r7, #56]
1940:keygen.c      **** 		x[u] = (uint32_t)z & 0x7FFFFFFF;
 8270              		.loc 2 1940 10 discriminator 4
 8271 00f2 B96B     		ldr	r1, [r7, #56]
 8272              		.loc 2 1940 4 discriminator 4
 8273 00f4 FB6D     		ldr	r3, [r7, #92]
 8274 00f6 9A00     		lsls	r2, r3, #2
 8275 00f8 FB6A     		ldr	r3, [r7, #44]
 8276 00fa 1A44     		add	r2, r2, r3
 8277              		.loc 2 1940 22 discriminator 4
 8278 00fc 21F00043 		bic	r3, r1, #-2147483648
 8279              		.loc 2 1940 8 discriminator 4
 8280 0100 1360     		str	r3, [r2]
1941:keygen.c      **** 
1942:keygen.c      **** 		/*
1943:keygen.c      **** 		 * Right-shifting the signed value z would yield
1944:keygen.c      **** 		 * implementation-defined results (arithmetic shift is
1945:keygen.c      **** 		 * not guaranteed). However, we can cast to unsigned,
1946:keygen.c      **** 		 * and get the next carry as an unsigned word. We can
1947:keygen.c      **** 		 * then convert it back to signed by using the guaranteed
1948:keygen.c      **** 		 * fact that 'int32_t' uses two's complement with no
1949:keygen.c      **** 		 * trap representation or padding bit, and with a layout
1950:keygen.c      **** 		 * compatible with that of 'uint32_t'.
1951:keygen.c      **** 		 */
1952:keygen.c      **** 		ccu = (uint32_t)(z >> 31);
 8281              		.loc 2 1952 22 discriminator 4
 8282 0102 D7E90E23 		ldrd	r2, [r7, #56]
 8283 0106 4FF00000 		mov	r0, #0
 8284 010a 4FF00001 		mov	r1, #0
 8285 010e D00F     		lsrs	r0, r2, #31
 8286 0110 40EA4300 		orr	r0, r0, r3, lsl #1
 8287 0114 D90F     		lsrs	r1, r3, #31
 8288              		.loc 2 1952 9 discriminator 4
 8289 0116 0346     		mov	r3, r0
 8290              		.loc 2 1952 7 discriminator 4
 8291 0118 7B63     		str	r3, [r7, #52]
1953:keygen.c      **** 		cc = *(int32_t *)&ccu;
 8292              		.loc 2 1953 20 discriminator 4
 8293 011a 07F13403 		add	r3, r7, #52
 8294              		.loc 2 1953 6 discriminator 4
 8295 011e 1B68     		ldr	r3, [r3]
 8296 0120 7B65     		str	r3, [r7, #84]
 8297              	.LBE25:
1923:keygen.c      **** 		size_t v;
 8298              		.loc 2 1923 28 discriminator 4
 8299 0122 FB6D     		ldr	r3, [r7, #92]
 8300 0124 0133     		adds	r3, r3, #1
 8301 0126 FB65     		str	r3, [r7, #92]
 8302              	.L131:
1923:keygen.c      **** 		size_t v;
 8303              		.loc 2 1923 2 discriminator 2
 8304 0128 FA6D     		ldr	r2, [r7, #92]
 8305 012a BB6A     		ldr	r3, [r7, #40]
 8306 012c 9A42     		cmp	r2, r3
 8307 012e 87D3     		bcc	.L134
 8308 0130 00E0     		b	.L128
 8309              	.L135:
1917:keygen.c      **** 	}
 8310              		.loc 2 1917 3
 8311 0132 00BF     		nop
 8312              	.L128:
1954:keygen.c      **** 	}
1955:keygen.c      **** }
 8313              		.loc 2 1955 1
 8314 0134 6437     		adds	r7, r7, #100
 8315              	.LCFI178:
 8316              		.cfi_def_cfa_offset 28
 8317 0136 BD46     		mov	sp, r7
 8318              	.LCFI179:
 8319              		.cfi_def_cfa_register 13
 8320              		@ sp needed
 8321 0138 BDE8B00F 		pop	{r4, r5, r7, r8, r9, r10, fp}
 8322              	.LCFI180:
 8323              		.cfi_restore 11
 8324              		.cfi_restore 10
 8325              		.cfi_restore 9
 8326              		.cfi_restore 8
 8327              		.cfi_restore 7
 8328              		.cfi_restore 5
 8329              		.cfi_restore 4
 8330              		.cfi_def_cfa_offset 0
 8331 013c 7047     		bx	lr
 8332              		.cfi_endproc
 8333              	.LFE44:
 8335              		.section	.text.zint_sub_scaled,"ax",%progbits
 8336              		.align	1
 8337              		.syntax unified
 8338              		.thumb
 8339              		.thumb_func
 8340              		.fpu softvfp
 8342              	zint_sub_scaled:
 8343              	.LFB45:
1956:keygen.c      **** 
1957:keygen.c      **** /*
1958:keygen.c      ****  * Subtract y*2^sc from x. The result is assumed to fit in the array of
1959:keygen.c      ****  * size xlen (truncation is applied if necessary).
1960:keygen.c      ****  * Scale factor 'sc' is provided as sch and scl, such that:
1961:keygen.c      ****  *   sch = sc / 31
1962:keygen.c      ****  *   scl = sc % 31
1963:keygen.c      ****  * xlen MUST NOT be lower than ylen.
1964:keygen.c      ****  *
1965:keygen.c      ****  * x[] and y[] are both signed integers, using two's complement for
1966:keygen.c      ****  * negative values.
1967:keygen.c      ****  */
1968:keygen.c      **** static void
1969:keygen.c      **** zint_sub_scaled(uint32_t *restrict x, size_t xlen,
1970:keygen.c      **** 	const uint32_t *restrict y, size_t ylen, uint32_t sch, uint32_t scl)
1971:keygen.c      **** {
 8344              		.loc 2 1971 1
 8345              		.cfi_startproc
 8346              		@ args = 8, pretend = 0, frame = 48
 8347              		@ frame_needed = 1, uses_anonymous_args = 0
 8348              		@ link register save eliminated.
 8349 0000 80B4     		push	{r7}
 8350              	.LCFI181:
 8351              		.cfi_def_cfa_offset 4
 8352              		.cfi_offset 7, -4
 8353 0002 8DB0     		sub	sp, sp, #52
 8354              	.LCFI182:
 8355              		.cfi_def_cfa_offset 56
 8356 0004 00AF     		add	r7, sp, #0
 8357              	.LCFI183:
 8358              		.cfi_def_cfa_register 7
 8359 0006 F860     		str	r0, [r7, #12]
 8360 0008 B960     		str	r1, [r7, #8]
 8361 000a 7A60     		str	r2, [r7, #4]
 8362 000c 3B60     		str	r3, [r7]
1972:keygen.c      **** 	size_t u;
1973:keygen.c      **** 	uint32_t ysign, tw;
1974:keygen.c      **** 	uint32_t cc;
1975:keygen.c      **** 
1976:keygen.c      **** 	if (ylen == 0) {
 8363              		.loc 2 1976 5
 8364 000e 3B68     		ldr	r3, [r7]
 8365 0010 002B     		cmp	r3, #0
 8366 0012 4FD0     		beq	.L143
1977:keygen.c      **** 		return;
1978:keygen.c      **** 	}
1979:keygen.c      **** 
1980:keygen.c      **** 	ysign = -(y[ylen - 1] >> 30) >> 1;
 8367              		.loc 2 1980 13
 8368 0014 3B68     		ldr	r3, [r7]
 8369 0016 03F18043 		add	r3, r3, #1073741824
 8370 001a 013B     		subs	r3, r3, #1
 8371 001c 9B00     		lsls	r3, r3, #2
 8372 001e 7A68     		ldr	r2, [r7, #4]
 8373 0020 1344     		add	r3, r3, r2
 8374 0022 1B68     		ldr	r3, [r3]
 8375              		.loc 2 1980 24
 8376 0024 9B0F     		lsrs	r3, r3, #30
 8377              		.loc 2 1980 10
 8378 0026 5B42     		rsbs	r3, r3, #0
 8379              		.loc 2 1980 8
 8380 0028 5B08     		lsrs	r3, r3, #1
 8381 002a 3B62     		str	r3, [r7, #32]
1981:keygen.c      **** 	tw = 0;
 8382              		.loc 2 1981 5
 8383 002c 0023     		movs	r3, #0
 8384 002e BB62     		str	r3, [r7, #40]
1982:keygen.c      **** 	cc = 0;
 8385              		.loc 2 1982 5
 8386 0030 0023     		movs	r3, #0
 8387 0032 7B62     		str	r3, [r7, #36]
1983:keygen.c      **** 	for (u = sch; u < xlen; u ++) {
 8388              		.loc 2 1983 9
 8389 0034 BB6B     		ldr	r3, [r7, #56]
 8390 0036 FB62     		str	r3, [r7, #44]
 8391              		.loc 2 1983 2
 8392 0038 37E0     		b	.L139
 8393              	.L142:
 8394              	.LBB26:
1984:keygen.c      **** 		size_t v;
1985:keygen.c      **** 		uint32_t w, wy, wys;
1986:keygen.c      **** 
1987:keygen.c      **** 		/*
1988:keygen.c      **** 		 * Get the next word of y (scaled).
1989:keygen.c      **** 		 */
1990:keygen.c      **** 		v = u - sch;
 8395              		.loc 2 1990 5
 8396 003a FA6A     		ldr	r2, [r7, #44]
 8397 003c BB6B     		ldr	r3, [r7, #56]
 8398 003e D31A     		subs	r3, r2, r3
 8399 0040 FB61     		str	r3, [r7, #28]
1991:keygen.c      **** 		wy = v < ylen ? y[v] : ysign;
 8400              		.loc 2 1991 24
 8401 0042 FA69     		ldr	r2, [r7, #28]
 8402 0044 3B68     		ldr	r3, [r7]
 8403 0046 9A42     		cmp	r2, r3
 8404 0048 05D2     		bcs	.L140
 8405              		.loc 2 1991 20 discriminator 1
 8406 004a FB69     		ldr	r3, [r7, #28]
 8407 004c 9B00     		lsls	r3, r3, #2
 8408 004e 7A68     		ldr	r2, [r7, #4]
 8409 0050 1344     		add	r3, r3, r2
 8410              		.loc 2 1991 24 discriminator 1
 8411 0052 1B68     		ldr	r3, [r3]
 8412 0054 00E0     		b	.L141
 8413              	.L140:
 8414              		.loc 2 1991 24 is_stmt 0 discriminator 2
 8415 0056 3B6A     		ldr	r3, [r7, #32]
 8416              	.L141:
 8417              		.loc 2 1991 6 is_stmt 1 discriminator 4
 8418 0058 BB61     		str	r3, [r7, #24]
1992:keygen.c      **** 		wys = ((wy << scl) & 0x7FFFFFFF) | tw;
 8419              		.loc 2 1992 14 discriminator 4
 8420 005a BA69     		ldr	r2, [r7, #24]
 8421 005c FB6B     		ldr	r3, [r7, #60]
 8422 005e 02FA03F3 		lsl	r3, r2, r3
 8423              		.loc 2 1992 22 discriminator 4
 8424 0062 23F00043 		bic	r3, r3, #-2147483648
 8425              		.loc 2 1992 7 discriminator 4
 8426 0066 BA6A     		ldr	r2, [r7, #40]
 8427 0068 1343     		orrs	r3, r3, r2
 8428 006a 7B61     		str	r3, [r7, #20]
1993:keygen.c      **** 		tw = wy >> (31 - scl);
 8429              		.loc 2 1993 18 discriminator 4
 8430 006c FB6B     		ldr	r3, [r7, #60]
 8431 006e C3F11F03 		rsb	r3, r3, #31
 8432              		.loc 2 1993 6 discriminator 4
 8433 0072 BA69     		ldr	r2, [r7, #24]
 8434 0074 22FA03F3 		lsr	r3, r2, r3
 8435 0078 BB62     		str	r3, [r7, #40]
1994:keygen.c      **** 
1995:keygen.c      **** 		w = x[u] - wys - cc;
 8436              		.loc 2 1995 8 discriminator 4
 8437 007a FB6A     		ldr	r3, [r7, #44]
 8438 007c 9B00     		lsls	r3, r3, #2
 8439 007e FA68     		ldr	r2, [r7, #12]
 8440 0080 1344     		add	r3, r3, r2
 8441 0082 1A68     		ldr	r2, [r3]
 8442              		.loc 2 1995 12 discriminator 4
 8443 0084 7B69     		ldr	r3, [r7, #20]
 8444 0086 D21A     		subs	r2, r2, r3
 8445              		.loc 2 1995 5 discriminator 4
 8446 0088 7B6A     		ldr	r3, [r7, #36]
 8447 008a D31A     		subs	r3, r2, r3
 8448 008c 3B61     		str	r3, [r7, #16]
1996:keygen.c      **** 		x[u] = w & 0x7FFFFFFF;
 8449              		.loc 2 1996 4 discriminator 4
 8450 008e FB6A     		ldr	r3, [r7, #44]
 8451 0090 9B00     		lsls	r3, r3, #2
 8452 0092 FA68     		ldr	r2, [r7, #12]
 8453 0094 1344     		add	r3, r3, r2
 8454              		.loc 2 1996 12 discriminator 4
 8455 0096 3A69     		ldr	r2, [r7, #16]
 8456 0098 22F00042 		bic	r2, r2, #-2147483648
 8457              		.loc 2 1996 8 discriminator 4
 8458 009c 1A60     		str	r2, [r3]
1997:keygen.c      **** 		cc = w >> 31;
 8459              		.loc 2 1997 6 discriminator 4
 8460 009e 3B69     		ldr	r3, [r7, #16]
 8461 00a0 DB0F     		lsrs	r3, r3, #31
 8462 00a2 7B62     		str	r3, [r7, #36]
 8463              	.LBE26:
1983:keygen.c      **** 		size_t v;
 8464              		.loc 2 1983 28 discriminator 4
 8465 00a4 FB6A     		ldr	r3, [r7, #44]
 8466 00a6 0133     		adds	r3, r3, #1
 8467 00a8 FB62     		str	r3, [r7, #44]
 8468              	.L139:
1983:keygen.c      **** 		size_t v;
 8469              		.loc 2 1983 2 discriminator 2
 8470 00aa FA6A     		ldr	r2, [r7, #44]
 8471 00ac BB68     		ldr	r3, [r7, #8]
 8472 00ae 9A42     		cmp	r2, r3
 8473 00b0 C3D3     		bcc	.L142
 8474 00b2 00E0     		b	.L136
 8475              	.L143:
1977:keygen.c      **** 	}
 8476              		.loc 2 1977 3
 8477 00b4 00BF     		nop
 8478              	.L136:
1998:keygen.c      **** 	}
1999:keygen.c      **** }
 8479              		.loc 2 1999 1
 8480 00b6 3437     		adds	r7, r7, #52
 8481              	.LCFI184:
 8482              		.cfi_def_cfa_offset 4
 8483 00b8 BD46     		mov	sp, r7
 8484              	.LCFI185:
 8485              		.cfi_def_cfa_register 13
 8486              		@ sp needed
 8487 00ba 80BC     		pop	{r7}
 8488              	.LCFI186:
 8489              		.cfi_restore 7
 8490              		.cfi_def_cfa_offset 0
 8491 00bc 7047     		bx	lr
 8492              		.cfi_endproc
 8493              	.LFE45:
 8495              		.section	.text.zint_one_to_plain,"ax",%progbits
 8496              		.align	1
 8497              		.syntax unified
 8498              		.thumb
 8499              		.thumb_func
 8500              		.fpu softvfp
 8502              	zint_one_to_plain:
 8503              	.LFB46:
2000:keygen.c      **** 
2001:keygen.c      **** /*
2002:keygen.c      ****  * Convert a one-word signed big integer into a signed value.
2003:keygen.c      ****  */
2004:keygen.c      **** static inline int32_t
2005:keygen.c      **** zint_one_to_plain(const uint32_t *x)
2006:keygen.c      **** {
 8504              		.loc 2 2006 1
 8505              		.cfi_startproc
 8506              		@ args = 0, pretend = 0, frame = 16
 8507              		@ frame_needed = 1, uses_anonymous_args = 0
 8508              		@ link register save eliminated.
 8509 0000 80B4     		push	{r7}
 8510              	.LCFI187:
 8511              		.cfi_def_cfa_offset 4
 8512              		.cfi_offset 7, -4
 8513 0002 85B0     		sub	sp, sp, #20
 8514              	.LCFI188:
 8515              		.cfi_def_cfa_offset 24
 8516 0004 00AF     		add	r7, sp, #0
 8517              	.LCFI189:
 8518              		.cfi_def_cfa_register 7
 8519 0006 7860     		str	r0, [r7, #4]
2007:keygen.c      **** 	uint32_t w;
2008:keygen.c      **** 
2009:keygen.c      **** 	w = x[0];
 8520              		.loc 2 2009 7
 8521 0008 7B68     		ldr	r3, [r7, #4]
 8522 000a 1B68     		ldr	r3, [r3]
 8523              		.loc 2 2009 4
 8524 000c FB60     		str	r3, [r7, #12]
2010:keygen.c      **** 	w |= (w & 0x40000000) << 1;
 8525              		.loc 2 2010 24
 8526 000e FB68     		ldr	r3, [r7, #12]
 8527 0010 5B00     		lsls	r3, r3, #1
 8528 0012 03F00042 		and	r2, r3, #-2147483648
 8529              		.loc 2 2010 4
 8530 0016 FB68     		ldr	r3, [r7, #12]
 8531 0018 1343     		orrs	r3, r3, r2
 8532 001a FB60     		str	r3, [r7, #12]
2011:keygen.c      **** 	return *(int32_t *)&w;
 8533              		.loc 2 2011 21
 8534 001c 07F10C03 		add	r3, r7, #12
 8535              		.loc 2 2011 9
 8536 0020 1B68     		ldr	r3, [r3]
2012:keygen.c      **** }
 8537              		.loc 2 2012 1
 8538 0022 1846     		mov	r0, r3
 8539 0024 1437     		adds	r7, r7, #20
 8540              	.LCFI190:
 8541              		.cfi_def_cfa_offset 4
 8542 0026 BD46     		mov	sp, r7
 8543              	.LCFI191:
 8544              		.cfi_def_cfa_register 13
 8545              		@ sp needed
 8546 0028 80BC     		pop	{r7}
 8547              	.LCFI192:
 8548              		.cfi_restore 7
 8549              		.cfi_def_cfa_offset 0
 8550 002a 7047     		bx	lr
 8551              		.cfi_endproc
 8552              	.LFE46:
 8554              		.section	.text.poly_big_to_fp,"ax",%progbits
 8555              		.align	1
 8556              		.syntax unified
 8557              		.thumb
 8558              		.thumb_func
 8559              		.fpu softvfp
 8561              	poly_big_to_fp:
 8562              	.LFB47:
2013:keygen.c      **** 
2014:keygen.c      **** /* ==================================================================== */
2015:keygen.c      **** 
2016:keygen.c      **** /*
2017:keygen.c      ****  * Convert a polynomial to floating-point values.
2018:keygen.c      ****  *
2019:keygen.c      ****  * Each coefficient has length flen words, and starts fstride words after
2020:keygen.c      ****  * the previous.
2021:keygen.c      ****  *
2022:keygen.c      ****  * IEEE-754 binary64 values can represent values in a finite range,
2023:keygen.c      ****  * roughly 2^(-1023) to 2^(+1023); thus, if coefficients are too large,
2024:keygen.c      ****  * they should be "trimmed" by pointing not to the lowest word of each,
2025:keygen.c      ****  * but upper.
2026:keygen.c      ****  */
2027:keygen.c      **** static void
2028:keygen.c      **** poly_big_to_fp(fpr *d, const uint32_t *f, size_t flen, size_t fstride,
2029:keygen.c      **** 	unsigned logn)
2030:keygen.c      **** {
 8563              		.loc 2 2030 1
 8564              		.cfi_startproc
 8565              		@ args = 4, pretend = 0, frame = 64
 8566              		@ frame_needed = 1, uses_anonymous_args = 0
 8567 0000 B0B5     		push	{r4, r5, r7, lr}
 8568              	.LCFI193:
 8569              		.cfi_def_cfa_offset 16
 8570              		.cfi_offset 4, -16
 8571              		.cfi_offset 5, -12
 8572              		.cfi_offset 7, -8
 8573              		.cfi_offset 14, -4
 8574 0002 90B0     		sub	sp, sp, #64
 8575              	.LCFI194:
 8576              		.cfi_def_cfa_offset 80
 8577 0004 00AF     		add	r7, sp, #0
 8578              	.LCFI195:
 8579              		.cfi_def_cfa_register 7
 8580 0006 F860     		str	r0, [r7, #12]
 8581 0008 B960     		str	r1, [r7, #8]
 8582 000a 7A60     		str	r2, [r7, #4]
 8583 000c 3B60     		str	r3, [r7]
2031:keygen.c      **** 	size_t n, u;
2032:keygen.c      **** 
2033:keygen.c      **** 	n = MKN(logn);
 8584              		.loc 2 2033 4
 8585 000e 0122     		movs	r2, #1
 8586 0010 3B6D     		ldr	r3, [r7, #80]
 8587 0012 02FA03F3 		lsl	r3, r2, r3
 8588 0016 FB61     		str	r3, [r7, #28]
2034:keygen.c      **** 	if (flen == 0) {
 8589              		.loc 2 2034 5
 8590 0018 7B68     		ldr	r3, [r7, #4]
 8591 001a 002B     		cmp	r3, #0
 8592 001c 14D1     		bne	.L147
2035:keygen.c      **** 		for (u = 0; u < n; u ++) {
 8593              		.loc 2 2035 10
 8594 001e 0023     		movs	r3, #0
 8595 0020 FB63     		str	r3, [r7, #60]
 8596              		.loc 2 2035 3
 8597 0022 0CE0     		b	.L148
 8598              	.L149:
2036:keygen.c      **** 			d[u] = fpr_zero;
 8599              		.loc 2 2036 5 discriminator 3
 8600 0024 FB6B     		ldr	r3, [r7, #60]
 8601 0026 DB00     		lsls	r3, r3, #3
 8602 0028 FA68     		ldr	r2, [r7, #12]
 8603 002a D118     		adds	r1, r2, r3
 8604              		.loc 2 2036 9 discriminator 3
 8605 002c 4FF00002 		mov	r2, #0
 8606 0030 4FF00003 		mov	r3, #0
 8607 0034 C1E90023 		strd	r2, [r1]
2035:keygen.c      **** 		for (u = 0; u < n; u ++) {
 8608              		.loc 2 2035 24 discriminator 3
 8609 0038 FB6B     		ldr	r3, [r7, #60]
 8610 003a 0133     		adds	r3, r3, #1
 8611 003c FB63     		str	r3, [r7, #60]
 8612              	.L148:
2035:keygen.c      **** 		for (u = 0; u < n; u ++) {
 8613              		.loc 2 2035 3 discriminator 1
 8614 003e FA6B     		ldr	r2, [r7, #60]
 8615 0040 FB69     		ldr	r3, [r7, #28]
 8616 0042 9A42     		cmp	r2, r3
 8617 0044 EED3     		bcc	.L149
2037:keygen.c      **** 		}
2038:keygen.c      **** 		return;
 8618              		.loc 2 2038 3
 8619 0046 74E0     		b	.L146
 8620              	.L147:
2039:keygen.c      **** 	}
2040:keygen.c      **** 	for (u = 0; u < n; u ++, f += fstride) {
 8621              		.loc 2 2040 9
 8622 0048 0023     		movs	r3, #0
 8623 004a FB63     		str	r3, [r7, #60]
 8624              		.loc 2 2040 2
 8625 004c 6DE0     		b	.L151
 8626              	.L154:
 8627              	.LBB27:
2041:keygen.c      **** 		size_t v;
2042:keygen.c      **** 		uint32_t neg, cc, xm;
2043:keygen.c      **** 		fpr x, fsc;
2044:keygen.c      **** 
2045:keygen.c      **** 		/*
2046:keygen.c      **** 		 * Get sign of the integer; if it is negative, then we
2047:keygen.c      **** 		 * will load its absolute value instead, and negate the
2048:keygen.c      **** 		 * result.
2049:keygen.c      **** 		 */
2050:keygen.c      **** 		neg = -(f[flen - 1] >> 30);
 8628              		.loc 2 2050 12
 8629 004e 7B68     		ldr	r3, [r7, #4]
 8630 0050 03F18043 		add	r3, r3, #1073741824
 8631 0054 013B     		subs	r3, r3, #1
 8632 0056 9B00     		lsls	r3, r3, #2
 8633 0058 BA68     		ldr	r2, [r7, #8]
 8634 005a 1344     		add	r3, r3, r2
 8635 005c 1B68     		ldr	r3, [r3]
 8636              		.loc 2 2050 23
 8637 005e 9B0F     		lsrs	r3, r3, #30
 8638              		.loc 2 2050 7
 8639 0060 5B42     		rsbs	r3, r3, #0
 8640 0062 BB61     		str	r3, [r7, #24]
2051:keygen.c      **** 		xm = neg >> 1;
 8641              		.loc 2 2051 6
 8642 0064 BB69     		ldr	r3, [r7, #24]
 8643 0066 5B08     		lsrs	r3, r3, #1
 8644 0068 7B61     		str	r3, [r7, #20]
2052:keygen.c      **** 		cc = neg & 1;
 8645              		.loc 2 2052 6
 8646 006a BB69     		ldr	r3, [r7, #24]
 8647 006c 03F00103 		and	r3, r3, #1
 8648 0070 7B63     		str	r3, [r7, #52]
2053:keygen.c      **** 		x = fpr_zero;
 8649              		.loc 2 2053 5
 8650 0072 4FF00002 		mov	r2, #0
 8651 0076 4FF00003 		mov	r3, #0
 8652 007a C7E90A23 		strd	r2, [r7, #40]
2054:keygen.c      **** 		fsc = fpr_one;
 8653              		.loc 2 2054 7
 8654 007e 4FF00002 		mov	r2, #0
 8655 0082 2D4B     		ldr	r3, .L155
 8656 0084 C7E90823 		strd	r2, [r7, #32]
2055:keygen.c      **** 		for (v = 0; v < flen; v ++, fsc = fpr_mul(fsc, fpr_ptwo31)) {
 8657              		.loc 2 2055 10
 8658 0088 0023     		movs	r3, #0
 8659 008a BB63     		str	r3, [r7, #56]
 8660              		.loc 2 2055 3
 8661 008c 39E0     		b	.L152
 8662              	.L153:
 8663              	.LBB28:
2056:keygen.c      **** 			uint32_t w;
2057:keygen.c      **** 
2058:keygen.c      **** 			w = (f[v] ^ xm) + cc;
 8664              		.loc 2 2058 10 discriminator 3
 8665 008e BB6B     		ldr	r3, [r7, #56]
 8666 0090 9B00     		lsls	r3, r3, #2
 8667 0092 BA68     		ldr	r2, [r7, #8]
 8668 0094 1344     		add	r3, r3, r2
 8669 0096 1A68     		ldr	r2, [r3]
 8670              		.loc 2 2058 14 discriminator 3
 8671 0098 7B69     		ldr	r3, [r7, #20]
 8672 009a 5A40     		eors	r2, r2, r3
 8673              		.loc 2 2058 20 discriminator 3
 8674 009c 7B6B     		ldr	r3, [r7, #52]
 8675 009e 1344     		add	r3, r3, r2
 8676              		.loc 2 2058 6 discriminator 3
 8677 00a0 3B61     		str	r3, [r7, #16]
2059:keygen.c      **** 			cc = w >> 31;
 8678              		.loc 2 2059 11 discriminator 3
 8679 00a2 3B69     		ldr	r3, [r7, #16]
 8680              		.loc 2 2059 7 discriminator 3
 8681 00a4 DB0F     		lsrs	r3, r3, #31
 8682 00a6 7B63     		str	r3, [r7, #52]
2060:keygen.c      **** 			w &= 0x7FFFFFFF;
 8683              		.loc 2 2060 6 discriminator 3
 8684 00a8 3B69     		ldr	r3, [r7, #16]
 8685 00aa 23F00043 		bic	r3, r3, #-2147483648
 8686 00ae 3B61     		str	r3, [r7, #16]
2061:keygen.c      **** 			w -= (w << 1) & neg;
 8687              		.loc 2 2061 6 discriminator 3
 8688 00b0 3A69     		ldr	r2, [r7, #16]
 8689              		.loc 2 2061 12 discriminator 3
 8690 00b2 3B69     		ldr	r3, [r7, #16]
 8691 00b4 5900     		lsls	r1, r3, #1
 8692              		.loc 2 2061 18 discriminator 3
 8693 00b6 BB69     		ldr	r3, [r7, #24]
 8694 00b8 0B40     		ands	r3, r3, r1
 8695              		.loc 2 2061 6 discriminator 3
 8696 00ba D31A     		subs	r3, r2, r3
 8697 00bc 3B61     		str	r3, [r7, #16]
2062:keygen.c      **** 			x = fpr_add(x, fpr_mul(fpr_of(*(int32_t *)&w), fsc));
 8698              		.loc 2 2062 46 discriminator 3
 8699 00be 07F11003 		add	r3, r7, #16
 8700              		.loc 2 2062 34 discriminator 3
 8701 00c2 1B68     		ldr	r3, [r3]
 8702              		.loc 2 2062 8 discriminator 3
 8703 00c4 DA17     		asrs	r2, r3, #31
 8704 00c6 1C46     		mov	r4, r3
 8705 00c8 1546     		mov	r5, r2
 8706 00ca 2046     		mov	r0, r4
 8707 00cc 2946     		mov	r1, r5
 8708 00ce FFF7FEFF 		bl	fpr_of
 8709 00d2 D7E90823 		ldrd	r2, [r7, #32]
 8710 00d6 FFF7FEFF 		bl	falcon_inner_fpr_mul
 8711 00da 0246     		mov	r2, r0
 8712 00dc 0B46     		mov	r3, r1
 8713 00de D7E90A01 		ldrd	r0, [r7, #40]
 8714 00e2 FFF7FEFF 		bl	falcon_inner_fpr_add
 8715 00e6 C7E90A01 		strd	r0, [r7, #40]
 8716              	.LBE28:
2055:keygen.c      **** 			uint32_t w;
 8717              		.loc 2 2055 27 discriminator 3
 8718 00ea BB6B     		ldr	r3, [r7, #56]
 8719 00ec 0133     		adds	r3, r3, #1
 8720 00ee BB63     		str	r3, [r7, #56]
2055:keygen.c      **** 			uint32_t w;
 8721              		.loc 2 2055 37 discriminator 3
 8722 00f0 4FF00002 		mov	r2, #0
 8723 00f4 114B     		ldr	r3, .L155+4
 8724 00f6 D7E90801 		ldrd	r0, [r7, #32]
 8725 00fa FFF7FEFF 		bl	falcon_inner_fpr_mul
 8726 00fe C7E90801 		strd	r0, [r7, #32]
 8727              	.L152:
2055:keygen.c      **** 			uint32_t w;
 8728              		.loc 2 2055 3 discriminator 1
 8729 0102 BA6B     		ldr	r2, [r7, #56]
 8730 0104 7B68     		ldr	r3, [r7, #4]
 8731 0106 9A42     		cmp	r2, r3
 8732 0108 C1D3     		bcc	.L153
2063:keygen.c      **** 		}
2064:keygen.c      **** 		d[u] = x;
 8733              		.loc 2 2064 4 discriminator 2
 8734 010a FB6B     		ldr	r3, [r7, #60]
 8735 010c DB00     		lsls	r3, r3, #3
 8736 010e FA68     		ldr	r2, [r7, #12]
 8737 0110 D118     		adds	r1, r2, r3
 8738              		.loc 2 2064 8 discriminator 2
 8739 0112 D7E90A23 		ldrd	r2, [r7, #40]
 8740 0116 C1E90023 		strd	r2, [r1]
 8741              	.LBE27:
2040:keygen.c      **** 		size_t v;
 8742              		.loc 2 2040 23 discriminator 2
 8743 011a FB6B     		ldr	r3, [r7, #60]
 8744 011c 0133     		adds	r3, r3, #1
 8745 011e FB63     		str	r3, [r7, #60]
2040:keygen.c      **** 		size_t v;
 8746              		.loc 2 2040 29 discriminator 2
 8747 0120 3B68     		ldr	r3, [r7]
 8748 0122 9B00     		lsls	r3, r3, #2
 8749 0124 BA68     		ldr	r2, [r7, #8]
 8750 0126 1344     		add	r3, r3, r2
 8751 0128 BB60     		str	r3, [r7, #8]
 8752              	.L151:
2040:keygen.c      **** 		size_t v;
 8753              		.loc 2 2040 2 discriminator 1
 8754 012a FA6B     		ldr	r2, [r7, #60]
 8755 012c FB69     		ldr	r3, [r7, #28]
 8756 012e 9A42     		cmp	r2, r3
 8757 0130 8DD3     		bcc	.L154
 8758              	.L146:
2065:keygen.c      **** 	}
2066:keygen.c      **** }
 8759              		.loc 2 2066 1
 8760 0132 4037     		adds	r7, r7, #64
 8761              	.LCFI196:
 8762              		.cfi_def_cfa_offset 16
 8763 0134 BD46     		mov	sp, r7
 8764              	.LCFI197:
 8765              		.cfi_def_cfa_register 13
 8766              		@ sp needed
 8767 0136 B0BD     		pop	{r4, r5, r7, pc}
 8768              	.L156:
 8769              		.align	2
 8770              	.L155:
 8771 0138 0000F03F 		.word	1072693248
 8772 013c 0000E041 		.word	1105199104
 8773              		.cfi_endproc
 8774              	.LFE47:
 8776              		.section	.text.poly_big_to_small,"ax",%progbits
 8777              		.align	1
 8778              		.syntax unified
 8779              		.thumb
 8780              		.thumb_func
 8781              		.fpu softvfp
 8783              	poly_big_to_small:
 8784              	.LFB48:
2067:keygen.c      **** 
2068:keygen.c      **** /*
2069:keygen.c      ****  * Convert a polynomial to small integers. Source values are supposed
2070:keygen.c      ****  * to be one-word integers, signed over 31 bits. Returned value is 0
2071:keygen.c      ****  * if any of the coefficients exceeds the provided limit (in absolute
2072:keygen.c      ****  * value), or 1 on success.
2073:keygen.c      ****  *
2074:keygen.c      ****  * This is not constant-time; this is not a problem here, because on
2075:keygen.c      ****  * any failure, the NTRU-solving process will be deemed to have failed
2076:keygen.c      ****  * and the (f,g) polynomials will be discarded.
2077:keygen.c      ****  */
2078:keygen.c      **** static int
2079:keygen.c      **** poly_big_to_small(int8_t *d, const uint32_t *s, int lim, unsigned logn)
2080:keygen.c      **** {
 8785              		.loc 2 2080 1
 8786              		.cfi_startproc
 8787              		@ args = 0, pretend = 0, frame = 32
 8788              		@ frame_needed = 1, uses_anonymous_args = 0
 8789 0000 80B5     		push	{r7, lr}
 8790              	.LCFI198:
 8791              		.cfi_def_cfa_offset 8
 8792              		.cfi_offset 7, -8
 8793              		.cfi_offset 14, -4
 8794 0002 88B0     		sub	sp, sp, #32
 8795              	.LCFI199:
 8796              		.cfi_def_cfa_offset 40
 8797 0004 00AF     		add	r7, sp, #0
 8798              	.LCFI200:
 8799              		.cfi_def_cfa_register 7
 8800 0006 F860     		str	r0, [r7, #12]
 8801 0008 B960     		str	r1, [r7, #8]
 8802 000a 7A60     		str	r2, [r7, #4]
 8803 000c 3B60     		str	r3, [r7]
2081:keygen.c      **** 	size_t n, u;
2082:keygen.c      **** 
2083:keygen.c      **** 	n = MKN(logn);
 8804              		.loc 2 2083 4
 8805 000e 0122     		movs	r2, #1
 8806 0010 3B68     		ldr	r3, [r7]
 8807 0012 02FA03F3 		lsl	r3, r2, r3
 8808 0016 BB61     		str	r3, [r7, #24]
2084:keygen.c      **** 	for (u = 0; u < n; u ++) {
 8809              		.loc 2 2084 9
 8810 0018 0023     		movs	r3, #0
 8811 001a FB61     		str	r3, [r7, #28]
 8812              		.loc 2 2084 2
 8813 001c 1BE0     		b	.L158
 8814              	.L162:
 8815              	.LBB29:
2085:keygen.c      **** 		int32_t z;
2086:keygen.c      **** 
2087:keygen.c      **** 		z = zint_one_to_plain(s + u);
 8816              		.loc 2 2087 27
 8817 001e FB69     		ldr	r3, [r7, #28]
 8818 0020 9B00     		lsls	r3, r3, #2
 8819              		.loc 2 2087 7
 8820 0022 BA68     		ldr	r2, [r7, #8]
 8821 0024 1344     		add	r3, r3, r2
 8822 0026 1846     		mov	r0, r3
 8823 0028 FFF7FEFF 		bl	zint_one_to_plain
 8824 002c 7861     		str	r0, [r7, #20]
2088:keygen.c      **** 		if (z < -lim || z > lim) {
 8825              		.loc 2 2088 11
 8826 002e 7B68     		ldr	r3, [r7, #4]
 8827 0030 5B42     		rsbs	r3, r3, #0
 8828              		.loc 2 2088 6
 8829 0032 7A69     		ldr	r2, [r7, #20]
 8830 0034 9A42     		cmp	r2, r3
 8831 0036 03DB     		blt	.L159
 8832              		.loc 2 2088 16 discriminator 1
 8833 0038 7A69     		ldr	r2, [r7, #20]
 8834 003a 7B68     		ldr	r3, [r7, #4]
 8835 003c 9A42     		cmp	r2, r3
 8836 003e 01DD     		ble	.L160
 8837              	.L159:
2089:keygen.c      **** 			return 0;
 8838              		.loc 2 2089 11
 8839 0040 0023     		movs	r3, #0
 8840 0042 0DE0     		b	.L161
 8841              	.L160:
2090:keygen.c      **** 		}
2091:keygen.c      **** 		d[u] = (int8_t)z;
 8842              		.loc 2 2091 4 discriminator 2
 8843 0044 FA68     		ldr	r2, [r7, #12]
 8844 0046 FB69     		ldr	r3, [r7, #28]
 8845 0048 1344     		add	r3, r3, r2
 8846              		.loc 2 2091 10 discriminator 2
 8847 004a 7A69     		ldr	r2, [r7, #20]
 8848 004c 52B2     		sxtb	r2, r2
 8849              		.loc 2 2091 8 discriminator 2
 8850 004e 1A70     		strb	r2, [r3]
 8851              	.LBE29:
2084:keygen.c      **** 		int32_t z;
 8852              		.loc 2 2084 23 discriminator 2
 8853 0050 FB69     		ldr	r3, [r7, #28]
 8854 0052 0133     		adds	r3, r3, #1
 8855 0054 FB61     		str	r3, [r7, #28]
 8856              	.L158:
2084:keygen.c      **** 		int32_t z;
 8857              		.loc 2 2084 2 discriminator 1
 8858 0056 FA69     		ldr	r2, [r7, #28]
 8859 0058 BB69     		ldr	r3, [r7, #24]
 8860 005a 9A42     		cmp	r2, r3
 8861 005c DFD3     		bcc	.L162
2092:keygen.c      **** 	}
2093:keygen.c      **** 	return 1;
 8862              		.loc 2 2093 9
 8863 005e 0123     		movs	r3, #1
 8864              	.L161:
2094:keygen.c      **** }
 8865              		.loc 2 2094 1
 8866 0060 1846     		mov	r0, r3
 8867 0062 2037     		adds	r7, r7, #32
 8868              	.LCFI201:
 8869              		.cfi_def_cfa_offset 8
 8870 0064 BD46     		mov	sp, r7
 8871              	.LCFI202:
 8872              		.cfi_def_cfa_register 13
 8873              		@ sp needed
 8874 0066 80BD     		pop	{r7, pc}
 8875              		.cfi_endproc
 8876              	.LFE48:
 8878              		.section	.text.poly_sub_scaled,"ax",%progbits
 8879              		.align	1
 8880              		.syntax unified
 8881              		.thumb
 8882              		.thumb_func
 8883              		.fpu softvfp
 8885              	poly_sub_scaled:
 8886              	.LFB49:
2095:keygen.c      **** 
2096:keygen.c      **** /*
2097:keygen.c      ****  * Subtract k*f from F, where F, f and k are polynomials modulo X^N+1.
2098:keygen.c      ****  * Coefficients of polynomial k are small integers (signed values in the
2099:keygen.c      ****  * -2^31..2^31 range) scaled by 2^sc. Value sc is provided as sch = sc / 31
2100:keygen.c      ****  * and scl = sc % 31.
2101:keygen.c      ****  *
2102:keygen.c      ****  * This function implements the basic quadratic multiplication algorithm,
2103:keygen.c      ****  * which is efficient in space (no extra buffer needed) but slow at
2104:keygen.c      ****  * high degree.
2105:keygen.c      ****  */
2106:keygen.c      **** static void
2107:keygen.c      **** poly_sub_scaled(uint32_t *restrict F, size_t Flen, size_t Fstride,
2108:keygen.c      **** 	const uint32_t *restrict f, size_t flen, size_t fstride,
2109:keygen.c      **** 	const int32_t *restrict k, uint32_t sch, uint32_t scl, unsigned logn)
2110:keygen.c      **** {
 8887              		.loc 2 2110 1
 8888              		.cfi_startproc
 8889              		@ args = 24, pretend = 0, frame = 40
 8890              		@ frame_needed = 1, uses_anonymous_args = 0
 8891 0000 80B5     		push	{r7, lr}
 8892              	.LCFI203:
 8893              		.cfi_def_cfa_offset 8
 8894              		.cfi_offset 7, -8
 8895              		.cfi_offset 14, -4
 8896 0002 8EB0     		sub	sp, sp, #56
 8897              	.LCFI204:
 8898              		.cfi_def_cfa_offset 64
 8899 0004 04AF     		add	r7, sp, #16
 8900              	.LCFI205:
 8901              		.cfi_def_cfa 7, 48
 8902 0006 F860     		str	r0, [r7, #12]
 8903 0008 B960     		str	r1, [r7, #8]
 8904 000a 7A60     		str	r2, [r7, #4]
 8905 000c 3B60     		str	r3, [r7]
2111:keygen.c      **** 	size_t n, u;
2112:keygen.c      **** 
2113:keygen.c      **** 	n = MKN(logn);
 8906              		.loc 2 2113 4
 8907 000e 0122     		movs	r2, #1
 8908 0010 7B6C     		ldr	r3, [r7, #68]
 8909 0012 02FA03F3 		lsl	r3, r2, r3
 8910 0016 3B61     		str	r3, [r7, #16]
2114:keygen.c      **** 	for (u = 0; u < n; u ++) {
 8911              		.loc 2 2114 9
 8912 0018 0023     		movs	r3, #0
 8913 001a 7B62     		str	r3, [r7, #36]
 8914              		.loc 2 2114 2
 8915 001c 40E0     		b	.L164
 8916              	.L169:
 8917              	.LBB30:
2115:keygen.c      **** 		int32_t kf;
2116:keygen.c      **** 		size_t v;
2117:keygen.c      **** 		uint32_t *x;
2118:keygen.c      **** 		const uint32_t *y;
2119:keygen.c      **** 
2120:keygen.c      **** 		kf = -k[u];
 8918              		.loc 2 2120 10
 8919 001e 7B6A     		ldr	r3, [r7, #36]
 8920 0020 9B00     		lsls	r3, r3, #2
 8921 0022 BA6B     		ldr	r2, [r7, #56]
 8922 0024 1344     		add	r3, r3, r2
 8923 0026 1B68     		ldr	r3, [r3]
 8924              		.loc 2 2120 6
 8925 0028 5B42     		rsbs	r3, r3, #0
 8926 002a 3B62     		str	r3, [r7, #32]
2121:keygen.c      **** 		x = F + u * Fstride;
 8927              		.loc 2 2121 13
 8928 002c 7B6A     		ldr	r3, [r7, #36]
 8929 002e 7A68     		ldr	r2, [r7, #4]
 8930 0030 02FB03F3 		mul	r3, r2, r3
 8931              		.loc 2 2121 9
 8932 0034 9B00     		lsls	r3, r3, #2
 8933              		.loc 2 2121 5
 8934 0036 FA68     		ldr	r2, [r7, #12]
 8935 0038 1344     		add	r3, r3, r2
 8936 003a BB61     		str	r3, [r7, #24]
2122:keygen.c      **** 		y = f;
 8937              		.loc 2 2122 5
 8938 003c 3B68     		ldr	r3, [r7]
 8939 003e 7B61     		str	r3, [r7, #20]
2123:keygen.c      **** 		for (v = 0; v < n; v ++) {
 8940              		.loc 2 2123 10
 8941 0040 0023     		movs	r3, #0
 8942 0042 FB61     		str	r3, [r7, #28]
 8943              		.loc 2 2123 3
 8944 0044 25E0     		b	.L165
 8945              	.L168:
2124:keygen.c      **** 			zint_add_scaled_mul_small(
 8946              		.loc 2 2124 4
 8947 0046 3B6C     		ldr	r3, [r7, #64]
 8948 0048 0293     		str	r3, [sp, #8]
 8949 004a FB6B     		ldr	r3, [r7, #60]
 8950 004c 0193     		str	r3, [sp, #4]
 8951 004e 3B6A     		ldr	r3, [r7, #32]
 8952 0050 0093     		str	r3, [sp]
 8953 0052 3B6B     		ldr	r3, [r7, #48]
 8954 0054 7A69     		ldr	r2, [r7, #20]
 8955 0056 B968     		ldr	r1, [r7, #8]
 8956 0058 B869     		ldr	r0, [r7, #24]
 8957 005a FFF7FEFF 		bl	zint_add_scaled_mul_small
2125:keygen.c      **** 				x, Flen, y, flen, kf, sch, scl);
2126:keygen.c      **** 			if (u + v == n - 1) {
 8958              		.loc 2 2126 10
 8959 005e 7A6A     		ldr	r2, [r7, #36]
 8960 0060 FB69     		ldr	r3, [r7, #28]
 8961 0062 1A44     		add	r2, r2, r3
 8962              		.loc 2 2126 19
 8963 0064 3B69     		ldr	r3, [r7, #16]
 8964 0066 013B     		subs	r3, r3, #1
 8965              		.loc 2 2126 7
 8966 0068 9A42     		cmp	r2, r3
 8967 006a 05D1     		bne	.L166
2127:keygen.c      **** 				x = F;
 8968              		.loc 2 2127 7
 8969 006c FB68     		ldr	r3, [r7, #12]
 8970 006e BB61     		str	r3, [r7, #24]
2128:keygen.c      **** 				kf = -kf;
 8971              		.loc 2 2128 8
 8972 0070 3B6A     		ldr	r3, [r7, #32]
 8973 0072 5B42     		rsbs	r3, r3, #0
 8974 0074 3B62     		str	r3, [r7, #32]
 8975 0076 04E0     		b	.L167
 8976              	.L166:
2129:keygen.c      **** 			} else {
2130:keygen.c      **** 				x += Fstride;
 8977              		.loc 2 2130 7
 8978 0078 7B68     		ldr	r3, [r7, #4]
 8979 007a 9B00     		lsls	r3, r3, #2
 8980 007c BA69     		ldr	r2, [r7, #24]
 8981 007e 1344     		add	r3, r3, r2
 8982 0080 BB61     		str	r3, [r7, #24]
 8983              	.L167:
2131:keygen.c      **** 			}
2132:keygen.c      **** 			y += fstride;
 8984              		.loc 2 2132 6 discriminator 2
 8985 0082 7B6B     		ldr	r3, [r7, #52]
 8986 0084 9B00     		lsls	r3, r3, #2
 8987 0086 7A69     		ldr	r2, [r7, #20]
 8988 0088 1344     		add	r3, r3, r2
 8989 008a 7B61     		str	r3, [r7, #20]
2123:keygen.c      **** 			zint_add_scaled_mul_small(
 8990              		.loc 2 2123 24 discriminator 2
 8991 008c FB69     		ldr	r3, [r7, #28]
 8992 008e 0133     		adds	r3, r3, #1
 8993 0090 FB61     		str	r3, [r7, #28]
 8994              	.L165:
2123:keygen.c      **** 			zint_add_scaled_mul_small(
 8995              		.loc 2 2123 3 discriminator 1
 8996 0092 FA69     		ldr	r2, [r7, #28]
 8997 0094 3B69     		ldr	r3, [r7, #16]
 8998 0096 9A42     		cmp	r2, r3
 8999 0098 D5D3     		bcc	.L168
 9000              	.LBE30:
2114:keygen.c      **** 		int32_t kf;
 9001              		.loc 2 2114 23 discriminator 2
 9002 009a 7B6A     		ldr	r3, [r7, #36]
 9003 009c 0133     		adds	r3, r3, #1
 9004 009e 7B62     		str	r3, [r7, #36]
 9005              	.L164:
2114:keygen.c      **** 		int32_t kf;
 9006              		.loc 2 2114 2 discriminator 1
 9007 00a0 7A6A     		ldr	r2, [r7, #36]
 9008 00a2 3B69     		ldr	r3, [r7, #16]
 9009 00a4 9A42     		cmp	r2, r3
 9010 00a6 BAD3     		bcc	.L169
2133:keygen.c      **** 		}
2134:keygen.c      **** 	}
2135:keygen.c      **** }
 9011              		.loc 2 2135 1
 9012 00a8 00BF     		nop
 9013 00aa 00BF     		nop
 9014 00ac 2837     		adds	r7, r7, #40
 9015              	.LCFI206:
 9016              		.cfi_def_cfa_offset 8
 9017 00ae BD46     		mov	sp, r7
 9018              	.LCFI207:
 9019              		.cfi_def_cfa_register 13
 9020              		@ sp needed
 9021 00b0 80BD     		pop	{r7, pc}
 9022              		.cfi_endproc
 9023              	.LFE49:
 9025              		.section	.text.poly_sub_scaled_ntt,"ax",%progbits
 9026              		.align	1
 9027              		.syntax unified
 9028              		.thumb
 9029              		.thumb_func
 9030              		.fpu softvfp
 9032              	poly_sub_scaled_ntt:
 9033              	.LFB50:
2136:keygen.c      **** 
2137:keygen.c      **** /*
2138:keygen.c      ****  * Subtract k*f from F. Coefficients of polynomial k are small integers
2139:keygen.c      ****  * (signed values in the -2^31..2^31 range) scaled by 2^sc. This function
2140:keygen.c      ****  * assumes that the degree is large, and integers relatively small.
2141:keygen.c      ****  * The value sc is provided as sch = sc / 31 and scl = sc % 31.
2142:keygen.c      ****  */
2143:keygen.c      **** static void
2144:keygen.c      **** poly_sub_scaled_ntt(uint32_t *restrict F, size_t Flen, size_t Fstride,
2145:keygen.c      **** 	const uint32_t *restrict f, size_t flen, size_t fstride,
2146:keygen.c      **** 	const int32_t *restrict k, uint32_t sch, uint32_t scl, unsigned logn,
2147:keygen.c      **** 	uint32_t *restrict tmp)
2148:keygen.c      **** {
 9034              		.loc 2 2148 1
 9035              		.cfi_startproc
 9036              		@ args = 28, pretend = 0, frame = 80
 9037              		@ frame_needed = 1, uses_anonymous_args = 0
 9038 0000 90B5     		push	{r4, r7, lr}
 9039              	.LCFI208:
 9040              		.cfi_def_cfa_offset 12
 9041              		.cfi_offset 4, -12
 9042              		.cfi_offset 7, -8
 9043              		.cfi_offset 14, -4
 9044 0002 99B0     		sub	sp, sp, #100
 9045              	.LCFI209:
 9046              		.cfi_def_cfa_offset 112
 9047 0004 04AF     		add	r7, sp, #16
 9048              	.LCFI210:
 9049              		.cfi_def_cfa 7, 96
 9050 0006 F860     		str	r0, [r7, #12]
 9051 0008 B960     		str	r1, [r7, #8]
 9052 000a 7A60     		str	r2, [r7, #4]
 9053 000c 3B60     		str	r3, [r7]
2149:keygen.c      **** 	uint32_t *gm, *igm, *fk, *t1, *x;
2150:keygen.c      **** 	const uint32_t *y;
2151:keygen.c      **** 	size_t n, u, tlen;
2152:keygen.c      **** 	const small_prime *primes;
2153:keygen.c      **** 
2154:keygen.c      **** 	n = MKN(logn);
 9054              		.loc 2 2154 4
 9055 000e 0122     		movs	r2, #1
 9056 0010 7B6F     		ldr	r3, [r7, #116]
 9057 0012 02FA03F3 		lsl	r3, r2, r3
 9058 0016 FB63     		str	r3, [r7, #60]
2155:keygen.c      **** 	tlen = flen + 1;
 9059              		.loc 2 2155 7
 9060 0018 3B6E     		ldr	r3, [r7, #96]
 9061 001a 0133     		adds	r3, r3, #1
 9062 001c BB63     		str	r3, [r7, #56]
2156:keygen.c      **** 	gm = tmp;
 9063              		.loc 2 2156 5
 9064 001e BB6F     		ldr	r3, [r7, #120]
 9065 0020 7B63     		str	r3, [r7, #52]
2157:keygen.c      **** 	igm = gm + MKN(logn);
 9066              		.loc 2 2157 11
 9067 0022 0422     		movs	r2, #4
 9068 0024 7B6F     		ldr	r3, [r7, #116]
 9069 0026 02FA03F3 		lsl	r3, r2, r3
 9070              		.loc 2 2157 6
 9071 002a 7A6B     		ldr	r2, [r7, #52]
 9072 002c 1344     		add	r3, r3, r2
 9073 002e 3B63     		str	r3, [r7, #48]
2158:keygen.c      **** 	fk = igm + MKN(logn);
 9074              		.loc 2 2158 11
 9075 0030 0422     		movs	r2, #4
 9076 0032 7B6F     		ldr	r3, [r7, #116]
 9077 0034 02FA03F3 		lsl	r3, r2, r3
 9078              		.loc 2 2158 5
 9079 0038 3A6B     		ldr	r2, [r7, #48]
 9080 003a 1344     		add	r3, r3, r2
 9081 003c FB62     		str	r3, [r7, #44]
2159:keygen.c      **** 	t1 = fk + n * tlen;
 9082              		.loc 2 2159 14
 9083 003e FB6B     		ldr	r3, [r7, #60]
 9084 0040 BA6B     		ldr	r2, [r7, #56]
 9085 0042 02FB03F3 		mul	r3, r2, r3
 9086              		.loc 2 2159 10
 9087 0046 9B00     		lsls	r3, r3, #2
 9088              		.loc 2 2159 5
 9089 0048 FA6A     		ldr	r2, [r7, #44]
 9090 004a 1344     		add	r3, r3, r2
 9091 004c BB62     		str	r3, [r7, #40]
2160:keygen.c      **** 
2161:keygen.c      **** 	primes = PRIMES;
 9092              		.loc 2 2161 9
 9093 004e 7C4B     		ldr	r3, .L181
 9094 0050 7B62     		str	r3, [r7, #36]
2162:keygen.c      **** 
2163:keygen.c      **** 	/*
2164:keygen.c      **** 	 * Compute k*f in fk[], in RNS notation.
2165:keygen.c      **** 	 */
2166:keygen.c      **** 	for (u = 0; u < tlen; u ++) {
 9095              		.loc 2 2166 9
 9096 0052 0023     		movs	r3, #0
 9097 0054 7B64     		str	r3, [r7, #68]
 9098              		.loc 2 2166 2
 9099 0056 BAE0     		b	.L171
 9100              	.L178:
 9101              	.LBB31:
2167:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
2168:keygen.c      **** 		size_t v;
2169:keygen.c      **** 
2170:keygen.c      **** 		p = primes[u].p;
 9102              		.loc 2 2170 13
 9103 0058 7A6C     		ldr	r2, [r7, #68]
 9104 005a 1346     		mov	r3, r2
 9105 005c 5B00     		lsls	r3, r3, #1
 9106 005e 1344     		add	r3, r3, r2
 9107 0060 9B00     		lsls	r3, r3, #2
 9108 0062 1A46     		mov	r2, r3
 9109 0064 7B6A     		ldr	r3, [r7, #36]
 9110 0066 1344     		add	r3, r3, r2
 9111              		.loc 2 2170 5
 9112 0068 1B68     		ldr	r3, [r3]
 9113 006a 3B62     		str	r3, [r7, #32]
2171:keygen.c      **** 		p0i = modp_ninv31(p);
 9114              		.loc 2 2171 9
 9115 006c 386A     		ldr	r0, [r7, #32]
 9116 006e FFF7FEFF 		bl	modp_ninv31
 9117 0072 F861     		str	r0, [r7, #28]
2172:keygen.c      **** 		R2 = modp_R2(p, p0i);
 9118              		.loc 2 2172 8
 9119 0074 F969     		ldr	r1, [r7, #28]
 9120 0076 386A     		ldr	r0, [r7, #32]
 9121 0078 FFF7FEFF 		bl	modp_R2
 9122 007c B861     		str	r0, [r7, #24]
2173:keygen.c      **** 		Rx = modp_Rx((unsigned)flen, p, p0i, R2);
 9123              		.loc 2 2173 8
 9124 007e BB69     		ldr	r3, [r7, #24]
 9125 0080 FA69     		ldr	r2, [r7, #28]
 9126 0082 396A     		ldr	r1, [r7, #32]
 9127 0084 386E     		ldr	r0, [r7, #96]
 9128 0086 FFF7FEFF 		bl	modp_Rx
 9129 008a 7861     		str	r0, [r7, #20]
2174:keygen.c      **** 		modp_mkgm2(gm, igm, logn, primes[u].g, p, p0i);
 9130              		.loc 2 2174 35
 9131 008c 7A6C     		ldr	r2, [r7, #68]
 9132 008e 1346     		mov	r3, r2
 9133 0090 5B00     		lsls	r3, r3, #1
 9134 0092 1344     		add	r3, r3, r2
 9135 0094 9B00     		lsls	r3, r3, #2
 9136 0096 1A46     		mov	r2, r3
 9137 0098 7B6A     		ldr	r3, [r7, #36]
 9138 009a 1344     		add	r3, r3, r2
 9139              		.loc 2 2174 3
 9140 009c 5A68     		ldr	r2, [r3, #4]
 9141 009e FB69     		ldr	r3, [r7, #28]
 9142 00a0 0193     		str	r3, [sp, #4]
 9143 00a2 3B6A     		ldr	r3, [r7, #32]
 9144 00a4 0093     		str	r3, [sp]
 9145 00a6 1346     		mov	r3, r2
 9146 00a8 7A6F     		ldr	r2, [r7, #116]
 9147 00aa 396B     		ldr	r1, [r7, #48]
 9148 00ac 786B     		ldr	r0, [r7, #52]
 9149 00ae FFF7FEFF 		bl	modp_mkgm2
2175:keygen.c      **** 
2176:keygen.c      **** 		for (v = 0; v < n; v ++) {
 9150              		.loc 2 2176 10
 9151 00b2 0023     		movs	r3, #0
 9152 00b4 3B64     		str	r3, [r7, #64]
 9153              		.loc 2 2176 3
 9154 00b6 10E0     		b	.L172
 9155              	.L173:
2177:keygen.c      **** 			t1[v] = modp_set(k[v], p);
 9156              		.loc 2 2177 22 discriminator 3
 9157 00b8 3B6C     		ldr	r3, [r7, #64]
 9158 00ba 9B00     		lsls	r3, r3, #2
 9159 00bc BA6E     		ldr	r2, [r7, #104]
 9160 00be 1344     		add	r3, r3, r2
 9161              		.loc 2 2177 12 discriminator 3
 9162 00c0 1868     		ldr	r0, [r3]
 9163              		.loc 2 2177 6 discriminator 3
 9164 00c2 3B6C     		ldr	r3, [r7, #64]
 9165 00c4 9B00     		lsls	r3, r3, #2
 9166 00c6 BA6A     		ldr	r2, [r7, #40]
 9167 00c8 D418     		adds	r4, r2, r3
 9168              		.loc 2 2177 12 discriminator 3
 9169 00ca 396A     		ldr	r1, [r7, #32]
 9170 00cc FFF7FEFF 		bl	modp_set
 9171 00d0 0346     		mov	r3, r0
 9172              		.loc 2 2177 10 discriminator 3
 9173 00d2 2360     		str	r3, [r4]
2176:keygen.c      **** 			t1[v] = modp_set(k[v], p);
 9174              		.loc 2 2176 24 discriminator 3
 9175 00d4 3B6C     		ldr	r3, [r7, #64]
 9176 00d6 0133     		adds	r3, r3, #1
 9177 00d8 3B64     		str	r3, [r7, #64]
 9178              	.L172:
2176:keygen.c      **** 			t1[v] = modp_set(k[v], p);
 9179              		.loc 2 2176 3 discriminator 1
 9180 00da 3A6C     		ldr	r2, [r7, #64]
 9181 00dc FB6B     		ldr	r3, [r7, #60]
 9182 00de 9A42     		cmp	r2, r3
 9183 00e0 EAD3     		bcc	.L173
2178:keygen.c      **** 		}
2179:keygen.c      **** 		modp_NTT2(t1, gm, logn, p, p0i);
 9184              		.loc 2 2179 3
 9185 00e2 FB69     		ldr	r3, [r7, #28]
 9186 00e4 0193     		str	r3, [sp, #4]
 9187 00e6 3B6A     		ldr	r3, [r7, #32]
 9188 00e8 0093     		str	r3, [sp]
 9189 00ea 7B6F     		ldr	r3, [r7, #116]
 9190 00ec 7A6B     		ldr	r2, [r7, #52]
 9191 00ee 0121     		movs	r1, #1
 9192 00f0 B86A     		ldr	r0, [r7, #40]
 9193 00f2 FFF7FEFF 		bl	modp_NTT2_ext
2180:keygen.c      **** 		for (v = 0, y = f, x = fk + u;
 9194              		.loc 2 2180 10
 9195 00f6 0023     		movs	r3, #0
 9196 00f8 3B64     		str	r3, [r7, #64]
 9197              		.loc 2 2180 17
 9198 00fa 3B68     		ldr	r3, [r7]
 9199 00fc BB64     		str	r3, [r7, #72]
 9200              		.loc 2 2180 29
 9201 00fe 7B6C     		ldr	r3, [r7, #68]
 9202 0100 9B00     		lsls	r3, r3, #2
 9203              		.loc 2 2180 24
 9204 0102 FA6A     		ldr	r2, [r7, #44]
 9205 0104 1344     		add	r3, r3, r2
 9206 0106 FB64     		str	r3, [r7, #76]
 9207              		.loc 2 2180 3
 9208 0108 19E0     		b	.L174
 9209              	.L175:
2181:keygen.c      **** 			v < n; v ++, y += fstride, x += tlen)
2182:keygen.c      **** 		{
2183:keygen.c      **** 			*x = zint_mod_small_signed(y, flen, p, p0i, R2, Rx);
 9210              		.loc 2 2183 9
 9211 010a 7B69     		ldr	r3, [r7, #20]
 9212 010c 0193     		str	r3, [sp, #4]
 9213 010e BB69     		ldr	r3, [r7, #24]
 9214 0110 0093     		str	r3, [sp]
 9215 0112 FB69     		ldr	r3, [r7, #28]
 9216 0114 3A6A     		ldr	r2, [r7, #32]
 9217 0116 396E     		ldr	r1, [r7, #96]
 9218 0118 B86C     		ldr	r0, [r7, #72]
 9219 011a FFF7FEFF 		bl	zint_mod_small_signed
 9220 011e 0246     		mov	r2, r0
 9221              		.loc 2 2183 7
 9222 0120 FB6C     		ldr	r3, [r7, #76]
 9223 0122 1A60     		str	r2, [r3]
2181:keygen.c      **** 			v < n; v ++, y += fstride, x += tlen)
 9224              		.loc 2 2181 13
 9225 0124 3B6C     		ldr	r3, [r7, #64]
 9226 0126 0133     		adds	r3, r3, #1
 9227 0128 3B64     		str	r3, [r7, #64]
2181:keygen.c      **** 			v < n; v ++, y += fstride, x += tlen)
 9228              		.loc 2 2181 19
 9229 012a 7B6E     		ldr	r3, [r7, #100]
 9230 012c 9B00     		lsls	r3, r3, #2
 9231 012e BA6C     		ldr	r2, [r7, #72]
 9232 0130 1344     		add	r3, r3, r2
 9233 0132 BB64     		str	r3, [r7, #72]
2181:keygen.c      **** 			v < n; v ++, y += fstride, x += tlen)
 9234              		.loc 2 2181 33
 9235 0134 BB6B     		ldr	r3, [r7, #56]
 9236 0136 9B00     		lsls	r3, r3, #2
 9237 0138 FA6C     		ldr	r2, [r7, #76]
 9238 013a 1344     		add	r3, r3, r2
 9239 013c FB64     		str	r3, [r7, #76]
 9240              	.L174:
2180:keygen.c      **** 		for (v = 0, y = f, x = fk + u;
 9241              		.loc 2 2180 3 discriminator 1
 9242 013e 3A6C     		ldr	r2, [r7, #64]
 9243 0140 FB6B     		ldr	r3, [r7, #60]
 9244 0142 9A42     		cmp	r2, r3
 9245 0144 E1D3     		bcc	.L175
2184:keygen.c      **** 		}
2185:keygen.c      **** 		modp_NTT2_ext(fk + u, tlen, gm, logn, p, p0i);
 9246              		.loc 2 2185 20
 9247 0146 7B6C     		ldr	r3, [r7, #68]
 9248 0148 9B00     		lsls	r3, r3, #2
 9249              		.loc 2 2185 3
 9250 014a FA6A     		ldr	r2, [r7, #44]
 9251 014c D018     		adds	r0, r2, r3
 9252 014e FB69     		ldr	r3, [r7, #28]
 9253 0150 0193     		str	r3, [sp, #4]
 9254 0152 3B6A     		ldr	r3, [r7, #32]
 9255 0154 0093     		str	r3, [sp]
 9256 0156 7B6F     		ldr	r3, [r7, #116]
 9257 0158 7A6B     		ldr	r2, [r7, #52]
 9258 015a B96B     		ldr	r1, [r7, #56]
 9259 015c FFF7FEFF 		bl	modp_NTT2_ext
2186:keygen.c      **** 		for (v = 0, x = fk + u; v < n; v ++, x += tlen) {
 9260              		.loc 2 2186 10
 9261 0160 0023     		movs	r3, #0
 9262 0162 3B64     		str	r3, [r7, #64]
 9263              		.loc 2 2186 22
 9264 0164 7B6C     		ldr	r3, [r7, #68]
 9265 0166 9B00     		lsls	r3, r3, #2
 9266              		.loc 2 2186 17
 9267 0168 FA6A     		ldr	r2, [r7, #44]
 9268 016a 1344     		add	r3, r3, r2
 9269 016c FB64     		str	r3, [r7, #76]
 9270              		.loc 2 2186 3
 9271 016e 1AE0     		b	.L176
 9272              	.L177:
2187:keygen.c      **** 			*x = modp_montymul(
2188:keygen.c      **** 				modp_montymul(t1[v], *x, p, p0i), R2, p, p0i);
 9273              		.loc 2 2188 21 discriminator 3
 9274 0170 3B6C     		ldr	r3, [r7, #64]
 9275 0172 9B00     		lsls	r3, r3, #2
 9276 0174 BA6A     		ldr	r2, [r7, #40]
 9277 0176 1344     		add	r3, r3, r2
2187:keygen.c      **** 			*x = modp_montymul(
 9278              		.loc 2 2187 9 discriminator 3
 9279 0178 1868     		ldr	r0, [r3]
 9280 017a FB6C     		ldr	r3, [r7, #76]
 9281 017c 1968     		ldr	r1, [r3]
 9282 017e FB69     		ldr	r3, [r7, #28]
 9283 0180 3A6A     		ldr	r2, [r7, #32]
 9284 0182 FFF7FEFF 		bl	modp_montymul
 9285 0186 FB69     		ldr	r3, [r7, #28]
 9286 0188 3A6A     		ldr	r2, [r7, #32]
 9287 018a B969     		ldr	r1, [r7, #24]
 9288 018c FFF7FEFF 		bl	modp_montymul
 9289 0190 0246     		mov	r2, r0
2187:keygen.c      **** 			*x = modp_montymul(
 9290              		.loc 2 2187 7 discriminator 3
 9291 0192 FB6C     		ldr	r3, [r7, #76]
 9292 0194 1A60     		str	r2, [r3]
2186:keygen.c      **** 		for (v = 0, x = fk + u; v < n; v ++, x += tlen) {
 9293              		.loc 2 2186 36 discriminator 3
 9294 0196 3B6C     		ldr	r3, [r7, #64]
 9295 0198 0133     		adds	r3, r3, #1
 9296 019a 3B64     		str	r3, [r7, #64]
2186:keygen.c      **** 		for (v = 0, x = fk + u; v < n; v ++, x += tlen) {
 9297              		.loc 2 2186 42 discriminator 3
 9298 019c BB6B     		ldr	r3, [r7, #56]
 9299 019e 9B00     		lsls	r3, r3, #2
 9300 01a0 FA6C     		ldr	r2, [r7, #76]
 9301 01a2 1344     		add	r3, r3, r2
 9302 01a4 FB64     		str	r3, [r7, #76]
 9303              	.L176:
2186:keygen.c      **** 		for (v = 0, x = fk + u; v < n; v ++, x += tlen) {
 9304              		.loc 2 2186 3 discriminator 1
 9305 01a6 3A6C     		ldr	r2, [r7, #64]
 9306 01a8 FB6B     		ldr	r3, [r7, #60]
 9307 01aa 9A42     		cmp	r2, r3
 9308 01ac E0D3     		bcc	.L177
2189:keygen.c      **** 		}
2190:keygen.c      **** 		modp_iNTT2_ext(fk + u, tlen, igm, logn, p, p0i);
 9309              		.loc 2 2190 21 discriminator 2
 9310 01ae 7B6C     		ldr	r3, [r7, #68]
 9311 01b0 9B00     		lsls	r3, r3, #2
 9312              		.loc 2 2190 3 discriminator 2
 9313 01b2 FA6A     		ldr	r2, [r7, #44]
 9314 01b4 D018     		adds	r0, r2, r3
 9315 01b6 FB69     		ldr	r3, [r7, #28]
 9316 01b8 0193     		str	r3, [sp, #4]
 9317 01ba 3B6A     		ldr	r3, [r7, #32]
 9318 01bc 0093     		str	r3, [sp]
 9319 01be 7B6F     		ldr	r3, [r7, #116]
 9320 01c0 3A6B     		ldr	r2, [r7, #48]
 9321 01c2 B96B     		ldr	r1, [r7, #56]
 9322 01c4 FFF7FEFF 		bl	modp_iNTT2_ext
 9323              	.LBE31:
2166:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
 9324              		.loc 2 2166 26 discriminator 2
 9325 01c8 7B6C     		ldr	r3, [r7, #68]
 9326 01ca 0133     		adds	r3, r3, #1
 9327 01cc 7B64     		str	r3, [r7, #68]
 9328              	.L171:
2166:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
 9329              		.loc 2 2166 2 discriminator 1
 9330 01ce 7A6C     		ldr	r2, [r7, #68]
 9331 01d0 BB6B     		ldr	r3, [r7, #56]
 9332 01d2 9A42     		cmp	r2, r3
 9333 01d4 FFF440AF 		bcc	.L178
2191:keygen.c      **** 	}
2192:keygen.c      **** 
2193:keygen.c      **** 	/*
2194:keygen.c      **** 	 * Rebuild k*f.
2195:keygen.c      **** 	 */
2196:keygen.c      **** 	zint_rebuild_CRT(fk, tlen, tlen, n, primes, 1, t1);
 9334              		.loc 2 2196 2
 9335 01d8 BB6A     		ldr	r3, [r7, #40]
 9336 01da 0293     		str	r3, [sp, #8]
 9337 01dc 0123     		movs	r3, #1
 9338 01de 0193     		str	r3, [sp, #4]
 9339 01e0 7B6A     		ldr	r3, [r7, #36]
 9340 01e2 0093     		str	r3, [sp]
 9341 01e4 FB6B     		ldr	r3, [r7, #60]
 9342 01e6 BA6B     		ldr	r2, [r7, #56]
 9343 01e8 B96B     		ldr	r1, [r7, #56]
 9344 01ea F86A     		ldr	r0, [r7, #44]
 9345 01ec FFF7FEFF 		bl	zint_rebuild_CRT
2197:keygen.c      **** 
2198:keygen.c      **** 	/*
2199:keygen.c      **** 	 * Subtract k*f, scaled, from F.
2200:keygen.c      **** 	 */
2201:keygen.c      **** 	for (u = 0, x = F, y = fk; u < n; u ++, x += Fstride, y += tlen) {
 9346              		.loc 2 2201 9
 9347 01f0 0023     		movs	r3, #0
 9348 01f2 7B64     		str	r3, [r7, #68]
 9349              		.loc 2 2201 16
 9350 01f4 FB68     		ldr	r3, [r7, #12]
 9351 01f6 FB64     		str	r3, [r7, #76]
 9352              		.loc 2 2201 23
 9353 01f8 FB6A     		ldr	r3, [r7, #44]
 9354 01fa BB64     		str	r3, [r7, #72]
 9355              		.loc 2 2201 2
 9356 01fc 16E0     		b	.L179
 9357              	.L180:
2202:keygen.c      **** 		zint_sub_scaled(x, Flen, y, tlen, sch, scl);
 9358              		.loc 2 2202 3 discriminator 3
 9359 01fe 3B6F     		ldr	r3, [r7, #112]
 9360 0200 0193     		str	r3, [sp, #4]
 9361 0202 FB6E     		ldr	r3, [r7, #108]
 9362 0204 0093     		str	r3, [sp]
 9363 0206 BB6B     		ldr	r3, [r7, #56]
 9364 0208 BA6C     		ldr	r2, [r7, #72]
 9365 020a B968     		ldr	r1, [r7, #8]
 9366 020c F86C     		ldr	r0, [r7, #76]
 9367 020e FFF7FEFF 		bl	zint_sub_scaled
2201:keygen.c      **** 		zint_sub_scaled(x, Flen, y, tlen, sch, scl);
 9368              		.loc 2 2201 38 discriminator 3
 9369 0212 7B6C     		ldr	r3, [r7, #68]
 9370 0214 0133     		adds	r3, r3, #1
 9371 0216 7B64     		str	r3, [r7, #68]
2201:keygen.c      **** 		zint_sub_scaled(x, Flen, y, tlen, sch, scl);
 9372              		.loc 2 2201 44 discriminator 3
 9373 0218 7B68     		ldr	r3, [r7, #4]
 9374 021a 9B00     		lsls	r3, r3, #2
 9375 021c FA6C     		ldr	r2, [r7, #76]
 9376 021e 1344     		add	r3, r3, r2
 9377 0220 FB64     		str	r3, [r7, #76]
2201:keygen.c      **** 		zint_sub_scaled(x, Flen, y, tlen, sch, scl);
 9378              		.loc 2 2201 58 discriminator 3
 9379 0222 BB6B     		ldr	r3, [r7, #56]
 9380 0224 9B00     		lsls	r3, r3, #2
 9381 0226 BA6C     		ldr	r2, [r7, #72]
 9382 0228 1344     		add	r3, r3, r2
 9383 022a BB64     		str	r3, [r7, #72]
 9384              	.L179:
2201:keygen.c      **** 		zint_sub_scaled(x, Flen, y, tlen, sch, scl);
 9385              		.loc 2 2201 2 discriminator 1
 9386 022c 7A6C     		ldr	r2, [r7, #68]
 9387 022e FB6B     		ldr	r3, [r7, #60]
 9388 0230 9A42     		cmp	r2, r3
 9389 0232 E4D3     		bcc	.L180
2203:keygen.c      **** 	}
2204:keygen.c      **** }
 9390              		.loc 2 2204 1
 9391 0234 00BF     		nop
 9392 0236 00BF     		nop
 9393 0238 5437     		adds	r7, r7, #84
 9394              	.LCFI211:
 9395              		.cfi_def_cfa_offset 12
 9396 023a BD46     		mov	sp, r7
 9397              	.LCFI212:
 9398              		.cfi_def_cfa_register 13
 9399              		@ sp needed
 9400 023c 90BD     		pop	{r4, r7, pc}
 9401              	.L182:
 9402 023e 00BF     		.align	2
 9403              	.L181:
 9404 0240 40010000 		.word	PRIMES
 9405              		.cfi_endproc
 9406              	.LFE50:
 9408              		.section	.text.get_rng_u64,"ax",%progbits
 9409              		.align	1
 9410              		.syntax unified
 9411              		.thumb
 9412              		.thumb_func
 9413              		.fpu softvfp
 9415              	get_rng_u64:
 9416              	.LFB51:
2205:keygen.c      **** 
2206:keygen.c      **** /* ==================================================================== */
2207:keygen.c      **** 
2208:keygen.c      **** 
2209:keygen.c      **** #define RNG_CONTEXT   inner_shake256_context
2210:keygen.c      **** 
2211:keygen.c      **** /*
2212:keygen.c      ****  * Get a random 8-byte integer from a SHAKE-based RNG. This function
2213:keygen.c      ****  * ensures consistent interpretation of the SHAKE output so that
2214:keygen.c      ****  * the same values will be obtained over different platforms, in case
2215:keygen.c      ****  * a known seed is used.
2216:keygen.c      ****  */
2217:keygen.c      **** static inline uint64_t
2218:keygen.c      **** get_rng_u64(inner_shake256_context *rng)
2219:keygen.c      **** {
 9417              		.loc 2 2219 1
 9418              		.cfi_startproc
 9419              		@ args = 0, pretend = 0, frame = 120
 9420              		@ frame_needed = 1, uses_anonymous_args = 0
 9421 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 9422              	.LCFI213:
 9423              		.cfi_def_cfa_offset 32
 9424              		.cfi_offset 4, -32
 9425              		.cfi_offset 5, -28
 9426              		.cfi_offset 7, -24
 9427              		.cfi_offset 8, -20
 9428              		.cfi_offset 9, -16
 9429              		.cfi_offset 10, -12
 9430              		.cfi_offset 11, -8
 9431              		.cfi_offset 14, -4
 9432 0004 9EB0     		sub	sp, sp, #120
 9433              	.LCFI214:
 9434              		.cfi_def_cfa_offset 152
 9435 0006 00AF     		add	r7, sp, #0
 9436              	.LCFI215:
 9437              		.cfi_def_cfa_register 7
 9438 0008 F866     		str	r0, [r7, #108]
2220:keygen.c      **** 	/*
2221:keygen.c      **** 	 * We enforce little-endian representation.
2222:keygen.c      **** 	 */
2223:keygen.c      **** 
2224:keygen.c      **** 	uint8_t tmp[8];
2225:keygen.c      **** 
2226:keygen.c      **** 	inner_shake256_extract(rng, tmp, sizeof tmp);
 9439              		.loc 2 2226 2
 9440 000a 07F17003 		add	r3, r7, #112
 9441 000e 0822     		movs	r2, #8
 9442 0010 1946     		mov	r1, r3
 9443 0012 F86E     		ldr	r0, [r7, #108]
 9444 0014 FFF7FEFF 		bl	falcon_inner_i_shake256_extract
2227:keygen.c      **** 	return (uint64_t)tmp[0]
 9445              		.loc 2 2227 22
 9446 0018 97F87030 		ldrb	r3, [r7, #112]	@ zero_extendqisi2
 9447              		.loc 2 2227 9
 9448 001c DBB2     		uxtb	r3, r3
 9449 001e 0022     		movs	r2, #0
 9450 0020 3B66     		str	r3, [r7, #96]
 9451 0022 7A66     		str	r2, [r7, #100]
2228:keygen.c      **** 		| ((uint64_t)tmp[1] << 8)
 9452              		.loc 2 2228 19
 9453 0024 97F87130 		ldrb	r3, [r7, #113]	@ zero_extendqisi2
 9454              		.loc 2 2228 6
 9455 0028 DBB2     		uxtb	r3, r3
 9456 002a 0022     		movs	r2, #0
 9457 002c 1C46     		mov	r4, r3
 9458 002e 1546     		mov	r5, r2
 9459              		.loc 2 2228 23
 9460 0030 4FF00002 		mov	r2, #0
 9461 0034 4FF00003 		mov	r3, #0
 9462 0038 2B02     		lsls	r3, r5, #8
 9463 003a 43EA1463 		orr	r3, r3, r4, lsr #24
 9464 003e 2202     		lsls	r2, r4, #8
 9465              		.loc 2 2228 3
 9466 0040 D7E91801 		ldrd	r0, [r7, #96]
 9467 0044 0446     		mov	r4, r0
 9468 0046 1443     		orrs	r4, r4, r2
 9469 0048 BC65     		str	r4, [r7, #88]
 9470 004a 1943     		orrs	r1, r1, r3
 9471 004c F965     		str	r1, [r7, #92]
2229:keygen.c      **** 		| ((uint64_t)tmp[2] << 16)
 9472              		.loc 2 2229 19
 9473 004e 97F87230 		ldrb	r3, [r7, #114]	@ zero_extendqisi2
 9474              		.loc 2 2229 6
 9475 0052 DBB2     		uxtb	r3, r3
 9476 0054 0022     		movs	r2, #0
 9477 0056 9846     		mov	r8, r3
 9478 0058 9146     		mov	r9, r2
 9479              		.loc 2 2229 23
 9480 005a 4FF00002 		mov	r2, #0
 9481 005e 4FF00003 		mov	r3, #0
 9482 0062 4FEA0943 		lsl	r3, r9, #16
 9483 0066 43EA1843 		orr	r3, r3, r8, lsr #16
 9484 006a 4FEA0842 		lsl	r2, r8, #16
 9485              		.loc 2 2229 3
 9486 006e D7E91601 		ldrd	r0, [r7, #88]
 9487 0072 0446     		mov	r4, r0
 9488 0074 1443     		orrs	r4, r4, r2
 9489 0076 3C65     		str	r4, [r7, #80]
 9490 0078 1943     		orrs	r1, r1, r3
 9491 007a 7965     		str	r1, [r7, #84]
2230:keygen.c      **** 		| ((uint64_t)tmp[3] << 24)
 9492              		.loc 2 2230 19
 9493 007c 97F87330 		ldrb	r3, [r7, #115]	@ zero_extendqisi2
 9494              		.loc 2 2230 6
 9495 0080 DBB2     		uxtb	r3, r3
 9496 0082 0022     		movs	r2, #0
 9497 0084 BB64     		str	r3, [r7, #72]
 9498 0086 FA64     		str	r2, [r7, #76]
 9499              		.loc 2 2230 23
 9500 0088 D7E91234 		ldrd	r3, [r7, #72]
 9501 008c 1A46     		mov	r2, r3
 9502 008e 4FEA122B 		lsr	fp, r2, #8
 9503 0092 4FEA036A 		lsl	r10, r3, #24
 9504              		.loc 2 2230 3
 9505 0096 D7E91434 		ldrd	r3, [r7, #80]
 9506 009a 1A46     		mov	r2, r3
 9507 009c 42EA0A02 		orr	r2, r2, r10
 9508 00a0 3A64     		str	r2, [r7, #64]
 9509 00a2 2346     		mov	r3, r4
 9510 00a4 43EA0B03 		orr	r3, r3, fp
 9511 00a8 7B64     		str	r3, [r7, #68]
2231:keygen.c      **** 		| ((uint64_t)tmp[4] << 32)
 9512              		.loc 2 2231 19
 9513 00aa 97F87430 		ldrb	r3, [r7, #116]	@ zero_extendqisi2
 9514              		.loc 2 2231 6
 9515 00ae DBB2     		uxtb	r3, r3
 9516 00b0 0022     		movs	r2, #0
 9517 00b2 BB63     		str	r3, [r7, #56]
 9518 00b4 FA63     		str	r2, [r7, #60]
 9519              		.loc 2 2231 23
 9520 00b6 4FF00002 		mov	r2, #0
 9521 00ba 4FF00003 		mov	r3, #0
 9522 00be B96B     		ldr	r1, [r7, #56]
 9523 00c0 0B00     		movs	r3, r1
 9524 00c2 0022     		movs	r2, #0
 9525              		.loc 2 2231 3
 9526 00c4 D7E91001 		ldrd	r0, [r7, #64]
 9527 00c8 0446     		mov	r4, r0
 9528 00ca 1443     		orrs	r4, r4, r2
 9529 00cc 3C63     		str	r4, [r7, #48]
 9530 00ce 1943     		orrs	r1, r1, r3
 9531 00d0 7963     		str	r1, [r7, #52]
2232:keygen.c      **** 		| ((uint64_t)tmp[5] << 40)
 9532              		.loc 2 2232 19
 9533 00d2 97F87530 		ldrb	r3, [r7, #117]	@ zero_extendqisi2
 9534              		.loc 2 2232 6
 9535 00d6 DBB2     		uxtb	r3, r3
 9536 00d8 0022     		movs	r2, #0
 9537 00da BB62     		str	r3, [r7, #40]
 9538 00dc FA62     		str	r2, [r7, #44]
 9539              		.loc 2 2232 23
 9540 00de 4FF00002 		mov	r2, #0
 9541 00e2 4FF00003 		mov	r3, #0
 9542 00e6 B96A     		ldr	r1, [r7, #40]
 9543 00e8 0B02     		lsls	r3, r1, #8
 9544 00ea 0022     		movs	r2, #0
 9545              		.loc 2 2232 3
 9546 00ec D7E90C01 		ldrd	r0, [r7, #48]
 9547 00f0 0446     		mov	r4, r0
 9548 00f2 1443     		orrs	r4, r4, r2
 9549 00f4 3C62     		str	r4, [r7, #32]
 9550 00f6 1943     		orrs	r1, r1, r3
 9551 00f8 7962     		str	r1, [r7, #36]
2233:keygen.c      **** 		| ((uint64_t)tmp[6] << 48)
 9552              		.loc 2 2233 19
 9553 00fa 97F87630 		ldrb	r3, [r7, #118]	@ zero_extendqisi2
 9554              		.loc 2 2233 6
 9555 00fe DBB2     		uxtb	r3, r3
 9556 0100 0022     		movs	r2, #0
 9557 0102 BB61     		str	r3, [r7, #24]
 9558 0104 FA61     		str	r2, [r7, #28]
 9559              		.loc 2 2233 23
 9560 0106 4FF00002 		mov	r2, #0
 9561 010a 4FF00003 		mov	r3, #0
 9562 010e B969     		ldr	r1, [r7, #24]
 9563 0110 0B04     		lsls	r3, r1, #16
 9564 0112 0022     		movs	r2, #0
 9565              		.loc 2 2233 3
 9566 0114 D7E90801 		ldrd	r0, [r7, #32]
 9567 0118 0446     		mov	r4, r0
 9568 011a 1443     		orrs	r4, r4, r2
 9569 011c 3C61     		str	r4, [r7, #16]
 9570 011e 1943     		orrs	r1, r1, r3
 9571 0120 7961     		str	r1, [r7, #20]
2234:keygen.c      **** 		| ((uint64_t)tmp[7] << 56);
 9572              		.loc 2 2234 19
 9573 0122 97F87730 		ldrb	r3, [r7, #119]	@ zero_extendqisi2
 9574              		.loc 2 2234 6
 9575 0126 DBB2     		uxtb	r3, r3
 9576 0128 0022     		movs	r2, #0
 9577 012a BB60     		str	r3, [r7, #8]
 9578 012c FA60     		str	r2, [r7, #12]
 9579              		.loc 2 2234 23
 9580 012e 4FF00002 		mov	r2, #0
 9581 0132 4FF00003 		mov	r3, #0
 9582 0136 B968     		ldr	r1, [r7, #8]
 9583 0138 0B06     		lsls	r3, r1, #24
 9584 013a 0022     		movs	r2, #0
 9585              		.loc 2 2234 3
 9586 013c D7E90401 		ldrd	r0, [r7, #16]
 9587 0140 0446     		mov	r4, r0
 9588 0142 1443     		orrs	r4, r4, r2
 9589 0144 3C60     		str	r4, [r7]
 9590 0146 1943     		orrs	r1, r1, r3
 9591 0148 7960     		str	r1, [r7, #4]
 9592 014a D7E90023 		ldrd	r2, [r7]
2235:keygen.c      **** }
 9593              		.loc 2 2235 1
 9594 014e 1046     		mov	r0, r2
 9595 0150 1946     		mov	r1, r3
 9596 0152 7837     		adds	r7, r7, #120
 9597              	.LCFI216:
 9598              		.cfi_def_cfa_offset 32
 9599 0154 BD46     		mov	sp, r7
 9600              	.LCFI217:
 9601              		.cfi_def_cfa_register 13
 9602              		@ sp needed
 9603 0156 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 9604              		.cfi_endproc
 9605              	.LFE51:
 9607              		.section	.rodata
 9608              		.align	3
 9611              	gauss_1024_12289:
 9612 21b8 58ABF22D 		.word	770878296
 9613 21bc D837D111 		.word	298923992
 9614 21c0 74F9F53F 		.word	1073084788
 9615 21c4 F6400C59 		.word	1493975286
 9616 21c8 B775B985 		.word	-2051443273
 9617 21cc 1DE49838 		.word	949543965
 9618 21d0 F98F8550 		.word	1350930425
 9619 21d4 EF64A920 		.word	547972335
 9620 21d8 EB573897 		.word	-1757915157
 9621 21dc AED10711 		.word	285725102
 9622 21e0 37EA2092 		.word	-1843336649
 9623 21e4 C21EFE07 		.word	134094530
 9624 21e8 39A437CD 		.word	-851991495
 9625 21ec CAAF5D03 		.word	56471498
 9626 21f0 426D2106 		.word	102853954
 9627 21f4 83D94401 		.word	21289347
 9628 21f8 5516F8EA 		.word	-352840107
 9629 21fc EE6B6D00 		.word	7171054
 9630 2200 4CA86F0D 		.word	225421388
 9631 2204 A0E12000 		.word	2154912
 9632 2208 9CDA9DCD 		.word	-845292900
 9633 220c DDCD0800 		.word	576989
 9634 2210 B4DCDCC3 		.word	-1008935756
 9635 2214 2F190200 		.word	137519
 9636 2218 E9573CCD 		.word	-851683351
 9637 221c DF710000 		.word	29151
 9638 2220 EB768D93 		.word	-1819445525
 9639 2224 74150000 		.word	5492
 9640 2228 E5330C4B 		.word	1259090917
 9641 222c 97030000 		.word	919
 9642 2230 FEA63D9D 		.word	-1656903938
 9643 2234 88000000 		.word	136
 9644 2238 CBC6DD04 		.word	81643211
 9645 223c 12000000 		.word	18
 9646 2240 7AB2D31B 		.word	466858618
 9647 2244 02000000 		.word	2
 9648 2248 5E1F0938 		.word	940121950
 9649 224c 00000000 		.word	0
 9650 2250 B07D2805 		.word	86539696
 9651 2254 00000000 		.word	0
 9652 2258 28C56B00 		.word	7062824
 9653 225c 00000000 		.word	0
 9654 2260 FBCB0700 		.word	510971
 9655 2264 00000000 		.word	0
 9656 2268 FC7F0000 		.word	32764
 9657 226c 00000000 		.word	0
 9658 2270 46070000 		.word	1862
 9659 2274 00000000 		.word	0
 9660 2278 5E000000 		.word	94
 9661 227c 00000000 		.word	0
 9662 2280 04000000 		.word	4
 9663 2284 00000000 		.word	0
 9664 2288 00000000 		.word	0
 9665 228c 00000000 		.word	0
 9666              		.section	.text.mkgauss,"ax",%progbits
 9667              		.align	1
 9668              		.syntax unified
 9669              		.thumb
 9670              		.thumb_func
 9671              		.fpu softvfp
 9673              	mkgauss:
 9674              	.LFB52:
2236:keygen.c      **** 
2237:keygen.c      **** 
2238:keygen.c      **** /*
2239:keygen.c      ****  * Table below incarnates a discrete Gaussian distribution:
2240:keygen.c      ****  *    D(x) = exp(-(x^2)/(2*sigma^2))
2241:keygen.c      ****  * where sigma = 1.17*sqrt(q/(2*N)), q = 12289, and N = 1024.
2242:keygen.c      ****  * Element 0 of the table is P(x = 0).
2243:keygen.c      ****  * For k > 0, element k is P(x >= k+1 | x > 0).
2244:keygen.c      ****  * Probabilities are scaled up by 2^63.
2245:keygen.c      ****  */
2246:keygen.c      **** static const uint64_t gauss_1024_12289[] = {
2247:keygen.c      **** 	 1283868770400643928u,  6416574995475331444u,  4078260278032692663u,
2248:keygen.c      **** 	 2353523259288686585u,  1227179971273316331u,   575931623374121527u,
2249:keygen.c      **** 	  242543240509105209u,    91437049221049666u,    30799446349977173u,
2250:keygen.c      **** 	    9255276791179340u,     2478152334826140u,      590642893610164u,
2251:keygen.c      **** 	     125206034929641u,       23590435911403u,        3948334035941u,
2252:keygen.c      **** 	        586753615614u,          77391054539u,           9056793210u,
2253:keygen.c      **** 	           940121950u,             86539696u,              7062824u,
2254:keygen.c      **** 	              510971u,                32764u,                 1862u,
2255:keygen.c      **** 	                  94u,                    4u,                    0u
2256:keygen.c      **** };
2257:keygen.c      **** 
2258:keygen.c      **** /*
2259:keygen.c      ****  * Generate a random value with a Gaussian distribution centered on 0.
2260:keygen.c      ****  * The RNG must be ready for extraction (already flipped).
2261:keygen.c      ****  *
2262:keygen.c      ****  * Distribution has standard deviation 1.17*sqrt(q/(2*N)). The
2263:keygen.c      ****  * precomputed table is for N = 1024. Since the sum of two independent
2264:keygen.c      ****  * values of standard deviation sigma has standard deviation
2265:keygen.c      ****  * sigma*sqrt(2), then we can just generate more values and add them
2266:keygen.c      ****  * together for lower dimensions.
2267:keygen.c      ****  */
2268:keygen.c      **** static int
2269:keygen.c      **** mkgauss(RNG_CONTEXT *rng, unsigned logn)
2270:keygen.c      **** {
 9675              		.loc 2 2270 1
 9676              		.cfi_startproc
 9677              		@ args = 0, pretend = 0, frame = 64
 9678              		@ frame_needed = 1, uses_anonymous_args = 0
 9679 0000 2DE9B04F 		push	{r4, r5, r7, r8, r9, r10, fp, lr}
 9680              	.LCFI218:
 9681              		.cfi_def_cfa_offset 32
 9682              		.cfi_offset 4, -32
 9683              		.cfi_offset 5, -28
 9684              		.cfi_offset 7, -24
 9685              		.cfi_offset 8, -20
 9686              		.cfi_offset 9, -16
 9687              		.cfi_offset 10, -12
 9688              		.cfi_offset 11, -8
 9689              		.cfi_offset 14, -4
 9690 0004 90B0     		sub	sp, sp, #64
 9691              	.LCFI219:
 9692              		.cfi_def_cfa_offset 96
 9693 0006 00AF     		add	r7, sp, #0
 9694              	.LCFI220:
 9695              		.cfi_def_cfa_register 7
 9696 0008 F860     		str	r0, [r7, #12]
 9697 000a B960     		str	r1, [r7, #8]
2271:keygen.c      **** 	unsigned u, g;
2272:keygen.c      **** 	int val;
2273:keygen.c      **** 
2274:keygen.c      **** 	g = 1U << (10 - logn);
 9698              		.loc 2 2274 16
 9699 000c BB68     		ldr	r3, [r7, #8]
 9700 000e C3F10A03 		rsb	r3, r3, #10
 9701              		.loc 2 2274 4
 9702 0012 0122     		movs	r2, #1
 9703 0014 02FA03F3 		lsl	r3, r2, r3
 9704 0018 FB62     		str	r3, [r7, #44]
2275:keygen.c      **** 	val = 0;
 9705              		.loc 2 2275 6
 9706 001a 0023     		movs	r3, #0
 9707 001c BB63     		str	r3, [r7, #56]
2276:keygen.c      **** 	for (u = 0; u < g; u ++) {
 9708              		.loc 2 2276 9
 9709 001e 0023     		movs	r3, #0
 9710 0020 FB63     		str	r3, [r7, #60]
 9711              		.loc 2 2276 2
 9712 0022 75E0     		b	.L186
 9713              	.L189:
 9714              	.LBB32:
2277:keygen.c      **** 		/*
2278:keygen.c      **** 		 * Each iteration generates one value with the
2279:keygen.c      **** 		 * Gaussian distribution for N = 1024.
2280:keygen.c      **** 		 *
2281:keygen.c      **** 		 * We use two random 64-bit values. First value
2282:keygen.c      **** 		 * decides on whether the generated value is 0, and,
2283:keygen.c      **** 		 * if not, the sign of the value. Second random 64-bit
2284:keygen.c      **** 		 * word is used to generate the non-zero value.
2285:keygen.c      **** 		 *
2286:keygen.c      **** 		 * For constant-time code we have to read the complete
2287:keygen.c      **** 		 * table. This has negligible cost, compared with the
2288:keygen.c      **** 		 * remainder of the keygen process (solving the NTRU
2289:keygen.c      **** 		 * equation).
2290:keygen.c      **** 		 */
2291:keygen.c      **** 		uint64_t r;
2292:keygen.c      **** 		uint32_t f, v, k, neg;
2293:keygen.c      **** 
2294:keygen.c      **** 		/*
2295:keygen.c      **** 		 * First value:
2296:keygen.c      **** 		 *  - flag 'neg' is randomly selected to be 0 or 1.
2297:keygen.c      **** 		 *  - flag 'f' is set to 1 if the generated value is zero,
2298:keygen.c      **** 		 *    or set to 0 otherwise.
2299:keygen.c      **** 		 */
2300:keygen.c      **** 		r = get_rng_u64(rng);
 9715              		.loc 2 2300 7
 9716 0024 F868     		ldr	r0, [r7, #12]
 9717 0026 FFF7FEFF 		bl	get_rng_u64
 9718 002a C7E90801 		strd	r0, [r7, #32]
2301:keygen.c      **** 		neg = (uint32_t)(r >> 63);
 9719              		.loc 2 2301 22
 9720 002e D7E90801 		ldrd	r0, [r7, #32]
 9721 0032 4FF00002 		mov	r2, #0
 9722 0036 4FF00003 		mov	r3, #0
 9723 003a CA0F     		lsrs	r2, r1, #31
 9724 003c 0023     		movs	r3, #0
 9725              		.loc 2 2301 7
 9726 003e 1346     		mov	r3, r2
 9727 0040 FB61     		str	r3, [r7, #28]
2302:keygen.c      **** 		r &= ~((uint64_t)1 << 63);
 9728              		.loc 2 2302 5
 9729 0042 D7E90823 		ldrd	r2, [r7, #32]
 9730 0046 9246     		mov	r10, r2
 9731 0048 23F0004B 		bic	fp, r3, #-2147483648
 9732 004c C7E908AB 		strd	r10, [r7, #32]
2303:keygen.c      **** 		f = (uint32_t)((r - gauss_1024_12289[0]) >> 63);
 9733              		.loc 2 2303 39
 9734 0050 36A1     		adr	r1, .L191+4
 9735 0052 D1E90001 		ldrd	r0, [r1]
 9736              		.loc 2 2303 21
 9737 0056 D7E90823 		ldrd	r2, [r7, #32]
 9738 005a 141A     		subs	r4, r2, r0
 9739 005c 63EB0105 		sbc	r5, r3, r1
 9740              		.loc 2 2303 44
 9741 0060 4FF00002 		mov	r2, #0
 9742 0064 4FF00003 		mov	r3, #0
 9743 0068 EA0F     		lsrs	r2, r5, #31
 9744 006a 0023     		movs	r3, #0
 9745              		.loc 2 2303 5
 9746 006c 1346     		mov	r3, r2
 9747 006e 7B63     		str	r3, [r7, #52]
2304:keygen.c      **** 
2305:keygen.c      **** 		/*
2306:keygen.c      **** 		 * We produce a new random 63-bit integer r, and go over
2307:keygen.c      **** 		 * the array, starting at index 1. We store in v the
2308:keygen.c      **** 		 * index of the first array element which is not greater
2309:keygen.c      **** 		 * than r, unless the flag f was already 1.
2310:keygen.c      **** 		 */
2311:keygen.c      **** 		v = 0;
 9748              		.loc 2 2311 5
 9749 0070 0023     		movs	r3, #0
 9750 0072 7B61     		str	r3, [r7, #20]
2312:keygen.c      **** 		r = get_rng_u64(rng);
 9751              		.loc 2 2312 7
 9752 0074 F868     		ldr	r0, [r7, #12]
 9753 0076 FFF7FEFF 		bl	get_rng_u64
 9754 007a C7E90801 		strd	r0, [r7, #32]
2313:keygen.c      **** 		r &= ~((uint64_t)1 << 63);
 9755              		.loc 2 2313 5
 9756 007e D7E90823 		ldrd	r2, [r7, #32]
 9757 0082 3A60     		str	r2, [r7]
 9758 0084 23F00043 		bic	r3, r3, #-2147483648
 9759 0088 7B60     		str	r3, [r7, #4]
 9760 008a D7E90023 		ldrd	r2, [r7]
 9761 008e C7E90823 		strd	r2, [r7, #32]
2314:keygen.c      **** 		for (k = 1; k < (sizeof gauss_1024_12289)
 9762              		.loc 2 2314 10
 9763 0092 0123     		movs	r3, #1
 9764 0094 3B63     		str	r3, [r7, #48]
 9765              		.loc 2 2314 3
 9766 0096 28E0     		b	.L187
 9767              	.L188:
 9768              	.LBB33:
2315:keygen.c      **** 			/ (sizeof gauss_1024_12289[0]); k ++)
2316:keygen.c      **** 		{
2317:keygen.c      **** 			uint32_t t;
2318:keygen.c      **** 
2319:keygen.c      **** 			t = (uint32_t)((r - gauss_1024_12289[k]) >> 63) ^ 1;
 9769              		.loc 2 2319 40
 9770 0098 234A     		ldr	r2, .L191
 9771 009a 3B6B     		ldr	r3, [r7, #48]
 9772 009c DB00     		lsls	r3, r3, #3
 9773 009e 1344     		add	r3, r3, r2
 9774 00a0 D3E90023 		ldrd	r2, [r3]
 9775              		.loc 2 2319 22
 9776 00a4 D7E90801 		ldrd	r0, [r7, #32]
 9777 00a8 B0EB0208 		subs	r8, r0, r2
 9778 00ac 61EB0309 		sbc	r9, r1, r3
 9779              		.loc 2 2319 45
 9780 00b0 4FF00002 		mov	r2, #0
 9781 00b4 4FF00003 		mov	r3, #0
 9782 00b8 4FEAD972 		lsr	r2, r9, #31
 9783 00bc 0023     		movs	r3, #0
 9784              		.loc 2 2319 8
 9785 00be 1346     		mov	r3, r2
 9786              		.loc 2 2319 6
 9787 00c0 83F00103 		eor	r3, r3, #1
 9788 00c4 BB61     		str	r3, [r7, #24]
2320:keygen.c      **** 			v |= k & -(t & (f ^ 1));
 9789              		.loc 2 2320 22
 9790 00c6 7B6B     		ldr	r3, [r7, #52]
 9791 00c8 83F00102 		eor	r2, r3, #1
 9792              		.loc 2 2320 17
 9793 00cc BB69     		ldr	r3, [r7, #24]
 9794 00ce 1340     		ands	r3, r3, r2
 9795              		.loc 2 2320 13
 9796 00d0 5A42     		rsbs	r2, r3, #0
 9797              		.loc 2 2320 11
 9798 00d2 3B6B     		ldr	r3, [r7, #48]
 9799 00d4 1A40     		ands	r2, r2, r3
 9800              		.loc 2 2320 6
 9801 00d6 7B69     		ldr	r3, [r7, #20]
 9802 00d8 1343     		orrs	r3, r3, r2
 9803 00da 7B61     		str	r3, [r7, #20]
2321:keygen.c      **** 			f |= t;
 9804              		.loc 2 2321 6
 9805 00dc 7A6B     		ldr	r2, [r7, #52]
 9806 00de BB69     		ldr	r3, [r7, #24]
 9807 00e0 1343     		orrs	r3, r3, r2
 9808 00e2 7B63     		str	r3, [r7, #52]
 9809              	.LBE33:
2315:keygen.c      **** 			/ (sizeof gauss_1024_12289[0]); k ++)
 9810              		.loc 2 2315 38
 9811 00e4 3B6B     		ldr	r3, [r7, #48]
 9812 00e6 0133     		adds	r3, r3, #1
 9813 00e8 3B63     		str	r3, [r7, #48]
 9814              	.L187:
2314:keygen.c      **** 			/ (sizeof gauss_1024_12289[0]); k ++)
 9815              		.loc 2 2314 3 discriminator 1
 9816 00ea 3B6B     		ldr	r3, [r7, #48]
 9817 00ec 1A2B     		cmp	r3, #26
 9818 00ee D3D9     		bls	.L188
2322:keygen.c      **** 		}
2323:keygen.c      **** 
2324:keygen.c      **** 		/*
2325:keygen.c      **** 		 * We apply the sign ('neg' flag). If the value is zero,
2326:keygen.c      **** 		 * the sign has no effect.
2327:keygen.c      **** 		 */
2328:keygen.c      **** 		v = (v ^ -neg) + neg;
 9819              		.loc 2 2328 12 discriminator 2
 9820 00f0 FB69     		ldr	r3, [r7, #28]
 9821 00f2 5A42     		rsbs	r2, r3, #0
 9822              		.loc 2 2328 10 discriminator 2
 9823 00f4 7B69     		ldr	r3, [r7, #20]
 9824 00f6 5A40     		eors	r2, r2, r3
 9825              		.loc 2 2328 18 discriminator 2
 9826 00f8 FB69     		ldr	r3, [r7, #28]
 9827 00fa 1344     		add	r3, r3, r2
 9828              		.loc 2 2328 5 discriminator 2
 9829 00fc 7B61     		str	r3, [r7, #20]
2329:keygen.c      **** 
2330:keygen.c      **** 		/*
2331:keygen.c      **** 		 * Generated value is added to val.
2332:keygen.c      **** 		 */
2333:keygen.c      **** 		val += *(int32_t *)&v;
 9830              		.loc 2 2333 22 discriminator 2
 9831 00fe 07F11403 		add	r3, r7, #20
 9832              		.loc 2 2333 10 discriminator 2
 9833 0102 1B68     		ldr	r3, [r3]
 9834              		.loc 2 2333 7 discriminator 2
 9835 0104 BA6B     		ldr	r2, [r7, #56]
 9836 0106 1344     		add	r3, r3, r2
 9837 0108 BB63     		str	r3, [r7, #56]
 9838              	.LBE32:
2276:keygen.c      **** 		/*
 9839              		.loc 2 2276 23 discriminator 2
 9840 010a FB6B     		ldr	r3, [r7, #60]
 9841 010c 0133     		adds	r3, r3, #1
 9842 010e FB63     		str	r3, [r7, #60]
 9843              	.L186:
2276:keygen.c      **** 		/*
 9844              		.loc 2 2276 2 discriminator 1
 9845 0110 FA6B     		ldr	r2, [r7, #60]
 9846 0112 FB6A     		ldr	r3, [r7, #44]
 9847 0114 9A42     		cmp	r2, r3
 9848 0116 85D3     		bcc	.L189
2334:keygen.c      **** 	}
2335:keygen.c      **** 	return val;
 9849              		.loc 2 2335 9
 9850 0118 BB6B     		ldr	r3, [r7, #56]
2336:keygen.c      **** }
 9851              		.loc 2 2336 1
 9852 011a 1846     		mov	r0, r3
 9853 011c 4037     		adds	r7, r7, #64
 9854              	.LCFI221:
 9855              		.cfi_def_cfa_offset 32
 9856 011e BD46     		mov	sp, r7
 9857              	.LCFI222:
 9858              		.cfi_def_cfa_register 13
 9859              		@ sp needed
 9860 0120 BDE8B08F 		pop	{r4, r5, r7, r8, r9, r10, fp, pc}
 9861              	.L192:
 9862 0124 AFF30080 		.align	3
 9863              	.L191:
 9864 0128 B8210000 		.word	gauss_1024_12289
 9865 012c 58ABF22D 		.word	770878296
 9866 0130 D837D111 		.word	298923992
 9867              		.cfi_endproc
 9868              	.LFE52:
 9870              		.section	.rodata
 9871              		.align	2
 9874              	MAX_BL_SMALL:
 9875 2290 01000000 		.word	1
 9876 2294 01000000 		.word	1
 9877 2298 02000000 		.word	2
 9878 229c 02000000 		.word	2
 9879 22a0 04000000 		.word	4
 9880 22a4 07000000 		.word	7
 9881 22a8 0E000000 		.word	14
 9882 22ac 1B000000 		.word	27
 9883 22b0 35000000 		.word	53
 9884 22b4 6A000000 		.word	106
 9885 22b8 D1000000 		.word	209
 9886              		.align	2
 9889              	MAX_BL_LARGE:
 9890 22bc 02000000 		.word	2
 9891 22c0 02000000 		.word	2
 9892 22c4 05000000 		.word	5
 9893 22c8 07000000 		.word	7
 9894 22cc 0C000000 		.word	12
 9895 22d0 15000000 		.word	21
 9896 22d4 28000000 		.word	40
 9897 22d8 4E000000 		.word	78
 9898 22dc 9D000000 		.word	157
 9899 22e0 34010000 		.word	308
 9900              		.align	2
 9903              	BITLENGTH:
 9904 22e4 04000000 		.word	4
 9905 22e8 00000000 		.word	0
 9906 22ec 0B000000 		.word	11
 9907 22f0 01000000 		.word	1
 9908 22f4 18000000 		.word	24
 9909 22f8 01000000 		.word	1
 9910 22fc 32000000 		.word	50
 9911 2300 01000000 		.word	1
 9912 2304 66000000 		.word	102
 9913 2308 01000000 		.word	1
 9914 230c CA000000 		.word	202
 9915 2310 02000000 		.word	2
 9916 2314 91010000 		.word	401
 9917 2318 04000000 		.word	4
 9918 231c 1A030000 		.word	794
 9919 2320 05000000 		.word	5
 9920 2324 29060000 		.word	1577
 9921 2328 08000000 		.word	8
 9922 232c 420C0000 		.word	3138
 9923 2330 0D000000 		.word	13
 9924 2334 A4180000 		.word	6308
 9925 2338 19000000 		.word	25
 9926              		.section	.text.poly_small_sqnorm,"ax",%progbits
 9927              		.align	1
 9928              		.syntax unified
 9929              		.thumb
 9930              		.thumb_func
 9931              		.fpu softvfp
 9933              	poly_small_sqnorm:
 9934              	.LFB53:
2337:keygen.c      **** 
2338:keygen.c      **** /*
2339:keygen.c      ****  * The MAX_BL_SMALL[] and MAX_BL_LARGE[] contain the lengths, in 31-bit
2340:keygen.c      ****  * words, of intermediate values in the computation:
2341:keygen.c      ****  *
2342:keygen.c      ****  *   MAX_BL_SMALL[depth]: length for the input f and g at that depth
2343:keygen.c      ****  *   MAX_BL_LARGE[depth]: length for the unreduced F and G at that depth
2344:keygen.c      ****  *
2345:keygen.c      ****  * Rules:
2346:keygen.c      ****  *
2347:keygen.c      ****  *  - Within an array, values grow.
2348:keygen.c      ****  *
2349:keygen.c      ****  *  - The 'SMALL' array must have an entry for maximum depth, corresponding
2350:keygen.c      ****  *    to the size of values used in the binary GCD. There is no such value
2351:keygen.c      ****  *    for the 'LARGE' array (the binary GCD yields already reduced
2352:keygen.c      ****  *    coefficients).
2353:keygen.c      ****  *
2354:keygen.c      ****  *  - MAX_BL_LARGE[depth] >= MAX_BL_SMALL[depth + 1].
2355:keygen.c      ****  *
2356:keygen.c      ****  *  - Values must be large enough to handle the common cases, with some
2357:keygen.c      ****  *    margins.
2358:keygen.c      ****  *
2359:keygen.c      ****  *  - Values must not be "too large" either because we will convert some
2360:keygen.c      ****  *    integers into floating-point values by considering the top 10 words,
2361:keygen.c      ****  *    i.e. 310 bits; hence, for values of length more than 10 words, we
2362:keygen.c      ****  *    should take care to have the length centered on the expected size.
2363:keygen.c      ****  *
2364:keygen.c      ****  * The following average lengths, in bits, have been measured on thousands
2365:keygen.c      ****  * of random keys (fg = max length of the absolute value of coefficients
2366:keygen.c      ****  * of f and g at that depth; FG = idem for the unreduced F and G; for the
2367:keygen.c      ****  * maximum depth, F and G are the output of binary GCD, multiplied by q;
2368:keygen.c      ****  * for each value, the average and standard deviation are provided).
2369:keygen.c      ****  *
2370:keygen.c      ****  * Binary case:
2371:keygen.c      ****  *    depth: 10    fg: 6307.52 (24.48)    FG: 6319.66 (24.51)
2372:keygen.c      ****  *    depth:  9    fg: 3138.35 (12.25)    FG: 9403.29 (27.55)
2373:keygen.c      ****  *    depth:  8    fg: 1576.87 ( 7.49)    FG: 4703.30 (14.77)
2374:keygen.c      ****  *    depth:  7    fg:  794.17 ( 4.98)    FG: 2361.84 ( 9.31)
2375:keygen.c      ****  *    depth:  6    fg:  400.67 ( 3.10)    FG: 1188.68 ( 6.04)
2376:keygen.c      ****  *    depth:  5    fg:  202.22 ( 1.87)    FG:  599.81 ( 3.87)
2377:keygen.c      ****  *    depth:  4    fg:  101.62 ( 1.02)    FG:  303.49 ( 2.38)
2378:keygen.c      ****  *    depth:  3    fg:   50.37 ( 0.53)    FG:  153.65 ( 1.39)
2379:keygen.c      ****  *    depth:  2    fg:   24.07 ( 0.25)    FG:   78.20 ( 0.73)
2380:keygen.c      ****  *    depth:  1    fg:   10.99 ( 0.08)    FG:   39.82 ( 0.41)
2381:keygen.c      ****  *    depth:  0    fg:    4.00 ( 0.00)    FG:   19.61 ( 0.49)
2382:keygen.c      ****  *
2383:keygen.c      ****  * Integers are actually represented either in binary notation over
2384:keygen.c      ****  * 31-bit words (signed, using two's complement), or in RNS, modulo
2385:keygen.c      ****  * many small primes. These small primes are close to, but slightly
2386:keygen.c      ****  * lower than, 2^31. Use of RNS loses less than two bits, even for
2387:keygen.c      ****  * the largest values.
2388:keygen.c      ****  *
2389:keygen.c      ****  * IMPORTANT: if these values are modified, then the temporary buffer
2390:keygen.c      ****  * sizes (FALCON_KEYGEN_TEMP_*, in inner.h) must be recomputed
2391:keygen.c      ****  * accordingly.
2392:keygen.c      ****  */
2393:keygen.c      **** 
2394:keygen.c      **** static const size_t MAX_BL_SMALL[] = {
2395:keygen.c      **** 	1, 1, 2, 2, 4, 7, 14, 27, 53, 106, 209
2396:keygen.c      **** };
2397:keygen.c      **** 
2398:keygen.c      **** static const size_t MAX_BL_LARGE[] = {
2399:keygen.c      **** 	2, 2, 5, 7, 12, 21, 40, 78, 157, 308
2400:keygen.c      **** };
2401:keygen.c      **** 
2402:keygen.c      **** /*
2403:keygen.c      ****  * Average and standard deviation for the maximum size (in bits) of
2404:keygen.c      ****  * coefficients of (f,g), depending on depth. These values are used
2405:keygen.c      ****  * to compute bounds for Babai's reduction.
2406:keygen.c      ****  */
2407:keygen.c      **** static const struct {
2408:keygen.c      **** 	int avg;
2409:keygen.c      **** 	int std;
2410:keygen.c      **** } BITLENGTH[] = {
2411:keygen.c      **** 	{    4,  0 },
2412:keygen.c      **** 	{   11,  1 },
2413:keygen.c      **** 	{   24,  1 },
2414:keygen.c      **** 	{   50,  1 },
2415:keygen.c      **** 	{  102,  1 },
2416:keygen.c      **** 	{  202,  2 },
2417:keygen.c      **** 	{  401,  4 },
2418:keygen.c      **** 	{  794,  5 },
2419:keygen.c      **** 	{ 1577,  8 },
2420:keygen.c      **** 	{ 3138, 13 },
2421:keygen.c      **** 	{ 6308, 25 }
2422:keygen.c      **** };
2423:keygen.c      **** 
2424:keygen.c      **** /*
2425:keygen.c      ****  * Minimal recursion depth at which we rebuild intermediate values
2426:keygen.c      ****  * when reconstructing f and g.
2427:keygen.c      ****  */
2428:keygen.c      **** #define DEPTH_INT_FG   4
2429:keygen.c      **** 
2430:keygen.c      **** /*
2431:keygen.c      ****  * Compute squared norm of a short vector. Returned value is saturated to
2432:keygen.c      ****  * 2^32-1 if it is not lower than 2^31.
2433:keygen.c      ****  */
2434:keygen.c      **** static uint32_t
2435:keygen.c      **** poly_small_sqnorm(const int8_t *f, unsigned logn)
2436:keygen.c      **** {
 9935              		.loc 2 2436 1
 9936              		.cfi_startproc
 9937              		@ args = 0, pretend = 0, frame = 32
 9938              		@ frame_needed = 1, uses_anonymous_args = 0
 9939              		@ link register save eliminated.
 9940 0000 80B4     		push	{r7}
 9941              	.LCFI223:
 9942              		.cfi_def_cfa_offset 4
 9943              		.cfi_offset 7, -4
 9944 0002 89B0     		sub	sp, sp, #36
 9945              	.LCFI224:
 9946              		.cfi_def_cfa_offset 40
 9947 0004 00AF     		add	r7, sp, #0
 9948              	.LCFI225:
 9949              		.cfi_def_cfa_register 7
 9950 0006 7860     		str	r0, [r7, #4]
 9951 0008 3960     		str	r1, [r7]
2437:keygen.c      **** 	size_t n, u;
2438:keygen.c      **** 	uint32_t s, ng;
2439:keygen.c      **** 
2440:keygen.c      **** 	n = MKN(logn);
 9952              		.loc 2 2440 4
 9953 000a 0122     		movs	r2, #1
 9954 000c 3B68     		ldr	r3, [r7]
 9955 000e 02FA03F3 		lsl	r3, r2, r3
 9956 0012 3B61     		str	r3, [r7, #16]
2441:keygen.c      **** 	s = 0;
 9957              		.loc 2 2441 4
 9958 0014 0023     		movs	r3, #0
 9959 0016 BB61     		str	r3, [r7, #24]
2442:keygen.c      **** 	ng = 0;
 9960              		.loc 2 2442 5
 9961 0018 0023     		movs	r3, #0
 9962 001a 7B61     		str	r3, [r7, #20]
2443:keygen.c      **** 	for (u = 0; u < n; u ++) {
 9963              		.loc 2 2443 9
 9964 001c 0023     		movs	r3, #0
 9965 001e FB61     		str	r3, [r7, #28]
 9966              		.loc 2 2443 2
 9967 0020 13E0     		b	.L194
 9968              	.L195:
 9969              	.LBB34:
2444:keygen.c      **** 		int32_t z;
2445:keygen.c      **** 
2446:keygen.c      **** 		z = f[u];
 9970              		.loc 2 2446 8 discriminator 3
 9971 0022 7A68     		ldr	r2, [r7, #4]
 9972 0024 FB69     		ldr	r3, [r7, #28]
 9973 0026 1344     		add	r3, r3, r2
 9974 0028 93F90030 		ldrsb	r3, [r3]
 9975              		.loc 2 2446 5 discriminator 3
 9976 002c FB60     		str	r3, [r7, #12]
2447:keygen.c      **** 		s += (uint32_t)(z * z);
 9977              		.loc 2 2447 21 discriminator 3
 9978 002e FB68     		ldr	r3, [r7, #12]
 9979 0030 03FB03F3 		mul	r3, r3, r3
 9980              		.loc 2 2447 8 discriminator 3
 9981 0034 1A46     		mov	r2, r3
 9982              		.loc 2 2447 5 discriminator 3
 9983 0036 BB69     		ldr	r3, [r7, #24]
 9984 0038 1344     		add	r3, r3, r2
 9985 003a BB61     		str	r3, [r7, #24]
2448:keygen.c      **** 		ng |= s;
 9986              		.loc 2 2448 6 discriminator 3
 9987 003c 7A69     		ldr	r2, [r7, #20]
 9988 003e BB69     		ldr	r3, [r7, #24]
 9989 0040 1343     		orrs	r3, r3, r2
 9990 0042 7B61     		str	r3, [r7, #20]
 9991              	.LBE34:
2443:keygen.c      **** 		int32_t z;
 9992              		.loc 2 2443 23 discriminator 3
 9993 0044 FB69     		ldr	r3, [r7, #28]
 9994 0046 0133     		adds	r3, r3, #1
 9995 0048 FB61     		str	r3, [r7, #28]
 9996              	.L194:
2443:keygen.c      **** 		int32_t z;
 9997              		.loc 2 2443 2 discriminator 1
 9998 004a FA69     		ldr	r2, [r7, #28]
 9999 004c 3B69     		ldr	r3, [r7, #16]
 10000 004e 9A42     		cmp	r2, r3
 10001 0050 E7D3     		bcc	.L195
2449:keygen.c      **** 	}
2450:keygen.c      **** 	return s | -(ng >> 31);
 10002              		.loc 2 2450 13
 10003 0052 7B69     		ldr	r3, [r7, #20]
 10004 0054 DB17     		asrs	r3, r3, #31
 10005 0056 1A46     		mov	r2, r3
 10006              		.loc 2 2450 11
 10007 0058 BB69     		ldr	r3, [r7, #24]
 10008 005a 1343     		orrs	r3, r3, r2
2451:keygen.c      **** }
 10009              		.loc 2 2451 1
 10010 005c 1846     		mov	r0, r3
 10011 005e 2437     		adds	r7, r7, #36
 10012              	.LCFI226:
 10013              		.cfi_def_cfa_offset 4
 10014 0060 BD46     		mov	sp, r7
 10015              	.LCFI227:
 10016              		.cfi_def_cfa_register 13
 10017              		@ sp needed
 10018 0062 80BC     		pop	{r7}
 10019              	.LCFI228:
 10020              		.cfi_restore 7
 10021              		.cfi_def_cfa_offset 0
 10022 0064 7047     		bx	lr
 10023              		.cfi_endproc
 10024              	.LFE53:
 10026              		.section	.text.align_fpr,"ax",%progbits
 10027              		.align	1
 10028              		.syntax unified
 10029              		.thumb
 10030              		.thumb_func
 10031              		.fpu softvfp
 10033              	align_fpr:
 10034              	.LFB54:
2452:keygen.c      **** 
2453:keygen.c      **** /*
2454:keygen.c      ****  * Align (upwards) the provided 'data' pointer with regards to 'base'
2455:keygen.c      ****  * so that the offset is a multiple of the size of 'fpr'.
2456:keygen.c      ****  */
2457:keygen.c      **** static fpr *
2458:keygen.c      **** align_fpr(void *base, void *data)
2459:keygen.c      **** {
 10035              		.loc 2 2459 1
 10036              		.cfi_startproc
 10037              		@ args = 0, pretend = 0, frame = 24
 10038              		@ frame_needed = 1, uses_anonymous_args = 0
 10039              		@ link register save eliminated.
 10040 0000 80B4     		push	{r7}
 10041              	.LCFI229:
 10042              		.cfi_def_cfa_offset 4
 10043              		.cfi_offset 7, -4
 10044 0002 87B0     		sub	sp, sp, #28
 10045              	.LCFI230:
 10046              		.cfi_def_cfa_offset 32
 10047 0004 00AF     		add	r7, sp, #0
 10048              	.LCFI231:
 10049              		.cfi_def_cfa_register 7
 10050 0006 7860     		str	r0, [r7, #4]
 10051 0008 3960     		str	r1, [r7]
2460:keygen.c      **** 	uint8_t *cb, *cd;
2461:keygen.c      **** 	size_t k, km;
2462:keygen.c      **** 
2463:keygen.c      **** 	cb = base;
 10052              		.loc 2 2463 5
 10053 000a 7B68     		ldr	r3, [r7, #4]
 10054 000c 3B61     		str	r3, [r7, #16]
2464:keygen.c      **** 	cd = data;
 10055              		.loc 2 2464 5
 10056 000e 3B68     		ldr	r3, [r7]
 10057 0010 FB60     		str	r3, [r7, #12]
2465:keygen.c      **** 	k = (size_t)(cd - cb);
 10058              		.loc 2 2465 18
 10059 0012 FA68     		ldr	r2, [r7, #12]
 10060 0014 3B69     		ldr	r3, [r7, #16]
 10061 0016 D31A     		subs	r3, r2, r3
 10062              		.loc 2 2465 4
 10063 0018 7B61     		str	r3, [r7, #20]
2466:keygen.c      **** 	km = k % sizeof(fpr);
 10064              		.loc 2 2466 5
 10065 001a 7B69     		ldr	r3, [r7, #20]
 10066 001c 03F00703 		and	r3, r3, #7
 10067 0020 BB60     		str	r3, [r7, #8]
2467:keygen.c      **** 	if (km) {
 10068              		.loc 2 2467 5
 10069 0022 BB68     		ldr	r3, [r7, #8]
 10070 0024 002B     		cmp	r3, #0
 10071 0026 04D0     		beq	.L198
2468:keygen.c      **** 		k += (sizeof(fpr)) - km;
 10072              		.loc 2 2468 5
 10073 0028 7A69     		ldr	r2, [r7, #20]
 10074 002a BB68     		ldr	r3, [r7, #8]
 10075 002c D31A     		subs	r3, r2, r3
 10076 002e 0833     		adds	r3, r3, #8
 10077 0030 7B61     		str	r3, [r7, #20]
 10078              	.L198:
2469:keygen.c      **** 	}
2470:keygen.c      **** 	return (fpr *)(cb + k);
 10079              		.loc 2 2470 9
 10080 0032 3A69     		ldr	r2, [r7, #16]
 10081 0034 7B69     		ldr	r3, [r7, #20]
 10082 0036 1344     		add	r3, r3, r2
2471:keygen.c      **** }
 10083              		.loc 2 2471 1
 10084 0038 1846     		mov	r0, r3
 10085 003a 1C37     		adds	r7, r7, #28
 10086              	.LCFI232:
 10087              		.cfi_def_cfa_offset 4
 10088 003c BD46     		mov	sp, r7
 10089              	.LCFI233:
 10090              		.cfi_def_cfa_register 13
 10091              		@ sp needed
 10092 003e 80BC     		pop	{r7}
 10093              	.LCFI234:
 10094              		.cfi_restore 7
 10095              		.cfi_def_cfa_offset 0
 10096 0040 7047     		bx	lr
 10097              		.cfi_endproc
 10098              	.LFE54:
 10100              		.section	.text.align_u32,"ax",%progbits
 10101              		.align	1
 10102              		.syntax unified
 10103              		.thumb
 10104              		.thumb_func
 10105              		.fpu softvfp
 10107              	align_u32:
 10108              	.LFB55:
2472:keygen.c      **** 
2473:keygen.c      **** /*
2474:keygen.c      ****  * Align (upwards) the provided 'data' pointer with regards to 'base'
2475:keygen.c      ****  * so that the offset is a multiple of the size of 'uint32_t'.
2476:keygen.c      ****  */
2477:keygen.c      **** static uint32_t *
2478:keygen.c      **** align_u32(void *base, void *data)
2479:keygen.c      **** {
 10109              		.loc 2 2479 1
 10110              		.cfi_startproc
 10111              		@ args = 0, pretend = 0, frame = 24
 10112              		@ frame_needed = 1, uses_anonymous_args = 0
 10113              		@ link register save eliminated.
 10114 0000 80B4     		push	{r7}
 10115              	.LCFI235:
 10116              		.cfi_def_cfa_offset 4
 10117              		.cfi_offset 7, -4
 10118 0002 87B0     		sub	sp, sp, #28
 10119              	.LCFI236:
 10120              		.cfi_def_cfa_offset 32
 10121 0004 00AF     		add	r7, sp, #0
 10122              	.LCFI237:
 10123              		.cfi_def_cfa_register 7
 10124 0006 7860     		str	r0, [r7, #4]
 10125 0008 3960     		str	r1, [r7]
2480:keygen.c      **** 	uint8_t *cb, *cd;
2481:keygen.c      **** 	size_t k, km;
2482:keygen.c      **** 
2483:keygen.c      **** 	cb = base;
 10126              		.loc 2 2483 5
 10127 000a 7B68     		ldr	r3, [r7, #4]
 10128 000c 3B61     		str	r3, [r7, #16]
2484:keygen.c      **** 	cd = data;
 10129              		.loc 2 2484 5
 10130 000e 3B68     		ldr	r3, [r7]
 10131 0010 FB60     		str	r3, [r7, #12]
2485:keygen.c      **** 	k = (size_t)(cd - cb);
 10132              		.loc 2 2485 18
 10133 0012 FA68     		ldr	r2, [r7, #12]
 10134 0014 3B69     		ldr	r3, [r7, #16]
 10135 0016 D31A     		subs	r3, r2, r3
 10136              		.loc 2 2485 4
 10137 0018 7B61     		str	r3, [r7, #20]
2486:keygen.c      **** 	km = k % sizeof(uint32_t);
 10138              		.loc 2 2486 5
 10139 001a 7B69     		ldr	r3, [r7, #20]
 10140 001c 03F00303 		and	r3, r3, #3
 10141 0020 BB60     		str	r3, [r7, #8]
2487:keygen.c      **** 	if (km) {
 10142              		.loc 2 2487 5
 10143 0022 BB68     		ldr	r3, [r7, #8]
 10144 0024 002B     		cmp	r3, #0
 10145 0026 04D0     		beq	.L201
2488:keygen.c      **** 		k += (sizeof(uint32_t)) - km;
 10146              		.loc 2 2488 5
 10147 0028 7A69     		ldr	r2, [r7, #20]
 10148 002a BB68     		ldr	r3, [r7, #8]
 10149 002c D31A     		subs	r3, r2, r3
 10150 002e 0433     		adds	r3, r3, #4
 10151 0030 7B61     		str	r3, [r7, #20]
 10152              	.L201:
2489:keygen.c      **** 	}
2490:keygen.c      **** 	return (uint32_t *)(cb + k);
 10153              		.loc 2 2490 9
 10154 0032 3A69     		ldr	r2, [r7, #16]
 10155 0034 7B69     		ldr	r3, [r7, #20]
 10156 0036 1344     		add	r3, r3, r2
2491:keygen.c      **** }
 10157              		.loc 2 2491 1
 10158 0038 1846     		mov	r0, r3
 10159 003a 1C37     		adds	r7, r7, #28
 10160              	.LCFI238:
 10161              		.cfi_def_cfa_offset 4
 10162 003c BD46     		mov	sp, r7
 10163              	.LCFI239:
 10164              		.cfi_def_cfa_register 13
 10165              		@ sp needed
 10166 003e 80BC     		pop	{r7}
 10167              	.LCFI240:
 10168              		.cfi_restore 7
 10169              		.cfi_def_cfa_offset 0
 10170 0040 7047     		bx	lr
 10171              		.cfi_endproc
 10172              	.LFE55:
 10174              		.section	.text.poly_small_to_fp,"ax",%progbits
 10175              		.align	1
 10176              		.syntax unified
 10177              		.thumb
 10178              		.thumb_func
 10179              		.fpu softvfp
 10181              	poly_small_to_fp:
 10182              	.LFB56:
2492:keygen.c      **** 
2493:keygen.c      **** /*
2494:keygen.c      ****  * Convert a small vector to floating point.
2495:keygen.c      ****  */
2496:keygen.c      **** static void
2497:keygen.c      **** poly_small_to_fp(fpr *x, const int8_t *f, unsigned logn)
2498:keygen.c      **** {
 10183              		.loc 2 2498 1
 10184              		.cfi_startproc
 10185              		@ args = 0, pretend = 0, frame = 24
 10186              		@ frame_needed = 1, uses_anonymous_args = 0
 10187 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 10188              	.LCFI241:
 10189              		.cfi_def_cfa_offset 20
 10190              		.cfi_offset 4, -20
 10191              		.cfi_offset 5, -16
 10192              		.cfi_offset 6, -12
 10193              		.cfi_offset 7, -8
 10194              		.cfi_offset 14, -4
 10195 0002 87B0     		sub	sp, sp, #28
 10196              	.LCFI242:
 10197              		.cfi_def_cfa_offset 48
 10198 0004 00AF     		add	r7, sp, #0
 10199              	.LCFI243:
 10200              		.cfi_def_cfa_register 7
 10201 0006 F860     		str	r0, [r7, #12]
 10202 0008 B960     		str	r1, [r7, #8]
 10203 000a 7A60     		str	r2, [r7, #4]
2499:keygen.c      **** 	size_t n, u;
2500:keygen.c      **** 
2501:keygen.c      **** 	n = MKN(logn);
 10204              		.loc 2 2501 4
 10205 000c 0122     		movs	r2, #1
 10206 000e 7B68     		ldr	r3, [r7, #4]
 10207 0010 02FA03F3 		lsl	r3, r2, r3
 10208 0014 3B61     		str	r3, [r7, #16]
2502:keygen.c      **** 	for (u = 0; u < n; u ++) {
 10209              		.loc 2 2502 9
 10210 0016 0023     		movs	r3, #0
 10211 0018 7B61     		str	r3, [r7, #20]
 10212              		.loc 2 2502 2
 10213 001a 17E0     		b	.L204
 10214              	.L205:
2503:keygen.c      **** 		x[u] = fpr_of(f[u]);
 10215              		.loc 2 2503 18 discriminator 3
 10216 001c BA68     		ldr	r2, [r7, #8]
 10217 001e 7B69     		ldr	r3, [r7, #20]
 10218 0020 1344     		add	r3, r3, r2
 10219 0022 93F90030 		ldrsb	r3, [r3]
 10220              		.loc 2 2503 10 discriminator 3
 10221 0026 5BB2     		sxtb	r3, r3
 10222 0028 DA17     		asrs	r2, r3, #31
 10223 002a 1C46     		mov	r4, r3
 10224 002c 1546     		mov	r5, r2
 10225              		.loc 2 2503 4 discriminator 3
 10226 002e 7B69     		ldr	r3, [r7, #20]
 10227 0030 DB00     		lsls	r3, r3, #3
 10228 0032 FA68     		ldr	r2, [r7, #12]
 10229 0034 D618     		adds	r6, r2, r3
 10230              		.loc 2 2503 10 discriminator 3
 10231 0036 2046     		mov	r0, r4
 10232 0038 2946     		mov	r1, r5
 10233 003a FFF7FEFF 		bl	fpr_of
 10234 003e 0246     		mov	r2, r0
 10235 0040 0B46     		mov	r3, r1
 10236              		.loc 2 2503 8 discriminator 3
 10237 0042 C6E90023 		strd	r2, [r6]
2502:keygen.c      **** 	for (u = 0; u < n; u ++) {
 10238              		.loc 2 2502 23 discriminator 3
 10239 0046 7B69     		ldr	r3, [r7, #20]
 10240 0048 0133     		adds	r3, r3, #1
 10241 004a 7B61     		str	r3, [r7, #20]
 10242              	.L204:
2502:keygen.c      **** 	for (u = 0; u < n; u ++) {
 10243              		.loc 2 2502 2 discriminator 1
 10244 004c 7A69     		ldr	r2, [r7, #20]
 10245 004e 3B69     		ldr	r3, [r7, #16]
 10246 0050 9A42     		cmp	r2, r3
 10247 0052 E3D3     		bcc	.L205
2504:keygen.c      **** 	}
2505:keygen.c      **** }
 10248              		.loc 2 2505 1
 10249 0054 00BF     		nop
 10250 0056 00BF     		nop
 10251 0058 1C37     		adds	r7, r7, #28
 10252              	.LCFI244:
 10253              		.cfi_def_cfa_offset 20
 10254 005a BD46     		mov	sp, r7
 10255              	.LCFI245:
 10256              		.cfi_def_cfa_register 13
 10257              		@ sp needed
 10258 005c F0BD     		pop	{r4, r5, r6, r7, pc}
 10259              		.cfi_endproc
 10260              	.LFE56:
 10262              		.section	.text.make_fg_step,"ax",%progbits
 10263              		.align	1
 10264              		.syntax unified
 10265              		.thumb
 10266              		.thumb_func
 10267              		.fpu softvfp
 10269              	make_fg_step:
 10270              	.LFB57:
2506:keygen.c      **** 
2507:keygen.c      **** /*
2508:keygen.c      ****  * Input: f,g of degree N = 2^logn; 'depth' is used only to get their
2509:keygen.c      ****  * individual length.
2510:keygen.c      ****  *
2511:keygen.c      ****  * Output: f',g' of degree N/2, with the length for 'depth+1'.
2512:keygen.c      ****  *
2513:keygen.c      ****  * Values are in RNS; input and/or output may also be in NTT.
2514:keygen.c      ****  */
2515:keygen.c      **** static void
2516:keygen.c      **** make_fg_step(uint32_t *data, unsigned logn, unsigned depth,
2517:keygen.c      **** 	int in_ntt, int out_ntt)
2518:keygen.c      **** {
 10271              		.loc 2 2518 1
 10272              		.cfi_startproc
 10273              		@ args = 4, pretend = 0, frame = 144
 10274              		@ frame_needed = 1, uses_anonymous_args = 0
 10275 0000 90B5     		push	{r4, r7, lr}
 10276              	.LCFI246:
 10277              		.cfi_def_cfa_offset 12
 10278              		.cfi_offset 4, -12
 10279              		.cfi_offset 7, -8
 10280              		.cfi_offset 14, -4
 10281 0002 A9B0     		sub	sp, sp, #164
 10282              	.LCFI247:
 10283              		.cfi_def_cfa_offset 176
 10284 0004 04AF     		add	r7, sp, #16
 10285              	.LCFI248:
 10286              		.cfi_def_cfa 7, 160
 10287 0006 F860     		str	r0, [r7, #12]
 10288 0008 B960     		str	r1, [r7, #8]
 10289 000a 7A60     		str	r2, [r7, #4]
 10290 000c 3B60     		str	r3, [r7]
2519:keygen.c      **** 	size_t n, hn, u;
2520:keygen.c      **** 	size_t slen, tlen;
2521:keygen.c      **** 	uint32_t *fd, *gd, *fs, *gs, *gm, *igm, *t1;
2522:keygen.c      **** 	const small_prime *primes;
2523:keygen.c      **** 
2524:keygen.c      **** 	n = (size_t)1 << logn;
 10291              		.loc 2 2524 4
 10292 000e 0122     		movs	r2, #1
 10293 0010 BB68     		ldr	r3, [r7, #8]
 10294 0012 02FA03F3 		lsl	r3, r2, r3
 10295 0016 BB67     		str	r3, [r7, #120]
2525:keygen.c      **** 	hn = n >> 1;
 10296              		.loc 2 2525 5
 10297 0018 BB6F     		ldr	r3, [r7, #120]
 10298 001a 5B08     		lsrs	r3, r3, #1
 10299 001c 7B67     		str	r3, [r7, #116]
2526:keygen.c      **** 	slen = MAX_BL_SMALL[depth];
 10300              		.loc 2 2526 7
 10301 001e 944A     		ldr	r2, .L233
 10302 0020 7B68     		ldr	r3, [r7, #4]
 10303 0022 52F82330 		ldr	r3, [r2, r3, lsl #2]
 10304 0026 3B67     		str	r3, [r7, #112]
2527:keygen.c      **** 	tlen = MAX_BL_SMALL[depth + 1];
 10305              		.loc 2 2527 28
 10306 0028 7B68     		ldr	r3, [r7, #4]
 10307 002a 0133     		adds	r3, r3, #1
 10308              		.loc 2 2527 7
 10309 002c 904A     		ldr	r2, .L233
 10310 002e 52F82330 		ldr	r3, [r2, r3, lsl #2]
 10311 0032 FB66     		str	r3, [r7, #108]
2528:keygen.c      **** 	primes = PRIMES;
 10312              		.loc 2 2528 9
 10313 0034 8F4B     		ldr	r3, .L233+4
 10314 0036 BB66     		str	r3, [r7, #104]
2529:keygen.c      **** 
2530:keygen.c      **** 	/*
2531:keygen.c      **** 	 * Prepare room for the result.
2532:keygen.c      **** 	 */
2533:keygen.c      **** 	fd = data;
 10315              		.loc 2 2533 5
 10316 0038 FB68     		ldr	r3, [r7, #12]
 10317 003a 7B66     		str	r3, [r7, #100]
2534:keygen.c      **** 	gd = fd + hn * tlen;
 10318              		.loc 2 2534 15
 10319 003c 7B6F     		ldr	r3, [r7, #116]
 10320 003e FA6E     		ldr	r2, [r7, #108]
 10321 0040 02FB03F3 		mul	r3, r2, r3
 10322              		.loc 2 2534 10
 10323 0044 9B00     		lsls	r3, r3, #2
 10324              		.loc 2 2534 5
 10325 0046 7A6E     		ldr	r2, [r7, #100]
 10326 0048 1344     		add	r3, r3, r2
 10327 004a 3B66     		str	r3, [r7, #96]
2535:keygen.c      **** 	fs = gd + hn * tlen;
 10328              		.loc 2 2535 15
 10329 004c 7B6F     		ldr	r3, [r7, #116]
 10330 004e FA6E     		ldr	r2, [r7, #108]
 10331 0050 02FB03F3 		mul	r3, r2, r3
 10332              		.loc 2 2535 10
 10333 0054 9B00     		lsls	r3, r3, #2
 10334              		.loc 2 2535 5
 10335 0056 3A6E     		ldr	r2, [r7, #96]
 10336 0058 1344     		add	r3, r3, r2
 10337 005a FB65     		str	r3, [r7, #92]
2536:keygen.c      **** 	gs = fs + n * slen;
 10338              		.loc 2 2536 14
 10339 005c BB6F     		ldr	r3, [r7, #120]
 10340 005e 3A6F     		ldr	r2, [r7, #112]
 10341 0060 02FB03F3 		mul	r3, r2, r3
 10342              		.loc 2 2536 10
 10343 0064 9B00     		lsls	r3, r3, #2
 10344              		.loc 2 2536 5
 10345 0066 FA6D     		ldr	r2, [r7, #92]
 10346 0068 1344     		add	r3, r3, r2
 10347 006a BB65     		str	r3, [r7, #88]
2537:keygen.c      **** 	gm = gs + n * slen;
 10348              		.loc 2 2537 14
 10349 006c BB6F     		ldr	r3, [r7, #120]
 10350 006e 3A6F     		ldr	r2, [r7, #112]
 10351 0070 02FB03F3 		mul	r3, r2, r3
 10352              		.loc 2 2537 10
 10353 0074 9B00     		lsls	r3, r3, #2
 10354              		.loc 2 2537 5
 10355 0076 BA6D     		ldr	r2, [r7, #88]
 10356 0078 1344     		add	r3, r3, r2
 10357 007a 7B65     		str	r3, [r7, #84]
2538:keygen.c      **** 	igm = gm + n;
 10358              		.loc 2 2538 11
 10359 007c BB6F     		ldr	r3, [r7, #120]
 10360 007e 9B00     		lsls	r3, r3, #2
 10361              		.loc 2 2538 6
 10362 0080 7A6D     		ldr	r2, [r7, #84]
 10363 0082 1344     		add	r3, r3, r2
 10364 0084 3B65     		str	r3, [r7, #80]
2539:keygen.c      **** 	t1 = igm + n;
 10365              		.loc 2 2539 11
 10366 0086 BB6F     		ldr	r3, [r7, #120]
 10367 0088 9B00     		lsls	r3, r3, #2
 10368              		.loc 2 2539 5
 10369 008a 3A6D     		ldr	r2, [r7, #80]
 10370 008c 1344     		add	r3, r3, r2
 10371 008e FB64     		str	r3, [r7, #76]
2540:keygen.c      **** 	memmove(fs, data, 2 * n * slen * sizeof *data);
 10372              		.loc 2 2540 26
 10373 0090 BB6F     		ldr	r3, [r7, #120]
 10374 0092 3A6F     		ldr	r2, [r7, #112]
 10375 0094 02FB03F3 		mul	r3, r2, r3
 10376              		.loc 2 2540 2
 10377 0098 DB00     		lsls	r3, r3, #3
 10378 009a 1A46     		mov	r2, r3
 10379 009c F968     		ldr	r1, [r7, #12]
 10380 009e F86D     		ldr	r0, [r7, #92]
 10381 00a0 FFF7FEFF 		bl	memmove
2541:keygen.c      **** 
2542:keygen.c      **** 	/*
2543:keygen.c      **** 	 * First slen words: we use the input values directly, and apply
2544:keygen.c      **** 	 * inverse NTT as we go.
2545:keygen.c      **** 	 */
2546:keygen.c      **** 	for (u = 0; u < slen; u ++) {
 10382              		.loc 2 2546 9
 10383 00a4 0023     		movs	r3, #0
 10384 00a6 C7F88C30 		str	r3, [r7, #140]
 10385              		.loc 2 2546 2
 10386 00aa 4EE1     		b	.L207
 10387              	.L221:
 10388              	.LBB35:
2547:keygen.c      **** 		uint32_t p, p0i, R2;
2548:keygen.c      **** 		size_t v;
2549:keygen.c      **** 		uint32_t *x;
2550:keygen.c      **** 
2551:keygen.c      **** 		p = primes[u].p;
 10389              		.loc 2 2551 13
 10390 00ac D7F88C20 		ldr	r2, [r7, #140]
 10391 00b0 1346     		mov	r3, r2
 10392 00b2 5B00     		lsls	r3, r3, #1
 10393 00b4 1344     		add	r3, r3, r2
 10394 00b6 9B00     		lsls	r3, r3, #2
 10395 00b8 1A46     		mov	r2, r3
 10396 00ba BB6E     		ldr	r3, [r7, #104]
 10397 00bc 1344     		add	r3, r3, r2
 10398              		.loc 2 2551 5
 10399 00be 1B68     		ldr	r3, [r3]
 10400 00c0 BB62     		str	r3, [r7, #40]
2552:keygen.c      **** 		p0i = modp_ninv31(p);
 10401              		.loc 2 2552 9
 10402 00c2 B86A     		ldr	r0, [r7, #40]
 10403 00c4 FFF7FEFF 		bl	modp_ninv31
 10404 00c8 7862     		str	r0, [r7, #36]
2553:keygen.c      **** 		R2 = modp_R2(p, p0i);
 10405              		.loc 2 2553 8
 10406 00ca 796A     		ldr	r1, [r7, #36]
 10407 00cc B86A     		ldr	r0, [r7, #40]
 10408 00ce FFF7FEFF 		bl	modp_R2
 10409 00d2 3862     		str	r0, [r7, #32]
2554:keygen.c      **** 		modp_mkgm2(gm, igm, logn, primes[u].g, p, p0i);
 10410              		.loc 2 2554 35
 10411 00d4 D7F88C20 		ldr	r2, [r7, #140]
 10412 00d8 1346     		mov	r3, r2
 10413 00da 5B00     		lsls	r3, r3, #1
 10414 00dc 1344     		add	r3, r3, r2
 10415 00de 9B00     		lsls	r3, r3, #2
 10416 00e0 1A46     		mov	r2, r3
 10417 00e2 BB6E     		ldr	r3, [r7, #104]
 10418 00e4 1344     		add	r3, r3, r2
 10419              		.loc 2 2554 3
 10420 00e6 5A68     		ldr	r2, [r3, #4]
 10421 00e8 7B6A     		ldr	r3, [r7, #36]
 10422 00ea 0193     		str	r3, [sp, #4]
 10423 00ec BB6A     		ldr	r3, [r7, #40]
 10424 00ee 0093     		str	r3, [sp]
 10425 00f0 1346     		mov	r3, r2
 10426 00f2 BA68     		ldr	r2, [r7, #8]
 10427 00f4 396D     		ldr	r1, [r7, #80]
 10428 00f6 786D     		ldr	r0, [r7, #84]
 10429 00f8 FFF7FEFF 		bl	modp_mkgm2
2555:keygen.c      **** 
2556:keygen.c      **** 		for (v = 0, x = fs + u; v < n; v ++, x += slen) {
 10430              		.loc 2 2556 10
 10431 00fc 0023     		movs	r3, #0
 10432 00fe C7F88830 		str	r3, [r7, #136]
 10433              		.loc 2 2556 22
 10434 0102 D7F88C30 		ldr	r3, [r7, #140]
 10435 0106 9B00     		lsls	r3, r3, #2
 10436              		.loc 2 2556 17
 10437 0108 FA6D     		ldr	r2, [r7, #92]
 10438 010a 1344     		add	r3, r3, r2
 10439 010c C7F88430 		str	r3, [r7, #132]
 10440              		.loc 2 2556 3
 10441 0110 14E0     		b	.L208
 10442              	.L209:
2557:keygen.c      **** 			t1[v] = *x;
 10443              		.loc 2 2557 6 discriminator 3
 10444 0112 D7F88830 		ldr	r3, [r7, #136]
 10445 0116 9B00     		lsls	r3, r3, #2
 10446 0118 FA6C     		ldr	r2, [r7, #76]
 10447 011a 1344     		add	r3, r3, r2
 10448              		.loc 2 2557 12 discriminator 3
 10449 011c D7F88420 		ldr	r2, [r7, #132]
 10450 0120 1268     		ldr	r2, [r2]
 10451              		.loc 2 2557 10 discriminator 3
 10452 0122 1A60     		str	r2, [r3]
2556:keygen.c      **** 			t1[v] = *x;
 10453              		.loc 2 2556 36 discriminator 3
 10454 0124 D7F88830 		ldr	r3, [r7, #136]
 10455 0128 0133     		adds	r3, r3, #1
 10456 012a C7F88830 		str	r3, [r7, #136]
2556:keygen.c      **** 			t1[v] = *x;
 10457              		.loc 2 2556 42 discriminator 3
 10458 012e 3B6F     		ldr	r3, [r7, #112]
 10459 0130 9B00     		lsls	r3, r3, #2
 10460 0132 D7F88420 		ldr	r2, [r7, #132]
 10461 0136 1344     		add	r3, r3, r2
 10462 0138 C7F88430 		str	r3, [r7, #132]
 10463              	.L208:
2556:keygen.c      **** 			t1[v] = *x;
 10464              		.loc 2 2556 3 discriminator 1
 10465 013c D7F88820 		ldr	r2, [r7, #136]
 10466 0140 BB6F     		ldr	r3, [r7, #120]
 10467 0142 9A42     		cmp	r2, r3
 10468 0144 E5D3     		bcc	.L209
2558:keygen.c      **** 		}
2559:keygen.c      **** 		if (!in_ntt) {
 10469              		.loc 2 2559 6
 10470 0146 3B68     		ldr	r3, [r7]
 10471 0148 002B     		cmp	r3, #0
 10472 014a 09D1     		bne	.L210
2560:keygen.c      **** 			modp_NTT2(t1, gm, logn, p, p0i);
 10473              		.loc 2 2560 4
 10474 014c 7B6A     		ldr	r3, [r7, #36]
 10475 014e 0193     		str	r3, [sp, #4]
 10476 0150 BB6A     		ldr	r3, [r7, #40]
 10477 0152 0093     		str	r3, [sp]
 10478 0154 BB68     		ldr	r3, [r7, #8]
 10479 0156 7A6D     		ldr	r2, [r7, #84]
 10480 0158 0121     		movs	r1, #1
 10481 015a F86C     		ldr	r0, [r7, #76]
 10482 015c FFF7FEFF 		bl	modp_NTT2_ext
 10483              	.L210:
2561:keygen.c      **** 		}
2562:keygen.c      **** 		for (v = 0, x = fd + u; v < hn; v ++, x += tlen) {
 10484              		.loc 2 2562 10
 10485 0160 0023     		movs	r3, #0
 10486 0162 C7F88830 		str	r3, [r7, #136]
 10487              		.loc 2 2562 22
 10488 0166 D7F88C30 		ldr	r3, [r7, #140]
 10489 016a 9B00     		lsls	r3, r3, #2
 10490              		.loc 2 2562 17
 10491 016c 7A6E     		ldr	r2, [r7, #100]
 10492 016e 1344     		add	r3, r3, r2
 10493 0170 C7F88430 		str	r3, [r7, #132]
 10494              		.loc 2 2562 3
 10495 0174 29E0     		b	.L211
 10496              	.L212:
 10497              	.LBB36:
2563:keygen.c      **** 			uint32_t w0, w1;
2564:keygen.c      **** 
2565:keygen.c      **** 			w0 = t1[(v << 1) + 0];
 10498              		.loc 2 2565 11 discriminator 3
 10499 0176 D7F88830 		ldr	r3, [r7, #136]
 10500 017a DB00     		lsls	r3, r3, #3
 10501 017c FA6C     		ldr	r2, [r7, #76]
 10502 017e 1344     		add	r3, r3, r2
 10503              		.loc 2 2565 7 discriminator 3
 10504 0180 1B68     		ldr	r3, [r3]
 10505 0182 7B61     		str	r3, [r7, #20]
2566:keygen.c      **** 			w1 = t1[(v << 1) + 1];
 10506              		.loc 2 2566 11 discriminator 3
 10507 0184 D7F88830 		ldr	r3, [r7, #136]
 10508 0188 DB00     		lsls	r3, r3, #3
 10509 018a 0433     		adds	r3, r3, #4
 10510 018c FA6C     		ldr	r2, [r7, #76]
 10511 018e 1344     		add	r3, r3, r2
 10512              		.loc 2 2566 7 discriminator 3
 10513 0190 1B68     		ldr	r3, [r3]
 10514 0192 3B61     		str	r3, [r7, #16]
2567:keygen.c      **** 			*x = modp_montymul(
 10515              		.loc 2 2567 9 discriminator 3
 10516 0194 7B6A     		ldr	r3, [r7, #36]
 10517 0196 BA6A     		ldr	r2, [r7, #40]
 10518 0198 3969     		ldr	r1, [r7, #16]
 10519 019a 7869     		ldr	r0, [r7, #20]
 10520 019c FFF7FEFF 		bl	modp_montymul
 10521 01a0 7B6A     		ldr	r3, [r7, #36]
 10522 01a2 BA6A     		ldr	r2, [r7, #40]
 10523 01a4 396A     		ldr	r1, [r7, #32]
 10524 01a6 FFF7FEFF 		bl	modp_montymul
 10525 01aa 0246     		mov	r2, r0
 10526              		.loc 2 2567 7 discriminator 3
 10527 01ac D7F88430 		ldr	r3, [r7, #132]
 10528 01b0 1A60     		str	r2, [r3]
 10529              	.LBE36:
2562:keygen.c      **** 			uint32_t w0, w1;
 10530              		.loc 2 2562 37 discriminator 3
 10531 01b2 D7F88830 		ldr	r3, [r7, #136]
 10532 01b6 0133     		adds	r3, r3, #1
 10533 01b8 C7F88830 		str	r3, [r7, #136]
2562:keygen.c      **** 			uint32_t w0, w1;
 10534              		.loc 2 2562 43 discriminator 3
 10535 01bc FB6E     		ldr	r3, [r7, #108]
 10536 01be 9B00     		lsls	r3, r3, #2
 10537 01c0 D7F88420 		ldr	r2, [r7, #132]
 10538 01c4 1344     		add	r3, r3, r2
 10539 01c6 C7F88430 		str	r3, [r7, #132]
 10540              	.L211:
2562:keygen.c      **** 			uint32_t w0, w1;
 10541              		.loc 2 2562 3 discriminator 1
 10542 01ca D7F88820 		ldr	r2, [r7, #136]
 10543 01ce 7B6F     		ldr	r3, [r7, #116]
 10544 01d0 9A42     		cmp	r2, r3
 10545 01d2 D0D3     		bcc	.L212
2568:keygen.c      **** 				modp_montymul(w0, w1, p, p0i), R2, p, p0i);
2569:keygen.c      **** 		}
2570:keygen.c      **** 		if (in_ntt) {
 10546              		.loc 2 2570 6
 10547 01d4 3B68     		ldr	r3, [r7]
 10548 01d6 002B     		cmp	r3, #0
 10549 01d8 0DD0     		beq	.L213
2571:keygen.c      **** 			modp_iNTT2_ext(fs + u, slen, igm, logn, p, p0i);
 10550              		.loc 2 2571 22
 10551 01da D7F88C30 		ldr	r3, [r7, #140]
 10552 01de 9B00     		lsls	r3, r3, #2
 10553              		.loc 2 2571 4
 10554 01e0 FA6D     		ldr	r2, [r7, #92]
 10555 01e2 D018     		adds	r0, r2, r3
 10556 01e4 7B6A     		ldr	r3, [r7, #36]
 10557 01e6 0193     		str	r3, [sp, #4]
 10558 01e8 BB6A     		ldr	r3, [r7, #40]
 10559 01ea 0093     		str	r3, [sp]
 10560 01ec BB68     		ldr	r3, [r7, #8]
 10561 01ee 3A6D     		ldr	r2, [r7, #80]
 10562 01f0 396F     		ldr	r1, [r7, #112]
 10563 01f2 FFF7FEFF 		bl	modp_iNTT2_ext
 10564              	.L213:
2572:keygen.c      **** 		}
2573:keygen.c      **** 
2574:keygen.c      **** 		for (v = 0, x = gs + u; v < n; v ++, x += slen) {
 10565              		.loc 2 2574 10
 10566 01f6 0023     		movs	r3, #0
 10567 01f8 C7F88830 		str	r3, [r7, #136]
 10568              		.loc 2 2574 22
 10569 01fc D7F88C30 		ldr	r3, [r7, #140]
 10570 0200 9B00     		lsls	r3, r3, #2
 10571              		.loc 2 2574 17
 10572 0202 BA6D     		ldr	r2, [r7, #88]
 10573 0204 1344     		add	r3, r3, r2
 10574 0206 C7F88430 		str	r3, [r7, #132]
 10575              		.loc 2 2574 3
 10576 020a 14E0     		b	.L214
 10577              	.L215:
2575:keygen.c      **** 			t1[v] = *x;
 10578              		.loc 2 2575 6 discriminator 3
 10579 020c D7F88830 		ldr	r3, [r7, #136]
 10580 0210 9B00     		lsls	r3, r3, #2
 10581 0212 FA6C     		ldr	r2, [r7, #76]
 10582 0214 1344     		add	r3, r3, r2
 10583              		.loc 2 2575 12 discriminator 3
 10584 0216 D7F88420 		ldr	r2, [r7, #132]
 10585 021a 1268     		ldr	r2, [r2]
 10586              		.loc 2 2575 10 discriminator 3
 10587 021c 1A60     		str	r2, [r3]
2574:keygen.c      **** 			t1[v] = *x;
 10588              		.loc 2 2574 36 discriminator 3
 10589 021e D7F88830 		ldr	r3, [r7, #136]
 10590 0222 0133     		adds	r3, r3, #1
 10591 0224 C7F88830 		str	r3, [r7, #136]
2574:keygen.c      **** 			t1[v] = *x;
 10592              		.loc 2 2574 42 discriminator 3
 10593 0228 3B6F     		ldr	r3, [r7, #112]
 10594 022a 9B00     		lsls	r3, r3, #2
 10595 022c D7F88420 		ldr	r2, [r7, #132]
 10596 0230 1344     		add	r3, r3, r2
 10597 0232 C7F88430 		str	r3, [r7, #132]
 10598              	.L214:
2574:keygen.c      **** 			t1[v] = *x;
 10599              		.loc 2 2574 3 discriminator 1
 10600 0236 D7F88820 		ldr	r2, [r7, #136]
 10601 023a BB6F     		ldr	r3, [r7, #120]
 10602 023c 9A42     		cmp	r2, r3
 10603 023e E5D3     		bcc	.L215
2576:keygen.c      **** 		}
2577:keygen.c      **** 		if (!in_ntt) {
 10604              		.loc 2 2577 6
 10605 0240 3B68     		ldr	r3, [r7]
 10606 0242 002B     		cmp	r3, #0
 10607 0244 09D1     		bne	.L216
2578:keygen.c      **** 			modp_NTT2(t1, gm, logn, p, p0i);
 10608              		.loc 2 2578 4
 10609 0246 7B6A     		ldr	r3, [r7, #36]
 10610 0248 0193     		str	r3, [sp, #4]
 10611 024a BB6A     		ldr	r3, [r7, #40]
 10612 024c 0093     		str	r3, [sp]
 10613 024e BB68     		ldr	r3, [r7, #8]
 10614 0250 7A6D     		ldr	r2, [r7, #84]
 10615 0252 0121     		movs	r1, #1
 10616 0254 F86C     		ldr	r0, [r7, #76]
 10617 0256 FFF7FEFF 		bl	modp_NTT2_ext
 10618              	.L216:
2579:keygen.c      **** 		}
2580:keygen.c      **** 		for (v = 0, x = gd + u; v < hn; v ++, x += tlen) {
 10619              		.loc 2 2580 10
 10620 025a 0023     		movs	r3, #0
 10621 025c C7F88830 		str	r3, [r7, #136]
 10622              		.loc 2 2580 22
 10623 0260 D7F88C30 		ldr	r3, [r7, #140]
 10624 0264 9B00     		lsls	r3, r3, #2
 10625              		.loc 2 2580 17
 10626 0266 3A6E     		ldr	r2, [r7, #96]
 10627 0268 1344     		add	r3, r3, r2
 10628 026a C7F88430 		str	r3, [r7, #132]
 10629              		.loc 2 2580 3
 10630 026e 2DE0     		b	.L217
 10631              	.L234:
 10632              		.align	2
 10633              	.L233:
 10634 0270 90220000 		.word	MAX_BL_SMALL
 10635 0274 40010000 		.word	PRIMES
 10636              	.L218:
 10637              	.LBB37:
2581:keygen.c      **** 			uint32_t w0, w1;
2582:keygen.c      **** 
2583:keygen.c      **** 			w0 = t1[(v << 1) + 0];
 10638              		.loc 2 2583 11 discriminator 3
 10639 0278 D7F88830 		ldr	r3, [r7, #136]
 10640 027c DB00     		lsls	r3, r3, #3
 10641 027e FA6C     		ldr	r2, [r7, #76]
 10642 0280 1344     		add	r3, r3, r2
 10643              		.loc 2 2583 7 discriminator 3
 10644 0282 1B68     		ldr	r3, [r3]
 10645 0284 FB61     		str	r3, [r7, #28]
2584:keygen.c      **** 			w1 = t1[(v << 1) + 1];
 10646              		.loc 2 2584 11 discriminator 3
 10647 0286 D7F88830 		ldr	r3, [r7, #136]
 10648 028a DB00     		lsls	r3, r3, #3
 10649 028c 0433     		adds	r3, r3, #4
 10650 028e FA6C     		ldr	r2, [r7, #76]
 10651 0290 1344     		add	r3, r3, r2
 10652              		.loc 2 2584 7 discriminator 3
 10653 0292 1B68     		ldr	r3, [r3]
 10654 0294 BB61     		str	r3, [r7, #24]
2585:keygen.c      **** 			*x = modp_montymul(
 10655              		.loc 2 2585 9 discriminator 3
 10656 0296 7B6A     		ldr	r3, [r7, #36]
 10657 0298 BA6A     		ldr	r2, [r7, #40]
 10658 029a B969     		ldr	r1, [r7, #24]
 10659 029c F869     		ldr	r0, [r7, #28]
 10660 029e FFF7FEFF 		bl	modp_montymul
 10661 02a2 7B6A     		ldr	r3, [r7, #36]
 10662 02a4 BA6A     		ldr	r2, [r7, #40]
 10663 02a6 396A     		ldr	r1, [r7, #32]
 10664 02a8 FFF7FEFF 		bl	modp_montymul
 10665 02ac 0246     		mov	r2, r0
 10666              		.loc 2 2585 7 discriminator 3
 10667 02ae D7F88430 		ldr	r3, [r7, #132]
 10668 02b2 1A60     		str	r2, [r3]
 10669              	.LBE37:
2580:keygen.c      **** 			uint32_t w0, w1;
 10670              		.loc 2 2580 37 discriminator 3
 10671 02b4 D7F88830 		ldr	r3, [r7, #136]
 10672 02b8 0133     		adds	r3, r3, #1
 10673 02ba C7F88830 		str	r3, [r7, #136]
2580:keygen.c      **** 			uint32_t w0, w1;
 10674              		.loc 2 2580 43 discriminator 3
 10675 02be FB6E     		ldr	r3, [r7, #108]
 10676 02c0 9B00     		lsls	r3, r3, #2
 10677 02c2 D7F88420 		ldr	r2, [r7, #132]
 10678 02c6 1344     		add	r3, r3, r2
 10679 02c8 C7F88430 		str	r3, [r7, #132]
 10680              	.L217:
2580:keygen.c      **** 			uint32_t w0, w1;
 10681              		.loc 2 2580 3 discriminator 1
 10682 02cc D7F88820 		ldr	r2, [r7, #136]
 10683 02d0 7B6F     		ldr	r3, [r7, #116]
 10684 02d2 9A42     		cmp	r2, r3
 10685 02d4 D0D3     		bcc	.L218
2586:keygen.c      **** 				modp_montymul(w0, w1, p, p0i), R2, p, p0i);
2587:keygen.c      **** 		}
2588:keygen.c      **** 		if (in_ntt) {
 10686              		.loc 2 2588 6
 10687 02d6 3B68     		ldr	r3, [r7]
 10688 02d8 002B     		cmp	r3, #0
 10689 02da 0DD0     		beq	.L219
2589:keygen.c      **** 			modp_iNTT2_ext(gs + u, slen, igm, logn, p, p0i);
 10690              		.loc 2 2589 22
 10691 02dc D7F88C30 		ldr	r3, [r7, #140]
 10692 02e0 9B00     		lsls	r3, r3, #2
 10693              		.loc 2 2589 4
 10694 02e2 BA6D     		ldr	r2, [r7, #88]
 10695 02e4 D018     		adds	r0, r2, r3
 10696 02e6 7B6A     		ldr	r3, [r7, #36]
 10697 02e8 0193     		str	r3, [sp, #4]
 10698 02ea BB6A     		ldr	r3, [r7, #40]
 10699 02ec 0093     		str	r3, [sp]
 10700 02ee BB68     		ldr	r3, [r7, #8]
 10701 02f0 3A6D     		ldr	r2, [r7, #80]
 10702 02f2 396F     		ldr	r1, [r7, #112]
 10703 02f4 FFF7FEFF 		bl	modp_iNTT2_ext
 10704              	.L219:
2590:keygen.c      **** 		}
2591:keygen.c      **** 
2592:keygen.c      **** 		if (!out_ntt) {
 10705              		.loc 2 2592 6
 10706 02f8 D7F8A030 		ldr	r3, [r7, #160]
 10707 02fc 002B     		cmp	r3, #0
 10708 02fe 1FD1     		bne	.L220
2593:keygen.c      **** 			modp_iNTT2_ext(fd + u, tlen, igm, logn - 1, p, p0i);
 10709              		.loc 2 2593 22
 10710 0300 D7F88C30 		ldr	r3, [r7, #140]
 10711 0304 9B00     		lsls	r3, r3, #2
 10712              		.loc 2 2593 4
 10713 0306 7A6E     		ldr	r2, [r7, #100]
 10714 0308 D018     		adds	r0, r2, r3
 10715 030a BB68     		ldr	r3, [r7, #8]
 10716 030c 5A1E     		subs	r2, r3, #1
 10717 030e 7B6A     		ldr	r3, [r7, #36]
 10718 0310 0193     		str	r3, [sp, #4]
 10719 0312 BB6A     		ldr	r3, [r7, #40]
 10720 0314 0093     		str	r3, [sp]
 10721 0316 1346     		mov	r3, r2
 10722 0318 3A6D     		ldr	r2, [r7, #80]
 10723 031a F96E     		ldr	r1, [r7, #108]
 10724 031c FFF7FEFF 		bl	modp_iNTT2_ext
2594:keygen.c      **** 			modp_iNTT2_ext(gd + u, tlen, igm, logn - 1, p, p0i);
 10725              		.loc 2 2594 22
 10726 0320 D7F88C30 		ldr	r3, [r7, #140]
 10727 0324 9B00     		lsls	r3, r3, #2
 10728              		.loc 2 2594 4
 10729 0326 3A6E     		ldr	r2, [r7, #96]
 10730 0328 D018     		adds	r0, r2, r3
 10731 032a BB68     		ldr	r3, [r7, #8]
 10732 032c 5A1E     		subs	r2, r3, #1
 10733 032e 7B6A     		ldr	r3, [r7, #36]
 10734 0330 0193     		str	r3, [sp, #4]
 10735 0332 BB6A     		ldr	r3, [r7, #40]
 10736 0334 0093     		str	r3, [sp]
 10737 0336 1346     		mov	r3, r2
 10738 0338 3A6D     		ldr	r2, [r7, #80]
 10739 033a F96E     		ldr	r1, [r7, #108]
 10740 033c FFF7FEFF 		bl	modp_iNTT2_ext
 10741              	.L220:
 10742              	.LBE35:
2546:keygen.c      **** 		uint32_t p, p0i, R2;
 10743              		.loc 2 2546 26 discriminator 2
 10744 0340 D7F88C30 		ldr	r3, [r7, #140]
 10745 0344 0133     		adds	r3, r3, #1
 10746 0346 C7F88C30 		str	r3, [r7, #140]
 10747              	.L207:
2546:keygen.c      **** 		uint32_t p, p0i, R2;
 10748              		.loc 2 2546 2 discriminator 1
 10749 034a D7F88C20 		ldr	r2, [r7, #140]
 10750 034e 3B6F     		ldr	r3, [r7, #112]
 10751 0350 9A42     		cmp	r2, r3
 10752 0352 FFF4ABAE 		bcc	.L221
2595:keygen.c      **** 		}
2596:keygen.c      **** 	}
2597:keygen.c      **** 
2598:keygen.c      **** 	/*
2599:keygen.c      **** 	 * Since the fs and gs words have been de-NTTized, we can use the
2600:keygen.c      **** 	 * CRT to rebuild the values.
2601:keygen.c      **** 	 */
2602:keygen.c      **** 	zint_rebuild_CRT(fs, slen, slen, n, primes, 1, gm);
 10753              		.loc 2 2602 2
 10754 0356 7B6D     		ldr	r3, [r7, #84]
 10755 0358 0293     		str	r3, [sp, #8]
 10756 035a 0123     		movs	r3, #1
 10757 035c 0193     		str	r3, [sp, #4]
 10758 035e BB6E     		ldr	r3, [r7, #104]
 10759 0360 0093     		str	r3, [sp]
 10760 0362 BB6F     		ldr	r3, [r7, #120]
 10761 0364 3A6F     		ldr	r2, [r7, #112]
 10762 0366 396F     		ldr	r1, [r7, #112]
 10763 0368 F86D     		ldr	r0, [r7, #92]
 10764 036a FFF7FEFF 		bl	zint_rebuild_CRT
2603:keygen.c      **** 	zint_rebuild_CRT(gs, slen, slen, n, primes, 1, gm);
 10765              		.loc 2 2603 2
 10766 036e 7B6D     		ldr	r3, [r7, #84]
 10767 0370 0293     		str	r3, [sp, #8]
 10768 0372 0123     		movs	r3, #1
 10769 0374 0193     		str	r3, [sp, #4]
 10770 0376 BB6E     		ldr	r3, [r7, #104]
 10771 0378 0093     		str	r3, [sp]
 10772 037a BB6F     		ldr	r3, [r7, #120]
 10773 037c 3A6F     		ldr	r2, [r7, #112]
 10774 037e 396F     		ldr	r1, [r7, #112]
 10775 0380 B86D     		ldr	r0, [r7, #88]
 10776 0382 FFF7FEFF 		bl	zint_rebuild_CRT
2604:keygen.c      **** 
2605:keygen.c      **** 	/*
2606:keygen.c      **** 	 * Remaining words: use modular reductions to extract the values.
2607:keygen.c      **** 	 */
2608:keygen.c      **** 	for (u = slen; u < tlen; u ++) {
 10777              		.loc 2 2608 9
 10778 0386 3B6F     		ldr	r3, [r7, #112]
 10779 0388 C7F88C30 		str	r3, [r7, #140]
 10780              		.loc 2 2608 2
 10781 038c 23E1     		b	.L222
 10782              	.L232:
 10783              	.LBB38:
2609:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
2610:keygen.c      **** 		size_t v;
2611:keygen.c      **** 		uint32_t *x;
2612:keygen.c      **** 
2613:keygen.c      **** 		p = primes[u].p;
 10784              		.loc 2 2613 13
 10785 038e D7F88C20 		ldr	r2, [r7, #140]
 10786 0392 1346     		mov	r3, r2
 10787 0394 5B00     		lsls	r3, r3, #1
 10788 0396 1344     		add	r3, r3, r2
 10789 0398 9B00     		lsls	r3, r3, #2
 10790 039a 1A46     		mov	r2, r3
 10791 039c BB6E     		ldr	r3, [r7, #104]
 10792 039e 1344     		add	r3, r3, r2
 10793              		.loc 2 2613 5
 10794 03a0 1B68     		ldr	r3, [r3]
 10795 03a2 BB64     		str	r3, [r7, #72]
2614:keygen.c      **** 		p0i = modp_ninv31(p);
 10796              		.loc 2 2614 9
 10797 03a4 B86C     		ldr	r0, [r7, #72]
 10798 03a6 FFF7FEFF 		bl	modp_ninv31
 10799 03aa 7864     		str	r0, [r7, #68]
2615:keygen.c      **** 		R2 = modp_R2(p, p0i);
 10800              		.loc 2 2615 8
 10801 03ac 796C     		ldr	r1, [r7, #68]
 10802 03ae B86C     		ldr	r0, [r7, #72]
 10803 03b0 FFF7FEFF 		bl	modp_R2
 10804 03b4 3864     		str	r0, [r7, #64]
2616:keygen.c      **** 		Rx = modp_Rx((unsigned)slen, p, p0i, R2);
 10805              		.loc 2 2616 8
 10806 03b6 3B6C     		ldr	r3, [r7, #64]
 10807 03b8 7A6C     		ldr	r2, [r7, #68]
 10808 03ba B96C     		ldr	r1, [r7, #72]
 10809 03bc 386F     		ldr	r0, [r7, #112]
 10810 03be FFF7FEFF 		bl	modp_Rx
 10811 03c2 F863     		str	r0, [r7, #60]
2617:keygen.c      **** 		modp_mkgm2(gm, igm, logn, primes[u].g, p, p0i);
 10812              		.loc 2 2617 35
 10813 03c4 D7F88C20 		ldr	r2, [r7, #140]
 10814 03c8 1346     		mov	r3, r2
 10815 03ca 5B00     		lsls	r3, r3, #1
 10816 03cc 1344     		add	r3, r3, r2
 10817 03ce 9B00     		lsls	r3, r3, #2
 10818 03d0 1A46     		mov	r2, r3
 10819 03d2 BB6E     		ldr	r3, [r7, #104]
 10820 03d4 1344     		add	r3, r3, r2
 10821              		.loc 2 2617 3
 10822 03d6 5A68     		ldr	r2, [r3, #4]
 10823 03d8 7B6C     		ldr	r3, [r7, #68]
 10824 03da 0193     		str	r3, [sp, #4]
 10825 03dc BB6C     		ldr	r3, [r7, #72]
 10826 03de 0093     		str	r3, [sp]
 10827 03e0 1346     		mov	r3, r2
 10828 03e2 BA68     		ldr	r2, [r7, #8]
 10829 03e4 396D     		ldr	r1, [r7, #80]
 10830 03e6 786D     		ldr	r0, [r7, #84]
 10831 03e8 FFF7FEFF 		bl	modp_mkgm2
2618:keygen.c      **** 		for (v = 0, x = fs; v < n; v ++, x += slen) {
 10832              		.loc 2 2618 10
 10833 03ec 0023     		movs	r3, #0
 10834 03ee C7F88030 		str	r3, [r7, #128]
 10835              		.loc 2 2618 17
 10836 03f2 FB6D     		ldr	r3, [r7, #92]
 10837 03f4 FB67     		str	r3, [r7, #124]
 10838              		.loc 2 2618 3
 10839 03f6 1AE0     		b	.L223
 10840              	.L224:
2619:keygen.c      **** 			t1[v] = zint_mod_small_signed(x, slen, p, p0i, R2, Rx);
 10841              		.loc 2 2619 6 discriminator 3
 10842 03f8 D7F88030 		ldr	r3, [r7, #128]
 10843 03fc 9B00     		lsls	r3, r3, #2
 10844 03fe FA6C     		ldr	r2, [r7, #76]
 10845 0400 D418     		adds	r4, r2, r3
 10846              		.loc 2 2619 12 discriminator 3
 10847 0402 FB6B     		ldr	r3, [r7, #60]
 10848 0404 0193     		str	r3, [sp, #4]
 10849 0406 3B6C     		ldr	r3, [r7, #64]
 10850 0408 0093     		str	r3, [sp]
 10851 040a 7B6C     		ldr	r3, [r7, #68]
 10852 040c BA6C     		ldr	r2, [r7, #72]
 10853 040e 396F     		ldr	r1, [r7, #112]
 10854 0410 F86F     		ldr	r0, [r7, #124]
 10855 0412 FFF7FEFF 		bl	zint_mod_small_signed
 10856 0416 0346     		mov	r3, r0
 10857              		.loc 2 2619 10 discriminator 3
 10858 0418 2360     		str	r3, [r4]
2618:keygen.c      **** 		for (v = 0, x = fs; v < n; v ++, x += slen) {
 10859              		.loc 2 2618 32 discriminator 3
 10860 041a D7F88030 		ldr	r3, [r7, #128]
 10861 041e 0133     		adds	r3, r3, #1
 10862 0420 C7F88030 		str	r3, [r7, #128]
2618:keygen.c      **** 		for (v = 0, x = fs; v < n; v ++, x += slen) {
 10863              		.loc 2 2618 38 discriminator 3
 10864 0424 3B6F     		ldr	r3, [r7, #112]
 10865 0426 9B00     		lsls	r3, r3, #2
 10866 0428 FA6F     		ldr	r2, [r7, #124]
 10867 042a 1344     		add	r3, r3, r2
 10868 042c FB67     		str	r3, [r7, #124]
 10869              	.L223:
2618:keygen.c      **** 		for (v = 0, x = fs; v < n; v ++, x += slen) {
 10870              		.loc 2 2618 3 discriminator 1
 10871 042e D7F88020 		ldr	r2, [r7, #128]
 10872 0432 BB6F     		ldr	r3, [r7, #120]
 10873 0434 9A42     		cmp	r2, r3
 10874 0436 DFD3     		bcc	.L224
2620:keygen.c      **** 		}
2621:keygen.c      **** 		modp_NTT2(t1, gm, logn, p, p0i);
 10875              		.loc 2 2621 3
 10876 0438 7B6C     		ldr	r3, [r7, #68]
 10877 043a 0193     		str	r3, [sp, #4]
 10878 043c BB6C     		ldr	r3, [r7, #72]
 10879 043e 0093     		str	r3, [sp]
 10880 0440 BB68     		ldr	r3, [r7, #8]
 10881 0442 7A6D     		ldr	r2, [r7, #84]
 10882 0444 0121     		movs	r1, #1
 10883 0446 F86C     		ldr	r0, [r7, #76]
 10884 0448 FFF7FEFF 		bl	modp_NTT2_ext
2622:keygen.c      **** 		for (v = 0, x = fd + u; v < hn; v ++, x += tlen) {
 10885              		.loc 2 2622 10
 10886 044c 0023     		movs	r3, #0
 10887 044e C7F88030 		str	r3, [r7, #128]
 10888              		.loc 2 2622 22
 10889 0452 D7F88C30 		ldr	r3, [r7, #140]
 10890 0456 9B00     		lsls	r3, r3, #2
 10891              		.loc 2 2622 17
 10892 0458 7A6E     		ldr	r2, [r7, #100]
 10893 045a 1344     		add	r3, r3, r2
 10894 045c FB67     		str	r3, [r7, #124]
 10895              		.loc 2 2622 3
 10896 045e 26E0     		b	.L225
 10897              	.L226:
 10898              	.LBB39:
2623:keygen.c      **** 			uint32_t w0, w1;
2624:keygen.c      **** 
2625:keygen.c      **** 			w0 = t1[(v << 1) + 0];
 10899              		.loc 2 2625 11 discriminator 3
 10900 0460 D7F88030 		ldr	r3, [r7, #128]
 10901 0464 DB00     		lsls	r3, r3, #3
 10902 0466 FA6C     		ldr	r2, [r7, #76]
 10903 0468 1344     		add	r3, r3, r2
 10904              		.loc 2 2625 7 discriminator 3
 10905 046a 1B68     		ldr	r3, [r3]
 10906 046c 3B63     		str	r3, [r7, #48]
2626:keygen.c      **** 			w1 = t1[(v << 1) + 1];
 10907              		.loc 2 2626 11 discriminator 3
 10908 046e D7F88030 		ldr	r3, [r7, #128]
 10909 0472 DB00     		lsls	r3, r3, #3
 10910 0474 0433     		adds	r3, r3, #4
 10911 0476 FA6C     		ldr	r2, [r7, #76]
 10912 0478 1344     		add	r3, r3, r2
 10913              		.loc 2 2626 7 discriminator 3
 10914 047a 1B68     		ldr	r3, [r3]
 10915 047c FB62     		str	r3, [r7, #44]
2627:keygen.c      **** 			*x = modp_montymul(
 10916              		.loc 2 2627 9 discriminator 3
 10917 047e 7B6C     		ldr	r3, [r7, #68]
 10918 0480 BA6C     		ldr	r2, [r7, #72]
 10919 0482 F96A     		ldr	r1, [r7, #44]
 10920 0484 386B     		ldr	r0, [r7, #48]
 10921 0486 FFF7FEFF 		bl	modp_montymul
 10922 048a 7B6C     		ldr	r3, [r7, #68]
 10923 048c BA6C     		ldr	r2, [r7, #72]
 10924 048e 396C     		ldr	r1, [r7, #64]
 10925 0490 FFF7FEFF 		bl	modp_montymul
 10926 0494 0246     		mov	r2, r0
 10927              		.loc 2 2627 7 discriminator 3
 10928 0496 FB6F     		ldr	r3, [r7, #124]
 10929 0498 1A60     		str	r2, [r3]
 10930              	.LBE39:
2622:keygen.c      **** 			uint32_t w0, w1;
 10931              		.loc 2 2622 37 discriminator 3
 10932 049a D7F88030 		ldr	r3, [r7, #128]
 10933 049e 0133     		adds	r3, r3, #1
 10934 04a0 C7F88030 		str	r3, [r7, #128]
2622:keygen.c      **** 			uint32_t w0, w1;
 10935              		.loc 2 2622 43 discriminator 3
 10936 04a4 FB6E     		ldr	r3, [r7, #108]
 10937 04a6 9B00     		lsls	r3, r3, #2
 10938 04a8 FA6F     		ldr	r2, [r7, #124]
 10939 04aa 1344     		add	r3, r3, r2
 10940 04ac FB67     		str	r3, [r7, #124]
 10941              	.L225:
2622:keygen.c      **** 			uint32_t w0, w1;
 10942              		.loc 2 2622 3 discriminator 1
 10943 04ae D7F88020 		ldr	r2, [r7, #128]
 10944 04b2 7B6F     		ldr	r3, [r7, #116]
 10945 04b4 9A42     		cmp	r2, r3
 10946 04b6 D3D3     		bcc	.L226
2628:keygen.c      **** 				modp_montymul(w0, w1, p, p0i), R2, p, p0i);
2629:keygen.c      **** 		}
2630:keygen.c      **** 		for (v = 0, x = gs; v < n; v ++, x += slen) {
 10947              		.loc 2 2630 10
 10948 04b8 0023     		movs	r3, #0
 10949 04ba C7F88030 		str	r3, [r7, #128]
 10950              		.loc 2 2630 17
 10951 04be BB6D     		ldr	r3, [r7, #88]
 10952 04c0 FB67     		str	r3, [r7, #124]
 10953              		.loc 2 2630 3
 10954 04c2 1AE0     		b	.L227
 10955              	.L228:
2631:keygen.c      **** 			t1[v] = zint_mod_small_signed(x, slen, p, p0i, R2, Rx);
 10956              		.loc 2 2631 6 discriminator 3
 10957 04c4 D7F88030 		ldr	r3, [r7, #128]
 10958 04c8 9B00     		lsls	r3, r3, #2
 10959 04ca FA6C     		ldr	r2, [r7, #76]
 10960 04cc D418     		adds	r4, r2, r3
 10961              		.loc 2 2631 12 discriminator 3
 10962 04ce FB6B     		ldr	r3, [r7, #60]
 10963 04d0 0193     		str	r3, [sp, #4]
 10964 04d2 3B6C     		ldr	r3, [r7, #64]
 10965 04d4 0093     		str	r3, [sp]
 10966 04d6 7B6C     		ldr	r3, [r7, #68]
 10967 04d8 BA6C     		ldr	r2, [r7, #72]
 10968 04da 396F     		ldr	r1, [r7, #112]
 10969 04dc F86F     		ldr	r0, [r7, #124]
 10970 04de FFF7FEFF 		bl	zint_mod_small_signed
 10971 04e2 0346     		mov	r3, r0
 10972              		.loc 2 2631 10 discriminator 3
 10973 04e4 2360     		str	r3, [r4]
2630:keygen.c      **** 			t1[v] = zint_mod_small_signed(x, slen, p, p0i, R2, Rx);
 10974              		.loc 2 2630 32 discriminator 3
 10975 04e6 D7F88030 		ldr	r3, [r7, #128]
 10976 04ea 0133     		adds	r3, r3, #1
 10977 04ec C7F88030 		str	r3, [r7, #128]
2630:keygen.c      **** 			t1[v] = zint_mod_small_signed(x, slen, p, p0i, R2, Rx);
 10978              		.loc 2 2630 38 discriminator 3
 10979 04f0 3B6F     		ldr	r3, [r7, #112]
 10980 04f2 9B00     		lsls	r3, r3, #2
 10981 04f4 FA6F     		ldr	r2, [r7, #124]
 10982 04f6 1344     		add	r3, r3, r2
 10983 04f8 FB67     		str	r3, [r7, #124]
 10984              	.L227:
2630:keygen.c      **** 			t1[v] = zint_mod_small_signed(x, slen, p, p0i, R2, Rx);
 10985              		.loc 2 2630 3 discriminator 1
 10986 04fa D7F88020 		ldr	r2, [r7, #128]
 10987 04fe BB6F     		ldr	r3, [r7, #120]
 10988 0500 9A42     		cmp	r2, r3
 10989 0502 DFD3     		bcc	.L228
2632:keygen.c      **** 		}
2633:keygen.c      **** 		modp_NTT2(t1, gm, logn, p, p0i);
 10990              		.loc 2 2633 3
 10991 0504 7B6C     		ldr	r3, [r7, #68]
 10992 0506 0193     		str	r3, [sp, #4]
 10993 0508 BB6C     		ldr	r3, [r7, #72]
 10994 050a 0093     		str	r3, [sp]
 10995 050c BB68     		ldr	r3, [r7, #8]
 10996 050e 7A6D     		ldr	r2, [r7, #84]
 10997 0510 0121     		movs	r1, #1
 10998 0512 F86C     		ldr	r0, [r7, #76]
 10999 0514 FFF7FEFF 		bl	modp_NTT2_ext
2634:keygen.c      **** 		for (v = 0, x = gd + u; v < hn; v ++, x += tlen) {
 11000              		.loc 2 2634 10
 11001 0518 0023     		movs	r3, #0
 11002 051a C7F88030 		str	r3, [r7, #128]
 11003              		.loc 2 2634 22
 11004 051e D7F88C30 		ldr	r3, [r7, #140]
 11005 0522 9B00     		lsls	r3, r3, #2
 11006              		.loc 2 2634 17
 11007 0524 3A6E     		ldr	r2, [r7, #96]
 11008 0526 1344     		add	r3, r3, r2
 11009 0528 FB67     		str	r3, [r7, #124]
 11010              		.loc 2 2634 3
 11011 052a 26E0     		b	.L229
 11012              	.L230:
 11013              	.LBB40:
2635:keygen.c      **** 			uint32_t w0, w1;
2636:keygen.c      **** 
2637:keygen.c      **** 			w0 = t1[(v << 1) + 0];
 11014              		.loc 2 2637 11 discriminator 3
 11015 052c D7F88030 		ldr	r3, [r7, #128]
 11016 0530 DB00     		lsls	r3, r3, #3
 11017 0532 FA6C     		ldr	r2, [r7, #76]
 11018 0534 1344     		add	r3, r3, r2
 11019              		.loc 2 2637 7 discriminator 3
 11020 0536 1B68     		ldr	r3, [r3]
 11021 0538 BB63     		str	r3, [r7, #56]
2638:keygen.c      **** 			w1 = t1[(v << 1) + 1];
 11022              		.loc 2 2638 11 discriminator 3
 11023 053a D7F88030 		ldr	r3, [r7, #128]
 11024 053e DB00     		lsls	r3, r3, #3
 11025 0540 0433     		adds	r3, r3, #4
 11026 0542 FA6C     		ldr	r2, [r7, #76]
 11027 0544 1344     		add	r3, r3, r2
 11028              		.loc 2 2638 7 discriminator 3
 11029 0546 1B68     		ldr	r3, [r3]
 11030 0548 7B63     		str	r3, [r7, #52]
2639:keygen.c      **** 			*x = modp_montymul(
 11031              		.loc 2 2639 9 discriminator 3
 11032 054a 7B6C     		ldr	r3, [r7, #68]
 11033 054c BA6C     		ldr	r2, [r7, #72]
 11034 054e 796B     		ldr	r1, [r7, #52]
 11035 0550 B86B     		ldr	r0, [r7, #56]
 11036 0552 FFF7FEFF 		bl	modp_montymul
 11037 0556 7B6C     		ldr	r3, [r7, #68]
 11038 0558 BA6C     		ldr	r2, [r7, #72]
 11039 055a 396C     		ldr	r1, [r7, #64]
 11040 055c FFF7FEFF 		bl	modp_montymul
 11041 0560 0246     		mov	r2, r0
 11042              		.loc 2 2639 7 discriminator 3
 11043 0562 FB6F     		ldr	r3, [r7, #124]
 11044 0564 1A60     		str	r2, [r3]
 11045              	.LBE40:
2634:keygen.c      **** 			uint32_t w0, w1;
 11046              		.loc 2 2634 37 discriminator 3
 11047 0566 D7F88030 		ldr	r3, [r7, #128]
 11048 056a 0133     		adds	r3, r3, #1
 11049 056c C7F88030 		str	r3, [r7, #128]
2634:keygen.c      **** 			uint32_t w0, w1;
 11050              		.loc 2 2634 43 discriminator 3
 11051 0570 FB6E     		ldr	r3, [r7, #108]
 11052 0572 9B00     		lsls	r3, r3, #2
 11053 0574 FA6F     		ldr	r2, [r7, #124]
 11054 0576 1344     		add	r3, r3, r2
 11055 0578 FB67     		str	r3, [r7, #124]
 11056              	.L229:
2634:keygen.c      **** 			uint32_t w0, w1;
 11057              		.loc 2 2634 3 discriminator 1
 11058 057a D7F88020 		ldr	r2, [r7, #128]
 11059 057e 7B6F     		ldr	r3, [r7, #116]
 11060 0580 9A42     		cmp	r2, r3
 11061 0582 D3D3     		bcc	.L230
2640:keygen.c      **** 				modp_montymul(w0, w1, p, p0i), R2, p, p0i);
2641:keygen.c      **** 		}
2642:keygen.c      **** 
2643:keygen.c      **** 		if (!out_ntt) {
 11062              		.loc 2 2643 6
 11063 0584 D7F8A030 		ldr	r3, [r7, #160]
 11064 0588 002B     		cmp	r3, #0
 11065 058a 1FD1     		bne	.L231
2644:keygen.c      **** 			modp_iNTT2_ext(fd + u, tlen, igm, logn - 1, p, p0i);
 11066              		.loc 2 2644 22
 11067 058c D7F88C30 		ldr	r3, [r7, #140]
 11068 0590 9B00     		lsls	r3, r3, #2
 11069              		.loc 2 2644 4
 11070 0592 7A6E     		ldr	r2, [r7, #100]
 11071 0594 D018     		adds	r0, r2, r3
 11072 0596 BB68     		ldr	r3, [r7, #8]
 11073 0598 5A1E     		subs	r2, r3, #1
 11074 059a 7B6C     		ldr	r3, [r7, #68]
 11075 059c 0193     		str	r3, [sp, #4]
 11076 059e BB6C     		ldr	r3, [r7, #72]
 11077 05a0 0093     		str	r3, [sp]
 11078 05a2 1346     		mov	r3, r2
 11079 05a4 3A6D     		ldr	r2, [r7, #80]
 11080 05a6 F96E     		ldr	r1, [r7, #108]
 11081 05a8 FFF7FEFF 		bl	modp_iNTT2_ext
2645:keygen.c      **** 			modp_iNTT2_ext(gd + u, tlen, igm, logn - 1, p, p0i);
 11082              		.loc 2 2645 22
 11083 05ac D7F88C30 		ldr	r3, [r7, #140]
 11084 05b0 9B00     		lsls	r3, r3, #2
 11085              		.loc 2 2645 4
 11086 05b2 3A6E     		ldr	r2, [r7, #96]
 11087 05b4 D018     		adds	r0, r2, r3
 11088 05b6 BB68     		ldr	r3, [r7, #8]
 11089 05b8 5A1E     		subs	r2, r3, #1
 11090 05ba 7B6C     		ldr	r3, [r7, #68]
 11091 05bc 0193     		str	r3, [sp, #4]
 11092 05be BB6C     		ldr	r3, [r7, #72]
 11093 05c0 0093     		str	r3, [sp]
 11094 05c2 1346     		mov	r3, r2
 11095 05c4 3A6D     		ldr	r2, [r7, #80]
 11096 05c6 F96E     		ldr	r1, [r7, #108]
 11097 05c8 FFF7FEFF 		bl	modp_iNTT2_ext
 11098              	.L231:
 11099              	.LBE38:
2608:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
 11100              		.loc 2 2608 29 discriminator 2
 11101 05cc D7F88C30 		ldr	r3, [r7, #140]
 11102 05d0 0133     		adds	r3, r3, #1
 11103 05d2 C7F88C30 		str	r3, [r7, #140]
 11104              	.L222:
2608:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
 11105              		.loc 2 2608 2 discriminator 1
 11106 05d6 D7F88C20 		ldr	r2, [r7, #140]
 11107 05da FB6E     		ldr	r3, [r7, #108]
 11108 05dc 9A42     		cmp	r2, r3
 11109 05de FFF4D6AE 		bcc	.L232
2646:keygen.c      **** 		}
2647:keygen.c      **** 	}
2648:keygen.c      **** }
 11110              		.loc 2 2648 1
 11111 05e2 00BF     		nop
 11112 05e4 00BF     		nop
 11113 05e6 9437     		adds	r7, r7, #148
 11114              	.LCFI249:
 11115              		.cfi_def_cfa_offset 12
 11116 05e8 BD46     		mov	sp, r7
 11117              	.LCFI250:
 11118              		.cfi_def_cfa_register 13
 11119              		@ sp needed
 11120 05ea 90BD     		pop	{r4, r7, pc}
 11121              		.cfi_endproc
 11122              	.LFE57:
 11124              		.section	.text.make_fg,"ax",%progbits
 11125              		.align	1
 11126              		.syntax unified
 11127              		.thumb
 11128              		.thumb_func
 11129              		.fpu softvfp
 11131              	make_fg:
 11132              	.LFB58:
2649:keygen.c      **** 
2650:keygen.c      **** /*
2651:keygen.c      ****  * Compute f and g at a specific depth, in RNS notation.
2652:keygen.c      ****  *
2653:keygen.c      ****  * Returned values are stored in the data[] array, at slen words per integer.
2654:keygen.c      ****  *
2655:keygen.c      ****  * Conditions:
2656:keygen.c      ****  *   0 <= depth <= logn
2657:keygen.c      ****  *
2658:keygen.c      ****  * Space use in data[]: enough room for any two successive values (f', g',
2659:keygen.c      ****  * f and g).
2660:keygen.c      ****  */
2661:keygen.c      **** static void
2662:keygen.c      **** make_fg(uint32_t *data, const int8_t *f, const int8_t *g,
2663:keygen.c      **** 	unsigned logn, unsigned depth, int out_ntt)
2664:keygen.c      **** {
 11133              		.loc 2 2664 1
 11134              		.cfi_startproc
 11135              		@ args = 8, pretend = 0, frame = 64
 11136              		@ frame_needed = 1, uses_anonymous_args = 0
 11137 0000 90B5     		push	{r4, r7, lr}
 11138              	.LCFI251:
 11139              		.cfi_def_cfa_offset 12
 11140              		.cfi_offset 4, -12
 11141              		.cfi_offset 7, -8
 11142              		.cfi_offset 14, -4
 11143 0002 93B0     		sub	sp, sp, #76
 11144              	.LCFI252:
 11145              		.cfi_def_cfa_offset 88
 11146 0004 02AF     		add	r7, sp, #8
 11147              	.LCFI253:
 11148              		.cfi_def_cfa 7, 80
 11149 0006 F860     		str	r0, [r7, #12]
 11150 0008 B960     		str	r1, [r7, #8]
 11151 000a 7A60     		str	r2, [r7, #4]
 11152 000c 3B60     		str	r3, [r7]
2665:keygen.c      **** 	size_t n, u;
2666:keygen.c      **** 	uint32_t *ft, *gt, p0;
2667:keygen.c      **** 	unsigned d;
2668:keygen.c      **** 	const small_prime *primes;
2669:keygen.c      **** 
2670:keygen.c      **** 	n = MKN(logn);
 11153              		.loc 2 2670 4
 11154 000e 0122     		movs	r2, #1
 11155 0010 3B68     		ldr	r3, [r7]
 11156 0012 02FA03F3 		lsl	r3, r2, r3
 11157 0016 7B63     		str	r3, [r7, #52]
2671:keygen.c      **** 	ft = data;
 11158              		.loc 2 2671 5
 11159 0018 FB68     		ldr	r3, [r7, #12]
 11160 001a 3B63     		str	r3, [r7, #48]
2672:keygen.c      **** 	gt = ft + n;
 11161              		.loc 2 2672 10
 11162 001c 7B6B     		ldr	r3, [r7, #52]
 11163 001e 9B00     		lsls	r3, r3, #2
 11164              		.loc 2 2672 5
 11165 0020 3A6B     		ldr	r2, [r7, #48]
 11166 0022 1344     		add	r3, r3, r2
 11167 0024 FB62     		str	r3, [r7, #44]
2673:keygen.c      **** 	primes = PRIMES;
 11168              		.loc 2 2673 9
 11169 0026 474B     		ldr	r3, .L245
 11170 0028 BB62     		str	r3, [r7, #40]
2674:keygen.c      **** 	p0 = primes[0].p;
 11171              		.loc 2 2674 5
 11172 002a BB6A     		ldr	r3, [r7, #40]
 11173 002c 1B68     		ldr	r3, [r3]
 11174 002e 7B62     		str	r3, [r7, #36]
2675:keygen.c      **** 	for (u = 0; u < n; u ++) {
 11175              		.loc 2 2675 9
 11176 0030 0023     		movs	r3, #0
 11177 0032 FB63     		str	r3, [r7, #60]
 11178              		.loc 2 2675 2
 11179 0034 20E0     		b	.L236
 11180              	.L237:
2676:keygen.c      **** 		ft[u] = modp_set(f[u], p0);
 11181              		.loc 2 2676 21 discriminator 3
 11182 0036 BA68     		ldr	r2, [r7, #8]
 11183 0038 FB6B     		ldr	r3, [r7, #60]
 11184 003a 1344     		add	r3, r3, r2
 11185 003c 93F90030 		ldrsb	r3, [r3]
 11186              		.loc 2 2676 11 discriminator 3
 11187 0040 1846     		mov	r0, r3
 11188              		.loc 2 2676 5 discriminator 3
 11189 0042 FB6B     		ldr	r3, [r7, #60]
 11190 0044 9B00     		lsls	r3, r3, #2
 11191 0046 3A6B     		ldr	r2, [r7, #48]
 11192 0048 D418     		adds	r4, r2, r3
 11193              		.loc 2 2676 11 discriminator 3
 11194 004a 796A     		ldr	r1, [r7, #36]
 11195 004c FFF7FEFF 		bl	modp_set
 11196 0050 0346     		mov	r3, r0
 11197              		.loc 2 2676 9 discriminator 3
 11198 0052 2360     		str	r3, [r4]
2677:keygen.c      **** 		gt[u] = modp_set(g[u], p0);
 11199              		.loc 2 2677 21 discriminator 3
 11200 0054 7A68     		ldr	r2, [r7, #4]
 11201 0056 FB6B     		ldr	r3, [r7, #60]
 11202 0058 1344     		add	r3, r3, r2
 11203 005a 93F90030 		ldrsb	r3, [r3]
 11204              		.loc 2 2677 11 discriminator 3
 11205 005e 1846     		mov	r0, r3
 11206              		.loc 2 2677 5 discriminator 3
 11207 0060 FB6B     		ldr	r3, [r7, #60]
 11208 0062 9B00     		lsls	r3, r3, #2
 11209 0064 FA6A     		ldr	r2, [r7, #44]
 11210 0066 D418     		adds	r4, r2, r3
 11211              		.loc 2 2677 11 discriminator 3
 11212 0068 796A     		ldr	r1, [r7, #36]
 11213 006a FFF7FEFF 		bl	modp_set
 11214 006e 0346     		mov	r3, r0
 11215              		.loc 2 2677 9 discriminator 3
 11216 0070 2360     		str	r3, [r4]
2675:keygen.c      **** 	for (u = 0; u < n; u ++) {
 11217              		.loc 2 2675 23 discriminator 3
 11218 0072 FB6B     		ldr	r3, [r7, #60]
 11219 0074 0133     		adds	r3, r3, #1
 11220 0076 FB63     		str	r3, [r7, #60]
 11221              	.L236:
2675:keygen.c      **** 	for (u = 0; u < n; u ++) {
 11222              		.loc 2 2675 2 discriminator 1
 11223 0078 FA6B     		ldr	r2, [r7, #60]
 11224 007a 7B6B     		ldr	r3, [r7, #52]
 11225 007c 9A42     		cmp	r2, r3
 11226 007e DAD3     		bcc	.L237
2678:keygen.c      **** 	}
2679:keygen.c      **** 
2680:keygen.c      **** 	if (depth == 0 && out_ntt) {
 11227              		.loc 2 2680 5
 11228 0080 3B6D     		ldr	r3, [r7, #80]
 11229 0082 002B     		cmp	r3, #0
 11230 0084 36D1     		bne	.L238
 11231              		.loc 2 2680 17 discriminator 1
 11232 0086 7B6D     		ldr	r3, [r7, #84]
 11233 0088 002B     		cmp	r3, #0
 11234 008a 33D0     		beq	.L238
 11235              	.LBB41:
2681:keygen.c      **** 		uint32_t *gm, *igm;
2682:keygen.c      **** 		uint32_t p, p0i;
2683:keygen.c      **** 
2684:keygen.c      **** 		p = primes[0].p;
 11236              		.loc 2 2684 5
 11237 008c BB6A     		ldr	r3, [r7, #40]
 11238 008e 1B68     		ldr	r3, [r3]
 11239 0090 3B62     		str	r3, [r7, #32]
2685:keygen.c      **** 		p0i = modp_ninv31(p);
 11240              		.loc 2 2685 9
 11241 0092 386A     		ldr	r0, [r7, #32]
 11242 0094 FFF7FEFF 		bl	modp_ninv31
 11243 0098 F861     		str	r0, [r7, #28]
2686:keygen.c      **** 		gm = gt + n;
 11244              		.loc 2 2686 11
 11245 009a 7B6B     		ldr	r3, [r7, #52]
 11246 009c 9B00     		lsls	r3, r3, #2
 11247              		.loc 2 2686 6
 11248 009e FA6A     		ldr	r2, [r7, #44]
 11249 00a0 1344     		add	r3, r3, r2
 11250 00a2 BB61     		str	r3, [r7, #24]
2687:keygen.c      **** 		igm = gm + MKN(logn);
 11251              		.loc 2 2687 12
 11252 00a4 0422     		movs	r2, #4
 11253 00a6 3B68     		ldr	r3, [r7]
 11254 00a8 02FA03F3 		lsl	r3, r2, r3
 11255              		.loc 2 2687 7
 11256 00ac BA69     		ldr	r2, [r7, #24]
 11257 00ae 1344     		add	r3, r3, r2
 11258 00b0 7B61     		str	r3, [r7, #20]
2688:keygen.c      **** 		modp_mkgm2(gm, igm, logn, primes[0].g, p, p0i);
 11259              		.loc 2 2688 3
 11260 00b2 BB6A     		ldr	r3, [r7, #40]
 11261 00b4 5A68     		ldr	r2, [r3, #4]
 11262 00b6 FB69     		ldr	r3, [r7, #28]
 11263 00b8 0193     		str	r3, [sp, #4]
 11264 00ba 3B6A     		ldr	r3, [r7, #32]
 11265 00bc 0093     		str	r3, [sp]
 11266 00be 1346     		mov	r3, r2
 11267 00c0 3A68     		ldr	r2, [r7]
 11268 00c2 7969     		ldr	r1, [r7, #20]
 11269 00c4 B869     		ldr	r0, [r7, #24]
 11270 00c6 FFF7FEFF 		bl	modp_mkgm2
2689:keygen.c      **** 		modp_NTT2(ft, gm, logn, p, p0i);
 11271              		.loc 2 2689 3
 11272 00ca FB69     		ldr	r3, [r7, #28]
 11273 00cc 0193     		str	r3, [sp, #4]
 11274 00ce 3B6A     		ldr	r3, [r7, #32]
 11275 00d0 0093     		str	r3, [sp]
 11276 00d2 3B68     		ldr	r3, [r7]
 11277 00d4 BA69     		ldr	r2, [r7, #24]
 11278 00d6 0121     		movs	r1, #1
 11279 00d8 386B     		ldr	r0, [r7, #48]
 11280 00da FFF7FEFF 		bl	modp_NTT2_ext
2690:keygen.c      **** 		modp_NTT2(gt, gm, logn, p, p0i);
 11281              		.loc 2 2690 3
 11282 00de FB69     		ldr	r3, [r7, #28]
 11283 00e0 0193     		str	r3, [sp, #4]
 11284 00e2 3B6A     		ldr	r3, [r7, #32]
 11285 00e4 0093     		str	r3, [sp]
 11286 00e6 3B68     		ldr	r3, [r7]
 11287 00e8 BA69     		ldr	r2, [r7, #24]
 11288 00ea 0121     		movs	r1, #1
 11289 00ec F86A     		ldr	r0, [r7, #44]
 11290 00ee FFF7FEFF 		bl	modp_NTT2_ext
2691:keygen.c      **** 		return;
 11291              		.loc 2 2691 3
 11292 00f2 24E0     		b	.L235
 11293              	.L238:
 11294              	.LBE41:
2692:keygen.c      **** 	}
2693:keygen.c      **** 
2694:keygen.c      **** 	for (d = 0; d < depth; d ++) {
 11295              		.loc 2 2694 9
 11296 00f4 0023     		movs	r3, #0
 11297 00f6 BB63     		str	r3, [r7, #56]
 11298              		.loc 2 2694 2
 11299 00f8 1DE0     		b	.L240
 11300              	.L244:
2695:keygen.c      **** 		make_fg_step(data, logn - d, d,
 11301              		.loc 2 2695 3
 11302 00fa 3A68     		ldr	r2, [r7]
 11303 00fc BB6B     		ldr	r3, [r7, #56]
 11304 00fe D11A     		subs	r1, r2, r3
 11305 0100 BB6B     		ldr	r3, [r7, #56]
 11306 0102 002B     		cmp	r3, #0
 11307 0104 14BF     		ite	ne
 11308 0106 0123     		movne	r3, #1
 11309 0108 0023     		moveq	r3, #0
 11310 010a DBB2     		uxtb	r3, r3
 11311 010c 1846     		mov	r0, r3
2696:keygen.c      **** 			d != 0, (d + 1) < depth || out_ntt);
 11312              		.loc 2 2696 15
 11313 010e BB6B     		ldr	r3, [r7, #56]
 11314 0110 0133     		adds	r3, r3, #1
2695:keygen.c      **** 		make_fg_step(data, logn - d, d,
 11315              		.loc 2 2695 3
 11316 0112 3A6D     		ldr	r2, [r7, #80]
 11317 0114 9A42     		cmp	r2, r3
 11318 0116 02D8     		bhi	.L241
2695:keygen.c      **** 		make_fg_step(data, logn - d, d,
 11319              		.loc 2 2695 3 is_stmt 0 discriminator 2
 11320 0118 7B6D     		ldr	r3, [r7, #84]
 11321 011a 002B     		cmp	r3, #0
 11322 011c 01D0     		beq	.L242
 11323              	.L241:
2695:keygen.c      **** 		make_fg_step(data, logn - d, d,
 11324              		.loc 2 2695 3 discriminator 3
 11325 011e 0123     		movs	r3, #1
 11326 0120 00E0     		b	.L243
 11327              	.L242:
2695:keygen.c      **** 		make_fg_step(data, logn - d, d,
 11328              		.loc 2 2695 3 discriminator 4
 11329 0122 0023     		movs	r3, #0
 11330              	.L243:
2695:keygen.c      **** 		make_fg_step(data, logn - d, d,
 11331              		.loc 2 2695 3 discriminator 6
 11332 0124 0093     		str	r3, [sp]
 11333 0126 0346     		mov	r3, r0
 11334 0128 BA6B     		ldr	r2, [r7, #56]
 11335 012a F868     		ldr	r0, [r7, #12]
 11336 012c FFF7FEFF 		bl	make_fg_step
2694:keygen.c      **** 		make_fg_step(data, logn - d, d,
 11337              		.loc 2 2694 27 is_stmt 1 discriminator 6
 11338 0130 BB6B     		ldr	r3, [r7, #56]
 11339 0132 0133     		adds	r3, r3, #1
 11340 0134 BB63     		str	r3, [r7, #56]
 11341              	.L240:
2694:keygen.c      **** 		make_fg_step(data, logn - d, d,
 11342              		.loc 2 2694 2 discriminator 2
 11343 0136 BA6B     		ldr	r2, [r7, #56]
 11344 0138 3B6D     		ldr	r3, [r7, #80]
 11345 013a 9A42     		cmp	r2, r3
 11346 013c DDD3     		bcc	.L244
 11347              	.L235:
2697:keygen.c      **** 	}
2698:keygen.c      **** }
 11348              		.loc 2 2698 1
 11349 013e 4437     		adds	r7, r7, #68
 11350              	.LCFI254:
 11351              		.cfi_def_cfa_offset 12
 11352 0140 BD46     		mov	sp, r7
 11353              	.LCFI255:
 11354              		.cfi_def_cfa_register 13
 11355              		@ sp needed
 11356 0142 90BD     		pop	{r4, r7, pc}
 11357              	.L246:
 11358              		.align	2
 11359              	.L245:
 11360 0144 40010000 		.word	PRIMES
 11361              		.cfi_endproc
 11362              	.LFE58:
 11364              		.section	.text.solve_NTRU_deepest,"ax",%progbits
 11365              		.align	1
 11366              		.syntax unified
 11367              		.thumb
 11368              		.thumb_func
 11369              		.fpu softvfp
 11371              	solve_NTRU_deepest:
 11372              	.LFB59:
2699:keygen.c      **** 
2700:keygen.c      **** /*
2701:keygen.c      ****  * Solving the NTRU equation, deepest level: compute the resultants of
2702:keygen.c      ****  * f and g with X^N+1, and use binary GCD. The F and G values are
2703:keygen.c      ****  * returned in tmp[].
2704:keygen.c      ****  *
2705:keygen.c      ****  * Returned value: 1 on success, 0 on error.
2706:keygen.c      ****  */
2707:keygen.c      **** static int
2708:keygen.c      **** solve_NTRU_deepest(unsigned logn_top,
2709:keygen.c      **** 	const int8_t *f, const int8_t *g, uint32_t *tmp)
2710:keygen.c      **** {
 11373              		.loc 2 2710 1
 11374              		.cfi_startproc
 11375              		@ args = 0, pretend = 0, frame = 48
 11376              		@ frame_needed = 1, uses_anonymous_args = 0
 11377 0000 80B5     		push	{r7, lr}
 11378              	.LCFI256:
 11379              		.cfi_def_cfa_offset 8
 11380              		.cfi_offset 7, -8
 11381              		.cfi_offset 14, -4
 11382 0002 90B0     		sub	sp, sp, #64
 11383              	.LCFI257:
 11384              		.cfi_def_cfa_offset 72
 11385 0004 04AF     		add	r7, sp, #16
 11386              	.LCFI258:
 11387              		.cfi_def_cfa 7, 56
 11388 0006 F860     		str	r0, [r7, #12]
 11389 0008 B960     		str	r1, [r7, #8]
 11390 000a 7A60     		str	r2, [r7, #4]
 11391 000c 3B60     		str	r3, [r7]
2711:keygen.c      **** 	size_t len;
2712:keygen.c      **** 	uint32_t *Fp, *Gp, *fp, *gp, *t1, q;
2713:keygen.c      **** 	const small_prime *primes;
2714:keygen.c      **** 
2715:keygen.c      **** 	len = MAX_BL_SMALL[logn_top];
 11392              		.loc 2 2715 6
 11393 000e 2E4A     		ldr	r2, .L252
 11394 0010 FB68     		ldr	r3, [r7, #12]
 11395 0012 52F82330 		ldr	r3, [r2, r3, lsl #2]
 11396 0016 FB62     		str	r3, [r7, #44]
2716:keygen.c      **** 	primes = PRIMES;
 11397              		.loc 2 2716 9
 11398 0018 2C4B     		ldr	r3, .L252+4
 11399 001a BB62     		str	r3, [r7, #40]
2717:keygen.c      **** 
2718:keygen.c      **** 	Fp = tmp;
 11400              		.loc 2 2718 5
 11401 001c 3B68     		ldr	r3, [r7]
 11402 001e 7B62     		str	r3, [r7, #36]
2719:keygen.c      **** 	Gp = Fp + len;
 11403              		.loc 2 2719 10
 11404 0020 FB6A     		ldr	r3, [r7, #44]
 11405 0022 9B00     		lsls	r3, r3, #2
 11406              		.loc 2 2719 5
 11407 0024 7A6A     		ldr	r2, [r7, #36]
 11408 0026 1344     		add	r3, r3, r2
 11409 0028 3B62     		str	r3, [r7, #32]
2720:keygen.c      **** 	fp = Gp + len;
 11410              		.loc 2 2720 10
 11411 002a FB6A     		ldr	r3, [r7, #44]
 11412 002c 9B00     		lsls	r3, r3, #2
 11413              		.loc 2 2720 5
 11414 002e 3A6A     		ldr	r2, [r7, #32]
 11415 0030 1344     		add	r3, r3, r2
 11416 0032 FB61     		str	r3, [r7, #28]
2721:keygen.c      **** 	gp = fp + len;
 11417              		.loc 2 2721 10
 11418 0034 FB6A     		ldr	r3, [r7, #44]
 11419 0036 9B00     		lsls	r3, r3, #2
 11420              		.loc 2 2721 5
 11421 0038 FA69     		ldr	r2, [r7, #28]
 11422 003a 1344     		add	r3, r3, r2
 11423 003c BB61     		str	r3, [r7, #24]
2722:keygen.c      **** 	t1 = gp + len;
 11424              		.loc 2 2722 10
 11425 003e FB6A     		ldr	r3, [r7, #44]
 11426 0040 9B00     		lsls	r3, r3, #2
 11427              		.loc 2 2722 5
 11428 0042 BA69     		ldr	r2, [r7, #24]
 11429 0044 1344     		add	r3, r3, r2
 11430 0046 7B61     		str	r3, [r7, #20]
2723:keygen.c      **** 
2724:keygen.c      **** 	make_fg(fp, f, g, logn_top, logn_top, 0);
 11431              		.loc 2 2724 2
 11432 0048 0023     		movs	r3, #0
 11433 004a 0193     		str	r3, [sp, #4]
 11434 004c FB68     		ldr	r3, [r7, #12]
 11435 004e 0093     		str	r3, [sp]
 11436 0050 FB68     		ldr	r3, [r7, #12]
 11437 0052 7A68     		ldr	r2, [r7, #4]
 11438 0054 B968     		ldr	r1, [r7, #8]
 11439 0056 F869     		ldr	r0, [r7, #28]
 11440 0058 FFF7FEFF 		bl	make_fg
2725:keygen.c      **** 
2726:keygen.c      **** 	/*
2727:keygen.c      **** 	 * We use the CRT to rebuild the resultants as big integers.
2728:keygen.c      **** 	 * There are two such big integers. The resultants are always
2729:keygen.c      **** 	 * nonnegative.
2730:keygen.c      **** 	 */
2731:keygen.c      **** 	zint_rebuild_CRT(fp, len, len, 2, primes, 0, t1);
 11441              		.loc 2 2731 2
 11442 005c 7B69     		ldr	r3, [r7, #20]
 11443 005e 0293     		str	r3, [sp, #8]
 11444 0060 0023     		movs	r3, #0
 11445 0062 0193     		str	r3, [sp, #4]
 11446 0064 BB6A     		ldr	r3, [r7, #40]
 11447 0066 0093     		str	r3, [sp]
 11448 0068 0223     		movs	r3, #2
 11449 006a FA6A     		ldr	r2, [r7, #44]
 11450 006c F96A     		ldr	r1, [r7, #44]
 11451 006e F869     		ldr	r0, [r7, #28]
 11452 0070 FFF7FEFF 		bl	zint_rebuild_CRT
2732:keygen.c      **** 
2733:keygen.c      **** 	/*
2734:keygen.c      **** 	 * Apply the binary GCD. The zint_bezout() function works only
2735:keygen.c      **** 	 * if both inputs are odd.
2736:keygen.c      **** 	 *
2737:keygen.c      **** 	 * We can test on the result and return 0 because that would
2738:keygen.c      **** 	 * imply failure of the NTRU solving equation, and the (f,g)
2739:keygen.c      **** 	 * values will be abandoned in that case.
2740:keygen.c      **** 	 */
2741:keygen.c      **** 	if (!zint_bezout(Gp, Fp, fp, gp, len, t1)) {
 11453              		.loc 2 2741 7
 11454 0074 7B69     		ldr	r3, [r7, #20]
 11455 0076 0193     		str	r3, [sp, #4]
 11456 0078 FB6A     		ldr	r3, [r7, #44]
 11457 007a 0093     		str	r3, [sp]
 11458 007c BB69     		ldr	r3, [r7, #24]
 11459 007e FA69     		ldr	r2, [r7, #28]
 11460 0080 796A     		ldr	r1, [r7, #36]
 11461 0082 386A     		ldr	r0, [r7, #32]
 11462 0084 FFF7FEFF 		bl	zint_bezout
 11463 0088 0346     		mov	r3, r0
 11464              		.loc 2 2741 5
 11465 008a 002B     		cmp	r3, #0
 11466 008c 01D1     		bne	.L248
2742:keygen.c      **** 		return 0;
 11467              		.loc 2 2742 10
 11468 008e 0023     		movs	r3, #0
 11469 0090 15E0     		b	.L249
 11470              	.L248:
2743:keygen.c      **** 	}
2744:keygen.c      **** 
2745:keygen.c      **** 	/*
2746:keygen.c      **** 	 * Multiply the two values by the target value q. Values must
2747:keygen.c      **** 	 * fit in the destination arrays.
2748:keygen.c      **** 	 * We can again test on the returned words: a non-zero output
2749:keygen.c      **** 	 * of zint_mul_small() means that we exceeded our array
2750:keygen.c      **** 	 * capacity, and that implies failure and rejection of (f,g).
2751:keygen.c      **** 	 */
2752:keygen.c      **** 	q = 12289;
 11471              		.loc 2 2752 4
 11472 0092 43F20103 		movw	r3, #12289
 11473 0096 3B61     		str	r3, [r7, #16]
2753:keygen.c      **** 	if (zint_mul_small(Fp, len, q) != 0
 11474              		.loc 2 2753 6
 11475 0098 3A69     		ldr	r2, [r7, #16]
 11476 009a F96A     		ldr	r1, [r7, #44]
 11477 009c 786A     		ldr	r0, [r7, #36]
 11478 009e FFF7FEFF 		bl	zint_mul_small
 11479 00a2 0346     		mov	r3, r0
 11480              		.loc 2 2753 5
 11481 00a4 002B     		cmp	r3, #0
 11482 00a6 07D1     		bne	.L250
2754:keygen.c      **** 		|| zint_mul_small(Gp, len, q) != 0)
 11483              		.loc 2 2754 6
 11484 00a8 3A69     		ldr	r2, [r7, #16]
 11485 00aa F96A     		ldr	r1, [r7, #44]
 11486 00ac 386A     		ldr	r0, [r7, #32]
 11487 00ae FFF7FEFF 		bl	zint_mul_small
 11488 00b2 0346     		mov	r3, r0
 11489              		.loc 2 2754 3
 11490 00b4 002B     		cmp	r3, #0
 11491 00b6 01D0     		beq	.L251
 11492              	.L250:
2755:keygen.c      **** 	{
2756:keygen.c      **** 		return 0;
 11493              		.loc 2 2756 10
 11494 00b8 0023     		movs	r3, #0
 11495 00ba 00E0     		b	.L249
 11496              	.L251:
2757:keygen.c      **** 	}
2758:keygen.c      **** 
2759:keygen.c      **** 	return 1;
 11497              		.loc 2 2759 9
 11498 00bc 0123     		movs	r3, #1
 11499              	.L249:
2760:keygen.c      **** }
 11500              		.loc 2 2760 1
 11501 00be 1846     		mov	r0, r3
 11502 00c0 3037     		adds	r7, r7, #48
 11503              	.LCFI259:
 11504              		.cfi_def_cfa_offset 8
 11505 00c2 BD46     		mov	sp, r7
 11506              	.LCFI260:
 11507              		.cfi_def_cfa_register 13
 11508              		@ sp needed
 11509 00c4 80BD     		pop	{r7, pc}
 11510              	.L253:
 11511 00c6 00BF     		.align	2
 11512              	.L252:
 11513 00c8 90220000 		.word	MAX_BL_SMALL
 11514 00cc 40010000 		.word	PRIMES
 11515              		.cfi_endproc
 11516              	.LFE59:
 11518              		.section	.text.solve_NTRU_intermediate,"ax",%progbits
 11519              		.align	1
 11520              		.syntax unified
 11521              		.thumb
 11522              		.thumb_func
 11523              		.fpu softvfp
 11525              	solve_NTRU_intermediate:
 11526              	.LFB60:
2761:keygen.c      **** 
2762:keygen.c      **** /*
2763:keygen.c      ****  * Solving the NTRU equation, intermediate level. Upon entry, the F and G
2764:keygen.c      ****  * from the previous level should be in the tmp[] array.
2765:keygen.c      ****  * This function MAY be invoked for the top-level (in which case depth = 0).
2766:keygen.c      ****  *
2767:keygen.c      ****  * Returned value: 1 on success, 0 on error.
2768:keygen.c      ****  */
2769:keygen.c      **** static int
2770:keygen.c      **** solve_NTRU_intermediate(unsigned logn_top,
2771:keygen.c      **** 	const int8_t *f, const int8_t *g, unsigned depth, uint32_t *tmp)
2772:keygen.c      **** {
 11527              		.loc 2 2772 1
 11528              		.cfi_startproc
 11529              		@ args = 4, pretend = 0, frame = 296
 11530              		@ frame_needed = 1, uses_anonymous_args = 0
 11531 0000 90B5     		push	{r4, r7, lr}
 11532              	.LCFI261:
 11533              		.cfi_def_cfa_offset 12
 11534              		.cfi_offset 4, -12
 11535              		.cfi_offset 7, -8
 11536              		.cfi_offset 14, -4
 11537 0002 D3B0     		sub	sp, sp, #332
 11538              	.LCFI262:
 11539              		.cfi_def_cfa_offset 344
 11540 0004 08AF     		add	r7, sp, #32
 11541              	.LCFI263:
 11542              		.cfi_def_cfa 7, 312
 11543 0006 07F59474 		add	r4, r7, #296
 11544 000a A4F58E74 		sub	r4, r4, #284
 11545 000e 2060     		str	r0, [r4]
 11546 0010 07F59470 		add	r0, r7, #296
 11547 0014 A0F59070 		sub	r0, r0, #288
 11548 0018 0160     		str	r1, [r0]
 11549 001a 07F59471 		add	r1, r7, #296
 11550 001e A1F59271 		sub	r1, r1, #292
 11551 0022 0A60     		str	r2, [r1]
 11552 0024 07F59472 		add	r2, r7, #296
 11553 0028 A2F59472 		sub	r2, r2, #296
 11554 002c 1360     		str	r3, [r2]
2773:keygen.c      **** 	/*
2774:keygen.c      **** 	 * In this function, 'logn' is the log2 of the degree for
2775:keygen.c      **** 	 * this step. If N = 2^logn, then:
2776:keygen.c      **** 	 *  - the F and G values already in fk->tmp (from the deeper
2777:keygen.c      **** 	 *    levels) have degree N/2;
2778:keygen.c      **** 	 *  - this function should return F and G of degree N.
2779:keygen.c      **** 	 */
2780:keygen.c      **** 	unsigned logn;
2781:keygen.c      **** 	size_t n, hn, slen, dlen, llen, rlen, FGlen, u;
2782:keygen.c      **** 	uint32_t *Fd, *Gd, *Ft, *Gt, *ft, *gt, *t1;
2783:keygen.c      **** 	fpr *rt1, *rt2, *rt3, *rt4, *rt5;
2784:keygen.c      **** 	int scale_fg, minbl_fg, maxbl_fg, maxbl_FG, scale_k;
2785:keygen.c      **** 	uint32_t *x, *y;
2786:keygen.c      **** 	int32_t *k;
2787:keygen.c      **** 	const small_prime *primes;
2788:keygen.c      **** 
2789:keygen.c      **** 	logn = logn_top - depth;
 11555              		.loc 2 2789 7
 11556 002e 07F59473 		add	r3, r7, #296
 11557 0032 A3F58E72 		sub	r2, r3, #284
 11558 0036 07F59473 		add	r3, r7, #296
 11559 003a A3F59473 		sub	r3, r3, #296
 11560 003e 1268     		ldr	r2, [r2]
 11561 0040 1B68     		ldr	r3, [r3]
 11562 0042 D31A     		subs	r3, r2, r3
 11563 0044 C7F8D030 		str	r3, [r7, #208]
2790:keygen.c      **** 	n = (size_t)1 << logn;
 11564              		.loc 2 2790 4
 11565 0048 0122     		movs	r2, #1
 11566 004a D7F8D030 		ldr	r3, [r7, #208]
 11567 004e 02FA03F3 		lsl	r3, r2, r3
 11568 0052 C7F8CC30 		str	r3, [r7, #204]
2791:keygen.c      **** 	hn = n >> 1;
 11569              		.loc 2 2791 5
 11570 0056 D7F8CC30 		ldr	r3, [r7, #204]
 11571 005a 5B08     		lsrs	r3, r3, #1
 11572 005c C7F8C830 		str	r3, [r7, #200]
2792:keygen.c      **** 
2793:keygen.c      **** 	/*
2794:keygen.c      **** 	 * slen = size for our input f and g; also size of the reduced
2795:keygen.c      **** 	 *        F and G we return (degree N)
2796:keygen.c      **** 	 *
2797:keygen.c      **** 	 * dlen = size of the F and G obtained from the deeper level
2798:keygen.c      **** 	 *        (degree N/2 or N/3)
2799:keygen.c      **** 	 *
2800:keygen.c      **** 	 * llen = size for intermediary F and G before reduction (degree N)
2801:keygen.c      **** 	 *
2802:keygen.c      **** 	 * We build our non-reduced F and G as two independent halves each,
2803:keygen.c      **** 	 * of degree N/2 (F = F0 + X*F1, G = G0 + X*G1).
2804:keygen.c      **** 	 */
2805:keygen.c      **** 	slen = MAX_BL_SMALL[depth];
 11573              		.loc 2 2805 7
 11574 0060 CE4A     		ldr	r2, .L301
 11575 0062 07F59473 		add	r3, r7, #296
 11576 0066 A3F59473 		sub	r3, r3, #296
 11577 006a 1B68     		ldr	r3, [r3]
 11578 006c 52F82330 		ldr	r3, [r2, r3, lsl #2]
 11579 0070 C7F8C430 		str	r3, [r7, #196]
2806:keygen.c      **** 	dlen = MAX_BL_SMALL[depth + 1];
 11580              		.loc 2 2806 28
 11581 0074 07F59473 		add	r3, r7, #296
 11582 0078 A3F59473 		sub	r3, r3, #296
 11583 007c 1B68     		ldr	r3, [r3]
 11584 007e 0133     		adds	r3, r3, #1
 11585              		.loc 2 2806 7
 11586 0080 C64A     		ldr	r2, .L301
 11587 0082 52F82330 		ldr	r3, [r2, r3, lsl #2]
 11588 0086 C7F8C030 		str	r3, [r7, #192]
2807:keygen.c      **** 	llen = MAX_BL_LARGE[depth];
 11589              		.loc 2 2807 7
 11590 008a C54A     		ldr	r2, .L301+4
 11591 008c 07F59473 		add	r3, r7, #296
 11592 0090 A3F59473 		sub	r3, r3, #296
 11593 0094 1B68     		ldr	r3, [r3]
 11594 0096 52F82330 		ldr	r3, [r2, r3, lsl #2]
 11595 009a C7F8BC30 		str	r3, [r7, #188]
2808:keygen.c      **** 	primes = PRIMES;
 11596              		.loc 2 2808 9
 11597 009e C14B     		ldr	r3, .L301+8
 11598 00a0 C7F8B830 		str	r3, [r7, #184]
2809:keygen.c      **** 
2810:keygen.c      **** 	/*
2811:keygen.c      **** 	 * Fd and Gd are the F and G from the deeper level.
2812:keygen.c      **** 	 */
2813:keygen.c      **** 	Fd = tmp;
 11599              		.loc 2 2813 5
 11600 00a4 D7F83831 		ldr	r3, [r7, #312]
 11601 00a8 C7F8B430 		str	r3, [r7, #180]
2814:keygen.c      **** 	Gd = Fd + dlen * hn;
 11602              		.loc 2 2814 17
 11603 00ac D7F8C030 		ldr	r3, [r7, #192]
 11604 00b0 D7F8C820 		ldr	r2, [r7, #200]
 11605 00b4 02FB03F3 		mul	r3, r2, r3
 11606              		.loc 2 2814 10
 11607 00b8 9B00     		lsls	r3, r3, #2
 11608              		.loc 2 2814 5
 11609 00ba D7F8B420 		ldr	r2, [r7, #180]
 11610 00be 1344     		add	r3, r3, r2
 11611 00c0 C7F8B030 		str	r3, [r7, #176]
2815:keygen.c      **** 
2816:keygen.c      **** 	/*
2817:keygen.c      **** 	 * Compute the input f and g for this level. Note that we get f
2818:keygen.c      **** 	 * and g in RNS + NTT representation.
2819:keygen.c      **** 	 */
2820:keygen.c      **** 	ft = Gd + dlen * hn;
 11612              		.loc 2 2820 17
 11613 00c4 D7F8C030 		ldr	r3, [r7, #192]
 11614 00c8 D7F8C820 		ldr	r2, [r7, #200]
 11615 00cc 02FB03F3 		mul	r3, r2, r3
 11616              		.loc 2 2820 10
 11617 00d0 9B00     		lsls	r3, r3, #2
 11618              		.loc 2 2820 5
 11619 00d2 D7F8B020 		ldr	r2, [r7, #176]
 11620 00d6 1344     		add	r3, r3, r2
 11621 00d8 C7F8AC30 		str	r3, [r7, #172]
2821:keygen.c      **** 	make_fg(ft, f, g, logn_top, depth, 1);
 11622              		.loc 2 2821 2
 11623 00dc 07F59473 		add	r3, r7, #296
 11624 00e0 A3F58E73 		sub	r3, r3, #284
 11625 00e4 07F59472 		add	r2, r7, #296
 11626 00e8 A2F59272 		sub	r2, r2, #292
 11627 00ec 07F59471 		add	r1, r7, #296
 11628 00f0 A1F59071 		sub	r1, r1, #288
 11629 00f4 0120     		movs	r0, #1
 11630 00f6 0190     		str	r0, [sp, #4]
 11631 00f8 07F59470 		add	r0, r7, #296
 11632 00fc A0F59470 		sub	r0, r0, #296
 11633 0100 0068     		ldr	r0, [r0]
 11634 0102 0090     		str	r0, [sp]
 11635 0104 1B68     		ldr	r3, [r3]
 11636 0106 1268     		ldr	r2, [r2]
 11637 0108 0968     		ldr	r1, [r1]
 11638 010a D7F8AC00 		ldr	r0, [r7, #172]
 11639 010e FFF7FEFF 		bl	make_fg
2822:keygen.c      **** 
2823:keygen.c      **** 	/*
2824:keygen.c      **** 	 * Move the newly computed f and g to make room for our candidate
2825:keygen.c      **** 	 * F and G (unreduced).
2826:keygen.c      **** 	 */
2827:keygen.c      **** 	Ft = tmp;
 11640              		.loc 2 2827 5
 11641 0112 D7F83831 		ldr	r3, [r7, #312]
 11642 0116 C7F81C31 		str	r3, [r7, #284]
2828:keygen.c      **** 	Gt = Ft + n * llen;
 11643              		.loc 2 2828 14
 11644 011a D7F8CC30 		ldr	r3, [r7, #204]
 11645 011e D7F8BC20 		ldr	r2, [r7, #188]
 11646 0122 02FB03F3 		mul	r3, r2, r3
 11647              		.loc 2 2828 10
 11648 0126 9B00     		lsls	r3, r3, #2
 11649              		.loc 2 2828 5
 11650 0128 D7F81C21 		ldr	r2, [r7, #284]
 11651 012c 1344     		add	r3, r3, r2
 11652 012e C7F81831 		str	r3, [r7, #280]
2829:keygen.c      **** 	t1 = Gt + n * llen;
 11653              		.loc 2 2829 14
 11654 0132 D7F8CC30 		ldr	r3, [r7, #204]
 11655 0136 D7F8BC20 		ldr	r2, [r7, #188]
 11656 013a 02FB03F3 		mul	r3, r2, r3
 11657              		.loc 2 2829 10
 11658 013e 9B00     		lsls	r3, r3, #2
 11659              		.loc 2 2829 5
 11660 0140 D7F81821 		ldr	r2, [r7, #280]
 11661 0144 1344     		add	r3, r3, r2
 11662 0146 C7F8A830 		str	r3, [r7, #168]
2830:keygen.c      **** 	memmove(t1, ft, 2 * n * slen * sizeof *ft);
 11663              		.loc 2 2830 24
 11664 014a D7F8CC30 		ldr	r3, [r7, #204]
 11665 014e D7F8C420 		ldr	r2, [r7, #196]
 11666 0152 02FB03F3 		mul	r3, r2, r3
 11667              		.loc 2 2830 2
 11668 0156 DB00     		lsls	r3, r3, #3
 11669 0158 1A46     		mov	r2, r3
 11670 015a D7F8AC10 		ldr	r1, [r7, #172]
 11671 015e D7F8A800 		ldr	r0, [r7, #168]
 11672 0162 FFF7FEFF 		bl	memmove
2831:keygen.c      **** 	ft = t1;
 11673              		.loc 2 2831 5
 11674 0166 D7F8A830 		ldr	r3, [r7, #168]
 11675 016a C7F8AC30 		str	r3, [r7, #172]
2832:keygen.c      **** 	gt = ft + slen * n;
 11676              		.loc 2 2832 17
 11677 016e D7F8C430 		ldr	r3, [r7, #196]
 11678 0172 D7F8CC20 		ldr	r2, [r7, #204]
 11679 0176 02FB03F3 		mul	r3, r2, r3
 11680              		.loc 2 2832 10
 11681 017a 9B00     		lsls	r3, r3, #2
 11682              		.loc 2 2832 5
 11683 017c D7F8AC20 		ldr	r2, [r7, #172]
 11684 0180 1344     		add	r3, r3, r2
 11685 0182 C7F8A430 		str	r3, [r7, #164]
2833:keygen.c      **** 	t1 = gt + slen * n;
 11686              		.loc 2 2833 17
 11687 0186 D7F8C430 		ldr	r3, [r7, #196]
 11688 018a D7F8CC20 		ldr	r2, [r7, #204]
 11689 018e 02FB03F3 		mul	r3, r2, r3
 11690              		.loc 2 2833 10
 11691 0192 9B00     		lsls	r3, r3, #2
 11692              		.loc 2 2833 5
 11693 0194 D7F8A420 		ldr	r2, [r7, #164]
 11694 0198 1344     		add	r3, r3, r2
 11695 019a C7F8A830 		str	r3, [r7, #168]
2834:keygen.c      **** 
2835:keygen.c      **** 	/*
2836:keygen.c      **** 	 * Move Fd and Gd _after_ f and g.
2837:keygen.c      **** 	 */
2838:keygen.c      **** 	memmove(t1, Fd, 2 * hn * dlen * sizeof *Fd);
 11696              		.loc 2 2838 25
 11697 019e D7F8C830 		ldr	r3, [r7, #200]
 11698 01a2 D7F8C020 		ldr	r2, [r7, #192]
 11699 01a6 02FB03F3 		mul	r3, r2, r3
 11700              		.loc 2 2838 2
 11701 01aa DB00     		lsls	r3, r3, #3
 11702 01ac 1A46     		mov	r2, r3
 11703 01ae D7F8B410 		ldr	r1, [r7, #180]
 11704 01b2 D7F8A800 		ldr	r0, [r7, #168]
 11705 01b6 FFF7FEFF 		bl	memmove
2839:keygen.c      **** 	Fd = t1;
 11706              		.loc 2 2839 5
 11707 01ba D7F8A830 		ldr	r3, [r7, #168]
 11708 01be C7F8B430 		str	r3, [r7, #180]
2840:keygen.c      **** 	Gd = Fd + hn * dlen;
 11709              		.loc 2 2840 15
 11710 01c2 D7F8C830 		ldr	r3, [r7, #200]
 11711 01c6 D7F8C020 		ldr	r2, [r7, #192]
 11712 01ca 02FB03F3 		mul	r3, r2, r3
 11713              		.loc 2 2840 10
 11714 01ce 9B00     		lsls	r3, r3, #2
 11715              		.loc 2 2840 5
 11716 01d0 D7F8B420 		ldr	r2, [r7, #180]
 11717 01d4 1344     		add	r3, r3, r2
 11718 01d6 C7F8B030 		str	r3, [r7, #176]
2841:keygen.c      **** 
2842:keygen.c      **** 	/*
2843:keygen.c      **** 	 * We reduce Fd and Gd modulo all the small primes we will need,
2844:keygen.c      **** 	 * and store the values in Ft and Gt (only n/2 values in each).
2845:keygen.c      **** 	 */
2846:keygen.c      **** 	for (u = 0; u < llen; u ++) {
 11719              		.loc 2 2846 9
 11720 01da 0023     		movs	r3, #0
 11721 01dc C7F82031 		str	r3, [r7, #288]
 11722              		.loc 2 2846 2
 11723 01e0 D0E0     		b	.L255
 11724              	.L258:
 11725              	.LBB42:
2847:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
2848:keygen.c      **** 		size_t v;
2849:keygen.c      **** 		uint32_t *xs, *ys, *xd, *yd;
2850:keygen.c      **** 
2851:keygen.c      **** 		p = primes[u].p;
 11726              		.loc 2 2851 13
 11727 01e2 D7F82021 		ldr	r2, [r7, #288]
 11728 01e6 1346     		mov	r3, r2
 11729 01e8 5B00     		lsls	r3, r3, #1
 11730 01ea 1344     		add	r3, r3, r2
 11731 01ec 9B00     		lsls	r3, r3, #2
 11732 01ee 1A46     		mov	r2, r3
 11733 01f0 D7F8B830 		ldr	r3, [r7, #184]
 11734 01f4 1A44     		add	r2, r2, r3
 11735              		.loc 2 2851 5
 11736 01f6 07F59473 		add	r3, r7, #296
 11737 01fa A3F58673 		sub	r3, r3, #268
 11738 01fe 1268     		ldr	r2, [r2]
 11739 0200 1A60     		str	r2, [r3]
2852:keygen.c      **** 		p0i = modp_ninv31(p);
 11740              		.loc 2 2852 9
 11741 0202 07F59473 		add	r3, r7, #296
 11742 0206 A3F58874 		sub	r4, r3, #272
 11743 020a 07F59473 		add	r3, r7, #296
 11744 020e A3F58673 		sub	r3, r3, #268
 11745 0212 1868     		ldr	r0, [r3]
 11746 0214 FFF7FEFF 		bl	modp_ninv31
 11747 0218 2060     		str	r0, [r4]
2853:keygen.c      **** 		R2 = modp_R2(p, p0i);
 11748              		.loc 2 2853 8
 11749 021a 07F59473 		add	r3, r7, #296
 11750 021e A3F58A74 		sub	r4, r3, #276
 11751 0222 07F59473 		add	r3, r7, #296
 11752 0226 A3F58872 		sub	r2, r3, #272
 11753 022a 07F59473 		add	r3, r7, #296
 11754 022e A3F58673 		sub	r3, r3, #268
 11755 0232 1168     		ldr	r1, [r2]
 11756 0234 1868     		ldr	r0, [r3]
 11757 0236 FFF7FEFF 		bl	modp_R2
 11758 023a 2060     		str	r0, [r4]
2854:keygen.c      **** 		Rx = modp_Rx((unsigned)dlen, p, p0i, R2);
 11759              		.loc 2 2854 8
 11760 023c 07F59473 		add	r3, r7, #296
 11761 0240 A3F58C74 		sub	r4, r3, #280
 11762 0244 07F59473 		add	r3, r7, #296
 11763 0248 A3F58A73 		sub	r3, r3, #276
 11764 024c 07F59472 		add	r2, r7, #296
 11765 0250 A2F58872 		sub	r2, r2, #272
 11766 0254 07F59471 		add	r1, r7, #296
 11767 0258 A1F58671 		sub	r1, r1, #268
 11768 025c 1B68     		ldr	r3, [r3]
 11769 025e 1268     		ldr	r2, [r2]
 11770 0260 0968     		ldr	r1, [r1]
 11771 0262 D7F8C000 		ldr	r0, [r7, #192]
 11772 0266 FFF7FEFF 		bl	modp_Rx
 11773 026a 2060     		str	r0, [r4]
2855:keygen.c      **** 		for (v = 0, xs = Fd, ys = Gd, xd = Ft + u, yd = Gt + u;
 11774              		.loc 2 2855 10
 11775 026c 0023     		movs	r3, #0
 11776 026e C7F80031 		str	r3, [r7, #256]
 11777              		.loc 2 2855 18
 11778 0272 D7F8B430 		ldr	r3, [r7, #180]
 11779 0276 C7F8FC30 		str	r3, [r7, #252]
 11780              		.loc 2 2855 27
 11781 027a D7F8B030 		ldr	r3, [r7, #176]
 11782 027e C7F8F830 		str	r3, [r7, #248]
 11783              		.loc 2 2855 41
 11784 0282 D7F82031 		ldr	r3, [r7, #288]
 11785 0286 9B00     		lsls	r3, r3, #2
 11786              		.loc 2 2855 36
 11787 0288 D7F81C21 		ldr	r2, [r7, #284]
 11788 028c 1344     		add	r3, r3, r2
 11789 028e C7F8F430 		str	r3, [r7, #244]
 11790              		.loc 2 2855 54
 11791 0292 D7F82031 		ldr	r3, [r7, #288]
 11792 0296 9B00     		lsls	r3, r3, #2
 11793              		.loc 2 2855 49
 11794 0298 D7F81821 		ldr	r2, [r7, #280]
 11795 029c 1344     		add	r3, r3, r2
 11796 029e C7F8F030 		str	r3, [r7, #240]
 11797              		.loc 2 2855 3
 11798 02a2 64E0     		b	.L256
 11799              	.L257:
2856:keygen.c      **** 			v < hn;
2857:keygen.c      **** 			v ++, xs += dlen, ys += dlen, xd += llen, yd += llen)
2858:keygen.c      **** 		{
2859:keygen.c      **** 			*xd = zint_mod_small_signed(xs, dlen, p, p0i, R2, Rx);
 11800              		.loc 2 2859 10
 11801 02a4 07F59473 		add	r3, r7, #296
 11802 02a8 A3F58873 		sub	r3, r3, #272
 11803 02ac 07F59472 		add	r2, r7, #296
 11804 02b0 A2F58672 		sub	r2, r2, #268
 11805 02b4 07F59471 		add	r1, r7, #296
 11806 02b8 A1F58C71 		sub	r1, r1, #280
 11807 02bc 0968     		ldr	r1, [r1]
 11808 02be 0191     		str	r1, [sp, #4]
 11809 02c0 07F59471 		add	r1, r7, #296
 11810 02c4 A1F58A71 		sub	r1, r1, #276
 11811 02c8 0968     		ldr	r1, [r1]
 11812 02ca 0091     		str	r1, [sp]
 11813 02cc 1B68     		ldr	r3, [r3]
 11814 02ce 1268     		ldr	r2, [r2]
 11815 02d0 D7F8C010 		ldr	r1, [r7, #192]
 11816 02d4 D7F8FC00 		ldr	r0, [r7, #252]
 11817 02d8 FFF7FEFF 		bl	zint_mod_small_signed
 11818 02dc 0246     		mov	r2, r0
 11819              		.loc 2 2859 8
 11820 02de D7F8F430 		ldr	r3, [r7, #244]
 11821 02e2 1A60     		str	r2, [r3]
2860:keygen.c      **** 			*yd = zint_mod_small_signed(ys, dlen, p, p0i, R2, Rx);
 11822              		.loc 2 2860 10
 11823 02e4 07F59473 		add	r3, r7, #296
 11824 02e8 A3F58873 		sub	r3, r3, #272
 11825 02ec 07F59472 		add	r2, r7, #296
 11826 02f0 A2F58672 		sub	r2, r2, #268
 11827 02f4 07F59471 		add	r1, r7, #296
 11828 02f8 A1F58C71 		sub	r1, r1, #280
 11829 02fc 0968     		ldr	r1, [r1]
 11830 02fe 0191     		str	r1, [sp, #4]
 11831 0300 07F59471 		add	r1, r7, #296
 11832 0304 A1F58A71 		sub	r1, r1, #276
 11833 0308 0968     		ldr	r1, [r1]
 11834 030a 0091     		str	r1, [sp]
 11835 030c 1B68     		ldr	r3, [r3]
 11836 030e 1268     		ldr	r2, [r2]
 11837 0310 D7F8C010 		ldr	r1, [r7, #192]
 11838 0314 D7F8F800 		ldr	r0, [r7, #248]
 11839 0318 FFF7FEFF 		bl	zint_mod_small_signed
 11840 031c 0246     		mov	r2, r0
 11841              		.loc 2 2860 8
 11842 031e D7F8F030 		ldr	r3, [r7, #240]
 11843 0322 1A60     		str	r2, [r3]
2857:keygen.c      **** 		{
 11844              		.loc 2 2857 6
 11845 0324 D7F80031 		ldr	r3, [r7, #256]
 11846 0328 0133     		adds	r3, r3, #1
 11847 032a C7F80031 		str	r3, [r7, #256]
2857:keygen.c      **** 		{
 11848              		.loc 2 2857 13
 11849 032e D7F8C030 		ldr	r3, [r7, #192]
 11850 0332 9B00     		lsls	r3, r3, #2
 11851 0334 D7F8FC20 		ldr	r2, [r7, #252]
 11852 0338 1344     		add	r3, r3, r2
 11853 033a C7F8FC30 		str	r3, [r7, #252]
2857:keygen.c      **** 		{
 11854              		.loc 2 2857 25
 11855 033e D7F8C030 		ldr	r3, [r7, #192]
 11856 0342 9B00     		lsls	r3, r3, #2
 11857 0344 D7F8F820 		ldr	r2, [r7, #248]
 11858 0348 1344     		add	r3, r3, r2
 11859 034a C7F8F830 		str	r3, [r7, #248]
2857:keygen.c      **** 		{
 11860              		.loc 2 2857 37
 11861 034e D7F8BC30 		ldr	r3, [r7, #188]
 11862 0352 9B00     		lsls	r3, r3, #2
 11863 0354 D7F8F420 		ldr	r2, [r7, #244]
 11864 0358 1344     		add	r3, r3, r2
 11865 035a C7F8F430 		str	r3, [r7, #244]
2857:keygen.c      **** 		{
 11866              		.loc 2 2857 49
 11867 035e D7F8BC30 		ldr	r3, [r7, #188]
 11868 0362 9B00     		lsls	r3, r3, #2
 11869 0364 D7F8F020 		ldr	r2, [r7, #240]
 11870 0368 1344     		add	r3, r3, r2
 11871 036a C7F8F030 		str	r3, [r7, #240]
 11872              	.L256:
2855:keygen.c      **** 			v < hn;
 11873              		.loc 2 2855 3 discriminator 1
 11874 036e D7F80021 		ldr	r2, [r7, #256]
 11875 0372 D7F8C830 		ldr	r3, [r7, #200]
 11876 0376 9A42     		cmp	r2, r3
 11877 0378 94D3     		bcc	.L257
 11878              	.LBE42:
2846:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
 11879              		.loc 2 2846 26 discriminator 2
 11880 037a D7F82031 		ldr	r3, [r7, #288]
 11881 037e 0133     		adds	r3, r3, #1
 11882 0380 C7F82031 		str	r3, [r7, #288]
 11883              	.L255:
2846:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
 11884              		.loc 2 2846 2 discriminator 1
 11885 0384 D7F82021 		ldr	r2, [r7, #288]
 11886 0388 D7F8BC30 		ldr	r3, [r7, #188]
 11887 038c 9A42     		cmp	r2, r3
 11888 038e FFF428AF 		bcc	.L258
2861:keygen.c      **** 		}
2862:keygen.c      **** 	}
2863:keygen.c      **** 
2864:keygen.c      **** 	/*
2865:keygen.c      **** 	 * We do not need Fd and Gd after that point.
2866:keygen.c      **** 	 */
2867:keygen.c      **** 
2868:keygen.c      **** 	/*
2869:keygen.c      **** 	 * Compute our F and G modulo sufficiently many small primes.
2870:keygen.c      **** 	 */
2871:keygen.c      **** 	for (u = 0; u < llen; u ++) {
 11889              		.loc 2 2871 9
 11890 0392 0023     		movs	r3, #0
 11891 0394 C7F82031 		str	r3, [r7, #288]
 11892              		.loc 2 2871 2
 11893 0398 89E2     		b	.L259
 11894              	.L302:
 11895 039a 00BF     		.align	2
 11896              	.L301:
 11897 039c 90220000 		.word	MAX_BL_SMALL
 11898 03a0 BC220000 		.word	MAX_BL_LARGE
 11899 03a4 40010000 		.word	PRIMES
 11900              	.L271:
 11901              	.LBB43:
2872:keygen.c      **** 		uint32_t p, p0i, R2;
2873:keygen.c      **** 		uint32_t *gm, *igm, *fx, *gx, *Fp, *Gp;
2874:keygen.c      **** 		size_t v;
2875:keygen.c      **** 
2876:keygen.c      **** 		/*
2877:keygen.c      **** 		 * All computations are done modulo p.
2878:keygen.c      **** 		 */
2879:keygen.c      **** 		p = primes[u].p;
 11902              		.loc 2 2879 13
 11903 03a8 D7F82021 		ldr	r2, [r7, #288]
 11904 03ac 1346     		mov	r3, r2
 11905 03ae 5B00     		lsls	r3, r3, #1
 11906 03b0 1344     		add	r3, r3, r2
 11907 03b2 9B00     		lsls	r3, r3, #2
 11908 03b4 1A46     		mov	r2, r3
 11909 03b6 D7F8B830 		ldr	r3, [r7, #184]
 11910 03ba 1344     		add	r3, r3, r2
 11911              		.loc 2 2879 5
 11912 03bc 1B68     		ldr	r3, [r3]
 11913 03be FB65     		str	r3, [r7, #92]
2880:keygen.c      **** 		p0i = modp_ninv31(p);
 11914              		.loc 2 2880 9
 11915 03c0 F86D     		ldr	r0, [r7, #92]
 11916 03c2 FFF7FEFF 		bl	modp_ninv31
 11917 03c6 B865     		str	r0, [r7, #88]
2881:keygen.c      **** 		R2 = modp_R2(p, p0i);
 11918              		.loc 2 2881 8
 11919 03c8 B96D     		ldr	r1, [r7, #88]
 11920 03ca F86D     		ldr	r0, [r7, #92]
 11921 03cc FFF7FEFF 		bl	modp_R2
 11922 03d0 7865     		str	r0, [r7, #84]
2882:keygen.c      **** 
2883:keygen.c      **** 		/*
2884:keygen.c      **** 		 * If we processed slen words, then f and g have been
2885:keygen.c      **** 		 * de-NTTized, and are in RNS; we can rebuild them.
2886:keygen.c      **** 		 */
2887:keygen.c      **** 		if (u == slen) {
 11923              		.loc 2 2887 6
 11924 03d2 D7F82021 		ldr	r2, [r7, #288]
 11925 03d6 D7F8C430 		ldr	r3, [r7, #196]
 11926 03da 9A42     		cmp	r2, r3
 11927 03dc 23D1     		bne	.L260
2888:keygen.c      **** 			zint_rebuild_CRT(ft, slen, slen, n, primes, 1, t1);
 11928              		.loc 2 2888 4
 11929 03de D7F8A830 		ldr	r3, [r7, #168]
 11930 03e2 0293     		str	r3, [sp, #8]
 11931 03e4 0123     		movs	r3, #1
 11932 03e6 0193     		str	r3, [sp, #4]
 11933 03e8 D7F8B830 		ldr	r3, [r7, #184]
 11934 03ec 0093     		str	r3, [sp]
 11935 03ee D7F8CC30 		ldr	r3, [r7, #204]
 11936 03f2 D7F8C420 		ldr	r2, [r7, #196]
 11937 03f6 D7F8C410 		ldr	r1, [r7, #196]
 11938 03fa D7F8AC00 		ldr	r0, [r7, #172]
 11939 03fe FFF7FEFF 		bl	zint_rebuild_CRT
2889:keygen.c      **** 			zint_rebuild_CRT(gt, slen, slen, n, primes, 1, t1);
 11940              		.loc 2 2889 4
 11941 0402 D7F8A830 		ldr	r3, [r7, #168]
 11942 0406 0293     		str	r3, [sp, #8]
 11943 0408 0123     		movs	r3, #1
 11944 040a 0193     		str	r3, [sp, #4]
 11945 040c D7F8B830 		ldr	r3, [r7, #184]
 11946 0410 0093     		str	r3, [sp]
 11947 0412 D7F8CC30 		ldr	r3, [r7, #204]
 11948 0416 D7F8C420 		ldr	r2, [r7, #196]
 11949 041a D7F8C410 		ldr	r1, [r7, #196]
 11950 041e D7F8A400 		ldr	r0, [r7, #164]
 11951 0422 FFF7FEFF 		bl	zint_rebuild_CRT
 11952              	.L260:
2890:keygen.c      **** 		}
2891:keygen.c      **** 
2892:keygen.c      **** 		gm = t1;
 11953              		.loc 2 2892 6
 11954 0426 D7F8A830 		ldr	r3, [r7, #168]
 11955 042a 3B65     		str	r3, [r7, #80]
2893:keygen.c      **** 		igm = gm + n;
 11956              		.loc 2 2893 12
 11957 042c D7F8CC30 		ldr	r3, [r7, #204]
 11958 0430 9B00     		lsls	r3, r3, #2
 11959              		.loc 2 2893 7
 11960 0432 3A6D     		ldr	r2, [r7, #80]
 11961 0434 1344     		add	r3, r3, r2
 11962 0436 FB64     		str	r3, [r7, #76]
2894:keygen.c      **** 		fx = igm + n;
 11963              		.loc 2 2894 12
 11964 0438 D7F8CC30 		ldr	r3, [r7, #204]
 11965 043c 9B00     		lsls	r3, r3, #2
 11966              		.loc 2 2894 6
 11967 043e FA6C     		ldr	r2, [r7, #76]
 11968 0440 1344     		add	r3, r3, r2
 11969 0442 BB64     		str	r3, [r7, #72]
2895:keygen.c      **** 		gx = fx + n;
 11970              		.loc 2 2895 11
 11971 0444 D7F8CC30 		ldr	r3, [r7, #204]
 11972 0448 9B00     		lsls	r3, r3, #2
 11973              		.loc 2 2895 6
 11974 044a BA6C     		ldr	r2, [r7, #72]
 11975 044c 1344     		add	r3, r3, r2
 11976 044e 7B64     		str	r3, [r7, #68]
2896:keygen.c      **** 
2897:keygen.c      **** 		modp_mkgm2(gm, igm, logn, primes[u].g, p, p0i);
 11977              		.loc 2 2897 35
 11978 0450 D7F82021 		ldr	r2, [r7, #288]
 11979 0454 1346     		mov	r3, r2
 11980 0456 5B00     		lsls	r3, r3, #1
 11981 0458 1344     		add	r3, r3, r2
 11982 045a 9B00     		lsls	r3, r3, #2
 11983 045c 1A46     		mov	r2, r3
 11984 045e D7F8B830 		ldr	r3, [r7, #184]
 11985 0462 1344     		add	r3, r3, r2
 11986              		.loc 2 2897 3
 11987 0464 5A68     		ldr	r2, [r3, #4]
 11988 0466 BB6D     		ldr	r3, [r7, #88]
 11989 0468 0193     		str	r3, [sp, #4]
 11990 046a FB6D     		ldr	r3, [r7, #92]
 11991 046c 0093     		str	r3, [sp]
 11992 046e 1346     		mov	r3, r2
 11993 0470 D7F8D020 		ldr	r2, [r7, #208]
 11994 0474 F96C     		ldr	r1, [r7, #76]
 11995 0476 386D     		ldr	r0, [r7, #80]
 11996 0478 FFF7FEFF 		bl	modp_mkgm2
2898:keygen.c      **** 
2899:keygen.c      **** 		if (u < slen) {
 11997              		.loc 2 2899 6
 11998 047c D7F82021 		ldr	r2, [r7, #288]
 11999 0480 D7F8C430 		ldr	r3, [r7, #196]
 12000 0484 9A42     		cmp	r2, r3
 12001 0486 63D2     		bcs	.L261
2900:keygen.c      **** 			for (v = 0, x = ft + u, y = gt + u;
 12002              		.loc 2 2900 11
 12003 0488 0023     		movs	r3, #0
 12004 048a C7F8EC30 		str	r3, [r7, #236]
 12005              		.loc 2 2900 23
 12006 048e D7F82031 		ldr	r3, [r7, #288]
 12007 0492 9B00     		lsls	r3, r3, #2
 12008              		.loc 2 2900 18
 12009 0494 D7F8AC20 		ldr	r2, [r7, #172]
 12010 0498 1344     		add	r3, r3, r2
 12011 049a C7F80831 		str	r3, [r7, #264]
 12012              		.loc 2 2900 35
 12013 049e D7F82031 		ldr	r3, [r7, #288]
 12014 04a2 9B00     		lsls	r3, r3, #2
 12015              		.loc 2 2900 30
 12016 04a4 D7F8A420 		ldr	r2, [r7, #164]
 12017 04a8 1344     		add	r3, r3, r2
 12018 04aa C7F80431 		str	r3, [r7, #260]
 12019              		.loc 2 2900 4
 12020 04ae 26E0     		b	.L262
 12021              	.L263:
2901:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
2902:keygen.c      **** 			{
2903:keygen.c      **** 				fx[v] = *x;
 12022              		.loc 2 2903 7
 12023 04b0 D7F8EC30 		ldr	r3, [r7, #236]
 12024 04b4 9B00     		lsls	r3, r3, #2
 12025 04b6 BA6C     		ldr	r2, [r7, #72]
 12026 04b8 1344     		add	r3, r3, r2
 12027              		.loc 2 2903 13
 12028 04ba D7F80821 		ldr	r2, [r7, #264]
 12029 04be 1268     		ldr	r2, [r2]
 12030              		.loc 2 2903 11
 12031 04c0 1A60     		str	r2, [r3]
2904:keygen.c      **** 				gx[v] = *y;
 12032              		.loc 2 2904 7
 12033 04c2 D7F8EC30 		ldr	r3, [r7, #236]
 12034 04c6 9B00     		lsls	r3, r3, #2
 12035 04c8 7A6C     		ldr	r2, [r7, #68]
 12036 04ca 1344     		add	r3, r3, r2
 12037              		.loc 2 2904 13
 12038 04cc D7F80421 		ldr	r2, [r7, #260]
 12039 04d0 1268     		ldr	r2, [r2]
 12040              		.loc 2 2904 11
 12041 04d2 1A60     		str	r2, [r3]
2901:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 12042              		.loc 2 2901 14
 12043 04d4 D7F8EC30 		ldr	r3, [r7, #236]
 12044 04d8 0133     		adds	r3, r3, #1
 12045 04da C7F8EC30 		str	r3, [r7, #236]
2901:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 12046              		.loc 2 2901 20
 12047 04de D7F8C430 		ldr	r3, [r7, #196]
 12048 04e2 9B00     		lsls	r3, r3, #2
 12049 04e4 D7F80821 		ldr	r2, [r7, #264]
 12050 04e8 1344     		add	r3, r3, r2
 12051 04ea C7F80831 		str	r3, [r7, #264]
2901:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 12052              		.loc 2 2901 31
 12053 04ee D7F8C430 		ldr	r3, [r7, #196]
 12054 04f2 9B00     		lsls	r3, r3, #2
 12055 04f4 D7F80421 		ldr	r2, [r7, #260]
 12056 04f8 1344     		add	r3, r3, r2
 12057 04fa C7F80431 		str	r3, [r7, #260]
 12058              	.L262:
2900:keygen.c      **** 			for (v = 0, x = ft + u, y = gt + u;
 12059              		.loc 2 2900 4 discriminator 1
 12060 04fe D7F8EC20 		ldr	r2, [r7, #236]
 12061 0502 D7F8CC30 		ldr	r3, [r7, #204]
 12062 0506 9A42     		cmp	r2, r3
 12063 0508 D2D3     		bcc	.L263
2905:keygen.c      **** 			}
2906:keygen.c      **** 			modp_iNTT2_ext(ft + u, slen, igm, logn, p, p0i);
 12064              		.loc 2 2906 22
 12065 050a D7F82031 		ldr	r3, [r7, #288]
 12066 050e 9B00     		lsls	r3, r3, #2
 12067              		.loc 2 2906 4
 12068 0510 D7F8AC20 		ldr	r2, [r7, #172]
 12069 0514 D018     		adds	r0, r2, r3
 12070 0516 BB6D     		ldr	r3, [r7, #88]
 12071 0518 0193     		str	r3, [sp, #4]
 12072 051a FB6D     		ldr	r3, [r7, #92]
 12073 051c 0093     		str	r3, [sp]
 12074 051e D7F8D030 		ldr	r3, [r7, #208]
 12075 0522 FA6C     		ldr	r2, [r7, #76]
 12076 0524 D7F8C410 		ldr	r1, [r7, #196]
 12077 0528 FFF7FEFF 		bl	modp_iNTT2_ext
2907:keygen.c      **** 			modp_iNTT2_ext(gt + u, slen, igm, logn, p, p0i);
 12078              		.loc 2 2907 22
 12079 052c D7F82031 		ldr	r3, [r7, #288]
 12080 0530 9B00     		lsls	r3, r3, #2
 12081              		.loc 2 2907 4
 12082 0532 D7F8A420 		ldr	r2, [r7, #164]
 12083 0536 D018     		adds	r0, r2, r3
 12084 0538 BB6D     		ldr	r3, [r7, #88]
 12085 053a 0193     		str	r3, [sp, #4]
 12086 053c FB6D     		ldr	r3, [r7, #92]
 12087 053e 0093     		str	r3, [sp]
 12088 0540 D7F8D030 		ldr	r3, [r7, #208]
 12089 0544 FA6C     		ldr	r2, [r7, #76]
 12090 0546 D7F8C410 		ldr	r1, [r7, #196]
 12091 054a FFF7FEFF 		bl	modp_iNTT2_ext
 12092 054e 6AE0     		b	.L264
 12093              	.L261:
 12094              	.LBB44:
2908:keygen.c      **** 		} else {
2909:keygen.c      **** 			uint32_t Rx;
2910:keygen.c      **** 
2911:keygen.c      **** 			Rx = modp_Rx((unsigned)slen, p, p0i, R2);
 12095              		.loc 2 2911 9
 12096 0550 7B6D     		ldr	r3, [r7, #84]
 12097 0552 BA6D     		ldr	r2, [r7, #88]
 12098 0554 F96D     		ldr	r1, [r7, #92]
 12099 0556 D7F8C400 		ldr	r0, [r7, #196]
 12100 055a FFF7FEFF 		bl	modp_Rx
 12101 055e 3864     		str	r0, [r7, #64]
2912:keygen.c      **** 			for (v = 0, x = ft, y = gt;
 12102              		.loc 2 2912 11
 12103 0560 0023     		movs	r3, #0
 12104 0562 C7F8EC30 		str	r3, [r7, #236]
 12105              		.loc 2 2912 18
 12106 0566 D7F8AC30 		ldr	r3, [r7, #172]
 12107 056a C7F80831 		str	r3, [r7, #264]
 12108              		.loc 2 2912 26
 12109 056e D7F8A430 		ldr	r3, [r7, #164]
 12110 0572 C7F80431 		str	r3, [r7, #260]
 12111              		.loc 2 2912 4
 12112 0576 3AE0     		b	.L265
 12113              	.L266:
2913:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
2914:keygen.c      **** 			{
2915:keygen.c      **** 				fx[v] = zint_mod_small_signed(x, slen,
 12114              		.loc 2 2915 7
 12115 0578 D7F8EC30 		ldr	r3, [r7, #236]
 12116 057c 9B00     		lsls	r3, r3, #2
 12117 057e BA6C     		ldr	r2, [r7, #72]
 12118 0580 D418     		adds	r4, r2, r3
 12119              		.loc 2 2915 13
 12120 0582 3B6C     		ldr	r3, [r7, #64]
 12121 0584 0193     		str	r3, [sp, #4]
 12122 0586 7B6D     		ldr	r3, [r7, #84]
 12123 0588 0093     		str	r3, [sp]
 12124 058a BB6D     		ldr	r3, [r7, #88]
 12125 058c FA6D     		ldr	r2, [r7, #92]
 12126 058e D7F8C410 		ldr	r1, [r7, #196]
 12127 0592 D7F80801 		ldr	r0, [r7, #264]
 12128 0596 FFF7FEFF 		bl	zint_mod_small_signed
 12129 059a 0346     		mov	r3, r0
 12130              		.loc 2 2915 11
 12131 059c 2360     		str	r3, [r4]
2916:keygen.c      **** 					p, p0i, R2, Rx);
2917:keygen.c      **** 				gx[v] = zint_mod_small_signed(y, slen,
 12132              		.loc 2 2917 7
 12133 059e D7F8EC30 		ldr	r3, [r7, #236]
 12134 05a2 9B00     		lsls	r3, r3, #2
 12135 05a4 7A6C     		ldr	r2, [r7, #68]
 12136 05a6 D418     		adds	r4, r2, r3
 12137              		.loc 2 2917 13
 12138 05a8 3B6C     		ldr	r3, [r7, #64]
 12139 05aa 0193     		str	r3, [sp, #4]
 12140 05ac 7B6D     		ldr	r3, [r7, #84]
 12141 05ae 0093     		str	r3, [sp]
 12142 05b0 BB6D     		ldr	r3, [r7, #88]
 12143 05b2 FA6D     		ldr	r2, [r7, #92]
 12144 05b4 D7F8C410 		ldr	r1, [r7, #196]
 12145 05b8 D7F80401 		ldr	r0, [r7, #260]
 12146 05bc FFF7FEFF 		bl	zint_mod_small_signed
 12147 05c0 0346     		mov	r3, r0
 12148              		.loc 2 2917 11
 12149 05c2 2360     		str	r3, [r4]
2913:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 12150              		.loc 2 2913 14
 12151 05c4 D7F8EC30 		ldr	r3, [r7, #236]
 12152 05c8 0133     		adds	r3, r3, #1
 12153 05ca C7F8EC30 		str	r3, [r7, #236]
2913:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 12154              		.loc 2 2913 20
 12155 05ce D7F8C430 		ldr	r3, [r7, #196]
 12156 05d2 9B00     		lsls	r3, r3, #2
 12157 05d4 D7F80821 		ldr	r2, [r7, #264]
 12158 05d8 1344     		add	r3, r3, r2
 12159 05da C7F80831 		str	r3, [r7, #264]
2913:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 12160              		.loc 2 2913 31
 12161 05de D7F8C430 		ldr	r3, [r7, #196]
 12162 05e2 9B00     		lsls	r3, r3, #2
 12163 05e4 D7F80421 		ldr	r2, [r7, #260]
 12164 05e8 1344     		add	r3, r3, r2
 12165 05ea C7F80431 		str	r3, [r7, #260]
 12166              	.L265:
2912:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 12167              		.loc 2 2912 4 discriminator 1
 12168 05ee D7F8EC20 		ldr	r2, [r7, #236]
 12169 05f2 D7F8CC30 		ldr	r3, [r7, #204]
 12170 05f6 9A42     		cmp	r2, r3
 12171 05f8 BED3     		bcc	.L266
2918:keygen.c      **** 					p, p0i, R2, Rx);
2919:keygen.c      **** 			}
2920:keygen.c      **** 			modp_NTT2(fx, gm, logn, p, p0i);
 12172              		.loc 2 2920 4
 12173 05fa BB6D     		ldr	r3, [r7, #88]
 12174 05fc 0193     		str	r3, [sp, #4]
 12175 05fe FB6D     		ldr	r3, [r7, #92]
 12176 0600 0093     		str	r3, [sp]
 12177 0602 D7F8D030 		ldr	r3, [r7, #208]
 12178 0606 3A6D     		ldr	r2, [r7, #80]
 12179 0608 0121     		movs	r1, #1
 12180 060a B86C     		ldr	r0, [r7, #72]
 12181 060c FFF7FEFF 		bl	modp_NTT2_ext
2921:keygen.c      **** 			modp_NTT2(gx, gm, logn, p, p0i);
 12182              		.loc 2 2921 4
 12183 0610 BB6D     		ldr	r3, [r7, #88]
 12184 0612 0193     		str	r3, [sp, #4]
 12185 0614 FB6D     		ldr	r3, [r7, #92]
 12186 0616 0093     		str	r3, [sp]
 12187 0618 D7F8D030 		ldr	r3, [r7, #208]
 12188 061c 3A6D     		ldr	r2, [r7, #80]
 12189 061e 0121     		movs	r1, #1
 12190 0620 786C     		ldr	r0, [r7, #68]
 12191 0622 FFF7FEFF 		bl	modp_NTT2_ext
 12192              	.L264:
 12193              	.LBE44:
2922:keygen.c      **** 		}
2923:keygen.c      **** 
2924:keygen.c      **** 		/*
2925:keygen.c      **** 		 * Get F' and G' modulo p and in NTT representation
2926:keygen.c      **** 		 * (they have degree n/2). These values were computed in
2927:keygen.c      **** 		 * a previous step, and stored in Ft and Gt.
2928:keygen.c      **** 		 */
2929:keygen.c      **** 		Fp = gx + n;
 12194              		.loc 2 2929 11
 12195 0626 D7F8CC30 		ldr	r3, [r7, #204]
 12196 062a 9B00     		lsls	r3, r3, #2
 12197              		.loc 2 2929 6
 12198 062c 7A6C     		ldr	r2, [r7, #68]
 12199 062e 1344     		add	r3, r3, r2
 12200 0630 FB63     		str	r3, [r7, #60]
2930:keygen.c      **** 		Gp = Fp + hn;
 12201              		.loc 2 2930 11
 12202 0632 D7F8C830 		ldr	r3, [r7, #200]
 12203 0636 9B00     		lsls	r3, r3, #2
 12204              		.loc 2 2930 6
 12205 0638 FA6B     		ldr	r2, [r7, #60]
 12206 063a 1344     		add	r3, r3, r2
 12207 063c BB63     		str	r3, [r7, #56]
2931:keygen.c      **** 		for (v = 0, x = Ft + u, y = Gt + u;
 12208              		.loc 2 2931 10
 12209 063e 0023     		movs	r3, #0
 12210 0640 C7F8EC30 		str	r3, [r7, #236]
 12211              		.loc 2 2931 22
 12212 0644 D7F82031 		ldr	r3, [r7, #288]
 12213 0648 9B00     		lsls	r3, r3, #2
 12214              		.loc 2 2931 17
 12215 064a D7F81C21 		ldr	r2, [r7, #284]
 12216 064e 1344     		add	r3, r3, r2
 12217 0650 C7F80831 		str	r3, [r7, #264]
 12218              		.loc 2 2931 34
 12219 0654 D7F82031 		ldr	r3, [r7, #288]
 12220 0658 9B00     		lsls	r3, r3, #2
 12221              		.loc 2 2931 29
 12222 065a D7F81821 		ldr	r2, [r7, #280]
 12223 065e 1344     		add	r3, r3, r2
 12224 0660 C7F80431 		str	r3, [r7, #260]
 12225              		.loc 2 2931 3
 12226 0664 26E0     		b	.L267
 12227              	.L268:
2932:keygen.c      **** 			v < hn; v ++, x += llen, y += llen)
2933:keygen.c      **** 		{
2934:keygen.c      **** 			Fp[v] = *x;
 12228              		.loc 2 2934 6
 12229 0666 D7F8EC30 		ldr	r3, [r7, #236]
 12230 066a 9B00     		lsls	r3, r3, #2
 12231 066c FA6B     		ldr	r2, [r7, #60]
 12232 066e 1344     		add	r3, r3, r2
 12233              		.loc 2 2934 12
 12234 0670 D7F80821 		ldr	r2, [r7, #264]
 12235 0674 1268     		ldr	r2, [r2]
 12236              		.loc 2 2934 10
 12237 0676 1A60     		str	r2, [r3]
2935:keygen.c      **** 			Gp[v] = *y;
 12238              		.loc 2 2935 6
 12239 0678 D7F8EC30 		ldr	r3, [r7, #236]
 12240 067c 9B00     		lsls	r3, r3, #2
 12241 067e BA6B     		ldr	r2, [r7, #56]
 12242 0680 1344     		add	r3, r3, r2
 12243              		.loc 2 2935 12
 12244 0682 D7F80421 		ldr	r2, [r7, #260]
 12245 0686 1268     		ldr	r2, [r2]
 12246              		.loc 2 2935 10
 12247 0688 1A60     		str	r2, [r3]
2932:keygen.c      **** 			v < hn; v ++, x += llen, y += llen)
 12248              		.loc 2 2932 14
 12249 068a D7F8EC30 		ldr	r3, [r7, #236]
 12250 068e 0133     		adds	r3, r3, #1
 12251 0690 C7F8EC30 		str	r3, [r7, #236]
2932:keygen.c      **** 			v < hn; v ++, x += llen, y += llen)
 12252              		.loc 2 2932 20
 12253 0694 D7F8BC30 		ldr	r3, [r7, #188]
 12254 0698 9B00     		lsls	r3, r3, #2
 12255 069a D7F80821 		ldr	r2, [r7, #264]
 12256 069e 1344     		add	r3, r3, r2
 12257 06a0 C7F80831 		str	r3, [r7, #264]
2932:keygen.c      **** 			v < hn; v ++, x += llen, y += llen)
 12258              		.loc 2 2932 31
 12259 06a4 D7F8BC30 		ldr	r3, [r7, #188]
 12260 06a8 9B00     		lsls	r3, r3, #2
 12261 06aa D7F80421 		ldr	r2, [r7, #260]
 12262 06ae 1344     		add	r3, r3, r2
 12263 06b0 C7F80431 		str	r3, [r7, #260]
 12264              	.L267:
2931:keygen.c      **** 		for (v = 0, x = Ft + u, y = Gt + u;
 12265              		.loc 2 2931 3 discriminator 1
 12266 06b4 D7F8EC20 		ldr	r2, [r7, #236]
 12267 06b8 D7F8C830 		ldr	r3, [r7, #200]
 12268 06bc 9A42     		cmp	r2, r3
 12269 06be D2D3     		bcc	.L268
2936:keygen.c      **** 		}
2937:keygen.c      **** 		modp_NTT2(Fp, gm, logn - 1, p, p0i);
 12270              		.loc 2 2937 3
 12271 06c0 D7F8D030 		ldr	r3, [r7, #208]
 12272 06c4 5A1E     		subs	r2, r3, #1
 12273 06c6 BB6D     		ldr	r3, [r7, #88]
 12274 06c8 0193     		str	r3, [sp, #4]
 12275 06ca FB6D     		ldr	r3, [r7, #92]
 12276 06cc 0093     		str	r3, [sp]
 12277 06ce 1346     		mov	r3, r2
 12278 06d0 3A6D     		ldr	r2, [r7, #80]
 12279 06d2 0121     		movs	r1, #1
 12280 06d4 F86B     		ldr	r0, [r7, #60]
 12281 06d6 FFF7FEFF 		bl	modp_NTT2_ext
2938:keygen.c      **** 		modp_NTT2(Gp, gm, logn - 1, p, p0i);
 12282              		.loc 2 2938 3
 12283 06da D7F8D030 		ldr	r3, [r7, #208]
 12284 06de 5A1E     		subs	r2, r3, #1
 12285 06e0 BB6D     		ldr	r3, [r7, #88]
 12286 06e2 0193     		str	r3, [sp, #4]
 12287 06e4 FB6D     		ldr	r3, [r7, #92]
 12288 06e6 0093     		str	r3, [sp]
 12289 06e8 1346     		mov	r3, r2
 12290 06ea 3A6D     		ldr	r2, [r7, #80]
 12291 06ec 0121     		movs	r1, #1
 12292 06ee B86B     		ldr	r0, [r7, #56]
 12293 06f0 FFF7FEFF 		bl	modp_NTT2_ext
2939:keygen.c      **** 
2940:keygen.c      **** 		/*
2941:keygen.c      **** 		 * Compute our F and G modulo p.
2942:keygen.c      **** 		 *
2943:keygen.c      **** 		 * General case:
2944:keygen.c      **** 		 *
2945:keygen.c      **** 		 *   we divide degree by d = 2 or 3
2946:keygen.c      **** 		 *   f'(x^d) = N(f)(x^d) = f * adj(f)
2947:keygen.c      **** 		 *   g'(x^d) = N(g)(x^d) = g * adj(g)
2948:keygen.c      **** 		 *   f'*G' - g'*F' = q
2949:keygen.c      **** 		 *   F = F'(x^d) * adj(g)
2950:keygen.c      **** 		 *   G = G'(x^d) * adj(f)
2951:keygen.c      **** 		 *
2952:keygen.c      **** 		 * We compute things in the NTT. We group roots of phi
2953:keygen.c      **** 		 * such that all roots x in a group share the same x^d.
2954:keygen.c      **** 		 * If the roots in a group are x_1, x_2... x_d, then:
2955:keygen.c      **** 		 *
2956:keygen.c      **** 		 *   N(f)(x_1^d) = f(x_1)*f(x_2)*...*f(x_d)
2957:keygen.c      **** 		 *
2958:keygen.c      **** 		 * Thus, we have:
2959:keygen.c      **** 		 *
2960:keygen.c      **** 		 *   G(x_1) = f(x_2)*f(x_3)*...*f(x_d)*G'(x_1^d)
2961:keygen.c      **** 		 *   G(x_2) = f(x_1)*f(x_3)*...*f(x_d)*G'(x_1^d)
2962:keygen.c      **** 		 *   ...
2963:keygen.c      **** 		 *   G(x_d) = f(x_1)*f(x_2)*...*f(x_{d-1})*G'(x_1^d)
2964:keygen.c      **** 		 *
2965:keygen.c      **** 		 * In all cases, we can thus compute F and G in NTT
2966:keygen.c      **** 		 * representation by a few simple multiplications.
2967:keygen.c      **** 		 * Moreover, in our chosen NTT representation, roots
2968:keygen.c      **** 		 * from the same group are consecutive in RAM.
2969:keygen.c      **** 		 */
2970:keygen.c      **** 		for (v = 0, x = Ft + u, y = Gt + u; v < hn;
 12294              		.loc 2 2970 10
 12295 06f4 0023     		movs	r3, #0
 12296 06f6 C7F8EC30 		str	r3, [r7, #236]
 12297              		.loc 2 2970 22
 12298 06fa D7F82031 		ldr	r3, [r7, #288]
 12299 06fe 9B00     		lsls	r3, r3, #2
 12300              		.loc 2 2970 17
 12301 0700 D7F81C21 		ldr	r2, [r7, #284]
 12302 0704 1344     		add	r3, r3, r2
 12303 0706 C7F80831 		str	r3, [r7, #264]
 12304              		.loc 2 2970 34
 12305 070a D7F82031 		ldr	r3, [r7, #288]
 12306 070e 9B00     		lsls	r3, r3, #2
 12307              		.loc 2 2970 29
 12308 0710 D7F81821 		ldr	r2, [r7, #280]
 12309 0714 1344     		add	r3, r3, r2
 12310 0716 C7F80431 		str	r3, [r7, #260]
 12311              		.loc 2 2970 3
 12312 071a 9AE0     		b	.L269
 12313              	.L270:
 12314              	.LBB45:
2971:keygen.c      **** 			v ++, x += (llen << 1), y += (llen << 1))
2972:keygen.c      **** 		{
2973:keygen.c      **** 			uint32_t ftA, ftB, gtA, gtB;
2974:keygen.c      **** 			uint32_t mFp, mGp;
2975:keygen.c      **** 
2976:keygen.c      **** 			ftA = fx[(v << 1) + 0];
 12315              		.loc 2 2976 12
 12316 071c D7F8EC30 		ldr	r3, [r7, #236]
 12317 0720 DB00     		lsls	r3, r3, #3
 12318 0722 BA6C     		ldr	r2, [r7, #72]
 12319 0724 1344     		add	r3, r3, r2
 12320              		.loc 2 2976 8
 12321 0726 1B68     		ldr	r3, [r3]
 12322 0728 7B63     		str	r3, [r7, #52]
2977:keygen.c      **** 			ftB = fx[(v << 1) + 1];
 12323              		.loc 2 2977 12
 12324 072a D7F8EC30 		ldr	r3, [r7, #236]
 12325 072e DB00     		lsls	r3, r3, #3
 12326 0730 0433     		adds	r3, r3, #4
 12327 0732 BA6C     		ldr	r2, [r7, #72]
 12328 0734 1344     		add	r3, r3, r2
 12329              		.loc 2 2977 8
 12330 0736 1B68     		ldr	r3, [r3]
 12331 0738 3B63     		str	r3, [r7, #48]
2978:keygen.c      **** 			gtA = gx[(v << 1) + 0];
 12332              		.loc 2 2978 12
 12333 073a D7F8EC30 		ldr	r3, [r7, #236]
 12334 073e DB00     		lsls	r3, r3, #3
 12335 0740 7A6C     		ldr	r2, [r7, #68]
 12336 0742 1344     		add	r3, r3, r2
 12337              		.loc 2 2978 8
 12338 0744 1B68     		ldr	r3, [r3]
 12339 0746 FB62     		str	r3, [r7, #44]
2979:keygen.c      **** 			gtB = gx[(v << 1) + 1];
 12340              		.loc 2 2979 12
 12341 0748 D7F8EC30 		ldr	r3, [r7, #236]
 12342 074c DB00     		lsls	r3, r3, #3
 12343 074e 0433     		adds	r3, r3, #4
 12344 0750 7A6C     		ldr	r2, [r7, #68]
 12345 0752 1A44     		add	r2, r2, r3
 12346              		.loc 2 2979 8
 12347 0754 07F59473 		add	r3, r7, #296
 12348 0758 A3F58073 		sub	r3, r3, #256
 12349 075c 1268     		ldr	r2, [r2]
 12350 075e 1A60     		str	r2, [r3]
2980:keygen.c      **** 			mFp = modp_montymul(Fp[v], R2, p, p0i);
 12351              		.loc 2 2980 26
 12352 0760 D7F8EC30 		ldr	r3, [r7, #236]
 12353 0764 9B00     		lsls	r3, r3, #2
 12354 0766 FA6B     		ldr	r2, [r7, #60]
 12355 0768 1344     		add	r3, r3, r2
 12356              		.loc 2 2980 10
 12357 076a 1868     		ldr	r0, [r3]
 12358 076c 07F59473 		add	r3, r7, #296
 12359 0770 A3F58274 		sub	r4, r3, #260
 12360 0774 BB6D     		ldr	r3, [r7, #88]
 12361 0776 FA6D     		ldr	r2, [r7, #92]
 12362 0778 796D     		ldr	r1, [r7, #84]
 12363 077a FFF7FEFF 		bl	modp_montymul
 12364 077e 2060     		str	r0, [r4]
2981:keygen.c      **** 			mGp = modp_montymul(Gp[v], R2, p, p0i);
 12365              		.loc 2 2981 26
 12366 0780 D7F8EC30 		ldr	r3, [r7, #236]
 12367 0784 9B00     		lsls	r3, r3, #2
 12368 0786 BA6B     		ldr	r2, [r7, #56]
 12369 0788 1344     		add	r3, r3, r2
 12370              		.loc 2 2981 10
 12371 078a 1868     		ldr	r0, [r3]
 12372 078c 07F59473 		add	r3, r7, #296
 12373 0790 A3F58474 		sub	r4, r3, #264
 12374 0794 BB6D     		ldr	r3, [r7, #88]
 12375 0796 FA6D     		ldr	r2, [r7, #92]
 12376 0798 796D     		ldr	r1, [r7, #84]
 12377 079a FFF7FEFF 		bl	modp_montymul
 12378 079e 2060     		str	r0, [r4]
2982:keygen.c      **** 			x[0] = modp_montymul(gtB, mFp, p, p0i);
 12379              		.loc 2 2982 11
 12380 07a0 07F59473 		add	r3, r7, #296
 12381 07a4 A3F58271 		sub	r1, r3, #260
 12382 07a8 07F59473 		add	r3, r7, #296
 12383 07ac A3F58070 		sub	r0, r3, #256
 12384 07b0 BB6D     		ldr	r3, [r7, #88]
 12385 07b2 FA6D     		ldr	r2, [r7, #92]
 12386 07b4 0968     		ldr	r1, [r1]
 12387 07b6 0068     		ldr	r0, [r0]
 12388 07b8 FFF7FEFF 		bl	modp_montymul
 12389 07bc 0246     		mov	r2, r0
 12390              		.loc 2 2982 9
 12391 07be D7F80831 		ldr	r3, [r7, #264]
 12392 07c2 1A60     		str	r2, [r3]
2983:keygen.c      **** 			x[llen] = modp_montymul(gtA, mFp, p, p0i);
 12393              		.loc 2 2983 5
 12394 07c4 D7F8BC30 		ldr	r3, [r7, #188]
 12395 07c8 9B00     		lsls	r3, r3, #2
 12396 07ca D7F80821 		ldr	r2, [r7, #264]
 12397 07ce D418     		adds	r4, r2, r3
 12398              		.loc 2 2983 14
 12399 07d0 07F59473 		add	r3, r7, #296
 12400 07d4 A3F58271 		sub	r1, r3, #260
 12401 07d8 BB6D     		ldr	r3, [r7, #88]
 12402 07da FA6D     		ldr	r2, [r7, #92]
 12403 07dc 0968     		ldr	r1, [r1]
 12404 07de F86A     		ldr	r0, [r7, #44]
 12405 07e0 FFF7FEFF 		bl	modp_montymul
 12406 07e4 0346     		mov	r3, r0
 12407              		.loc 2 2983 12
 12408 07e6 2360     		str	r3, [r4]
2984:keygen.c      **** 			y[0] = modp_montymul(ftB, mGp, p, p0i);
 12409              		.loc 2 2984 11
 12410 07e8 07F59473 		add	r3, r7, #296
 12411 07ec A3F58471 		sub	r1, r3, #264
 12412 07f0 BB6D     		ldr	r3, [r7, #88]
 12413 07f2 FA6D     		ldr	r2, [r7, #92]
 12414 07f4 0968     		ldr	r1, [r1]
 12415 07f6 386B     		ldr	r0, [r7, #48]
 12416 07f8 FFF7FEFF 		bl	modp_montymul
 12417 07fc 0246     		mov	r2, r0
 12418              		.loc 2 2984 9
 12419 07fe D7F80431 		ldr	r3, [r7, #260]
 12420 0802 1A60     		str	r2, [r3]
2985:keygen.c      **** 			y[llen] = modp_montymul(ftA, mGp, p, p0i);
 12421              		.loc 2 2985 5
 12422 0804 D7F8BC30 		ldr	r3, [r7, #188]
 12423 0808 9B00     		lsls	r3, r3, #2
 12424 080a D7F80421 		ldr	r2, [r7, #260]
 12425 080e D418     		adds	r4, r2, r3
 12426              		.loc 2 2985 14
 12427 0810 07F59473 		add	r3, r7, #296
 12428 0814 A3F58471 		sub	r1, r3, #264
 12429 0818 BB6D     		ldr	r3, [r7, #88]
 12430 081a FA6D     		ldr	r2, [r7, #92]
 12431 081c 0968     		ldr	r1, [r1]
 12432 081e 786B     		ldr	r0, [r7, #52]
 12433 0820 FFF7FEFF 		bl	modp_montymul
 12434 0824 0346     		mov	r3, r0
 12435              		.loc 2 2985 12
 12436 0826 2360     		str	r3, [r4]
 12437              	.LBE45:
2971:keygen.c      **** 		{
 12438              		.loc 2 2971 6
 12439 0828 D7F8EC30 		ldr	r3, [r7, #236]
 12440 082c 0133     		adds	r3, r3, #1
 12441 082e C7F8EC30 		str	r3, [r7, #236]
2971:keygen.c      **** 		{
 12442              		.loc 2 2971 12
 12443 0832 D7F8BC30 		ldr	r3, [r7, #188]
 12444 0836 DB00     		lsls	r3, r3, #3
 12445 0838 D7F80821 		ldr	r2, [r7, #264]
 12446 083c 1344     		add	r3, r3, r2
 12447 083e C7F80831 		str	r3, [r7, #264]
2971:keygen.c      **** 		{
 12448              		.loc 2 2971 30
 12449 0842 D7F8BC30 		ldr	r3, [r7, #188]
 12450 0846 DB00     		lsls	r3, r3, #3
 12451 0848 D7F80421 		ldr	r2, [r7, #260]
 12452 084c 1344     		add	r3, r3, r2
 12453 084e C7F80431 		str	r3, [r7, #260]
 12454              	.L269:
2970:keygen.c      **** 			v ++, x += (llen << 1), y += (llen << 1))
 12455              		.loc 2 2970 3 discriminator 1
 12456 0852 D7F8EC20 		ldr	r2, [r7, #236]
 12457 0856 D7F8C830 		ldr	r3, [r7, #200]
 12458 085a 9A42     		cmp	r2, r3
 12459 085c FFF45EAF 		bcc	.L270
2986:keygen.c      **** 		}
2987:keygen.c      **** 		modp_iNTT2_ext(Ft + u, llen, igm, logn, p, p0i);
 12460              		.loc 2 2987 21 discriminator 2
 12461 0860 D7F82031 		ldr	r3, [r7, #288]
 12462 0864 9B00     		lsls	r3, r3, #2
 12463              		.loc 2 2987 3 discriminator 2
 12464 0866 D7F81C21 		ldr	r2, [r7, #284]
 12465 086a D018     		adds	r0, r2, r3
 12466 086c BB6D     		ldr	r3, [r7, #88]
 12467 086e 0193     		str	r3, [sp, #4]
 12468 0870 FB6D     		ldr	r3, [r7, #92]
 12469 0872 0093     		str	r3, [sp]
 12470 0874 D7F8D030 		ldr	r3, [r7, #208]
 12471 0878 FA6C     		ldr	r2, [r7, #76]
 12472 087a D7F8BC10 		ldr	r1, [r7, #188]
 12473 087e FFF7FEFF 		bl	modp_iNTT2_ext
2988:keygen.c      **** 		modp_iNTT2_ext(Gt + u, llen, igm, logn, p, p0i);
 12474              		.loc 2 2988 21 discriminator 2
 12475 0882 D7F82031 		ldr	r3, [r7, #288]
 12476 0886 9B00     		lsls	r3, r3, #2
 12477              		.loc 2 2988 3 discriminator 2
 12478 0888 D7F81821 		ldr	r2, [r7, #280]
 12479 088c D018     		adds	r0, r2, r3
 12480 088e BB6D     		ldr	r3, [r7, #88]
 12481 0890 0193     		str	r3, [sp, #4]
 12482 0892 FB6D     		ldr	r3, [r7, #92]
 12483 0894 0093     		str	r3, [sp]
 12484 0896 D7F8D030 		ldr	r3, [r7, #208]
 12485 089a FA6C     		ldr	r2, [r7, #76]
 12486 089c D7F8BC10 		ldr	r1, [r7, #188]
 12487 08a0 FFF7FEFF 		bl	modp_iNTT2_ext
 12488              	.LBE43:
2871:keygen.c      **** 		uint32_t p, p0i, R2;
 12489              		.loc 2 2871 26 discriminator 2
 12490 08a4 D7F82031 		ldr	r3, [r7, #288]
 12491 08a8 0133     		adds	r3, r3, #1
 12492 08aa C7F82031 		str	r3, [r7, #288]
 12493              	.L259:
2871:keygen.c      **** 		uint32_t p, p0i, R2;
 12494              		.loc 2 2871 2 discriminator 1
 12495 08ae D7F82021 		ldr	r2, [r7, #288]
 12496 08b2 D7F8BC30 		ldr	r3, [r7, #188]
 12497 08b6 9A42     		cmp	r2, r3
 12498 08b8 FFF476AD 		bcc	.L271
2989:keygen.c      **** 	}
2990:keygen.c      **** 
2991:keygen.c      **** 	/*
2992:keygen.c      **** 	 * Rebuild F and G with the CRT.
2993:keygen.c      **** 	 */
2994:keygen.c      **** 	zint_rebuild_CRT(Ft, llen, llen, n, primes, 1, t1);
 12499              		.loc 2 2994 2
 12500 08bc D7F8A830 		ldr	r3, [r7, #168]
 12501 08c0 0293     		str	r3, [sp, #8]
 12502 08c2 0123     		movs	r3, #1
 12503 08c4 0193     		str	r3, [sp, #4]
 12504 08c6 D7F8B830 		ldr	r3, [r7, #184]
 12505 08ca 0093     		str	r3, [sp]
 12506 08cc D7F8CC30 		ldr	r3, [r7, #204]
 12507 08d0 D7F8BC20 		ldr	r2, [r7, #188]
 12508 08d4 D7F8BC10 		ldr	r1, [r7, #188]
 12509 08d8 D7F81C01 		ldr	r0, [r7, #284]
 12510 08dc FFF7FEFF 		bl	zint_rebuild_CRT
2995:keygen.c      **** 	zint_rebuild_CRT(Gt, llen, llen, n, primes, 1, t1);
 12511              		.loc 2 2995 2
 12512 08e0 D7F8A830 		ldr	r3, [r7, #168]
 12513 08e4 0293     		str	r3, [sp, #8]
 12514 08e6 0123     		movs	r3, #1
 12515 08e8 0193     		str	r3, [sp, #4]
 12516 08ea D7F8B830 		ldr	r3, [r7, #184]
 12517 08ee 0093     		str	r3, [sp]
 12518 08f0 D7F8CC30 		ldr	r3, [r7, #204]
 12519 08f4 D7F8BC20 		ldr	r2, [r7, #188]
 12520 08f8 D7F8BC10 		ldr	r1, [r7, #188]
 12521 08fc D7F81801 		ldr	r0, [r7, #280]
 12522 0900 FFF7FEFF 		bl	zint_rebuild_CRT
2996:keygen.c      **** 
2997:keygen.c      **** 	/*
2998:keygen.c      **** 	 * At that point, Ft, Gt, ft and gt are consecutive in RAM (in that
2999:keygen.c      **** 	 * order).
3000:keygen.c      **** 	 */
3001:keygen.c      **** 
3002:keygen.c      **** 	/*
3003:keygen.c      **** 	 * Apply Babai reduction to bring back F and G to size slen.
3004:keygen.c      **** 	 *
3005:keygen.c      **** 	 * We use the FFT to compute successive approximations of the
3006:keygen.c      **** 	 * reduction coefficient. We first isolate the top bits of
3007:keygen.c      **** 	 * the coefficients of f and g, and convert them to floating
3008:keygen.c      **** 	 * point; with the FFT, we compute adj(f), adj(g), and
3009:keygen.c      **** 	 * 1/(f*adj(f)+g*adj(g)).
3010:keygen.c      **** 	 *
3011:keygen.c      **** 	 * Then, we repeatedly apply the following:
3012:keygen.c      **** 	 *
3013:keygen.c      **** 	 *   - Get the top bits of the coefficients of F and G into
3014:keygen.c      **** 	 *     floating point, and use the FFT to compute:
3015:keygen.c      **** 	 *        (F*adj(f)+G*adj(g))/(f*adj(f)+g*adj(g))
3016:keygen.c      **** 	 *
3017:keygen.c      **** 	 *   - Convert back that value into normal representation, and
3018:keygen.c      **** 	 *     round it to the nearest integers, yielding a polynomial k.
3019:keygen.c      **** 	 *     Proper scaling is applied to f, g, F and G so that the
3020:keygen.c      **** 	 *     coefficients fit on 32 bits (signed).
3021:keygen.c      **** 	 *
3022:keygen.c      **** 	 *   - Subtract k*f from F and k*g from G.
3023:keygen.c      **** 	 *
3024:keygen.c      **** 	 * Under normal conditions, this process reduces the size of F
3025:keygen.c      **** 	 * and G by some bits at each iteration. For constant-time
3026:keygen.c      **** 	 * operation, we do not want to measure the actual length of
3027:keygen.c      **** 	 * F and G; instead, we do the following:
3028:keygen.c      **** 	 *
3029:keygen.c      **** 	 *   - f and g are converted to floating-point, with some scaling
3030:keygen.c      **** 	 *     if necessary to keep values in the representable range.
3031:keygen.c      **** 	 *
3032:keygen.c      **** 	 *   - For each iteration, we _assume_ a maximum size for F and G,
3033:keygen.c      **** 	 *     and use the values at that size. If we overreach, then
3034:keygen.c      **** 	 *     we get zeros, which is harmless: the resulting coefficients
3035:keygen.c      **** 	 *     of k will be 0 and the value won't be reduced.
3036:keygen.c      **** 	 *
3037:keygen.c      **** 	 *   - We conservatively assume that F and G will be reduced by
3038:keygen.c      **** 	 *     at least 25 bits at each iteration.
3039:keygen.c      **** 	 *
3040:keygen.c      **** 	 * Even when reaching the bottom of the reduction, reduction
3041:keygen.c      **** 	 * coefficient will remain low. If it goes out-of-range, then
3042:keygen.c      **** 	 * something wrong occurred and the whole NTRU solving fails.
3043:keygen.c      **** 	 */
3044:keygen.c      **** 
3045:keygen.c      **** 	/*
3046:keygen.c      **** 	 * Memory layout:
3047:keygen.c      **** 	 *  - We need to compute and keep adj(f), adj(g), and
3048:keygen.c      **** 	 *    1/(f*adj(f)+g*adj(g)) (sizes N, N and N/2 fp numbers,
3049:keygen.c      **** 	 *    respectively).
3050:keygen.c      **** 	 *  - At each iteration we need two extra fp buffer (N fp values),
3051:keygen.c      **** 	 *    and produce a k (N 32-bit words). k will be shared with one
3052:keygen.c      **** 	 *    of the fp buffers.
3053:keygen.c      **** 	 *  - To compute k*f and k*g efficiently (with the NTT), we need
3054:keygen.c      **** 	 *    some extra room; we reuse the space of the temporary buffers.
3055:keygen.c      **** 	 *
3056:keygen.c      **** 	 * Arrays of 'fpr' are obtained from the temporary array itself.
3057:keygen.c      **** 	 * We ensure that the base is at a properly aligned offset (the
3058:keygen.c      **** 	 * source array tmp[] is supposed to be already aligned).
3059:keygen.c      **** 	 */
3060:keygen.c      **** 
3061:keygen.c      **** 	rt3 = align_fpr(tmp, t1);
 12523              		.loc 2 3061 8
 12524 0904 D7F8A810 		ldr	r1, [r7, #168]
 12525 0908 D7F83801 		ldr	r0, [r7, #312]
 12526 090c FFF7FEFF 		bl	align_fpr
 12527 0910 C7F8A000 		str	r0, [r7, #160]
3062:keygen.c      **** 	rt4 = rt3 + n;
 12528              		.loc 2 3062 12
 12529 0914 D7F8CC30 		ldr	r3, [r7, #204]
 12530 0918 DB00     		lsls	r3, r3, #3
 12531              		.loc 2 3062 6
 12532 091a D7F8A020 		ldr	r2, [r7, #160]
 12533 091e 1344     		add	r3, r3, r2
 12534 0920 C7F89C30 		str	r3, [r7, #156]
3063:keygen.c      **** 	rt5 = rt4 + n;
 12535              		.loc 2 3063 12
 12536 0924 D7F8CC30 		ldr	r3, [r7, #204]
 12537 0928 DB00     		lsls	r3, r3, #3
 12538              		.loc 2 3063 6
 12539 092a D7F89C20 		ldr	r2, [r7, #156]
 12540 092e 1344     		add	r3, r3, r2
 12541 0930 C7F89830 		str	r3, [r7, #152]
3064:keygen.c      **** 	rt1 = rt5 + (n >> 1);
 12542              		.loc 2 3064 17
 12543 0934 D7F8CC30 		ldr	r3, [r7, #204]
 12544 0938 5B08     		lsrs	r3, r3, #1
 12545              		.loc 2 3064 12
 12546 093a DB00     		lsls	r3, r3, #3
 12547              		.loc 2 3064 6
 12548 093c D7F89820 		ldr	r2, [r7, #152]
 12549 0940 1344     		add	r3, r3, r2
 12550 0942 C7F89430 		str	r3, [r7, #148]
3065:keygen.c      **** 	k = (int32_t *)align_u32(tmp, rt1);
 12551              		.loc 2 3065 17
 12552 0946 D7F89410 		ldr	r1, [r7, #148]
 12553 094a D7F83801 		ldr	r0, [r7, #312]
 12554 094e FFF7FEFF 		bl	align_u32
 12555 0952 C7F89000 		str	r0, [r7, #144]
3066:keygen.c      **** 	rt2 = align_fpr(tmp, k + n);
 12556              		.loc 2 3066 25
 12557 0956 D7F8CC30 		ldr	r3, [r7, #204]
 12558 095a 9B00     		lsls	r3, r3, #2
 12559 095c D7F89020 		ldr	r2, [r7, #144]
 12560 0960 1344     		add	r3, r3, r2
 12561              		.loc 2 3066 8
 12562 0962 1946     		mov	r1, r3
 12563 0964 D7F83801 		ldr	r0, [r7, #312]
 12564 0968 FFF7FEFF 		bl	align_fpr
 12565 096c C7F81401 		str	r0, [r7, #276]
3067:keygen.c      **** 	if (rt2 < (rt1 + n)) {
 12566              		.loc 2 3067 17
 12567 0970 D7F8CC30 		ldr	r3, [r7, #204]
 12568 0974 DB00     		lsls	r3, r3, #3
 12569 0976 D7F89420 		ldr	r2, [r7, #148]
 12570 097a 1344     		add	r3, r3, r2
 12571              		.loc 2 3067 5
 12572 097c D7F81421 		ldr	r2, [r7, #276]
 12573 0980 9A42     		cmp	r2, r3
 12574 0982 07D2     		bcs	.L272
3068:keygen.c      **** 		rt2 = rt1 + n;
 12575              		.loc 2 3068 13
 12576 0984 D7F8CC30 		ldr	r3, [r7, #204]
 12577 0988 DB00     		lsls	r3, r3, #3
 12578              		.loc 2 3068 7
 12579 098a D7F89420 		ldr	r2, [r7, #148]
 12580 098e 1344     		add	r3, r3, r2
 12581 0990 C7F81431 		str	r3, [r7, #276]
 12582              	.L272:
3069:keygen.c      **** 	}
3070:keygen.c      **** 	t1 = (uint32_t *)k + n;
 12583              		.loc 2 3070 21
 12584 0994 D7F8CC30 		ldr	r3, [r7, #204]
 12585 0998 9B00     		lsls	r3, r3, #2
 12586              		.loc 2 3070 5
 12587 099a D7F89020 		ldr	r2, [r7, #144]
 12588 099e 1344     		add	r3, r3, r2
 12589 09a0 C7F8A830 		str	r3, [r7, #168]
3071:keygen.c      **** 
3072:keygen.c      **** 	/*
3073:keygen.c      **** 	 * Get f and g into rt3 and rt4 as floating-point approximations.
3074:keygen.c      **** 	 *
3075:keygen.c      **** 	 * We need to "scale down" the floating-point representation of
3076:keygen.c      **** 	 * coefficients when they are too big. We want to keep the value
3077:keygen.c      **** 	 * below 2^310 or so. Thus, when values are larger than 10 words,
3078:keygen.c      **** 	 * we consider only the top 10 words. Array lengths have been
3079:keygen.c      **** 	 * computed so that average maximum length will fall in the
3080:keygen.c      **** 	 * middle or the upper half of these top 10 words.
3081:keygen.c      **** 	 */
3082:keygen.c      **** 	rlen = (slen > 10) ? 10 : slen;
 12590              		.loc 2 3082 7
 12591 09a4 D7F8C430 		ldr	r3, [r7, #196]
 12592 09a8 0A2B     		cmp	r3, #10
 12593 09aa 28BF     		it	cs
 12594 09ac 0A23     		movcs	r3, #10
 12595 09ae C7F88C30 		str	r3, [r7, #140]
3083:keygen.c      **** 	poly_big_to_fp(rt3, ft + slen - rlen, rlen, slen, logn);
 12596              		.loc 2 3083 32
 12597 09b2 D7F8C420 		ldr	r2, [r7, #196]
 12598 09b6 D7F88C30 		ldr	r3, [r7, #140]
 12599 09ba D31A     		subs	r3, r2, r3
 12600 09bc 9B00     		lsls	r3, r3, #2
 12601 09be D7F8AC20 		ldr	r2, [r7, #172]
 12602 09c2 D118     		adds	r1, r2, r3
 12603              		.loc 2 3083 2
 12604 09c4 D7F8D030 		ldr	r3, [r7, #208]
 12605 09c8 0093     		str	r3, [sp]
 12606 09ca D7F8C430 		ldr	r3, [r7, #196]
 12607 09ce D7F88C20 		ldr	r2, [r7, #140]
 12608 09d2 D7F8A000 		ldr	r0, [r7, #160]
 12609 09d6 FFF7FEFF 		bl	poly_big_to_fp
3084:keygen.c      **** 	poly_big_to_fp(rt4, gt + slen - rlen, rlen, slen, logn);
 12610              		.loc 2 3084 32
 12611 09da D7F8C420 		ldr	r2, [r7, #196]
 12612 09de D7F88C30 		ldr	r3, [r7, #140]
 12613 09e2 D31A     		subs	r3, r2, r3
 12614 09e4 9B00     		lsls	r3, r3, #2
 12615 09e6 D7F8A420 		ldr	r2, [r7, #164]
 12616 09ea D118     		adds	r1, r2, r3
 12617              		.loc 2 3084 2
 12618 09ec D7F8D030 		ldr	r3, [r7, #208]
 12619 09f0 0093     		str	r3, [sp]
 12620 09f2 D7F8C430 		ldr	r3, [r7, #196]
 12621 09f6 D7F88C20 		ldr	r2, [r7, #140]
 12622 09fa D7F89C00 		ldr	r0, [r7, #156]
 12623 09fe FFF7FEFF 		bl	poly_big_to_fp
3085:keygen.c      **** 
3086:keygen.c      **** 	/*
3087:keygen.c      **** 	 * Values in rt3 and rt4 are downscaled by 2^(scale_fg).
3088:keygen.c      **** 	 */
3089:keygen.c      **** 	scale_fg = 31 * (int)(slen - rlen);
 12624              		.loc 2 3089 29
 12625 0a02 D7F8C420 		ldr	r2, [r7, #196]
 12626 0a06 D7F88C30 		ldr	r3, [r7, #140]
 12627 0a0a D31A     		subs	r3, r2, r3
 12628              		.loc 2 3089 18
 12629 0a0c 1A46     		mov	r2, r3
 12630              		.loc 2 3089 11
 12631 0a0e 1346     		mov	r3, r2
 12632 0a10 5B01     		lsls	r3, r3, #5
 12633 0a12 9B1A     		subs	r3, r3, r2
 12634 0a14 C7F88830 		str	r3, [r7, #136]
3090:keygen.c      **** 
3091:keygen.c      **** 	/*
3092:keygen.c      **** 	 * Estimated boundaries for the maximum size (in bits) of the
3093:keygen.c      **** 	 * coefficients of (f,g). We use the measured average, and
3094:keygen.c      **** 	 * allow for a deviation of at most six times the standard
3095:keygen.c      **** 	 * deviation.
3096:keygen.c      **** 	 */
3097:keygen.c      **** 	minbl_fg = BITLENGTH[depth].avg - 6 * BITLENGTH[depth].std;
 12635              		.loc 2 3097 29
 12636 0a18 9F4A     		ldr	r2, .L303+16
 12637 0a1a 07F59473 		add	r3, r7, #296
 12638 0a1e A3F59473 		sub	r3, r3, #296
 12639 0a22 1B68     		ldr	r3, [r3]
 12640 0a24 52F83310 		ldr	r1, [r2, r3, lsl #3]
 12641              		.loc 2 3097 56
 12642 0a28 9B4A     		ldr	r2, .L303+16
 12643 0a2a 07F59473 		add	r3, r7, #296
 12644 0a2e A3F59473 		sub	r3, r3, #296
 12645 0a32 1B68     		ldr	r3, [r3]
 12646 0a34 DB00     		lsls	r3, r3, #3
 12647 0a36 1344     		add	r3, r3, r2
 12648 0a38 5A68     		ldr	r2, [r3, #4]
 12649              		.loc 2 3097 38
 12650 0a3a 1346     		mov	r3, r2
 12651 0a3c 9200     		lsls	r2, r2, #2
 12652 0a3e 9B1A     		subs	r3, r3, r2
 12653 0a40 5B00     		lsls	r3, r3, #1
 12654              		.loc 2 3097 11
 12655 0a42 0B44     		add	r3, r3, r1
 12656 0a44 C7F88430 		str	r3, [r7, #132]
3098:keygen.c      **** 	maxbl_fg = BITLENGTH[depth].avg + 6 * BITLENGTH[depth].std;
 12657              		.loc 2 3098 29
 12658 0a48 934A     		ldr	r2, .L303+16
 12659 0a4a 07F59473 		add	r3, r7, #296
 12660 0a4e A3F59473 		sub	r3, r3, #296
 12661 0a52 1B68     		ldr	r3, [r3]
 12662 0a54 52F83310 		ldr	r1, [r2, r3, lsl #3]
 12663              		.loc 2 3098 56
 12664 0a58 8F4A     		ldr	r2, .L303+16
 12665 0a5a 07F59473 		add	r3, r7, #296
 12666 0a5e A3F59473 		sub	r3, r3, #296
 12667 0a62 1B68     		ldr	r3, [r3]
 12668 0a64 DB00     		lsls	r3, r3, #3
 12669 0a66 1344     		add	r3, r3, r2
 12670 0a68 5A68     		ldr	r2, [r3, #4]
 12671              		.loc 2 3098 38
 12672 0a6a 1346     		mov	r3, r2
 12673 0a6c 5B00     		lsls	r3, r3, #1
 12674 0a6e 1344     		add	r3, r3, r2
 12675 0a70 5B00     		lsls	r3, r3, #1
 12676              		.loc 2 3098 11
 12677 0a72 0B44     		add	r3, r3, r1
 12678 0a74 C7F88030 		str	r3, [r7, #128]
3099:keygen.c      **** 
3100:keygen.c      **** 	/*
3101:keygen.c      **** 	 * Compute 1/(f*adj(f)+g*adj(g)) in rt5. We also keep adj(f)
3102:keygen.c      **** 	 * and adj(g) in rt3 and rt4, respectively.
3103:keygen.c      **** 	 */
3104:keygen.c      **** 	Zf(FFT)(rt3, logn);
 12679              		.loc 2 3104 2
 12680 0a78 D7F8D010 		ldr	r1, [r7, #208]
 12681 0a7c D7F8A000 		ldr	r0, [r7, #160]
 12682 0a80 FFF7FEFF 		bl	falcon_inner_FFT
3105:keygen.c      **** 	Zf(FFT)(rt4, logn);
 12683              		.loc 2 3105 2
 12684 0a84 D7F8D010 		ldr	r1, [r7, #208]
 12685 0a88 D7F89C00 		ldr	r0, [r7, #156]
 12686 0a8c FFF7FEFF 		bl	falcon_inner_FFT
3106:keygen.c      **** 	Zf(poly_invnorm2_fft)(rt5, rt3, rt4, logn);
 12687              		.loc 2 3106 2
 12688 0a90 D7F8D030 		ldr	r3, [r7, #208]
 12689 0a94 D7F89C20 		ldr	r2, [r7, #156]
 12690 0a98 D7F8A010 		ldr	r1, [r7, #160]
 12691 0a9c D7F89800 		ldr	r0, [r7, #152]
 12692 0aa0 FFF7FEFF 		bl	falcon_inner_poly_invnorm2_fft
3107:keygen.c      **** 	Zf(poly_adj_fft)(rt3, logn);
 12693              		.loc 2 3107 2
 12694 0aa4 D7F8D010 		ldr	r1, [r7, #208]
 12695 0aa8 D7F8A000 		ldr	r0, [r7, #160]
 12696 0aac FFF7FEFF 		bl	falcon_inner_poly_adj_fft
3108:keygen.c      **** 	Zf(poly_adj_fft)(rt4, logn);
 12697              		.loc 2 3108 2
 12698 0ab0 D7F8D010 		ldr	r1, [r7, #208]
 12699 0ab4 D7F89C00 		ldr	r0, [r7, #156]
 12700 0ab8 FFF7FEFF 		bl	falcon_inner_poly_adj_fft
3109:keygen.c      **** 
3110:keygen.c      **** 	/*
3111:keygen.c      **** 	 * Reduce F and G repeatedly.
3112:keygen.c      **** 	 *
3113:keygen.c      **** 	 * The expected maximum bit length of coefficients of F and G
3114:keygen.c      **** 	 * is kept in maxbl_FG, with the corresponding word length in
3115:keygen.c      **** 	 * FGlen.
3116:keygen.c      **** 	 */
3117:keygen.c      **** 	FGlen = llen;
 12701              		.loc 2 3117 8
 12702 0abc D7F8BC30 		ldr	r3, [r7, #188]
 12703 0ac0 C7F82431 		str	r3, [r7, #292]
3118:keygen.c      **** 	maxbl_FG = 31 * (int)llen;
 12704              		.loc 2 3118 18
 12705 0ac4 D7F8BC20 		ldr	r2, [r7, #188]
 12706              		.loc 2 3118 11
 12707 0ac8 1346     		mov	r3, r2
 12708 0aca 5B01     		lsls	r3, r3, #5
 12709 0acc 9B1A     		subs	r3, r3, r2
 12710 0ace C7F81031 		str	r3, [r7, #272]
3119:keygen.c      **** 
3120:keygen.c      **** 	/*
3121:keygen.c      **** 	 * Each reduction operation computes the reduction polynomial
3122:keygen.c      **** 	 * "k". We need that polynomial to have coefficients that fit
3123:keygen.c      **** 	 * on 32-bit signed integers, with some scaling; thus, we use
3124:keygen.c      **** 	 * a descending sequence of scaling values, down to zero.
3125:keygen.c      **** 	 *
3126:keygen.c      **** 	 * The size of the coefficients of k is (roughly) the difference
3127:keygen.c      **** 	 * between the size of the coefficients of (F,G) and the size
3128:keygen.c      **** 	 * of the coefficients of (f,g). Thus, the maximum size of the
3129:keygen.c      **** 	 * coefficients of k is, at the start, maxbl_FG - minbl_fg;
3130:keygen.c      **** 	 * this is our starting scale value for k.
3131:keygen.c      **** 	 *
3132:keygen.c      **** 	 * We need to estimate the size of (F,G) during the execution of
3133:keygen.c      **** 	 * the algorithm; we are allowed some overestimation but not too
3134:keygen.c      **** 	 * much (poly_big_to_fp() uses a 310-bit window). Generally
3135:keygen.c      **** 	 * speaking, after applying a reduction with k scaled to
3136:keygen.c      **** 	 * scale_k, the size of (F,G) will be size(f,g) + scale_k + dd,
3137:keygen.c      **** 	 * where 'dd' is a few bits to account for the fact that the
3138:keygen.c      **** 	 * reduction is never perfect (intuitively, dd is on the order
3139:keygen.c      **** 	 * of sqrt(N), so at most 5 bits; we here allow for 10 extra
3140:keygen.c      **** 	 * bits).
3141:keygen.c      **** 	 *
3142:keygen.c      **** 	 * The size of (f,g) is not known exactly, but maxbl_fg is an
3143:keygen.c      **** 	 * upper bound.
3144:keygen.c      **** 	 */
3145:keygen.c      **** 	scale_k = maxbl_FG - minbl_fg;
 12711              		.loc 2 3145 10
 12712 0ad2 D7F81021 		ldr	r2, [r7, #272]
 12713 0ad6 D7F88430 		ldr	r3, [r7, #132]
 12714 0ada D31A     		subs	r3, r2, r3
 12715 0adc C7F80C31 		str	r3, [r7, #268]
 12716              	.L289:
 12717              	.LBB46:
3146:keygen.c      **** 
3147:keygen.c      **** 	for (;;) {
3148:keygen.c      **** 		int scale_FG, dc, new_maxbl_FG;
3149:keygen.c      **** 		uint32_t scl, sch;
3150:keygen.c      **** 		fpr pdc, pt;
3151:keygen.c      **** 
3152:keygen.c      **** 		/*
3153:keygen.c      **** 		 * Convert current F and G into floating-point. We apply
3154:keygen.c      **** 		 * scaling if the current length is more than 10 words.
3155:keygen.c      **** 		 */
3156:keygen.c      **** 		rlen = (FGlen > 10) ? 10 : FGlen;
 12718              		.loc 2 3156 8
 12719 0ae0 D7F82431 		ldr	r3, [r7, #292]
 12720 0ae4 0A2B     		cmp	r3, #10
 12721 0ae6 28BF     		it	cs
 12722 0ae8 0A23     		movcs	r3, #10
 12723 0aea C7F88C30 		str	r3, [r7, #140]
3157:keygen.c      **** 		scale_FG = 31 * (int)(FGlen - rlen);
 12724              		.loc 2 3157 31
 12725 0aee D7F82421 		ldr	r2, [r7, #292]
 12726 0af2 D7F88C30 		ldr	r3, [r7, #140]
 12727 0af6 D31A     		subs	r3, r2, r3
 12728              		.loc 2 3157 19
 12729 0af8 1A46     		mov	r2, r3
 12730              		.loc 2 3157 12
 12731 0afa 1346     		mov	r3, r2
 12732 0afc 5B01     		lsls	r3, r3, #5
 12733 0afe 9B1A     		subs	r3, r3, r2
 12734 0b00 FB67     		str	r3, [r7, #124]
3158:keygen.c      **** 		poly_big_to_fp(rt1, Ft + FGlen - rlen, rlen, llen, logn);
 12735              		.loc 2 3158 34
 12736 0b02 D7F82421 		ldr	r2, [r7, #292]
 12737 0b06 D7F88C30 		ldr	r3, [r7, #140]
 12738 0b0a D31A     		subs	r3, r2, r3
 12739 0b0c 9B00     		lsls	r3, r3, #2
 12740 0b0e D7F81C21 		ldr	r2, [r7, #284]
 12741 0b12 D118     		adds	r1, r2, r3
 12742              		.loc 2 3158 3
 12743 0b14 D7F8D030 		ldr	r3, [r7, #208]
 12744 0b18 0093     		str	r3, [sp]
 12745 0b1a D7F8BC30 		ldr	r3, [r7, #188]
 12746 0b1e D7F88C20 		ldr	r2, [r7, #140]
 12747 0b22 D7F89400 		ldr	r0, [r7, #148]
 12748 0b26 FFF7FEFF 		bl	poly_big_to_fp
3159:keygen.c      **** 		poly_big_to_fp(rt2, Gt + FGlen - rlen, rlen, llen, logn);
 12749              		.loc 2 3159 34
 12750 0b2a D7F82421 		ldr	r2, [r7, #292]
 12751 0b2e D7F88C30 		ldr	r3, [r7, #140]
 12752 0b32 D31A     		subs	r3, r2, r3
 12753 0b34 9B00     		lsls	r3, r3, #2
 12754 0b36 D7F81821 		ldr	r2, [r7, #280]
 12755 0b3a D118     		adds	r1, r2, r3
 12756              		.loc 2 3159 3
 12757 0b3c D7F8D030 		ldr	r3, [r7, #208]
 12758 0b40 0093     		str	r3, [sp]
 12759 0b42 D7F8BC30 		ldr	r3, [r7, #188]
 12760 0b46 D7F88C20 		ldr	r2, [r7, #140]
 12761 0b4a D7F81401 		ldr	r0, [r7, #276]
 12762 0b4e FFF7FEFF 		bl	poly_big_to_fp
3160:keygen.c      **** 
3161:keygen.c      **** 		/*
3162:keygen.c      **** 		 * Compute (F*adj(f)+G*adj(g))/(f*adj(f)+g*adj(g)) in rt2.
3163:keygen.c      **** 		 */
3164:keygen.c      **** 		Zf(FFT)(rt1, logn);
 12763              		.loc 2 3164 3
 12764 0b52 D7F8D010 		ldr	r1, [r7, #208]
 12765 0b56 D7F89400 		ldr	r0, [r7, #148]
 12766 0b5a FFF7FEFF 		bl	falcon_inner_FFT
3165:keygen.c      **** 		Zf(FFT)(rt2, logn);
 12767              		.loc 2 3165 3
 12768 0b5e D7F8D010 		ldr	r1, [r7, #208]
 12769 0b62 D7F81401 		ldr	r0, [r7, #276]
 12770 0b66 FFF7FEFF 		bl	falcon_inner_FFT
3166:keygen.c      **** 		Zf(poly_mul_fft)(rt1, rt3, logn);
 12771              		.loc 2 3166 3
 12772 0b6a D7F8D020 		ldr	r2, [r7, #208]
 12773 0b6e D7F8A010 		ldr	r1, [r7, #160]
 12774 0b72 D7F89400 		ldr	r0, [r7, #148]
 12775 0b76 FFF7FEFF 		bl	falcon_inner_poly_mul_fft
3167:keygen.c      **** 		Zf(poly_mul_fft)(rt2, rt4, logn);
 12776              		.loc 2 3167 3
 12777 0b7a D7F8D020 		ldr	r2, [r7, #208]
 12778 0b7e D7F89C10 		ldr	r1, [r7, #156]
 12779 0b82 D7F81401 		ldr	r0, [r7, #276]
 12780 0b86 FFF7FEFF 		bl	falcon_inner_poly_mul_fft
3168:keygen.c      **** 		Zf(poly_add)(rt2, rt1, logn);
 12781              		.loc 2 3168 3
 12782 0b8a D7F8D020 		ldr	r2, [r7, #208]
 12783 0b8e D7F89410 		ldr	r1, [r7, #148]
 12784 0b92 D7F81401 		ldr	r0, [r7, #276]
 12785 0b96 FFF7FEFF 		bl	falcon_inner_poly_add
3169:keygen.c      **** 		Zf(poly_mul_autoadj_fft)(rt2, rt5, logn);
 12786              		.loc 2 3169 3
 12787 0b9a D7F8D020 		ldr	r2, [r7, #208]
 12788 0b9e D7F89810 		ldr	r1, [r7, #152]
 12789 0ba2 D7F81401 		ldr	r0, [r7, #276]
 12790 0ba6 FFF7FEFF 		bl	falcon_inner_poly_mul_autoadj_fft
3170:keygen.c      **** 		Zf(iFFT)(rt2, logn);
 12791              		.loc 2 3170 3
 12792 0baa D7F8D010 		ldr	r1, [r7, #208]
 12793 0bae D7F81401 		ldr	r0, [r7, #276]
 12794 0bb2 FFF7FEFF 		bl	falcon_inner_iFFT
3171:keygen.c      **** 
3172:keygen.c      **** 		/*
3173:keygen.c      **** 		 * (f,g) are scaled by 'scale_fg', meaning that the
3174:keygen.c      **** 		 * numbers in rt3/rt4 should be multiplied by 2^(scale_fg)
3175:keygen.c      **** 		 * to have their true mathematical value.
3176:keygen.c      **** 		 *
3177:keygen.c      **** 		 * (F,G) are similarly scaled by 'scale_FG'. Therefore,
3178:keygen.c      **** 		 * the value we computed in rt2 is scaled by
3179:keygen.c      **** 		 * 'scale_FG-scale_fg'.
3180:keygen.c      **** 		 *
3181:keygen.c      **** 		 * We want that value to be scaled by 'scale_k', hence we
3182:keygen.c      **** 		 * apply a corrective scaling. After scaling, the values
3183:keygen.c      **** 		 * should fit in -2^31-1..+2^31-1.
3184:keygen.c      **** 		 */
3185:keygen.c      **** 		dc = scale_k - scale_FG + scale_fg;
 12795              		.loc 2 3185 16
 12796 0bb6 D7F80C21 		ldr	r2, [r7, #268]
 12797 0bba FB6F     		ldr	r3, [r7, #124]
 12798 0bbc D31A     		subs	r3, r2, r3
 12799              		.loc 2 3185 6
 12800 0bbe D7F88820 		ldr	r2, [r7, #136]
 12801 0bc2 1344     		add	r3, r3, r2
 12802 0bc4 C7F8E830 		str	r3, [r7, #232]
3186:keygen.c      **** 
3187:keygen.c      **** 		/*
3188:keygen.c      **** 		 * We will need to multiply values by 2^(-dc). The value
3189:keygen.c      **** 		 * 'dc' is not secret, so we can compute 2^(-dc) with a
3190:keygen.c      **** 		 * non-constant-time process.
3191:keygen.c      **** 		 * (We could use ldexp(), but we prefer to avoid any
3192:keygen.c      **** 		 * dependency on libm. When using FP emulation, we could
3193:keygen.c      **** 		 * use our fpr_ldexp(), which is constant-time.)
3194:keygen.c      **** 		 */
3195:keygen.c      **** 		if (dc < 0) {
 12803              		.loc 2 3195 6
 12804 0bc8 D7F8E830 		ldr	r3, [r7, #232]
 12805 0bcc 002B     		cmp	r3, #0
 12806 0bce 0BDA     		bge	.L273
3196:keygen.c      **** 			dc = -dc;
 12807              		.loc 2 3196 7
 12808 0bd0 D7F8E830 		ldr	r3, [r7, #232]
 12809 0bd4 5B42     		rsbs	r3, r3, #0
 12810 0bd6 C7F8E830 		str	r3, [r7, #232]
3197:keygen.c      **** 			pt = fpr_two;
 12811              		.loc 2 3197 7
 12812 0bda 4FF00002 		mov	r2, #0
 12813 0bde 4FF08043 		mov	r3, #1073741824
 12814 0be2 C7E93623 		strd	r2, [r7, #216]
 12815 0be6 04E0     		b	.L274
 12816              	.L273:
3198:keygen.c      **** 		} else {
3199:keygen.c      **** 			pt = fpr_onehalf;
 12817              		.loc 2 3199 7
 12818 0be8 4FF00002 		mov	r2, #0
 12819 0bec 2B4B     		ldr	r3, .L303+20
 12820 0bee C7E93623 		strd	r2, [r7, #216]
 12821              	.L274:
3200:keygen.c      **** 		}
3201:keygen.c      **** 		pdc = fpr_one;
 12822              		.loc 2 3201 7
 12823 0bf2 4FF00002 		mov	r2, #0
 12824 0bf6 2A4B     		ldr	r3, .L303+24
 12825 0bf8 C7E93823 		strd	r2, [r7, #224]
3202:keygen.c      **** 		while (dc != 0) {
 12826              		.loc 2 3202 9
 12827 0bfc 18E0     		b	.L275
 12828              	.L277:
3203:keygen.c      **** 			if ((dc & 1) != 0) {
 12829              		.loc 2 3203 12
 12830 0bfe D7F8E830 		ldr	r3, [r7, #232]
 12831 0c02 03F00103 		and	r3, r3, #1
 12832              		.loc 2 3203 7
 12833 0c06 002B     		cmp	r3, #0
 12834 0c08 07D0     		beq	.L276
3204:keygen.c      **** 				pdc = fpr_mul(pdc, pt);
 12835              		.loc 2 3204 11
 12836 0c0a D7E93623 		ldrd	r2, [r7, #216]
 12837 0c0e D7E93801 		ldrd	r0, [r7, #224]
 12838 0c12 FFF7FEFF 		bl	falcon_inner_fpr_mul
 12839 0c16 C7E93801 		strd	r0, [r7, #224]
 12840              	.L276:
3205:keygen.c      **** 			}
3206:keygen.c      **** 			dc >>= 1;
 12841              		.loc 2 3206 7
 12842 0c1a D7F8E830 		ldr	r3, [r7, #232]
 12843 0c1e 5B10     		asrs	r3, r3, #1
 12844 0c20 C7F8E830 		str	r3, [r7, #232]
3207:keygen.c      **** 			pt = fpr_sqr(pt);
 12845              		.loc 2 3207 9
 12846 0c24 D7E93601 		ldrd	r0, [r7, #216]
 12847 0c28 FFF7FEFF 		bl	fpr_sqr
 12848 0c2c C7E93601 		strd	r0, [r7, #216]
 12849              	.L275:
3202:keygen.c      **** 			if ((dc & 1) != 0) {
 12850              		.loc 2 3202 9
 12851 0c30 D7F8E830 		ldr	r3, [r7, #232]
 12852 0c34 002B     		cmp	r3, #0
 12853 0c36 E2D1     		bne	.L277
3208:keygen.c      **** 		}
3209:keygen.c      **** 
3210:keygen.c      **** 		for (u = 0; u < n; u ++) {
 12854              		.loc 2 3210 10
 12855 0c38 0023     		movs	r3, #0
 12856 0c3a C7F82031 		str	r3, [r7, #288]
 12857              		.loc 2 3210 3
 12858 0c3e 42E0     		b	.L278
 12859              	.L282:
 12860              	.LBB47:
3211:keygen.c      **** 			fpr xv;
3212:keygen.c      **** 
3213:keygen.c      **** 			xv = fpr_mul(rt2[u], pdc);
 12861              		.loc 2 3213 20
 12862 0c40 D7F82031 		ldr	r3, [r7, #288]
 12863 0c44 DB00     		lsls	r3, r3, #3
 12864 0c46 D7F81421 		ldr	r2, [r7, #276]
 12865 0c4a 1344     		add	r3, r3, r2
 12866              		.loc 2 3213 9
 12867 0c4c D3E90001 		ldrd	r0, [r3]
 12868 0c50 D7E93823 		ldrd	r2, [r7, #224]
 12869 0c54 FFF7FEFF 		bl	falcon_inner_fpr_mul
 12870 0c58 C7E91801 		strd	r0, [r7, #96]
3214:keygen.c      **** 
3215:keygen.c      **** 			/*
3216:keygen.c      **** 			 * Sometimes the values can be out-of-bounds if
3217:keygen.c      **** 			 * the algorithm fails; we must not call
3218:keygen.c      **** 			 * fpr_rint() (and cast to int32_t) if the value
3219:keygen.c      **** 			 * is not in-bounds. Note that the test does not
3220:keygen.c      **** 			 * break constant-time discipline, since any
3221:keygen.c      **** 			 * failure here implies that we discard the current
3222:keygen.c      **** 			 * secret key (f,g).
3223:keygen.c      **** 			 */
3224:keygen.c      **** 			if (!fpr_lt(fpr_mtwo31m1, xv)
 12871              		.loc 2 3224 9
 12872 0c5c 0AA1     		adr	r1, .L303
 12873 0c5e D1E90001 		ldrd	r0, [r1]
 12874 0c62 D7E91823 		ldrd	r2, [r7, #96]
 12875 0c66 FFF7FEFF 		bl	fpr_lt
 12876 0c6a 0346     		mov	r3, r0
 12877              		.loc 2 3224 7
 12878 0c6c 002B     		cmp	r3, #0
 12879 0c6e 09D0     		beq	.L279
3225:keygen.c      **** 				|| !fpr_lt(xv, fpr_ptwo31m1))
 12880              		.loc 2 3225 9
 12881 0c70 07A3     		adr	r3, .L303+8
 12882 0c72 D3E90023 		ldrd	r2, [r3]
 12883 0c76 D7E91801 		ldrd	r0, [r7, #96]
 12884 0c7a FFF7FEFF 		bl	fpr_lt
 12885 0c7e 0346     		mov	r3, r0
 12886              		.loc 2 3225 5
 12887 0c80 002B     		cmp	r3, #0
 12888 0c82 0FD1     		bne	.L280
 12889              	.L279:
3226:keygen.c      **** 			{
3227:keygen.c      **** 				return 0;
 12890              		.loc 2 3227 12
 12891 0c84 0023     		movs	r3, #0
 12892 0c86 88E1     		b	.L281
 12893              	.L304:
 12894              		.align	3
 12895              	.L303:
 12896 0c88 0000C0FF 		.word	-4194304
 12897 0c8c FFFFDFC1 		.word	-1042284545
 12898 0c90 0000C0FF 		.word	-4194304
 12899 0c94 FFFFDF41 		.word	1105199103
 12900 0c98 E4220000 		.word	BITLENGTH
 12901 0c9c 0000E03F 		.word	1071644672
 12902 0ca0 0000F03F 		.word	1072693248
 12903              	.L280:
3228:keygen.c      **** 			}
3229:keygen.c      **** 			k[u] = (int32_t)fpr_rint(xv);
 12904              		.loc 2 3229 20 discriminator 2
 12905 0ca4 D7E91801 		ldrd	r0, [r7, #96]
 12906 0ca8 FFF7FEFF 		bl	fpr_rint
 12907              		.loc 2 3229 5 discriminator 2
 12908 0cac D7F82031 		ldr	r3, [r7, #288]
 12909 0cb0 9B00     		lsls	r3, r3, #2
 12910 0cb2 D7F89020 		ldr	r2, [r7, #144]
 12911 0cb6 1344     		add	r3, r3, r2
 12912              		.loc 2 3229 11 discriminator 2
 12913 0cb8 0246     		mov	r2, r0
 12914              		.loc 2 3229 9 discriminator 2
 12915 0cba 1A60     		str	r2, [r3]
 12916              	.LBE47:
3210:keygen.c      **** 			fpr xv;
 12917              		.loc 2 3210 24 discriminator 2
 12918 0cbc D7F82031 		ldr	r3, [r7, #288]
 12919 0cc0 0133     		adds	r3, r3, #1
 12920 0cc2 C7F82031 		str	r3, [r7, #288]
 12921              	.L278:
3210:keygen.c      **** 			fpr xv;
 12922              		.loc 2 3210 3 discriminator 1
 12923 0cc6 D7F82021 		ldr	r2, [r7, #288]
 12924 0cca D7F8CC30 		ldr	r3, [r7, #204]
 12925 0cce 9A42     		cmp	r2, r3
 12926 0cd0 B6D3     		bcc	.L282
3230:keygen.c      **** 		}
3231:keygen.c      **** 
3232:keygen.c      **** 		/*
3233:keygen.c      **** 		 * Values in k[] are integers. They really are scaled
3234:keygen.c      **** 		 * down by maxbl_FG - minbl_fg bits.
3235:keygen.c      **** 		 *
3236:keygen.c      **** 		 * If we are at low depth, then we use the NTT to
3237:keygen.c      **** 		 * compute k*f and k*g.
3238:keygen.c      **** 		 */
3239:keygen.c      **** 		sch = (uint32_t)(scale_k / 31);
 12927              		.loc 2 3239 28
 12928 0cd2 D7F80C31 		ldr	r3, [r7, #268]
 12929 0cd6 B34A     		ldr	r2, .L305
 12930 0cd8 82FB0312 		smull	r1, r2, r2, r3
 12931 0cdc 1A44     		add	r2, r2, r3
 12932 0cde 1211     		asrs	r2, r2, #4
 12933 0ce0 DB17     		asrs	r3, r3, #31
 12934 0ce2 D31A     		subs	r3, r2, r3
 12935              		.loc 2 3239 7
 12936 0ce4 BB67     		str	r3, [r7, #120]
3240:keygen.c      **** 		scl = (uint32_t)(scale_k % 31);
 12937              		.loc 2 3240 28
 12938 0ce6 D7F80C21 		ldr	r2, [r7, #268]
 12939 0cea AE4B     		ldr	r3, .L305
 12940 0cec 83FB0213 		smull	r1, r3, r3, r2
 12941 0cf0 1344     		add	r3, r3, r2
 12942 0cf2 1911     		asrs	r1, r3, #4
 12943 0cf4 D317     		asrs	r3, r2, #31
 12944 0cf6 C91A     		subs	r1, r1, r3
 12945 0cf8 0B46     		mov	r3, r1
 12946 0cfa 5B01     		lsls	r3, r3, #5
 12947 0cfc 5B1A     		subs	r3, r3, r1
 12948 0cfe D11A     		subs	r1, r2, r3
 12949              		.loc 2 3240 7
 12950 0d00 7967     		str	r1, [r7, #116]
3241:keygen.c      **** 		if (depth <= DEPTH_INT_FG) {
 12951              		.loc 2 3241 6
 12952 0d02 07F59473 		add	r3, r7, #296
 12953 0d06 A3F59473 		sub	r3, r3, #296
 12954 0d0a 1B68     		ldr	r3, [r3]
 12955 0d0c 042B     		cmp	r3, #4
 12956 0d0e 3AD8     		bhi	.L283
3242:keygen.c      **** 			poly_sub_scaled_ntt(Ft, FGlen, llen, ft, slen, slen,
 12957              		.loc 2 3242 4
 12958 0d10 D7F8A830 		ldr	r3, [r7, #168]
 12959 0d14 0693     		str	r3, [sp, #24]
 12960 0d16 D7F8D030 		ldr	r3, [r7, #208]
 12961 0d1a 0593     		str	r3, [sp, #20]
 12962 0d1c 7B6F     		ldr	r3, [r7, #116]
 12963 0d1e 0493     		str	r3, [sp, #16]
 12964 0d20 BB6F     		ldr	r3, [r7, #120]
 12965 0d22 0393     		str	r3, [sp, #12]
 12966 0d24 D7F89030 		ldr	r3, [r7, #144]
 12967 0d28 0293     		str	r3, [sp, #8]
 12968 0d2a D7F8C430 		ldr	r3, [r7, #196]
 12969 0d2e 0193     		str	r3, [sp, #4]
 12970 0d30 D7F8C430 		ldr	r3, [r7, #196]
 12971 0d34 0093     		str	r3, [sp]
 12972 0d36 D7F8AC30 		ldr	r3, [r7, #172]
 12973 0d3a D7F8BC20 		ldr	r2, [r7, #188]
 12974 0d3e D7F82411 		ldr	r1, [r7, #292]
 12975 0d42 D7F81C01 		ldr	r0, [r7, #284]
 12976 0d46 FFF7FEFF 		bl	poly_sub_scaled_ntt
3243:keygen.c      **** 				k, sch, scl, logn, t1);
3244:keygen.c      **** 			poly_sub_scaled_ntt(Gt, FGlen, llen, gt, slen, slen,
 12977              		.loc 2 3244 4
 12978 0d4a D7F8A830 		ldr	r3, [r7, #168]
 12979 0d4e 0693     		str	r3, [sp, #24]
 12980 0d50 D7F8D030 		ldr	r3, [r7, #208]
 12981 0d54 0593     		str	r3, [sp, #20]
 12982 0d56 7B6F     		ldr	r3, [r7, #116]
 12983 0d58 0493     		str	r3, [sp, #16]
 12984 0d5a BB6F     		ldr	r3, [r7, #120]
 12985 0d5c 0393     		str	r3, [sp, #12]
 12986 0d5e D7F89030 		ldr	r3, [r7, #144]
 12987 0d62 0293     		str	r3, [sp, #8]
 12988 0d64 D7F8C430 		ldr	r3, [r7, #196]
 12989 0d68 0193     		str	r3, [sp, #4]
 12990 0d6a D7F8C430 		ldr	r3, [r7, #196]
 12991 0d6e 0093     		str	r3, [sp]
 12992 0d70 D7F8A430 		ldr	r3, [r7, #164]
 12993 0d74 D7F8BC20 		ldr	r2, [r7, #188]
 12994 0d78 D7F82411 		ldr	r1, [r7, #292]
 12995 0d7c D7F81801 		ldr	r0, [r7, #280]
 12996 0d80 FFF7FEFF 		bl	poly_sub_scaled_ntt
 12997 0d84 33E0     		b	.L284
 12998              	.L283:
3245:keygen.c      **** 				k, sch, scl, logn, t1);
3246:keygen.c      **** 		} else {
3247:keygen.c      **** 			poly_sub_scaled(Ft, FGlen, llen, ft, slen, slen,
 12999              		.loc 2 3247 4
 13000 0d86 D7F8D030 		ldr	r3, [r7, #208]
 13001 0d8a 0593     		str	r3, [sp, #20]
 13002 0d8c 7B6F     		ldr	r3, [r7, #116]
 13003 0d8e 0493     		str	r3, [sp, #16]
 13004 0d90 BB6F     		ldr	r3, [r7, #120]
 13005 0d92 0393     		str	r3, [sp, #12]
 13006 0d94 D7F89030 		ldr	r3, [r7, #144]
 13007 0d98 0293     		str	r3, [sp, #8]
 13008 0d9a D7F8C430 		ldr	r3, [r7, #196]
 13009 0d9e 0193     		str	r3, [sp, #4]
 13010 0da0 D7F8C430 		ldr	r3, [r7, #196]
 13011 0da4 0093     		str	r3, [sp]
 13012 0da6 D7F8AC30 		ldr	r3, [r7, #172]
 13013 0daa D7F8BC20 		ldr	r2, [r7, #188]
 13014 0dae D7F82411 		ldr	r1, [r7, #292]
 13015 0db2 D7F81C01 		ldr	r0, [r7, #284]
 13016 0db6 FFF7FEFF 		bl	poly_sub_scaled
3248:keygen.c      **** 				k, sch, scl, logn);
3249:keygen.c      **** 			poly_sub_scaled(Gt, FGlen, llen, gt, slen, slen,
 13017              		.loc 2 3249 4
 13018 0dba D7F8D030 		ldr	r3, [r7, #208]
 13019 0dbe 0593     		str	r3, [sp, #20]
 13020 0dc0 7B6F     		ldr	r3, [r7, #116]
 13021 0dc2 0493     		str	r3, [sp, #16]
 13022 0dc4 BB6F     		ldr	r3, [r7, #120]
 13023 0dc6 0393     		str	r3, [sp, #12]
 13024 0dc8 D7F89030 		ldr	r3, [r7, #144]
 13025 0dcc 0293     		str	r3, [sp, #8]
 13026 0dce D7F8C430 		ldr	r3, [r7, #196]
 13027 0dd2 0193     		str	r3, [sp, #4]
 13028 0dd4 D7F8C430 		ldr	r3, [r7, #196]
 13029 0dd8 0093     		str	r3, [sp]
 13030 0dda D7F8A430 		ldr	r3, [r7, #164]
 13031 0dde D7F8BC20 		ldr	r2, [r7, #188]
 13032 0de2 D7F82411 		ldr	r1, [r7, #292]
 13033 0de6 D7F81801 		ldr	r0, [r7, #280]
 13034 0dea FFF7FEFF 		bl	poly_sub_scaled
 13035              	.L284:
3250:keygen.c      **** 				k, sch, scl, logn);
3251:keygen.c      **** 		}
3252:keygen.c      **** 
3253:keygen.c      **** 		/*
3254:keygen.c      **** 		 * We compute the new maximum size of (F,G), assuming that
3255:keygen.c      **** 		 * (f,g) has _maximal_ length (i.e. that reduction is
3256:keygen.c      **** 		 * "late" instead of "early". We also adjust FGlen
3257:keygen.c      **** 		 * accordingly.
3258:keygen.c      **** 		 */
3259:keygen.c      **** 		new_maxbl_FG = scale_k + maxbl_fg + 10;
 13036              		.loc 2 3259 26
 13037 0dee D7F80C21 		ldr	r2, [r7, #268]
 13038 0df2 D7F88030 		ldr	r3, [r7, #128]
 13039 0df6 1344     		add	r3, r3, r2
 13040              		.loc 2 3259 16
 13041 0df8 0A33     		adds	r3, r3, #10
 13042 0dfa 3B67     		str	r3, [r7, #112]
3260:keygen.c      **** 		if (new_maxbl_FG < maxbl_FG) {
 13043              		.loc 2 3260 6
 13044 0dfc 3A6F     		ldr	r2, [r7, #112]
 13045 0dfe D7F81031 		ldr	r3, [r7, #272]
 13046 0e02 9A42     		cmp	r2, r3
 13047 0e04 12DA     		bge	.L285
3261:keygen.c      **** 			maxbl_FG = new_maxbl_FG;
 13048              		.loc 2 3261 13
 13049 0e06 3B6F     		ldr	r3, [r7, #112]
 13050 0e08 C7F81031 		str	r3, [r7, #272]
3262:keygen.c      **** 			if ((int)FGlen * 31 >= maxbl_FG + 31) {
 13051              		.loc 2 3262 24
 13052 0e0c D7F81031 		ldr	r3, [r7, #272]
 13053 0e10 03F11E01 		add	r1, r3, #30
 13054              		.loc 2 3262 8
 13055 0e14 D7F82421 		ldr	r2, [r7, #292]
 13056              		.loc 2 3262 19
 13057 0e18 1346     		mov	r3, r2
 13058 0e1a 5B01     		lsls	r3, r3, #5
 13059 0e1c 9B1A     		subs	r3, r3, r2
 13060              		.loc 2 3262 7
 13061 0e1e 9942     		cmp	r1, r3
 13062 0e20 04DA     		bge	.L285
3263:keygen.c      **** 				FGlen --;
 13063              		.loc 2 3263 11
 13064 0e22 D7F82431 		ldr	r3, [r7, #292]
 13065 0e26 013B     		subs	r3, r3, #1
 13066 0e28 C7F82431 		str	r3, [r7, #292]
 13067              	.L285:
3264:keygen.c      **** 			}
3265:keygen.c      **** 		}
3266:keygen.c      **** 
3267:keygen.c      **** 		/*
3268:keygen.c      **** 		 * We suppose that scaling down achieves a reduction by
3269:keygen.c      **** 		 * at least 25 bits per iteration. We stop when we have
3270:keygen.c      **** 		 * done the loop with an unscaled k.
3271:keygen.c      **** 		 */
3272:keygen.c      **** 		if (scale_k <= 0) {
 13068              		.loc 2 3272 6
 13069 0e2c D7F80C31 		ldr	r3, [r7, #268]
 13070 0e30 002B     		cmp	r3, #0
 13071 0e32 0DDD     		ble	.L300
3273:keygen.c      **** 			break;
3274:keygen.c      **** 		}
3275:keygen.c      **** 		scale_k -= 25;
 13072              		.loc 2 3275 11
 13073 0e34 D7F80C31 		ldr	r3, [r7, #268]
 13074 0e38 193B     		subs	r3, r3, #25
 13075 0e3a C7F80C31 		str	r3, [r7, #268]
3276:keygen.c      **** 		if (scale_k < 0) {
 13076              		.loc 2 3276 6
 13077 0e3e D7F80C31 		ldr	r3, [r7, #268]
 13078 0e42 002B     		cmp	r3, #0
 13079 0e44 BFF64CAE 		bge	.L289
3277:keygen.c      **** 			scale_k = 0;
 13080              		.loc 2 3277 12
 13081 0e48 0023     		movs	r3, #0
 13082 0e4a C7F80C31 		str	r3, [r7, #268]
 13083              	.LBE46:
3147:keygen.c      **** 		int scale_FG, dc, new_maxbl_FG;
 13084              		.loc 2 3147 11
 13085 0e4e 47E6     		b	.L289
 13086              	.L300:
 13087              	.LBB48:
3273:keygen.c      **** 		}
 13088              		.loc 2 3273 4
 13089 0e50 00BF     		nop
 13090              	.LBE48:
3278:keygen.c      **** 		}
3279:keygen.c      **** 	}
3280:keygen.c      **** 
3281:keygen.c      **** 	/*
3282:keygen.c      **** 	 * If (F,G) length was lowered below 'slen', then we must take
3283:keygen.c      **** 	 * care to re-extend the sign.
3284:keygen.c      **** 	 */
3285:keygen.c      **** 	if (FGlen < slen) {
 13091              		.loc 2 3285 5
 13092 0e52 D7F82421 		ldr	r2, [r7, #292]
 13093 0e56 D7F8C430 		ldr	r3, [r7, #196]
 13094 0e5a 9A42     		cmp	r2, r3
 13095 0e5c 6AD2     		bcs	.L290
3286:keygen.c      **** 		for (u = 0; u < n; u ++, Ft += llen, Gt += llen) {
 13096              		.loc 2 3286 10
 13097 0e5e 0023     		movs	r3, #0
 13098 0e60 C7F82031 		str	r3, [r7, #288]
 13099              		.loc 2 3286 3
 13100 0e64 60E0     		b	.L291
 13101              	.L296:
 13102              	.LBB49:
3287:keygen.c      **** 			size_t v;
3288:keygen.c      **** 			uint32_t sw;
3289:keygen.c      **** 
3290:keygen.c      **** 			sw = -(Ft[FGlen - 1] >> 30) >> 1;
 13103              		.loc 2 3290 13
 13104 0e66 D7F82431 		ldr	r3, [r7, #292]
 13105 0e6a 03F18043 		add	r3, r3, #1073741824
 13106 0e6e 013B     		subs	r3, r3, #1
 13107 0e70 9B00     		lsls	r3, r3, #2
 13108 0e72 D7F81C21 		ldr	r2, [r7, #284]
 13109 0e76 1344     		add	r3, r3, r2
 13110 0e78 1B68     		ldr	r3, [r3]
 13111              		.loc 2 3290 25
 13112 0e7a 9B0F     		lsrs	r3, r3, #30
 13113              		.loc 2 3290 9
 13114 0e7c 5B42     		rsbs	r3, r3, #0
 13115              		.loc 2 3290 7
 13116 0e7e 5B08     		lsrs	r3, r3, #1
 13117 0e80 FB66     		str	r3, [r7, #108]
3291:keygen.c      **** 			for (v = FGlen; v < slen; v ++) {
 13118              		.loc 2 3291 11
 13119 0e82 D7F82431 		ldr	r3, [r7, #292]
 13120 0e86 C7F8D430 		str	r3, [r7, #212]
 13121              		.loc 2 3291 4
 13122 0e8a 0CE0     		b	.L292
 13123              	.L293:
3292:keygen.c      **** 				Ft[v] = sw;
 13124              		.loc 2 3292 7 discriminator 3
 13125 0e8c D7F8D430 		ldr	r3, [r7, #212]
 13126 0e90 9B00     		lsls	r3, r3, #2
 13127 0e92 D7F81C21 		ldr	r2, [r7, #284]
 13128 0e96 1344     		add	r3, r3, r2
 13129              		.loc 2 3292 11 discriminator 3
 13130 0e98 FA6E     		ldr	r2, [r7, #108]
 13131 0e9a 1A60     		str	r2, [r3]
3291:keygen.c      **** 			for (v = FGlen; v < slen; v ++) {
 13132              		.loc 2 3291 32 discriminator 3
 13133 0e9c D7F8D430 		ldr	r3, [r7, #212]
 13134 0ea0 0133     		adds	r3, r3, #1
 13135 0ea2 C7F8D430 		str	r3, [r7, #212]
 13136              	.L292:
3291:keygen.c      **** 			for (v = FGlen; v < slen; v ++) {
 13137              		.loc 2 3291 4 discriminator 1
 13138 0ea6 D7F8D420 		ldr	r2, [r7, #212]
 13139 0eaa D7F8C430 		ldr	r3, [r7, #196]
 13140 0eae 9A42     		cmp	r2, r3
 13141 0eb0 ECD3     		bcc	.L293
3293:keygen.c      **** 			}
3294:keygen.c      **** 			sw = -(Gt[FGlen - 1] >> 30) >> 1;
 13142              		.loc 2 3294 13
 13143 0eb2 D7F82431 		ldr	r3, [r7, #292]
 13144 0eb6 03F18043 		add	r3, r3, #1073741824
 13145 0eba 013B     		subs	r3, r3, #1
 13146 0ebc 9B00     		lsls	r3, r3, #2
 13147 0ebe D7F81821 		ldr	r2, [r7, #280]
 13148 0ec2 1344     		add	r3, r3, r2
 13149 0ec4 1B68     		ldr	r3, [r3]
 13150              		.loc 2 3294 25
 13151 0ec6 9B0F     		lsrs	r3, r3, #30
 13152              		.loc 2 3294 9
 13153 0ec8 5B42     		rsbs	r3, r3, #0
 13154              		.loc 2 3294 7
 13155 0eca 5B08     		lsrs	r3, r3, #1
 13156 0ecc FB66     		str	r3, [r7, #108]
3295:keygen.c      **** 			for (v = FGlen; v < slen; v ++) {
 13157              		.loc 2 3295 11
 13158 0ece D7F82431 		ldr	r3, [r7, #292]
 13159 0ed2 C7F8D430 		str	r3, [r7, #212]
 13160              		.loc 2 3295 4
 13161 0ed6 0CE0     		b	.L294
 13162              	.L295:
3296:keygen.c      **** 				Gt[v] = sw;
 13163              		.loc 2 3296 7 discriminator 3
 13164 0ed8 D7F8D430 		ldr	r3, [r7, #212]
 13165 0edc 9B00     		lsls	r3, r3, #2
 13166 0ede D7F81821 		ldr	r2, [r7, #280]
 13167 0ee2 1344     		add	r3, r3, r2
 13168              		.loc 2 3296 11 discriminator 3
 13169 0ee4 FA6E     		ldr	r2, [r7, #108]
 13170 0ee6 1A60     		str	r2, [r3]
3295:keygen.c      **** 			for (v = FGlen; v < slen; v ++) {
 13171              		.loc 2 3295 32 discriminator 3
 13172 0ee8 D7F8D430 		ldr	r3, [r7, #212]
 13173 0eec 0133     		adds	r3, r3, #1
 13174 0eee C7F8D430 		str	r3, [r7, #212]
 13175              	.L294:
3295:keygen.c      **** 			for (v = FGlen; v < slen; v ++) {
 13176              		.loc 2 3295 4 discriminator 1
 13177 0ef2 D7F8D420 		ldr	r2, [r7, #212]
 13178 0ef6 D7F8C430 		ldr	r3, [r7, #196]
 13179 0efa 9A42     		cmp	r2, r3
 13180 0efc ECD3     		bcc	.L295
 13181              	.LBE49:
3286:keygen.c      **** 			size_t v;
 13182              		.loc 2 3286 24 discriminator 2
 13183 0efe D7F82031 		ldr	r3, [r7, #288]
 13184 0f02 0133     		adds	r3, r3, #1
 13185 0f04 C7F82031 		str	r3, [r7, #288]
3286:keygen.c      **** 			size_t v;
 13186              		.loc 2 3286 31 discriminator 2
 13187 0f08 D7F8BC30 		ldr	r3, [r7, #188]
 13188 0f0c 9B00     		lsls	r3, r3, #2
 13189 0f0e D7F81C21 		ldr	r2, [r7, #284]
 13190 0f12 1344     		add	r3, r3, r2
 13191 0f14 C7F81C31 		str	r3, [r7, #284]
3286:keygen.c      **** 			size_t v;
 13192              		.loc 2 3286 43 discriminator 2
 13193 0f18 D7F8BC30 		ldr	r3, [r7, #188]
 13194 0f1c 9B00     		lsls	r3, r3, #2
 13195 0f1e D7F81821 		ldr	r2, [r7, #280]
 13196 0f22 1344     		add	r3, r3, r2
 13197 0f24 C7F81831 		str	r3, [r7, #280]
 13198              	.L291:
3286:keygen.c      **** 			size_t v;
 13199              		.loc 2 3286 3 discriminator 1
 13200 0f28 D7F82021 		ldr	r2, [r7, #288]
 13201 0f2c D7F8CC30 		ldr	r3, [r7, #204]
 13202 0f30 9A42     		cmp	r2, r3
 13203 0f32 98D3     		bcc	.L296
 13204              	.L290:
3297:keygen.c      **** 			}
3298:keygen.c      **** 		}
3299:keygen.c      **** 	}
3300:keygen.c      **** 
3301:keygen.c      **** 	/*
3302:keygen.c      **** 	 * Compress encoding of all values to 'slen' words (this is the
3303:keygen.c      **** 	 * expected output format).
3304:keygen.c      **** 	 */
3305:keygen.c      **** 	for (u = 0, x = tmp, y = tmp;
 13205              		.loc 2 3305 9
 13206 0f34 0023     		movs	r3, #0
 13207 0f36 C7F82031 		str	r3, [r7, #288]
 13208              		.loc 2 3305 16
 13209 0f3a D7F83831 		ldr	r3, [r7, #312]
 13210 0f3e C7F80831 		str	r3, [r7, #264]
 13211              		.loc 2 3305 25
 13212 0f42 D7F83831 		ldr	r3, [r7, #312]
 13213 0f46 C7F80431 		str	r3, [r7, #260]
 13214              		.loc 2 3305 2
 13215 0f4a 1EE0     		b	.L297
 13216              	.L298:
3306:keygen.c      **** 		u < (n << 1); u ++, x += slen, y += llen)
3307:keygen.c      **** 	{
3308:keygen.c      **** 		memmove(x, y, slen * sizeof *y);
 13217              		.loc 2 3308 3 discriminator 1
 13218 0f4c D7F8C430 		ldr	r3, [r7, #196]
 13219 0f50 9B00     		lsls	r3, r3, #2
 13220 0f52 1A46     		mov	r2, r3
 13221 0f54 D7F80411 		ldr	r1, [r7, #260]
 13222 0f58 D7F80801 		ldr	r0, [r7, #264]
 13223 0f5c FFF7FEFF 		bl	memmove
3306:keygen.c      **** 		u < (n << 1); u ++, x += slen, y += llen)
 13224              		.loc 2 3306 19 discriminator 1
 13225 0f60 D7F82031 		ldr	r3, [r7, #288]
 13226 0f64 0133     		adds	r3, r3, #1
 13227 0f66 C7F82031 		str	r3, [r7, #288]
3306:keygen.c      **** 		u < (n << 1); u ++, x += slen, y += llen)
 13228              		.loc 2 3306 25 discriminator 1
 13229 0f6a D7F8C430 		ldr	r3, [r7, #196]
 13230 0f6e 9B00     		lsls	r3, r3, #2
 13231 0f70 D7F80821 		ldr	r2, [r7, #264]
 13232 0f74 1344     		add	r3, r3, r2
 13233 0f76 C7F80831 		str	r3, [r7, #264]
3306:keygen.c      **** 		u < (n << 1); u ++, x += slen, y += llen)
 13234              		.loc 2 3306 36 discriminator 1
 13235 0f7a D7F8BC30 		ldr	r3, [r7, #188]
 13236 0f7e 9B00     		lsls	r3, r3, #2
 13237 0f80 D7F80421 		ldr	r2, [r7, #260]
 13238 0f84 1344     		add	r3, r3, r2
 13239 0f86 C7F80431 		str	r3, [r7, #260]
 13240              	.L297:
3306:keygen.c      **** 		u < (n << 1); u ++, x += slen, y += llen)
 13241              		.loc 2 3306 10 discriminator 1
 13242 0f8a D7F8CC30 		ldr	r3, [r7, #204]
 13243 0f8e 5B00     		lsls	r3, r3, #1
3305:keygen.c      **** 		u < (n << 1); u ++, x += slen, y += llen)
 13244              		.loc 2 3305 2 discriminator 1
 13245 0f90 D7F82021 		ldr	r2, [r7, #288]
 13246 0f94 9A42     		cmp	r2, r3
 13247 0f96 D9D3     		bcc	.L298
3309:keygen.c      **** 	}
3310:keygen.c      **** 	return 1;
 13248              		.loc 2 3310 9
 13249 0f98 0123     		movs	r3, #1
 13250              	.L281:
3311:keygen.c      **** }
 13251              		.loc 2 3311 1
 13252 0f9a 1846     		mov	r0, r3
 13253 0f9c 07F59677 		add	r7, r7, #300
 13254              	.LCFI264:
 13255              		.cfi_def_cfa_offset 12
 13256 0fa0 BD46     		mov	sp, r7
 13257              	.LCFI265:
 13258              		.cfi_def_cfa_register 13
 13259              		@ sp needed
 13260 0fa2 90BD     		pop	{r4, r7, pc}
 13261              	.L306:
 13262              		.align	2
 13263              	.L305:
 13264 0fa4 43082184 		.word	-2078209981
 13265              		.cfi_endproc
 13266              	.LFE60:
 13268              		.section	.text.solve_NTRU_binary_depth1,"ax",%progbits
 13269              		.align	1
 13270              		.syntax unified
 13271              		.thumb
 13272              		.thumb_func
 13273              		.fpu softvfp
 13275              	solve_NTRU_binary_depth1:
 13276              	.LFB61:
3312:keygen.c      **** 
3313:keygen.c      **** /*
3314:keygen.c      ****  * Solving the NTRU equation, binary case, depth = 1. Upon entry, the
3315:keygen.c      ****  * F and G from the previous level should be in the tmp[] array.
3316:keygen.c      ****  *
3317:keygen.c      ****  * Returned value: 1 on success, 0 on error.
3318:keygen.c      ****  */
3319:keygen.c      **** static int
3320:keygen.c      **** solve_NTRU_binary_depth1(unsigned logn_top,
3321:keygen.c      **** 	const int8_t *f, const int8_t *g, uint32_t *tmp)
3322:keygen.c      **** {
 13277              		.loc 2 3322 1
 13278              		.cfi_startproc
 13279              		@ args = 0, pretend = 0, frame = 224
 13280              		@ frame_needed = 1, uses_anonymous_args = 0
 13281 0000 90B5     		push	{r4, r7, lr}
 13282              	.LCFI266:
 13283              		.cfi_def_cfa_offset 12
 13284              		.cfi_offset 4, -12
 13285              		.cfi_offset 7, -8
 13286              		.cfi_offset 14, -4
 13287 0002 BDB0     		sub	sp, sp, #244
 13288              	.LCFI267:
 13289              		.cfi_def_cfa_offset 256
 13290 0004 04AF     		add	r7, sp, #16
 13291              	.LCFI268:
 13292              		.cfi_def_cfa 7, 240
 13293 0006 F860     		str	r0, [r7, #12]
 13294 0008 B960     		str	r1, [r7, #8]
 13295 000a 7A60     		str	r2, [r7, #4]
 13296 000c 3B60     		str	r3, [r7]
3323:keygen.c      **** 	/*
3324:keygen.c      **** 	 * The first half of this function is a copy of the corresponding
3325:keygen.c      **** 	 * part in solve_NTRU_intermediate(), for the reconstruction of
3326:keygen.c      **** 	 * the unreduced F and G. The second half (Babai reduction) is
3327:keygen.c      **** 	 * done differently, because the unreduced F and G fit in 53 bits
3328:keygen.c      **** 	 * of precision, allowing a much simpler process with lower RAM
3329:keygen.c      **** 	 * usage.
3330:keygen.c      **** 	 */
3331:keygen.c      **** 	unsigned depth, logn;
3332:keygen.c      **** 	size_t n_top, n, hn, slen, dlen, llen, u;
3333:keygen.c      **** 	uint32_t *Fd, *Gd, *Ft, *Gt, *ft, *gt, *t1;
3334:keygen.c      **** 	fpr *rt1, *rt2, *rt3, *rt4, *rt5, *rt6;
3335:keygen.c      **** 	uint32_t *x, *y;
3336:keygen.c      **** 
3337:keygen.c      **** 	depth = 1;
 13297              		.loc 2 3337 8
 13298 000e 0123     		movs	r3, #1
 13299 0010 C7F8A830 		str	r3, [r7, #168]
3338:keygen.c      **** 	n_top = (size_t)1 << logn_top;
 13300              		.loc 2 3338 8
 13301 0014 0122     		movs	r2, #1
 13302 0016 FB68     		ldr	r3, [r7, #12]
 13303 0018 02FA03F3 		lsl	r3, r2, r3
 13304 001c C7F8A430 		str	r3, [r7, #164]
3339:keygen.c      **** 	logn = logn_top - depth;
 13305              		.loc 2 3339 7
 13306 0020 FA68     		ldr	r2, [r7, #12]
 13307 0022 D7F8A830 		ldr	r3, [r7, #168]
 13308 0026 D31A     		subs	r3, r2, r3
 13309 0028 C7F8A030 		str	r3, [r7, #160]
3340:keygen.c      **** 	n = (size_t)1 << logn;
 13310              		.loc 2 3340 4
 13311 002c 0122     		movs	r2, #1
 13312 002e D7F8A030 		ldr	r3, [r7, #160]
 13313 0032 02FA03F3 		lsl	r3, r2, r3
 13314 0036 C7F89C30 		str	r3, [r7, #156]
3341:keygen.c      **** 	hn = n >> 1;
 13315              		.loc 2 3341 5
 13316 003a D7F89C30 		ldr	r3, [r7, #156]
 13317 003e 5B08     		lsrs	r3, r3, #1
 13318 0040 C7F89830 		str	r3, [r7, #152]
3342:keygen.c      **** 
3343:keygen.c      **** 	/*
3344:keygen.c      **** 	 * Equations are:
3345:keygen.c      **** 	 *
3346:keygen.c      **** 	 *   f' = f0^2 - X^2*f1^2
3347:keygen.c      **** 	 *   g' = g0^2 - X^2*g1^2
3348:keygen.c      **** 	 *   F' and G' are a solution to f'G' - g'F' = q (from deeper levels)
3349:keygen.c      **** 	 *   F = F'*(g0 - X*g1)
3350:keygen.c      **** 	 *   G = G'*(f0 - X*f1)
3351:keygen.c      **** 	 *
3352:keygen.c      **** 	 * f0, f1, g0, g1, f', g', F' and G' are all "compressed" to
3353:keygen.c      **** 	 * degree N/2 (their odd-indexed coefficients are all zero).
3354:keygen.c      **** 	 */
3355:keygen.c      **** 
3356:keygen.c      **** 	/*
3357:keygen.c      **** 	 * slen = size for our input f and g; also size of the reduced
3358:keygen.c      **** 	 *        F and G we return (degree N)
3359:keygen.c      **** 	 *
3360:keygen.c      **** 	 * dlen = size of the F and G obtained from the deeper level
3361:keygen.c      **** 	 *        (degree N/2)
3362:keygen.c      **** 	 *
3363:keygen.c      **** 	 * llen = size for intermediary F and G before reduction (degree N)
3364:keygen.c      **** 	 *
3365:keygen.c      **** 	 * We build our non-reduced F and G as two independent halves each,
3366:keygen.c      **** 	 * of degree N/2 (F = F0 + X*F1, G = G0 + X*G1).
3367:keygen.c      **** 	 */
3368:keygen.c      **** 	slen = MAX_BL_SMALL[depth];
 13319              		.loc 2 3368 7
 13320 0044 B14A     		ldr	r2, .L333
 13321 0046 D7F8A830 		ldr	r3, [r7, #168]
 13322 004a 52F82330 		ldr	r3, [r2, r3, lsl #2]
 13323 004e C7F89430 		str	r3, [r7, #148]
3369:keygen.c      **** 	dlen = MAX_BL_SMALL[depth + 1];
 13324              		.loc 2 3369 28
 13325 0052 D7F8A830 		ldr	r3, [r7, #168]
 13326 0056 0133     		adds	r3, r3, #1
 13327              		.loc 2 3369 7
 13328 0058 AC4A     		ldr	r2, .L333
 13329 005a 52F82330 		ldr	r3, [r2, r3, lsl #2]
 13330 005e C7F89030 		str	r3, [r7, #144]
3370:keygen.c      **** 	llen = MAX_BL_LARGE[depth];
 13331              		.loc 2 3370 7
 13332 0062 AB4A     		ldr	r2, .L333+4
 13333 0064 D7F8A830 		ldr	r3, [r7, #168]
 13334 0068 52F82330 		ldr	r3, [r2, r3, lsl #2]
 13335 006c C7F88C30 		str	r3, [r7, #140]
3371:keygen.c      **** 
3372:keygen.c      **** 	/*
3373:keygen.c      **** 	 * Fd and Gd are the F and G from the deeper level. Ft and Gt
3374:keygen.c      **** 	 * are the destination arrays for the unreduced F and G.
3375:keygen.c      **** 	 */
3376:keygen.c      **** 	Fd = tmp;
 13336              		.loc 2 3376 5
 13337 0070 3B68     		ldr	r3, [r7]
 13338 0072 C7F88830 		str	r3, [r7, #136]
3377:keygen.c      **** 	Gd = Fd + dlen * hn;
 13339              		.loc 2 3377 17
 13340 0076 D7F89030 		ldr	r3, [r7, #144]
 13341 007a D7F89820 		ldr	r2, [r7, #152]
 13342 007e 02FB03F3 		mul	r3, r2, r3
 13343              		.loc 2 3377 10
 13344 0082 9B00     		lsls	r3, r3, #2
 13345              		.loc 2 3377 5
 13346 0084 D7F88820 		ldr	r2, [r7, #136]
 13347 0088 1344     		add	r3, r3, r2
 13348 008a C7F88430 		str	r3, [r7, #132]
3378:keygen.c      **** 	Ft = Gd + dlen * hn;
 13349              		.loc 2 3378 17
 13350 008e D7F89030 		ldr	r3, [r7, #144]
 13351 0092 D7F89820 		ldr	r2, [r7, #152]
 13352 0096 02FB03F3 		mul	r3, r2, r3
 13353              		.loc 2 3378 10
 13354 009a 9B00     		lsls	r3, r3, #2
 13355              		.loc 2 3378 5
 13356 009c D7F88420 		ldr	r2, [r7, #132]
 13357 00a0 1344     		add	r3, r3, r2
 13358 00a2 C7F88030 		str	r3, [r7, #128]
3379:keygen.c      **** 	Gt = Ft + llen * n;
 13359              		.loc 2 3379 17
 13360 00a6 D7F88C30 		ldr	r3, [r7, #140]
 13361 00aa D7F89C20 		ldr	r2, [r7, #156]
 13362 00ae 02FB03F3 		mul	r3, r2, r3
 13363              		.loc 2 3379 10
 13364 00b2 9B00     		lsls	r3, r3, #2
 13365              		.loc 2 3379 5
 13366 00b4 D7F88020 		ldr	r2, [r7, #128]
 13367 00b8 1344     		add	r3, r3, r2
 13368 00ba FB67     		str	r3, [r7, #124]
3380:keygen.c      **** 
3381:keygen.c      **** 	/*
3382:keygen.c      **** 	 * We reduce Fd and Gd modulo all the small primes we will need,
3383:keygen.c      **** 	 * and store the values in Ft and Gt.
3384:keygen.c      **** 	 */
3385:keygen.c      **** 	for (u = 0; u < llen; u ++) {
 13369              		.loc 2 3385 9
 13370 00bc 0023     		movs	r3, #0
 13371 00be C7F8DC30 		str	r3, [r7, #220]
 13372              		.loc 2 3385 2
 13373 00c2 85E0     		b	.L308
 13374              	.L311:
 13375              	.LBB50:
3386:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
3387:keygen.c      **** 		size_t v;
3388:keygen.c      **** 		uint32_t *xs, *ys, *xd, *yd;
3389:keygen.c      **** 
3390:keygen.c      **** 		p = PRIMES[u].p;
 13376              		.loc 2 3390 5
 13377 00c4 9349     		ldr	r1, .L333+8
 13378 00c6 D7F8DC20 		ldr	r2, [r7, #220]
 13379 00ca 1346     		mov	r3, r2
 13380 00cc 5B00     		lsls	r3, r3, #1
 13381 00ce 1344     		add	r3, r3, r2
 13382 00d0 9B00     		lsls	r3, r3, #2
 13383 00d2 0B44     		add	r3, r3, r1
 13384 00d4 1B68     		ldr	r3, [r3]
 13385 00d6 FB61     		str	r3, [r7, #28]
3391:keygen.c      **** 		p0i = modp_ninv31(p);
 13386              		.loc 2 3391 9
 13387 00d8 F869     		ldr	r0, [r7, #28]
 13388 00da FFF7FEFF 		bl	modp_ninv31
 13389 00de B861     		str	r0, [r7, #24]
3392:keygen.c      **** 		R2 = modp_R2(p, p0i);
 13390              		.loc 2 3392 8
 13391 00e0 B969     		ldr	r1, [r7, #24]
 13392 00e2 F869     		ldr	r0, [r7, #28]
 13393 00e4 FFF7FEFF 		bl	modp_R2
 13394 00e8 7861     		str	r0, [r7, #20]
3393:keygen.c      **** 		Rx = modp_Rx((unsigned)dlen, p, p0i, R2);
 13395              		.loc 2 3393 8
 13396 00ea 7B69     		ldr	r3, [r7, #20]
 13397 00ec BA69     		ldr	r2, [r7, #24]
 13398 00ee F969     		ldr	r1, [r7, #28]
 13399 00f0 D7F89000 		ldr	r0, [r7, #144]
 13400 00f4 FFF7FEFF 		bl	modp_Rx
 13401 00f8 3861     		str	r0, [r7, #16]
3394:keygen.c      **** 		for (v = 0, xs = Fd, ys = Gd, xd = Ft + u, yd = Gt + u;
 13402              		.loc 2 3394 10
 13403 00fa 0023     		movs	r3, #0
 13404 00fc C7F8D030 		str	r3, [r7, #208]
 13405              		.loc 2 3394 18
 13406 0100 D7F88830 		ldr	r3, [r7, #136]
 13407 0104 C7F8CC30 		str	r3, [r7, #204]
 13408              		.loc 2 3394 27
 13409 0108 D7F88430 		ldr	r3, [r7, #132]
 13410 010c C7F8C830 		str	r3, [r7, #200]
 13411              		.loc 2 3394 41
 13412 0110 D7F8DC30 		ldr	r3, [r7, #220]
 13413 0114 9B00     		lsls	r3, r3, #2
 13414              		.loc 2 3394 36
 13415 0116 D7F88020 		ldr	r2, [r7, #128]
 13416 011a 1344     		add	r3, r3, r2
 13417 011c C7F8C430 		str	r3, [r7, #196]
 13418              		.loc 2 3394 54
 13419 0120 D7F8DC30 		ldr	r3, [r7, #220]
 13420 0124 9B00     		lsls	r3, r3, #2
 13421              		.loc 2 3394 49
 13422 0126 FA6F     		ldr	r2, [r7, #124]
 13423 0128 1344     		add	r3, r3, r2
 13424 012a C7F8C030 		str	r3, [r7, #192]
 13425              		.loc 2 3394 3
 13426 012e 44E0     		b	.L309
 13427              	.L310:
3395:keygen.c      **** 			v < hn;
3396:keygen.c      **** 			v ++, xs += dlen, ys += dlen, xd += llen, yd += llen)
3397:keygen.c      **** 		{
3398:keygen.c      **** 			*xd = zint_mod_small_signed(xs, dlen, p, p0i, R2, Rx);
 13428              		.loc 2 3398 10
 13429 0130 3B69     		ldr	r3, [r7, #16]
 13430 0132 0193     		str	r3, [sp, #4]
 13431 0134 7B69     		ldr	r3, [r7, #20]
 13432 0136 0093     		str	r3, [sp]
 13433 0138 BB69     		ldr	r3, [r7, #24]
 13434 013a FA69     		ldr	r2, [r7, #28]
 13435 013c D7F89010 		ldr	r1, [r7, #144]
 13436 0140 D7F8CC00 		ldr	r0, [r7, #204]
 13437 0144 FFF7FEFF 		bl	zint_mod_small_signed
 13438 0148 0246     		mov	r2, r0
 13439              		.loc 2 3398 8
 13440 014a D7F8C430 		ldr	r3, [r7, #196]
 13441 014e 1A60     		str	r2, [r3]
3399:keygen.c      **** 			*yd = zint_mod_small_signed(ys, dlen, p, p0i, R2, Rx);
 13442              		.loc 2 3399 10
 13443 0150 3B69     		ldr	r3, [r7, #16]
 13444 0152 0193     		str	r3, [sp, #4]
 13445 0154 7B69     		ldr	r3, [r7, #20]
 13446 0156 0093     		str	r3, [sp]
 13447 0158 BB69     		ldr	r3, [r7, #24]
 13448 015a FA69     		ldr	r2, [r7, #28]
 13449 015c D7F89010 		ldr	r1, [r7, #144]
 13450 0160 D7F8C800 		ldr	r0, [r7, #200]
 13451 0164 FFF7FEFF 		bl	zint_mod_small_signed
 13452 0168 0246     		mov	r2, r0
 13453              		.loc 2 3399 8
 13454 016a D7F8C030 		ldr	r3, [r7, #192]
 13455 016e 1A60     		str	r2, [r3]
3396:keygen.c      **** 		{
 13456              		.loc 2 3396 6
 13457 0170 D7F8D030 		ldr	r3, [r7, #208]
 13458 0174 0133     		adds	r3, r3, #1
 13459 0176 C7F8D030 		str	r3, [r7, #208]
3396:keygen.c      **** 		{
 13460              		.loc 2 3396 13
 13461 017a D7F89030 		ldr	r3, [r7, #144]
 13462 017e 9B00     		lsls	r3, r3, #2
 13463 0180 D7F8CC20 		ldr	r2, [r7, #204]
 13464 0184 1344     		add	r3, r3, r2
 13465 0186 C7F8CC30 		str	r3, [r7, #204]
3396:keygen.c      **** 		{
 13466              		.loc 2 3396 25
 13467 018a D7F89030 		ldr	r3, [r7, #144]
 13468 018e 9B00     		lsls	r3, r3, #2
 13469 0190 D7F8C820 		ldr	r2, [r7, #200]
 13470 0194 1344     		add	r3, r3, r2
 13471 0196 C7F8C830 		str	r3, [r7, #200]
3396:keygen.c      **** 		{
 13472              		.loc 2 3396 37
 13473 019a D7F88C30 		ldr	r3, [r7, #140]
 13474 019e 9B00     		lsls	r3, r3, #2
 13475 01a0 D7F8C420 		ldr	r2, [r7, #196]
 13476 01a4 1344     		add	r3, r3, r2
 13477 01a6 C7F8C430 		str	r3, [r7, #196]
3396:keygen.c      **** 		{
 13478              		.loc 2 3396 49
 13479 01aa D7F88C30 		ldr	r3, [r7, #140]
 13480 01ae 9B00     		lsls	r3, r3, #2
 13481 01b0 D7F8C020 		ldr	r2, [r7, #192]
 13482 01b4 1344     		add	r3, r3, r2
 13483 01b6 C7F8C030 		str	r3, [r7, #192]
 13484              	.L309:
3394:keygen.c      **** 			v < hn;
 13485              		.loc 2 3394 3 discriminator 1
 13486 01ba D7F8D020 		ldr	r2, [r7, #208]
 13487 01be D7F89830 		ldr	r3, [r7, #152]
 13488 01c2 9A42     		cmp	r2, r3
 13489 01c4 B4D3     		bcc	.L310
 13490              	.LBE50:
3385:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
 13491              		.loc 2 3385 26 discriminator 2
 13492 01c6 D7F8DC30 		ldr	r3, [r7, #220]
 13493 01ca 0133     		adds	r3, r3, #1
 13494 01cc C7F8DC30 		str	r3, [r7, #220]
 13495              	.L308:
3385:keygen.c      **** 		uint32_t p, p0i, R2, Rx;
 13496              		.loc 2 3385 2 discriminator 1
 13497 01d0 D7F8DC20 		ldr	r2, [r7, #220]
 13498 01d4 D7F88C30 		ldr	r3, [r7, #140]
 13499 01d8 9A42     		cmp	r2, r3
 13500 01da FFF473AF 		bcc	.L311
3400:keygen.c      **** 		}
3401:keygen.c      **** 	}
3402:keygen.c      **** 
3403:keygen.c      **** 	/*
3404:keygen.c      **** 	 * Now Fd and Gd are not needed anymore; we can squeeze them out.
3405:keygen.c      **** 	 */
3406:keygen.c      **** 	memmove(tmp, Ft, llen * n * sizeof(uint32_t));
 13501              		.loc 2 3406 24
 13502 01de D7F88C30 		ldr	r3, [r7, #140]
 13503 01e2 D7F89C20 		ldr	r2, [r7, #156]
 13504 01e6 02FB03F3 		mul	r3, r2, r3
 13505              		.loc 2 3406 2
 13506 01ea 9B00     		lsls	r3, r3, #2
 13507 01ec 1A46     		mov	r2, r3
 13508 01ee D7F88010 		ldr	r1, [r7, #128]
 13509 01f2 3868     		ldr	r0, [r7]
 13510 01f4 FFF7FEFF 		bl	memmove
3407:keygen.c      **** 	Ft = tmp;
 13511              		.loc 2 3407 5
 13512 01f8 3B68     		ldr	r3, [r7]
 13513 01fa C7F88030 		str	r3, [r7, #128]
3408:keygen.c      **** 	memmove(Ft + llen * n, Gt, llen * n * sizeof(uint32_t));
 13514              		.loc 2 3408 20
 13515 01fe D7F88C30 		ldr	r3, [r7, #140]
 13516 0202 D7F89C20 		ldr	r2, [r7, #156]
 13517 0206 02FB03F3 		mul	r3, r2, r3
 13518              		.loc 2 3408 13
 13519 020a 9B00     		lsls	r3, r3, #2
 13520 020c D7F88020 		ldr	r2, [r7, #128]
 13521 0210 D018     		adds	r0, r2, r3
 13522              		.loc 2 3408 34
 13523 0212 D7F88C30 		ldr	r3, [r7, #140]
 13524 0216 D7F89C20 		ldr	r2, [r7, #156]
 13525 021a 02FB03F3 		mul	r3, r2, r3
 13526              		.loc 2 3408 2
 13527 021e 9B00     		lsls	r3, r3, #2
 13528 0220 1A46     		mov	r2, r3
 13529 0222 F96F     		ldr	r1, [r7, #124]
 13530 0224 FFF7FEFF 		bl	memmove
3409:keygen.c      **** 	Gt = Ft + llen * n;
 13531              		.loc 2 3409 17
 13532 0228 D7F88C30 		ldr	r3, [r7, #140]
 13533 022c D7F89C20 		ldr	r2, [r7, #156]
 13534 0230 02FB03F3 		mul	r3, r2, r3
 13535              		.loc 2 3409 10
 13536 0234 9B00     		lsls	r3, r3, #2
 13537              		.loc 2 3409 5
 13538 0236 D7F88020 		ldr	r2, [r7, #128]
 13539 023a 1344     		add	r3, r3, r2
 13540 023c FB67     		str	r3, [r7, #124]
3410:keygen.c      **** 	ft = Gt + llen * n;
 13541              		.loc 2 3410 17
 13542 023e D7F88C30 		ldr	r3, [r7, #140]
 13543 0242 D7F89C20 		ldr	r2, [r7, #156]
 13544 0246 02FB03F3 		mul	r3, r2, r3
 13545              		.loc 2 3410 10
 13546 024a 9B00     		lsls	r3, r3, #2
 13547              		.loc 2 3410 5
 13548 024c FA6F     		ldr	r2, [r7, #124]
 13549 024e 1344     		add	r3, r3, r2
 13550 0250 BB67     		str	r3, [r7, #120]
3411:keygen.c      **** 	gt = ft + slen * n;
 13551              		.loc 2 3411 17
 13552 0252 D7F89430 		ldr	r3, [r7, #148]
 13553 0256 D7F89C20 		ldr	r2, [r7, #156]
 13554 025a 02FB03F3 		mul	r3, r2, r3
 13555              		.loc 2 3411 10
 13556 025e 9B00     		lsls	r3, r3, #2
 13557              		.loc 2 3411 5
 13558 0260 BA6F     		ldr	r2, [r7, #120]
 13559 0262 1344     		add	r3, r3, r2
 13560 0264 7B67     		str	r3, [r7, #116]
3412:keygen.c      **** 
3413:keygen.c      **** 	t1 = gt + slen * n;
 13561              		.loc 2 3413 17
 13562 0266 D7F89430 		ldr	r3, [r7, #148]
 13563 026a D7F89C20 		ldr	r2, [r7, #156]
 13564 026e 02FB03F3 		mul	r3, r2, r3
 13565              		.loc 2 3413 10
 13566 0272 9B00     		lsls	r3, r3, #2
 13567              		.loc 2 3413 5
 13568 0274 7A6F     		ldr	r2, [r7, #116]
 13569 0276 1344     		add	r3, r3, r2
 13570 0278 3B67     		str	r3, [r7, #112]
3414:keygen.c      **** 
3415:keygen.c      **** 	/*
3416:keygen.c      **** 	 * Compute our F and G modulo sufficiently many small primes.
3417:keygen.c      **** 	 */
3418:keygen.c      **** 	for (u = 0; u < llen; u ++) {
 13571              		.loc 2 3418 9
 13572 027a 0023     		movs	r3, #0
 13573 027c C7F8DC30 		str	r3, [r7, #220]
 13574              		.loc 2 3418 2
 13575 0280 7FE2     		b	.L312
 13576              	.L325:
 13577              	.LBB51:
3419:keygen.c      **** 		uint32_t p, p0i, R2;
3420:keygen.c      **** 		uint32_t *gm, *igm, *fx, *gx, *Fp, *Gp;
3421:keygen.c      **** 		unsigned e;
3422:keygen.c      **** 		size_t v;
3423:keygen.c      **** 
3424:keygen.c      **** 		/*
3425:keygen.c      **** 		 * All computations are done modulo p.
3426:keygen.c      **** 		 */
3427:keygen.c      **** 		p = PRIMES[u].p;
 13578              		.loc 2 3427 5
 13579 0282 2449     		ldr	r1, .L333+8
 13580 0284 D7F8DC20 		ldr	r2, [r7, #220]
 13581 0288 1346     		mov	r3, r2
 13582 028a 5B00     		lsls	r3, r3, #1
 13583 028c 1344     		add	r3, r3, r2
 13584 028e 9B00     		lsls	r3, r3, #2
 13585 0290 0B44     		add	r3, r3, r1
 13586 0292 1B68     		ldr	r3, [r3]
 13587 0294 FB64     		str	r3, [r7, #76]
3428:keygen.c      **** 		p0i = modp_ninv31(p);
 13588              		.loc 2 3428 9
 13589 0296 F86C     		ldr	r0, [r7, #76]
 13590 0298 FFF7FEFF 		bl	modp_ninv31
 13591 029c B864     		str	r0, [r7, #72]
3429:keygen.c      **** 		R2 = modp_R2(p, p0i);
 13592              		.loc 2 3429 8
 13593 029e B96C     		ldr	r1, [r7, #72]
 13594 02a0 F86C     		ldr	r0, [r7, #76]
 13595 02a2 FFF7FEFF 		bl	modp_R2
 13596 02a6 7864     		str	r0, [r7, #68]
3430:keygen.c      **** 
3431:keygen.c      **** 		/*
3432:keygen.c      **** 		 * We recompute things from the source f and g, of full
3433:keygen.c      **** 		 * degree. However, we will need only the n first elements
3434:keygen.c      **** 		 * of the inverse NTT table (igm); the call to modp_mkgm()
3435:keygen.c      **** 		 * below will fill n_top elements in igm[] (thus overflowing
3436:keygen.c      **** 		 * into fx[]) but later code will overwrite these extra
3437:keygen.c      **** 		 * elements.
3438:keygen.c      **** 		 */
3439:keygen.c      **** 		gm = t1;
 13597              		.loc 2 3439 6
 13598 02a8 3B6F     		ldr	r3, [r7, #112]
 13599 02aa 3B64     		str	r3, [r7, #64]
3440:keygen.c      **** 		igm = gm + n_top;
 13600              		.loc 2 3440 12
 13601 02ac D7F8A430 		ldr	r3, [r7, #164]
 13602 02b0 9B00     		lsls	r3, r3, #2
 13603              		.loc 2 3440 7
 13604 02b2 3A6C     		ldr	r2, [r7, #64]
 13605 02b4 1344     		add	r3, r3, r2
 13606 02b6 C7F8BC30 		str	r3, [r7, #188]
3441:keygen.c      **** 		fx = igm + n;
 13607              		.loc 2 3441 12
 13608 02ba D7F89C30 		ldr	r3, [r7, #156]
 13609 02be 9B00     		lsls	r3, r3, #2
 13610              		.loc 2 3441 6
 13611 02c0 D7F8BC20 		ldr	r2, [r7, #188]
 13612 02c4 1344     		add	r3, r3, r2
 13613 02c6 C7F8B830 		str	r3, [r7, #184]
3442:keygen.c      **** 		gx = fx + n_top;
 13614              		.loc 2 3442 11
 13615 02ca D7F8A430 		ldr	r3, [r7, #164]
 13616 02ce 9B00     		lsls	r3, r3, #2
 13617              		.loc 2 3442 6
 13618 02d0 D7F8B820 		ldr	r2, [r7, #184]
 13619 02d4 1344     		add	r3, r3, r2
 13620 02d6 C7F8B430 		str	r3, [r7, #180]
3443:keygen.c      **** 		modp_mkgm2(gm, igm, logn_top, PRIMES[u].g, p, p0i);
 13621              		.loc 2 3443 3
 13622 02da 0E49     		ldr	r1, .L333+8
 13623 02dc D7F8DC20 		ldr	r2, [r7, #220]
 13624 02e0 1346     		mov	r3, r2
 13625 02e2 5B00     		lsls	r3, r3, #1
 13626 02e4 1344     		add	r3, r3, r2
 13627 02e6 9B00     		lsls	r3, r3, #2
 13628 02e8 0B44     		add	r3, r3, r1
 13629 02ea 0433     		adds	r3, r3, #4
 13630 02ec 1A68     		ldr	r2, [r3]
 13631 02ee BB6C     		ldr	r3, [r7, #72]
 13632 02f0 0193     		str	r3, [sp, #4]
 13633 02f2 FB6C     		ldr	r3, [r7, #76]
 13634 02f4 0093     		str	r3, [sp]
 13635 02f6 1346     		mov	r3, r2
 13636 02f8 FA68     		ldr	r2, [r7, #12]
 13637 02fa D7F8BC10 		ldr	r1, [r7, #188]
 13638 02fe 386C     		ldr	r0, [r7, #64]
 13639 0300 FFF7FEFF 		bl	modp_mkgm2
3444:keygen.c      **** 
3445:keygen.c      **** 		/*
3446:keygen.c      **** 		 * Set ft and gt to f and g modulo p, respectively.
3447:keygen.c      **** 		 */
3448:keygen.c      **** 		for (v = 0; v < n_top; v ++) {
 13640              		.loc 2 3448 10
 13641 0304 0023     		movs	r3, #0
 13642 0306 C7F8AC30 		str	r3, [r7, #172]
 13643              		.loc 2 3448 3
 13644 030a 2EE0     		b	.L313
 13645              	.L334:
 13646              		.align	2
 13647              	.L333:
 13648 030c 90220000 		.word	MAX_BL_SMALL
 13649 0310 BC220000 		.word	MAX_BL_LARGE
 13650 0314 40010000 		.word	PRIMES
 13651              	.L314:
3449:keygen.c      **** 			fx[v] = modp_set(f[v], p);
 13652              		.loc 2 3449 22 discriminator 3
 13653 0318 BA68     		ldr	r2, [r7, #8]
 13654 031a D7F8AC30 		ldr	r3, [r7, #172]
 13655 031e 1344     		add	r3, r3, r2
 13656 0320 93F90030 		ldrsb	r3, [r3]
 13657              		.loc 2 3449 12 discriminator 3
 13658 0324 1846     		mov	r0, r3
 13659              		.loc 2 3449 6 discriminator 3
 13660 0326 D7F8AC30 		ldr	r3, [r7, #172]
 13661 032a 9B00     		lsls	r3, r3, #2
 13662 032c D7F8B820 		ldr	r2, [r7, #184]
 13663 0330 D418     		adds	r4, r2, r3
 13664              		.loc 2 3449 12 discriminator 3
 13665 0332 F96C     		ldr	r1, [r7, #76]
 13666 0334 FFF7FEFF 		bl	modp_set
 13667 0338 0346     		mov	r3, r0
 13668              		.loc 2 3449 10 discriminator 3
 13669 033a 2360     		str	r3, [r4]
3450:keygen.c      **** 			gx[v] = modp_set(g[v], p);
 13670              		.loc 2 3450 22 discriminator 3
 13671 033c 7A68     		ldr	r2, [r7, #4]
 13672 033e D7F8AC30 		ldr	r3, [r7, #172]
 13673 0342 1344     		add	r3, r3, r2
 13674 0344 93F90030 		ldrsb	r3, [r3]
 13675              		.loc 2 3450 12 discriminator 3
 13676 0348 1846     		mov	r0, r3
 13677              		.loc 2 3450 6 discriminator 3
 13678 034a D7F8AC30 		ldr	r3, [r7, #172]
 13679 034e 9B00     		lsls	r3, r3, #2
 13680 0350 D7F8B420 		ldr	r2, [r7, #180]
 13681 0354 D418     		adds	r4, r2, r3
 13682              		.loc 2 3450 12 discriminator 3
 13683 0356 F96C     		ldr	r1, [r7, #76]
 13684 0358 FFF7FEFF 		bl	modp_set
 13685 035c 0346     		mov	r3, r0
 13686              		.loc 2 3450 10 discriminator 3
 13687 035e 2360     		str	r3, [r4]
3448:keygen.c      **** 			fx[v] = modp_set(f[v], p);
 13688              		.loc 2 3448 28 discriminator 3
 13689 0360 D7F8AC30 		ldr	r3, [r7, #172]
 13690 0364 0133     		adds	r3, r3, #1
 13691 0366 C7F8AC30 		str	r3, [r7, #172]
 13692              	.L313:
3448:keygen.c      **** 			fx[v] = modp_set(f[v], p);
 13693              		.loc 2 3448 3 discriminator 1
 13694 036a D7F8AC20 		ldr	r2, [r7, #172]
 13695 036e D7F8A430 		ldr	r3, [r7, #164]
 13696 0372 9A42     		cmp	r2, r3
 13697 0374 D0D3     		bcc	.L314
3451:keygen.c      **** 		}
3452:keygen.c      **** 
3453:keygen.c      **** 		/*
3454:keygen.c      **** 		 * Convert to NTT and compute our f and g.
3455:keygen.c      **** 		 */
3456:keygen.c      **** 		modp_NTT2(fx, gm, logn_top, p, p0i);
 13698              		.loc 2 3456 3
 13699 0376 BB6C     		ldr	r3, [r7, #72]
 13700 0378 0193     		str	r3, [sp, #4]
 13701 037a FB6C     		ldr	r3, [r7, #76]
 13702 037c 0093     		str	r3, [sp]
 13703 037e FB68     		ldr	r3, [r7, #12]
 13704 0380 3A6C     		ldr	r2, [r7, #64]
 13705 0382 0121     		movs	r1, #1
 13706 0384 D7F8B800 		ldr	r0, [r7, #184]
 13707 0388 FFF7FEFF 		bl	modp_NTT2_ext
3457:keygen.c      **** 		modp_NTT2(gx, gm, logn_top, p, p0i);
 13708              		.loc 2 3457 3
 13709 038c BB6C     		ldr	r3, [r7, #72]
 13710 038e 0193     		str	r3, [sp, #4]
 13711 0390 FB6C     		ldr	r3, [r7, #76]
 13712 0392 0093     		str	r3, [sp]
 13713 0394 FB68     		ldr	r3, [r7, #12]
 13714 0396 3A6C     		ldr	r2, [r7, #64]
 13715 0398 0121     		movs	r1, #1
 13716 039a D7F8B400 		ldr	r0, [r7, #180]
 13717 039e FFF7FEFF 		bl	modp_NTT2_ext
3458:keygen.c      **** 		for (e = logn_top; e > logn; e --) {
 13718              		.loc 2 3458 10
 13719 03a2 FB68     		ldr	r3, [r7, #12]
 13720 03a4 C7F8B030 		str	r3, [r7, #176]
 13721              		.loc 2 3458 3
 13722 03a8 18E0     		b	.L315
 13723              	.L316:
3459:keygen.c      **** 			modp_poly_rec_res(fx, e, p, p0i, R2);
 13724              		.loc 2 3459 4 discriminator 3
 13725 03aa 7B6C     		ldr	r3, [r7, #68]
 13726 03ac 0093     		str	r3, [sp]
 13727 03ae BB6C     		ldr	r3, [r7, #72]
 13728 03b0 FA6C     		ldr	r2, [r7, #76]
 13729 03b2 D7F8B010 		ldr	r1, [r7, #176]
 13730 03b6 D7F8B800 		ldr	r0, [r7, #184]
 13731 03ba FFF7FEFF 		bl	modp_poly_rec_res
3460:keygen.c      **** 			modp_poly_rec_res(gx, e, p, p0i, R2);
 13732              		.loc 2 3460 4 discriminator 3
 13733 03be 7B6C     		ldr	r3, [r7, #68]
 13734 03c0 0093     		str	r3, [sp]
 13735 03c2 BB6C     		ldr	r3, [r7, #72]
 13736 03c4 FA6C     		ldr	r2, [r7, #76]
 13737 03c6 D7F8B010 		ldr	r1, [r7, #176]
 13738 03ca D7F8B400 		ldr	r0, [r7, #180]
 13739 03ce FFF7FEFF 		bl	modp_poly_rec_res
3458:keygen.c      **** 		for (e = logn_top; e > logn; e --) {
 13740              		.loc 2 3458 34 discriminator 3
 13741 03d2 D7F8B030 		ldr	r3, [r7, #176]
 13742 03d6 013B     		subs	r3, r3, #1
 13743 03d8 C7F8B030 		str	r3, [r7, #176]
 13744              	.L315:
3458:keygen.c      **** 		for (e = logn_top; e > logn; e --) {
 13745              		.loc 2 3458 3 discriminator 1
 13746 03dc D7F8B020 		ldr	r2, [r7, #176]
 13747 03e0 D7F8A030 		ldr	r3, [r7, #160]
 13748 03e4 9A42     		cmp	r2, r3
 13749 03e6 E0D8     		bhi	.L316
3461:keygen.c      **** 		}
3462:keygen.c      **** 
3463:keygen.c      **** 		/*
3464:keygen.c      **** 		 * From that point onward, we only need tables for
3465:keygen.c      **** 		 * degree n, so we can save some space.
3466:keygen.c      **** 		 */
3467:keygen.c      **** 		if (depth > 0) { /* always true */
 13750              		.loc 2 3467 6
 13751 03e8 D7F8A830 		ldr	r3, [r7, #168]
 13752 03ec 002B     		cmp	r3, #0
 13753 03ee 3FD0     		beq	.L317
3468:keygen.c      **** 			memmove(gm + n, igm, n * sizeof *igm);
 13754              		.loc 2 3468 15
 13755 03f0 D7F89C30 		ldr	r3, [r7, #156]
 13756 03f4 9B00     		lsls	r3, r3, #2
 13757 03f6 3A6C     		ldr	r2, [r7, #64]
 13758 03f8 D018     		adds	r0, r2, r3
 13759              		.loc 2 3468 4
 13760 03fa D7F89C30 		ldr	r3, [r7, #156]
 13761 03fe 9B00     		lsls	r3, r3, #2
 13762 0400 1A46     		mov	r2, r3
 13763 0402 D7F8BC10 		ldr	r1, [r7, #188]
 13764 0406 FFF7FEFF 		bl	memmove
3469:keygen.c      **** 			igm = gm + n;
 13765              		.loc 2 3469 13
 13766 040a D7F89C30 		ldr	r3, [r7, #156]
 13767 040e 9B00     		lsls	r3, r3, #2
 13768              		.loc 2 3469 8
 13769 0410 3A6C     		ldr	r2, [r7, #64]
 13770 0412 1344     		add	r3, r3, r2
 13771 0414 C7F8BC30 		str	r3, [r7, #188]
3470:keygen.c      **** 			memmove(igm + n, fx, n * sizeof *ft);
 13772              		.loc 2 3470 16
 13773 0418 D7F89C30 		ldr	r3, [r7, #156]
 13774 041c 9B00     		lsls	r3, r3, #2
 13775 041e D7F8BC20 		ldr	r2, [r7, #188]
 13776 0422 D018     		adds	r0, r2, r3
 13777              		.loc 2 3470 4
 13778 0424 D7F89C30 		ldr	r3, [r7, #156]
 13779 0428 9B00     		lsls	r3, r3, #2
 13780 042a 1A46     		mov	r2, r3
 13781 042c D7F8B810 		ldr	r1, [r7, #184]
 13782 0430 FFF7FEFF 		bl	memmove
3471:keygen.c      **** 			fx = igm + n;
 13783              		.loc 2 3471 13
 13784 0434 D7F89C30 		ldr	r3, [r7, #156]
 13785 0438 9B00     		lsls	r3, r3, #2
 13786              		.loc 2 3471 7
 13787 043a D7F8BC20 		ldr	r2, [r7, #188]
 13788 043e 1344     		add	r3, r3, r2
 13789 0440 C7F8B830 		str	r3, [r7, #184]
3472:keygen.c      **** 			memmove(fx + n, gx, n * sizeof *gt);
 13790              		.loc 2 3472 15
 13791 0444 D7F89C30 		ldr	r3, [r7, #156]
 13792 0448 9B00     		lsls	r3, r3, #2
 13793 044a D7F8B820 		ldr	r2, [r7, #184]
 13794 044e D018     		adds	r0, r2, r3
 13795              		.loc 2 3472 4
 13796 0450 D7F89C30 		ldr	r3, [r7, #156]
 13797 0454 9B00     		lsls	r3, r3, #2
 13798 0456 1A46     		mov	r2, r3
 13799 0458 D7F8B410 		ldr	r1, [r7, #180]
 13800 045c FFF7FEFF 		bl	memmove
3473:keygen.c      **** 			gx = fx + n;
 13801              		.loc 2 3473 12
 13802 0460 D7F89C30 		ldr	r3, [r7, #156]
 13803 0464 9B00     		lsls	r3, r3, #2
 13804              		.loc 2 3473 7
 13805 0466 D7F8B820 		ldr	r2, [r7, #184]
 13806 046a 1344     		add	r3, r3, r2
 13807 046c C7F8B430 		str	r3, [r7, #180]
 13808              	.L317:
3474:keygen.c      **** 		}
3475:keygen.c      **** 
3476:keygen.c      **** 		/*
3477:keygen.c      **** 		 * Get F' and G' modulo p and in NTT representation
3478:keygen.c      **** 		 * (they have degree n/2). These values were computed
3479:keygen.c      **** 		 * in a previous step, and stored in Ft and Gt.
3480:keygen.c      **** 		 */
3481:keygen.c      **** 		Fp = gx + n;
 13809              		.loc 2 3481 11
 13810 0470 D7F89C30 		ldr	r3, [r7, #156]
 13811 0474 9B00     		lsls	r3, r3, #2
 13812              		.loc 2 3481 6
 13813 0476 D7F8B420 		ldr	r2, [r7, #180]
 13814 047a 1344     		add	r3, r3, r2
 13815 047c FB63     		str	r3, [r7, #60]
3482:keygen.c      **** 		Gp = Fp + hn;
 13816              		.loc 2 3482 11
 13817 047e D7F89830 		ldr	r3, [r7, #152]
 13818 0482 9B00     		lsls	r3, r3, #2
 13819              		.loc 2 3482 6
 13820 0484 FA6B     		ldr	r2, [r7, #60]
 13821 0486 1344     		add	r3, r3, r2
 13822 0488 BB63     		str	r3, [r7, #56]
3483:keygen.c      **** 		for (v = 0, x = Ft + u, y = Gt + u;
 13823              		.loc 2 3483 10
 13824 048a 0023     		movs	r3, #0
 13825 048c C7F8AC30 		str	r3, [r7, #172]
 13826              		.loc 2 3483 22
 13827 0490 D7F8DC30 		ldr	r3, [r7, #220]
 13828 0494 9B00     		lsls	r3, r3, #2
 13829              		.loc 2 3483 17
 13830 0496 D7F88020 		ldr	r2, [r7, #128]
 13831 049a 1344     		add	r3, r3, r2
 13832 049c C7F8D830 		str	r3, [r7, #216]
 13833              		.loc 2 3483 34
 13834 04a0 D7F8DC30 		ldr	r3, [r7, #220]
 13835 04a4 9B00     		lsls	r3, r3, #2
 13836              		.loc 2 3483 29
 13837 04a6 FA6F     		ldr	r2, [r7, #124]
 13838 04a8 1344     		add	r3, r3, r2
 13839 04aa C7F8D430 		str	r3, [r7, #212]
 13840              		.loc 2 3483 3
 13841 04ae 26E0     		b	.L318
 13842              	.L319:
3484:keygen.c      **** 			v < hn; v ++, x += llen, y += llen)
3485:keygen.c      **** 		{
3486:keygen.c      **** 			Fp[v] = *x;
 13843              		.loc 2 3486 6
 13844 04b0 D7F8AC30 		ldr	r3, [r7, #172]
 13845 04b4 9B00     		lsls	r3, r3, #2
 13846 04b6 FA6B     		ldr	r2, [r7, #60]
 13847 04b8 1344     		add	r3, r3, r2
 13848              		.loc 2 3486 12
 13849 04ba D7F8D820 		ldr	r2, [r7, #216]
 13850 04be 1268     		ldr	r2, [r2]
 13851              		.loc 2 3486 10
 13852 04c0 1A60     		str	r2, [r3]
3487:keygen.c      **** 			Gp[v] = *y;
 13853              		.loc 2 3487 6
 13854 04c2 D7F8AC30 		ldr	r3, [r7, #172]
 13855 04c6 9B00     		lsls	r3, r3, #2
 13856 04c8 BA6B     		ldr	r2, [r7, #56]
 13857 04ca 1344     		add	r3, r3, r2
 13858              		.loc 2 3487 12
 13859 04cc D7F8D420 		ldr	r2, [r7, #212]
 13860 04d0 1268     		ldr	r2, [r2]
 13861              		.loc 2 3487 10
 13862 04d2 1A60     		str	r2, [r3]
3484:keygen.c      **** 			v < hn; v ++, x += llen, y += llen)
 13863              		.loc 2 3484 14
 13864 04d4 D7F8AC30 		ldr	r3, [r7, #172]
 13865 04d8 0133     		adds	r3, r3, #1
 13866 04da C7F8AC30 		str	r3, [r7, #172]
3484:keygen.c      **** 			v < hn; v ++, x += llen, y += llen)
 13867              		.loc 2 3484 20
 13868 04de D7F88C30 		ldr	r3, [r7, #140]
 13869 04e2 9B00     		lsls	r3, r3, #2
 13870 04e4 D7F8D820 		ldr	r2, [r7, #216]
 13871 04e8 1344     		add	r3, r3, r2
 13872 04ea C7F8D830 		str	r3, [r7, #216]
3484:keygen.c      **** 			v < hn; v ++, x += llen, y += llen)
 13873              		.loc 2 3484 31
 13874 04ee D7F88C30 		ldr	r3, [r7, #140]
 13875 04f2 9B00     		lsls	r3, r3, #2
 13876 04f4 D7F8D420 		ldr	r2, [r7, #212]
 13877 04f8 1344     		add	r3, r3, r2
 13878 04fa C7F8D430 		str	r3, [r7, #212]
 13879              	.L318:
3483:keygen.c      **** 		for (v = 0, x = Ft + u, y = Gt + u;
 13880              		.loc 2 3483 3 discriminator 1
 13881 04fe D7F8AC20 		ldr	r2, [r7, #172]
 13882 0502 D7F89830 		ldr	r3, [r7, #152]
 13883 0506 9A42     		cmp	r2, r3
 13884 0508 D2D3     		bcc	.L319
3488:keygen.c      **** 		}
3489:keygen.c      **** 		modp_NTT2(Fp, gm, logn - 1, p, p0i);
 13885              		.loc 2 3489 3
 13886 050a D7F8A030 		ldr	r3, [r7, #160]
 13887 050e 5A1E     		subs	r2, r3, #1
 13888 0510 BB6C     		ldr	r3, [r7, #72]
 13889 0512 0193     		str	r3, [sp, #4]
 13890 0514 FB6C     		ldr	r3, [r7, #76]
 13891 0516 0093     		str	r3, [sp]
 13892 0518 1346     		mov	r3, r2
 13893 051a 3A6C     		ldr	r2, [r7, #64]
 13894 051c 0121     		movs	r1, #1
 13895 051e F86B     		ldr	r0, [r7, #60]
 13896 0520 FFF7FEFF 		bl	modp_NTT2_ext
3490:keygen.c      **** 		modp_NTT2(Gp, gm, logn - 1, p, p0i);
 13897              		.loc 2 3490 3
 13898 0524 D7F8A030 		ldr	r3, [r7, #160]
 13899 0528 5A1E     		subs	r2, r3, #1
 13900 052a BB6C     		ldr	r3, [r7, #72]
 13901 052c 0193     		str	r3, [sp, #4]
 13902 052e FB6C     		ldr	r3, [r7, #76]
 13903 0530 0093     		str	r3, [sp]
 13904 0532 1346     		mov	r3, r2
 13905 0534 3A6C     		ldr	r2, [r7, #64]
 13906 0536 0121     		movs	r1, #1
 13907 0538 B86B     		ldr	r0, [r7, #56]
 13908 053a FFF7FEFF 		bl	modp_NTT2_ext
3491:keygen.c      **** 
3492:keygen.c      **** 		/*
3493:keygen.c      **** 		 * Compute our F and G modulo p.
3494:keygen.c      **** 		 *
3495:keygen.c      **** 		 * Equations are:
3496:keygen.c      **** 		 *
3497:keygen.c      **** 		 *   f'(x^2) = N(f)(x^2) = f * adj(f)
3498:keygen.c      **** 		 *   g'(x^2) = N(g)(x^2) = g * adj(g)
3499:keygen.c      **** 		 *
3500:keygen.c      **** 		 *   f'*G' - g'*F' = q
3501:keygen.c      **** 		 *
3502:keygen.c      **** 		 *   F = F'(x^2) * adj(g)
3503:keygen.c      **** 		 *   G = G'(x^2) * adj(f)
3504:keygen.c      **** 		 *
3505:keygen.c      **** 		 * The NTT representation of f is f(w) for all w which
3506:keygen.c      **** 		 * are roots of phi. In the binary case, as well as in
3507:keygen.c      **** 		 * the ternary case for all depth except the deepest,
3508:keygen.c      **** 		 * these roots can be grouped in pairs (w,-w), and we
3509:keygen.c      **** 		 * then have:
3510:keygen.c      **** 		 *
3511:keygen.c      **** 		 *   f(w) = adj(f)(-w)
3512:keygen.c      **** 		 *   f(-w) = adj(f)(w)
3513:keygen.c      **** 		 *
3514:keygen.c      **** 		 * and w^2 is then a root for phi at the half-degree.
3515:keygen.c      **** 		 *
3516:keygen.c      **** 		 * At the deepest level in the ternary case, this still
3517:keygen.c      **** 		 * holds, in the following sense: the roots of x^2-x+1
3518:keygen.c      **** 		 * are (w,-w^2) (for w^3 = -1, and w != -1), and we
3519:keygen.c      **** 		 * have:
3520:keygen.c      **** 		 *
3521:keygen.c      **** 		 *   f(w) = adj(f)(-w^2)
3522:keygen.c      **** 		 *   f(-w^2) = adj(f)(w)
3523:keygen.c      **** 		 *
3524:keygen.c      **** 		 * In all case, we can thus compute F and G in NTT
3525:keygen.c      **** 		 * representation by a few simple multiplications.
3526:keygen.c      **** 		 * Moreover, the two roots for each pair are consecutive
3527:keygen.c      **** 		 * in our bit-reversal encoding.
3528:keygen.c      **** 		 */
3529:keygen.c      **** 		for (v = 0, x = Ft + u, y = Gt + u;
 13909              		.loc 2 3529 10
 13910 053e 0023     		movs	r3, #0
 13911 0540 C7F8AC30 		str	r3, [r7, #172]
 13912              		.loc 2 3529 22
 13913 0544 D7F8DC30 		ldr	r3, [r7, #220]
 13914 0548 9B00     		lsls	r3, r3, #2
 13915              		.loc 2 3529 17
 13916 054a D7F88020 		ldr	r2, [r7, #128]
 13917 054e 1344     		add	r3, r3, r2
 13918 0550 C7F8D830 		str	r3, [r7, #216]
 13919              		.loc 2 3529 34
 13920 0554 D7F8DC30 		ldr	r3, [r7, #220]
 13921 0558 9B00     		lsls	r3, r3, #2
 13922              		.loc 2 3529 29
 13923 055a FA6F     		ldr	r2, [r7, #124]
 13924 055c 1344     		add	r3, r3, r2
 13925 055e C7F8D430 		str	r3, [r7, #212]
 13926              		.loc 2 3529 3
 13927 0562 7EE0     		b	.L320
 13928              	.L321:
 13929              	.LBB52:
3530:keygen.c      **** 			v < hn; v ++, x += (llen << 1), y += (llen << 1))
3531:keygen.c      **** 		{
3532:keygen.c      **** 			uint32_t ftA, ftB, gtA, gtB;
3533:keygen.c      **** 			uint32_t mFp, mGp;
3534:keygen.c      **** 
3535:keygen.c      **** 			ftA = fx[(v << 1) + 0];
 13930              		.loc 2 3535 12
 13931 0564 D7F8AC30 		ldr	r3, [r7, #172]
 13932 0568 DB00     		lsls	r3, r3, #3
 13933 056a D7F8B820 		ldr	r2, [r7, #184]
 13934 056e 1344     		add	r3, r3, r2
 13935              		.loc 2 3535 8
 13936 0570 1B68     		ldr	r3, [r3]
 13937 0572 7B63     		str	r3, [r7, #52]
3536:keygen.c      **** 			ftB = fx[(v << 1) + 1];
 13938              		.loc 2 3536 12
 13939 0574 D7F8AC30 		ldr	r3, [r7, #172]
 13940 0578 DB00     		lsls	r3, r3, #3
 13941 057a 0433     		adds	r3, r3, #4
 13942 057c D7F8B820 		ldr	r2, [r7, #184]
 13943 0580 1344     		add	r3, r3, r2
 13944              		.loc 2 3536 8
 13945 0582 1B68     		ldr	r3, [r3]
 13946 0584 3B63     		str	r3, [r7, #48]
3537:keygen.c      **** 			gtA = gx[(v << 1) + 0];
 13947              		.loc 2 3537 12
 13948 0586 D7F8AC30 		ldr	r3, [r7, #172]
 13949 058a DB00     		lsls	r3, r3, #3
 13950 058c D7F8B420 		ldr	r2, [r7, #180]
 13951 0590 1344     		add	r3, r3, r2
 13952              		.loc 2 3537 8
 13953 0592 1B68     		ldr	r3, [r3]
 13954 0594 FB62     		str	r3, [r7, #44]
3538:keygen.c      **** 			gtB = gx[(v << 1) + 1];
 13955              		.loc 2 3538 12
 13956 0596 D7F8AC30 		ldr	r3, [r7, #172]
 13957 059a DB00     		lsls	r3, r3, #3
 13958 059c 0433     		adds	r3, r3, #4
 13959 059e D7F8B420 		ldr	r2, [r7, #180]
 13960 05a2 1344     		add	r3, r3, r2
 13961              		.loc 2 3538 8
 13962 05a4 1B68     		ldr	r3, [r3]
 13963 05a6 BB62     		str	r3, [r7, #40]
3539:keygen.c      **** 			mFp = modp_montymul(Fp[v], R2, p, p0i);
 13964              		.loc 2 3539 26
 13965 05a8 D7F8AC30 		ldr	r3, [r7, #172]
 13966 05ac 9B00     		lsls	r3, r3, #2
 13967 05ae FA6B     		ldr	r2, [r7, #60]
 13968 05b0 1344     		add	r3, r3, r2
 13969              		.loc 2 3539 10
 13970 05b2 1868     		ldr	r0, [r3]
 13971 05b4 BB6C     		ldr	r3, [r7, #72]
 13972 05b6 FA6C     		ldr	r2, [r7, #76]
 13973 05b8 796C     		ldr	r1, [r7, #68]
 13974 05ba FFF7FEFF 		bl	modp_montymul
 13975 05be 7862     		str	r0, [r7, #36]
3540:keygen.c      **** 			mGp = modp_montymul(Gp[v], R2, p, p0i);
 13976              		.loc 2 3540 26
 13977 05c0 D7F8AC30 		ldr	r3, [r7, #172]
 13978 05c4 9B00     		lsls	r3, r3, #2
 13979 05c6 BA6B     		ldr	r2, [r7, #56]
 13980 05c8 1344     		add	r3, r3, r2
 13981              		.loc 2 3540 10
 13982 05ca 1868     		ldr	r0, [r3]
 13983 05cc BB6C     		ldr	r3, [r7, #72]
 13984 05ce FA6C     		ldr	r2, [r7, #76]
 13985 05d0 796C     		ldr	r1, [r7, #68]
 13986 05d2 FFF7FEFF 		bl	modp_montymul
 13987 05d6 3862     		str	r0, [r7, #32]
3541:keygen.c      **** 			x[0] = modp_montymul(gtB, mFp, p, p0i);
 13988              		.loc 2 3541 11
 13989 05d8 BB6C     		ldr	r3, [r7, #72]
 13990 05da FA6C     		ldr	r2, [r7, #76]
 13991 05dc 796A     		ldr	r1, [r7, #36]
 13992 05de B86A     		ldr	r0, [r7, #40]
 13993 05e0 FFF7FEFF 		bl	modp_montymul
 13994 05e4 0246     		mov	r2, r0
 13995              		.loc 2 3541 9
 13996 05e6 D7F8D830 		ldr	r3, [r7, #216]
 13997 05ea 1A60     		str	r2, [r3]
3542:keygen.c      **** 			x[llen] = modp_montymul(gtA, mFp, p, p0i);
 13998              		.loc 2 3542 5
 13999 05ec D7F88C30 		ldr	r3, [r7, #140]
 14000 05f0 9B00     		lsls	r3, r3, #2
 14001 05f2 D7F8D820 		ldr	r2, [r7, #216]
 14002 05f6 D418     		adds	r4, r2, r3
 14003              		.loc 2 3542 14
 14004 05f8 BB6C     		ldr	r3, [r7, #72]
 14005 05fa FA6C     		ldr	r2, [r7, #76]
 14006 05fc 796A     		ldr	r1, [r7, #36]
 14007 05fe F86A     		ldr	r0, [r7, #44]
 14008 0600 FFF7FEFF 		bl	modp_montymul
 14009 0604 0346     		mov	r3, r0
 14010              		.loc 2 3542 12
 14011 0606 2360     		str	r3, [r4]
3543:keygen.c      **** 			y[0] = modp_montymul(ftB, mGp, p, p0i);
 14012              		.loc 2 3543 11
 14013 0608 BB6C     		ldr	r3, [r7, #72]
 14014 060a FA6C     		ldr	r2, [r7, #76]
 14015 060c 396A     		ldr	r1, [r7, #32]
 14016 060e 386B     		ldr	r0, [r7, #48]
 14017 0610 FFF7FEFF 		bl	modp_montymul
 14018 0614 0246     		mov	r2, r0
 14019              		.loc 2 3543 9
 14020 0616 D7F8D430 		ldr	r3, [r7, #212]
 14021 061a 1A60     		str	r2, [r3]
3544:keygen.c      **** 			y[llen] = modp_montymul(ftA, mGp, p, p0i);
 14022              		.loc 2 3544 5
 14023 061c D7F88C30 		ldr	r3, [r7, #140]
 14024 0620 9B00     		lsls	r3, r3, #2
 14025 0622 D7F8D420 		ldr	r2, [r7, #212]
 14026 0626 D418     		adds	r4, r2, r3
 14027              		.loc 2 3544 14
 14028 0628 BB6C     		ldr	r3, [r7, #72]
 14029 062a FA6C     		ldr	r2, [r7, #76]
 14030 062c 396A     		ldr	r1, [r7, #32]
 14031 062e 786B     		ldr	r0, [r7, #52]
 14032 0630 FFF7FEFF 		bl	modp_montymul
 14033 0634 0346     		mov	r3, r0
 14034              		.loc 2 3544 12
 14035 0636 2360     		str	r3, [r4]
 14036              	.LBE52:
3530:keygen.c      **** 		{
 14037              		.loc 2 3530 14
 14038 0638 D7F8AC30 		ldr	r3, [r7, #172]
 14039 063c 0133     		adds	r3, r3, #1
 14040 063e C7F8AC30 		str	r3, [r7, #172]
3530:keygen.c      **** 		{
 14041              		.loc 2 3530 20
 14042 0642 D7F88C30 		ldr	r3, [r7, #140]
 14043 0646 DB00     		lsls	r3, r3, #3
 14044 0648 D7F8D820 		ldr	r2, [r7, #216]
 14045 064c 1344     		add	r3, r3, r2
 14046 064e C7F8D830 		str	r3, [r7, #216]
3530:keygen.c      **** 		{
 14047              		.loc 2 3530 38
 14048 0652 D7F88C30 		ldr	r3, [r7, #140]
 14049 0656 DB00     		lsls	r3, r3, #3
 14050 0658 D7F8D420 		ldr	r2, [r7, #212]
 14051 065c 1344     		add	r3, r3, r2
 14052 065e C7F8D430 		str	r3, [r7, #212]
 14053              	.L320:
3529:keygen.c      **** 			v < hn; v ++, x += (llen << 1), y += (llen << 1))
 14054              		.loc 2 3529 3 discriminator 1
 14055 0662 D7F8AC20 		ldr	r2, [r7, #172]
 14056 0666 D7F89830 		ldr	r3, [r7, #152]
 14057 066a 9A42     		cmp	r2, r3
 14058 066c FFF47AAF 		bcc	.L321
3545:keygen.c      **** 		}
3546:keygen.c      **** 		modp_iNTT2_ext(Ft + u, llen, igm, logn, p, p0i);
 14059              		.loc 2 3546 21
 14060 0670 D7F8DC30 		ldr	r3, [r7, #220]
 14061 0674 9B00     		lsls	r3, r3, #2
 14062              		.loc 2 3546 3
 14063 0676 D7F88020 		ldr	r2, [r7, #128]
 14064 067a D018     		adds	r0, r2, r3
 14065 067c BB6C     		ldr	r3, [r7, #72]
 14066 067e 0193     		str	r3, [sp, #4]
 14067 0680 FB6C     		ldr	r3, [r7, #76]
 14068 0682 0093     		str	r3, [sp]
 14069 0684 D7F8A030 		ldr	r3, [r7, #160]
 14070 0688 D7F8BC20 		ldr	r2, [r7, #188]
 14071 068c D7F88C10 		ldr	r1, [r7, #140]
 14072 0690 FFF7FEFF 		bl	modp_iNTT2_ext
3547:keygen.c      **** 		modp_iNTT2_ext(Gt + u, llen, igm, logn, p, p0i);
 14073              		.loc 2 3547 21
 14074 0694 D7F8DC30 		ldr	r3, [r7, #220]
 14075 0698 9B00     		lsls	r3, r3, #2
 14076              		.loc 2 3547 3
 14077 069a FA6F     		ldr	r2, [r7, #124]
 14078 069c D018     		adds	r0, r2, r3
 14079 069e BB6C     		ldr	r3, [r7, #72]
 14080 06a0 0193     		str	r3, [sp, #4]
 14081 06a2 FB6C     		ldr	r3, [r7, #76]
 14082 06a4 0093     		str	r3, [sp]
 14083 06a6 D7F8A030 		ldr	r3, [r7, #160]
 14084 06aa D7F8BC20 		ldr	r2, [r7, #188]
 14085 06ae D7F88C10 		ldr	r1, [r7, #140]
 14086 06b2 FFF7FEFF 		bl	modp_iNTT2_ext
3548:keygen.c      **** 
3549:keygen.c      **** 		/*
3550:keygen.c      **** 		 * Also save ft and gt (only up to size slen).
3551:keygen.c      **** 		 */
3552:keygen.c      **** 		if (u < slen) {
 14087              		.loc 2 3552 6
 14088 06b6 D7F8DC20 		ldr	r2, [r7, #220]
 14089 06ba D7F89430 		ldr	r3, [r7, #148]
 14090 06be 9A42     		cmp	r2, r3
 14091 06c0 5AD2     		bcs	.L322
3553:keygen.c      **** 			modp_iNTT2(fx, igm, logn, p, p0i);
 14092              		.loc 2 3553 4
 14093 06c2 BB6C     		ldr	r3, [r7, #72]
 14094 06c4 0193     		str	r3, [sp, #4]
 14095 06c6 FB6C     		ldr	r3, [r7, #76]
 14096 06c8 0093     		str	r3, [sp]
 14097 06ca D7F8A030 		ldr	r3, [r7, #160]
 14098 06ce D7F8BC20 		ldr	r2, [r7, #188]
 14099 06d2 0121     		movs	r1, #1
 14100 06d4 D7F8B800 		ldr	r0, [r7, #184]
 14101 06d8 FFF7FEFF 		bl	modp_iNTT2_ext
3554:keygen.c      **** 			modp_iNTT2(gx, igm, logn, p, p0i);
 14102              		.loc 2 3554 4
 14103 06dc BB6C     		ldr	r3, [r7, #72]
 14104 06de 0193     		str	r3, [sp, #4]
 14105 06e0 FB6C     		ldr	r3, [r7, #76]
 14106 06e2 0093     		str	r3, [sp]
 14107 06e4 D7F8A030 		ldr	r3, [r7, #160]
 14108 06e8 D7F8BC20 		ldr	r2, [r7, #188]
 14109 06ec 0121     		movs	r1, #1
 14110 06ee D7F8B400 		ldr	r0, [r7, #180]
 14111 06f2 FFF7FEFF 		bl	modp_iNTT2_ext
3555:keygen.c      **** 			for (v = 0, x = ft + u, y = gt + u;
 14112              		.loc 2 3555 11
 14113 06f6 0023     		movs	r3, #0
 14114 06f8 C7F8AC30 		str	r3, [r7, #172]
 14115              		.loc 2 3555 23
 14116 06fc D7F8DC30 		ldr	r3, [r7, #220]
 14117 0700 9B00     		lsls	r3, r3, #2
 14118              		.loc 2 3555 18
 14119 0702 BA6F     		ldr	r2, [r7, #120]
 14120 0704 1344     		add	r3, r3, r2
 14121 0706 C7F8D830 		str	r3, [r7, #216]
 14122              		.loc 2 3555 35
 14123 070a D7F8DC30 		ldr	r3, [r7, #220]
 14124 070e 9B00     		lsls	r3, r3, #2
 14125              		.loc 2 3555 30
 14126 0710 7A6F     		ldr	r2, [r7, #116]
 14127 0712 1344     		add	r3, r3, r2
 14128 0714 C7F8D430 		str	r3, [r7, #212]
 14129              		.loc 2 3555 4
 14130 0718 28E0     		b	.L323
 14131              	.L324:
3556:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
3557:keygen.c      **** 			{
3558:keygen.c      **** 				*x = fx[v];
 14132              		.loc 2 3558 12
 14133 071a D7F8AC30 		ldr	r3, [r7, #172]
 14134 071e 9B00     		lsls	r3, r3, #2
 14135 0720 D7F8B820 		ldr	r2, [r7, #184]
 14136 0724 1344     		add	r3, r3, r2
 14137 0726 1A68     		ldr	r2, [r3]
 14138              		.loc 2 3558 8
 14139 0728 D7F8D830 		ldr	r3, [r7, #216]
 14140 072c 1A60     		str	r2, [r3]
3559:keygen.c      **** 				*y = gx[v];
 14141              		.loc 2 3559 12
 14142 072e D7F8AC30 		ldr	r3, [r7, #172]
 14143 0732 9B00     		lsls	r3, r3, #2
 14144 0734 D7F8B420 		ldr	r2, [r7, #180]
 14145 0738 1344     		add	r3, r3, r2
 14146 073a 1A68     		ldr	r2, [r3]
 14147              		.loc 2 3559 8
 14148 073c D7F8D430 		ldr	r3, [r7, #212]
 14149 0740 1A60     		str	r2, [r3]
3556:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 14150              		.loc 2 3556 14
 14151 0742 D7F8AC30 		ldr	r3, [r7, #172]
 14152 0746 0133     		adds	r3, r3, #1
 14153 0748 C7F8AC30 		str	r3, [r7, #172]
3556:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 14154              		.loc 2 3556 20
 14155 074c D7F89430 		ldr	r3, [r7, #148]
 14156 0750 9B00     		lsls	r3, r3, #2
 14157 0752 D7F8D820 		ldr	r2, [r7, #216]
 14158 0756 1344     		add	r3, r3, r2
 14159 0758 C7F8D830 		str	r3, [r7, #216]
3556:keygen.c      **** 				v < n; v ++, x += slen, y += slen)
 14160              		.loc 2 3556 31
 14161 075c D7F89430 		ldr	r3, [r7, #148]
 14162 0760 9B00     		lsls	r3, r3, #2
 14163 0762 D7F8D420 		ldr	r2, [r7, #212]
 14164 0766 1344     		add	r3, r3, r2
 14165 0768 C7F8D430 		str	r3, [r7, #212]
 14166              	.L323:
3555:keygen.c      **** 			for (v = 0, x = ft + u, y = gt + u;
 14167              		.loc 2 3555 4 discriminator 1
 14168 076c D7F8AC20 		ldr	r2, [r7, #172]
 14169 0770 D7F89C30 		ldr	r3, [r7, #156]
 14170 0774 9A42     		cmp	r2, r3
 14171 0776 D0D3     		bcc	.L324
 14172              	.L322:
 14173              	.LBE51:
3418:keygen.c      **** 		uint32_t p, p0i, R2;
 14174              		.loc 2 3418 26 discriminator 2
 14175 0778 D7F8DC30 		ldr	r3, [r7, #220]
 14176 077c 0133     		adds	r3, r3, #1
 14177 077e C7F8DC30 		str	r3, [r7, #220]
 14178              	.L312:
3418:keygen.c      **** 		uint32_t p, p0i, R2;
 14179              		.loc 2 3418 2 discriminator 1
 14180 0782 D7F8DC20 		ldr	r2, [r7, #220]
 14181 0786 D7F88C30 		ldr	r3, [r7, #140]
 14182 078a 9A42     		cmp	r2, r3
 14183 078c FFF479AD 		bcc	.L325
3560:keygen.c      **** 			}
3561:keygen.c      **** 		}
3562:keygen.c      **** 	}
3563:keygen.c      **** 
3564:keygen.c      **** 	/*
3565:keygen.c      **** 	 * Rebuild f, g, F and G with the CRT. Note that the elements of F
3566:keygen.c      **** 	 * and G are consecutive, and thus can be rebuilt in a single
3567:keygen.c      **** 	 * loop; similarly, the elements of f and g are consecutive.
3568:keygen.c      **** 	 */
3569:keygen.c      **** 	zint_rebuild_CRT(Ft, llen, llen, n << 1, PRIMES, 1, t1);
 14184              		.loc 2 3569 2
 14185 0790 D7F89C30 		ldr	r3, [r7, #156]
 14186 0794 5A00     		lsls	r2, r3, #1
 14187 0796 3B6F     		ldr	r3, [r7, #112]
 14188 0798 0293     		str	r3, [sp, #8]
 14189 079a 0123     		movs	r3, #1
 14190 079c 0193     		str	r3, [sp, #4]
 14191 079e 8D4B     		ldr	r3, .L335
 14192 07a0 0093     		str	r3, [sp]
 14193 07a2 1346     		mov	r3, r2
 14194 07a4 D7F88C20 		ldr	r2, [r7, #140]
 14195 07a8 D7F88C10 		ldr	r1, [r7, #140]
 14196 07ac D7F88000 		ldr	r0, [r7, #128]
 14197 07b0 FFF7FEFF 		bl	zint_rebuild_CRT
3570:keygen.c      **** 	zint_rebuild_CRT(ft, slen, slen, n << 1, PRIMES, 1, t1);
 14198              		.loc 2 3570 2
 14199 07b4 D7F89C30 		ldr	r3, [r7, #156]
 14200 07b8 5A00     		lsls	r2, r3, #1
 14201 07ba 3B6F     		ldr	r3, [r7, #112]
 14202 07bc 0293     		str	r3, [sp, #8]
 14203 07be 0123     		movs	r3, #1
 14204 07c0 0193     		str	r3, [sp, #4]
 14205 07c2 844B     		ldr	r3, .L335
 14206 07c4 0093     		str	r3, [sp]
 14207 07c6 1346     		mov	r3, r2
 14208 07c8 D7F89420 		ldr	r2, [r7, #148]
 14209 07cc D7F89410 		ldr	r1, [r7, #148]
 14210 07d0 B86F     		ldr	r0, [r7, #120]
 14211 07d2 FFF7FEFF 		bl	zint_rebuild_CRT
3571:keygen.c      **** 
3572:keygen.c      **** 	/*
3573:keygen.c      **** 	 * Here starts the Babai reduction, specialized for depth = 1.
3574:keygen.c      **** 	 *
3575:keygen.c      **** 	 * Candidates F and G (from Ft and Gt), and base f and g (ft and gt),
3576:keygen.c      **** 	 * are converted to floating point. There is no scaling, and a
3577:keygen.c      **** 	 * single pass is sufficient.
3578:keygen.c      **** 	 */
3579:keygen.c      **** 
3580:keygen.c      **** 	/*
3581:keygen.c      **** 	 * Convert F and G into floating point (rt1 and rt2).
3582:keygen.c      **** 	 */
3583:keygen.c      **** 	rt1 = align_fpr(tmp, gt + slen * n);
 14212              		.loc 2 3583 33
 14213 07d6 D7F89430 		ldr	r3, [r7, #148]
 14214 07da D7F89C20 		ldr	r2, [r7, #156]
 14215 07de 02FB03F3 		mul	r3, r2, r3
 14216              		.loc 2 3583 26
 14217 07e2 9B00     		lsls	r3, r3, #2
 14218 07e4 7A6F     		ldr	r2, [r7, #116]
 14219 07e6 1344     		add	r3, r3, r2
 14220              		.loc 2 3583 8
 14221 07e8 1946     		mov	r1, r3
 14222 07ea 3868     		ldr	r0, [r7]
 14223 07ec FFF7FEFF 		bl	align_fpr
 14224 07f0 F866     		str	r0, [r7, #108]
3584:keygen.c      **** 	rt2 = rt1 + n;
 14225              		.loc 2 3584 12
 14226 07f2 D7F89C30 		ldr	r3, [r7, #156]
 14227 07f6 DB00     		lsls	r3, r3, #3
 14228              		.loc 2 3584 6
 14229 07f8 FA6E     		ldr	r2, [r7, #108]
 14230 07fa 1344     		add	r3, r3, r2
 14231 07fc BB66     		str	r3, [r7, #104]
3585:keygen.c      **** 	poly_big_to_fp(rt1, Ft, llen, llen, logn);
 14232              		.loc 2 3585 2
 14233 07fe D7F8A030 		ldr	r3, [r7, #160]
 14234 0802 0093     		str	r3, [sp]
 14235 0804 D7F88C30 		ldr	r3, [r7, #140]
 14236 0808 D7F88C20 		ldr	r2, [r7, #140]
 14237 080c D7F88010 		ldr	r1, [r7, #128]
 14238 0810 F86E     		ldr	r0, [r7, #108]
 14239 0812 FFF7FEFF 		bl	poly_big_to_fp
3586:keygen.c      **** 	poly_big_to_fp(rt2, Gt, llen, llen, logn);
 14240              		.loc 2 3586 2
 14241 0816 D7F8A030 		ldr	r3, [r7, #160]
 14242 081a 0093     		str	r3, [sp]
 14243 081c D7F88C30 		ldr	r3, [r7, #140]
 14244 0820 D7F88C20 		ldr	r2, [r7, #140]
 14245 0824 F96F     		ldr	r1, [r7, #124]
 14246 0826 B86E     		ldr	r0, [r7, #104]
 14247 0828 FFF7FEFF 		bl	poly_big_to_fp
3587:keygen.c      **** 
3588:keygen.c      **** 	/*
3589:keygen.c      **** 	 * Integer representation of F and G is no longer needed, we
3590:keygen.c      **** 	 * can remove it.
3591:keygen.c      **** 	 */
3592:keygen.c      **** 	memmove(tmp, ft, 2 * slen * n * sizeof *ft);
 14248              		.loc 2 3592 28
 14249 082c D7F89430 		ldr	r3, [r7, #148]
 14250 0830 D7F89C20 		ldr	r2, [r7, #156]
 14251 0834 02FB03F3 		mul	r3, r2, r3
 14252              		.loc 2 3592 2
 14253 0838 DB00     		lsls	r3, r3, #3
 14254 083a 1A46     		mov	r2, r3
 14255 083c B96F     		ldr	r1, [r7, #120]
 14256 083e 3868     		ldr	r0, [r7]
 14257 0840 FFF7FEFF 		bl	memmove
3593:keygen.c      **** 	ft = tmp;
 14258              		.loc 2 3593 5
 14259 0844 3B68     		ldr	r3, [r7]
 14260 0846 BB67     		str	r3, [r7, #120]
3594:keygen.c      **** 	gt = ft + slen * n;
 14261              		.loc 2 3594 17
 14262 0848 D7F89430 		ldr	r3, [r7, #148]
 14263 084c D7F89C20 		ldr	r2, [r7, #156]
 14264 0850 02FB03F3 		mul	r3, r2, r3
 14265              		.loc 2 3594 10
 14266 0854 9B00     		lsls	r3, r3, #2
 14267              		.loc 2 3594 5
 14268 0856 BA6F     		ldr	r2, [r7, #120]
 14269 0858 1344     		add	r3, r3, r2
 14270 085a 7B67     		str	r3, [r7, #116]
3595:keygen.c      **** 	rt3 = align_fpr(tmp, gt + slen * n);
 14271              		.loc 2 3595 33
 14272 085c D7F89430 		ldr	r3, [r7, #148]
 14273 0860 D7F89C20 		ldr	r2, [r7, #156]
 14274 0864 02FB03F3 		mul	r3, r2, r3
 14275              		.loc 2 3595 26
 14276 0868 9B00     		lsls	r3, r3, #2
 14277 086a 7A6F     		ldr	r2, [r7, #116]
 14278 086c 1344     		add	r3, r3, r2
 14279              		.loc 2 3595 8
 14280 086e 1946     		mov	r1, r3
 14281 0870 3868     		ldr	r0, [r7]
 14282 0872 FFF7FEFF 		bl	align_fpr
 14283 0876 7866     		str	r0, [r7, #100]
3596:keygen.c      **** 	memmove(rt3, rt1, 2 * n * sizeof *rt1);
 14284              		.loc 2 3596 2
 14285 0878 D7F89C30 		ldr	r3, [r7, #156]
 14286 087c 1B01     		lsls	r3, r3, #4
 14287 087e 1A46     		mov	r2, r3
 14288 0880 F96E     		ldr	r1, [r7, #108]
 14289 0882 786E     		ldr	r0, [r7, #100]
 14290 0884 FFF7FEFF 		bl	memmove
3597:keygen.c      **** 	rt1 = rt3;
 14291              		.loc 2 3597 6
 14292 0888 7B6E     		ldr	r3, [r7, #100]
 14293 088a FB66     		str	r3, [r7, #108]
3598:keygen.c      **** 	rt2 = rt1 + n;
 14294              		.loc 2 3598 12
 14295 088c D7F89C30 		ldr	r3, [r7, #156]
 14296 0890 DB00     		lsls	r3, r3, #3
 14297              		.loc 2 3598 6
 14298 0892 FA6E     		ldr	r2, [r7, #108]
 14299 0894 1344     		add	r3, r3, r2
 14300 0896 BB66     		str	r3, [r7, #104]
3599:keygen.c      **** 	rt3 = rt2 + n;
 14301              		.loc 2 3599 12
 14302 0898 D7F89C30 		ldr	r3, [r7, #156]
 14303 089c DB00     		lsls	r3, r3, #3
 14304              		.loc 2 3599 6
 14305 089e BA6E     		ldr	r2, [r7, #104]
 14306 08a0 1344     		add	r3, r3, r2
 14307 08a2 7B66     		str	r3, [r7, #100]
3600:keygen.c      **** 	rt4 = rt3 + n;
 14308              		.loc 2 3600 12
 14309 08a4 D7F89C30 		ldr	r3, [r7, #156]
 14310 08a8 DB00     		lsls	r3, r3, #3
 14311              		.loc 2 3600 6
 14312 08aa 7A6E     		ldr	r2, [r7, #100]
 14313 08ac 1344     		add	r3, r3, r2
 14314 08ae 3B66     		str	r3, [r7, #96]
3601:keygen.c      **** 
3602:keygen.c      **** 	/*
3603:keygen.c      **** 	 * Convert f and g into floating point (rt3 and rt4).
3604:keygen.c      **** 	 */
3605:keygen.c      **** 	poly_big_to_fp(rt3, ft, slen, slen, logn);
 14315              		.loc 2 3605 2
 14316 08b0 D7F8A030 		ldr	r3, [r7, #160]
 14317 08b4 0093     		str	r3, [sp]
 14318 08b6 D7F89430 		ldr	r3, [r7, #148]
 14319 08ba D7F89420 		ldr	r2, [r7, #148]
 14320 08be B96F     		ldr	r1, [r7, #120]
 14321 08c0 786E     		ldr	r0, [r7, #100]
 14322 08c2 FFF7FEFF 		bl	poly_big_to_fp
3606:keygen.c      **** 	poly_big_to_fp(rt4, gt, slen, slen, logn);
 14323              		.loc 2 3606 2
 14324 08c6 D7F8A030 		ldr	r3, [r7, #160]
 14325 08ca 0093     		str	r3, [sp]
 14326 08cc D7F89430 		ldr	r3, [r7, #148]
 14327 08d0 D7F89420 		ldr	r2, [r7, #148]
 14328 08d4 796F     		ldr	r1, [r7, #116]
 14329 08d6 386E     		ldr	r0, [r7, #96]
 14330 08d8 FFF7FEFF 		bl	poly_big_to_fp
3607:keygen.c      **** 
3608:keygen.c      **** 	/*
3609:keygen.c      **** 	 * Remove unneeded ft and gt.
3610:keygen.c      **** 	 */
3611:keygen.c      **** 	memmove(tmp, rt1, 4 * n * sizeof *rt1);
 14331              		.loc 2 3611 2
 14332 08dc D7F89C30 		ldr	r3, [r7, #156]
 14333 08e0 5B01     		lsls	r3, r3, #5
 14334 08e2 1A46     		mov	r2, r3
 14335 08e4 F96E     		ldr	r1, [r7, #108]
 14336 08e6 3868     		ldr	r0, [r7]
 14337 08e8 FFF7FEFF 		bl	memmove
3612:keygen.c      **** 	rt1 = (fpr *)tmp;
 14338              		.loc 2 3612 6
 14339 08ec 3B68     		ldr	r3, [r7]
 14340 08ee FB66     		str	r3, [r7, #108]
3613:keygen.c      **** 	rt2 = rt1 + n;
 14341              		.loc 2 3613 12
 14342 08f0 D7F89C30 		ldr	r3, [r7, #156]
 14343 08f4 DB00     		lsls	r3, r3, #3
 14344              		.loc 2 3613 6
 14345 08f6 FA6E     		ldr	r2, [r7, #108]
 14346 08f8 1344     		add	r3, r3, r2
 14347 08fa BB66     		str	r3, [r7, #104]
3614:keygen.c      **** 	rt3 = rt2 + n;
 14348              		.loc 2 3614 12
 14349 08fc D7F89C30 		ldr	r3, [r7, #156]
 14350 0900 DB00     		lsls	r3, r3, #3
 14351              		.loc 2 3614 6
 14352 0902 BA6E     		ldr	r2, [r7, #104]
 14353 0904 1344     		add	r3, r3, r2
 14354 0906 7B66     		str	r3, [r7, #100]
3615:keygen.c      **** 	rt4 = rt3 + n;
 14355              		.loc 2 3615 12
 14356 0908 D7F89C30 		ldr	r3, [r7, #156]
 14357 090c DB00     		lsls	r3, r3, #3
 14358              		.loc 2 3615 6
 14359 090e 7A6E     		ldr	r2, [r7, #100]
 14360 0910 1344     		add	r3, r3, r2
 14361 0912 3B66     		str	r3, [r7, #96]
3616:keygen.c      **** 
3617:keygen.c      **** 	/*
3618:keygen.c      **** 	 * We now have:
3619:keygen.c      **** 	 *   rt1 = F
3620:keygen.c      **** 	 *   rt2 = G
3621:keygen.c      **** 	 *   rt3 = f
3622:keygen.c      **** 	 *   rt4 = g
3623:keygen.c      **** 	 * in that order in RAM. We convert all of them to FFT.
3624:keygen.c      **** 	 */
3625:keygen.c      **** 	Zf(FFT)(rt1, logn);
 14362              		.loc 2 3625 2
 14363 0914 D7F8A010 		ldr	r1, [r7, #160]
 14364 0918 F86E     		ldr	r0, [r7, #108]
 14365 091a FFF7FEFF 		bl	falcon_inner_FFT
3626:keygen.c      **** 	Zf(FFT)(rt2, logn);
 14366              		.loc 2 3626 2
 14367 091e D7F8A010 		ldr	r1, [r7, #160]
 14368 0922 B86E     		ldr	r0, [r7, #104]
 14369 0924 FFF7FEFF 		bl	falcon_inner_FFT
3627:keygen.c      **** 	Zf(FFT)(rt3, logn);
 14370              		.loc 2 3627 2
 14371 0928 D7F8A010 		ldr	r1, [r7, #160]
 14372 092c 786E     		ldr	r0, [r7, #100]
 14373 092e FFF7FEFF 		bl	falcon_inner_FFT
3628:keygen.c      **** 	Zf(FFT)(rt4, logn);
 14374              		.loc 2 3628 2
 14375 0932 D7F8A010 		ldr	r1, [r7, #160]
 14376 0936 386E     		ldr	r0, [r7, #96]
 14377 0938 FFF7FEFF 		bl	falcon_inner_FFT
3629:keygen.c      **** 
3630:keygen.c      **** 	/*
3631:keygen.c      **** 	 * Compute:
3632:keygen.c      **** 	 *   rt5 = F*adj(f) + G*adj(g)
3633:keygen.c      **** 	 *   rt6 = 1 / (f*adj(f) + g*adj(g))
3634:keygen.c      **** 	 * (Note that rt6 is half-length.)
3635:keygen.c      **** 	 */
3636:keygen.c      **** 	rt5 = rt4 + n;
 14378              		.loc 2 3636 12
 14379 093c D7F89C30 		ldr	r3, [r7, #156]
 14380 0940 DB00     		lsls	r3, r3, #3
 14381              		.loc 2 3636 6
 14382 0942 3A6E     		ldr	r2, [r7, #96]
 14383 0944 1344     		add	r3, r3, r2
 14384 0946 FB65     		str	r3, [r7, #92]
3637:keygen.c      **** 	rt6 = rt5 + n;
 14385              		.loc 2 3637 12
 14386 0948 D7F89C30 		ldr	r3, [r7, #156]
 14387 094c DB00     		lsls	r3, r3, #3
 14388              		.loc 2 3637 6
 14389 094e FA6D     		ldr	r2, [r7, #92]
 14390 0950 1344     		add	r3, r3, r2
 14391 0952 BB65     		str	r3, [r7, #88]
3638:keygen.c      **** 	Zf(poly_add_muladj_fft)(rt5, rt1, rt2, rt3, rt4, logn);
 14392              		.loc 2 3638 2
 14393 0954 D7F8A030 		ldr	r3, [r7, #160]
 14394 0958 0193     		str	r3, [sp, #4]
 14395 095a 3B6E     		ldr	r3, [r7, #96]
 14396 095c 0093     		str	r3, [sp]
 14397 095e 7B6E     		ldr	r3, [r7, #100]
 14398 0960 BA6E     		ldr	r2, [r7, #104]
 14399 0962 F96E     		ldr	r1, [r7, #108]
 14400 0964 F86D     		ldr	r0, [r7, #92]
 14401 0966 FFF7FEFF 		bl	falcon_inner_poly_add_muladj_fft
3639:keygen.c      **** 	Zf(poly_invnorm2_fft)(rt6, rt3, rt4, logn);
 14402              		.loc 2 3639 2
 14403 096a D7F8A030 		ldr	r3, [r7, #160]
 14404 096e 3A6E     		ldr	r2, [r7, #96]
 14405 0970 796E     		ldr	r1, [r7, #100]
 14406 0972 B86D     		ldr	r0, [r7, #88]
 14407 0974 FFF7FEFF 		bl	falcon_inner_poly_invnorm2_fft
3640:keygen.c      **** 
3641:keygen.c      **** 	/*
3642:keygen.c      **** 	 * Compute:
3643:keygen.c      **** 	 *   rt5 = (F*adj(f)+G*adj(g)) / (f*adj(f)+g*adj(g))
3644:keygen.c      **** 	 */
3645:keygen.c      **** 	Zf(poly_mul_autoadj_fft)(rt5, rt6, logn);
 14408              		.loc 2 3645 2
 14409 0978 D7F8A020 		ldr	r2, [r7, #160]
 14410 097c B96D     		ldr	r1, [r7, #88]
 14411 097e F86D     		ldr	r0, [r7, #92]
 14412 0980 FFF7FEFF 		bl	falcon_inner_poly_mul_autoadj_fft
3646:keygen.c      **** 
3647:keygen.c      **** 	/*
3648:keygen.c      **** 	 * Compute k as the rounded version of rt5. Check that none of
3649:keygen.c      **** 	 * the values is larger than 2^63-1 (in absolute value)
3650:keygen.c      **** 	 * because that would make the fpr_rint() do something undefined;
3651:keygen.c      **** 	 * note that any out-of-bounds value here implies a failure and
3652:keygen.c      **** 	 * (f,g) will be discarded, so we can make a simple test.
3653:keygen.c      **** 	 */
3654:keygen.c      **** 	Zf(iFFT)(rt5, logn);
 14413              		.loc 2 3654 2
 14414 0984 D7F8A010 		ldr	r1, [r7, #160]
 14415 0988 F86D     		ldr	r0, [r7, #92]
 14416 098a FFF7FEFF 		bl	falcon_inner_iFFT
3655:keygen.c      **** 	for (u = 0; u < n; u ++) {
 14417              		.loc 2 3655 9
 14418 098e 0023     		movs	r3, #0
 14419 0990 C7F8DC30 		str	r3, [r7, #220]
 14420              		.loc 2 3655 2
 14421 0994 3CE0     		b	.L326
 14422              	.L330:
 14423              	.LBB53:
3656:keygen.c      **** 		fpr z;
3657:keygen.c      **** 
3658:keygen.c      **** 		z = rt5[u];
 14424              		.loc 2 3658 10
 14425 0996 D7F8DC30 		ldr	r3, [r7, #220]
 14426 099a DB00     		lsls	r3, r3, #3
 14427 099c FA6D     		ldr	r2, [r7, #92]
 14428 099e 1344     		add	r3, r3, r2
 14429              		.loc 2 3658 5
 14430 09a0 D3E90023 		ldrd	r2, [r3]
 14431 09a4 C7E91423 		strd	r2, [r7, #80]
3659:keygen.c      **** 		if (!fpr_lt(z, fpr_ptwo63m1) || !fpr_lt(fpr_mtwo63m1, z)) {
 14432              		.loc 2 3659 8
 14433 09a8 4FF00002 		mov	r2, #0
 14434 09ac 0A4B     		ldr	r3, .L335+4
 14435 09ae D7E91401 		ldrd	r0, [r7, #80]
 14436 09b2 FFF7FEFF 		bl	fpr_lt
 14437 09b6 0346     		mov	r3, r0
 14438              		.loc 2 3659 6
 14439 09b8 002B     		cmp	r3, #0
 14440 09ba 09D0     		beq	.L327
 14441              		.loc 2 3659 36 discriminator 1
 14442 09bc 4FF00000 		mov	r0, #0
 14443 09c0 0649     		ldr	r1, .L335+8
 14444 09c2 D7E91423 		ldrd	r2, [r7, #80]
 14445 09c6 FFF7FEFF 		bl	fpr_lt
 14446 09ca 0346     		mov	r3, r0
 14447              		.loc 2 3659 32 discriminator 1
 14448 09cc 002B     		cmp	r3, #0
 14449 09ce 07D1     		bne	.L328
 14450              	.L327:
3660:keygen.c      **** 			return 0;
 14451              		.loc 2 3660 11
 14452 09d0 0023     		movs	r3, #0
 14453 09d2 A3E0     		b	.L329
 14454              	.L336:
 14455              		.align	2
 14456              	.L335:
 14457 09d4 40010000 		.word	PRIMES
 14458 09d8 0000E043 		.word	1138753536
 14459 09dc 0000E0C3 		.word	-1008730112
 14460              	.L328:
3661:keygen.c      **** 		}
3662:keygen.c      **** 		rt5[u] = fpr_of(fpr_rint(z));
 14461              		.loc 2 3662 12 discriminator 2
 14462 09e0 D7E91401 		ldrd	r0, [r7, #80]
 14463 09e4 FFF7FEFF 		bl	fpr_rint
 14464 09e8 0246     		mov	r2, r0
 14465 09ea 0B46     		mov	r3, r1
 14466              		.loc 2 3662 6 discriminator 2
 14467 09ec D7F8DC10 		ldr	r1, [r7, #220]
 14468 09f0 C900     		lsls	r1, r1, #3
 14469 09f2 F86D     		ldr	r0, [r7, #92]
 14470 09f4 4418     		adds	r4, r0, r1
 14471              		.loc 2 3662 12 discriminator 2
 14472 09f6 1046     		mov	r0, r2
 14473 09f8 1946     		mov	r1, r3
 14474 09fa FFF7FEFF 		bl	fpr_of
 14475 09fe 0246     		mov	r2, r0
 14476 0a00 0B46     		mov	r3, r1
 14477              		.loc 2 3662 10 discriminator 2
 14478 0a02 C4E90023 		strd	r2, [r4]
 14479              	.LBE53:
3655:keygen.c      **** 		fpr z;
 14480              		.loc 2 3655 23 discriminator 2
 14481 0a06 D7F8DC30 		ldr	r3, [r7, #220]
 14482 0a0a 0133     		adds	r3, r3, #1
 14483 0a0c C7F8DC30 		str	r3, [r7, #220]
 14484              	.L326:
3655:keygen.c      **** 		fpr z;
 14485              		.loc 2 3655 2 discriminator 1
 14486 0a10 D7F8DC20 		ldr	r2, [r7, #220]
 14487 0a14 D7F89C30 		ldr	r3, [r7, #156]
 14488 0a18 9A42     		cmp	r2, r3
 14489 0a1a BCD3     		bcc	.L330
3663:keygen.c      **** 	}
3664:keygen.c      **** 	Zf(FFT)(rt5, logn);
 14490              		.loc 2 3664 2
 14491 0a1c D7F8A010 		ldr	r1, [r7, #160]
 14492 0a20 F86D     		ldr	r0, [r7, #92]
 14493 0a22 FFF7FEFF 		bl	falcon_inner_FFT
3665:keygen.c      **** 
3666:keygen.c      **** 	/*
3667:keygen.c      **** 	 * Subtract k*f from F, and k*g from G.
3668:keygen.c      **** 	 */
3669:keygen.c      **** 	Zf(poly_mul_fft)(rt3, rt5, logn);
 14494              		.loc 2 3669 2
 14495 0a26 D7F8A020 		ldr	r2, [r7, #160]
 14496 0a2a F96D     		ldr	r1, [r7, #92]
 14497 0a2c 786E     		ldr	r0, [r7, #100]
 14498 0a2e FFF7FEFF 		bl	falcon_inner_poly_mul_fft
3670:keygen.c      **** 	Zf(poly_mul_fft)(rt4, rt5, logn);
 14499              		.loc 2 3670 2
 14500 0a32 D7F8A020 		ldr	r2, [r7, #160]
 14501 0a36 F96D     		ldr	r1, [r7, #92]
 14502 0a38 386E     		ldr	r0, [r7, #96]
 14503 0a3a FFF7FEFF 		bl	falcon_inner_poly_mul_fft
3671:keygen.c      **** 	Zf(poly_sub)(rt1, rt3, logn);
 14504              		.loc 2 3671 2
 14505 0a3e D7F8A020 		ldr	r2, [r7, #160]
 14506 0a42 796E     		ldr	r1, [r7, #100]
 14507 0a44 F86E     		ldr	r0, [r7, #108]
 14508 0a46 FFF7FEFF 		bl	falcon_inner_poly_sub
3672:keygen.c      **** 	Zf(poly_sub)(rt2, rt4, logn);
 14509              		.loc 2 3672 2
 14510 0a4a D7F8A020 		ldr	r2, [r7, #160]
 14511 0a4e 396E     		ldr	r1, [r7, #96]
 14512 0a50 B86E     		ldr	r0, [r7, #104]
 14513 0a52 FFF7FEFF 		bl	falcon_inner_poly_sub
3673:keygen.c      **** 	Zf(iFFT)(rt1, logn);
 14514              		.loc 2 3673 2
 14515 0a56 D7F8A010 		ldr	r1, [r7, #160]
 14516 0a5a F86E     		ldr	r0, [r7, #108]
 14517 0a5c FFF7FEFF 		bl	falcon_inner_iFFT
3674:keygen.c      **** 	Zf(iFFT)(rt2, logn);
 14518              		.loc 2 3674 2
 14519 0a60 D7F8A010 		ldr	r1, [r7, #160]
 14520 0a64 B86E     		ldr	r0, [r7, #104]
 14521 0a66 FFF7FEFF 		bl	falcon_inner_iFFT
3675:keygen.c      **** 
3676:keygen.c      **** 	/*
3677:keygen.c      **** 	 * Convert back F and G to integers, and return.
3678:keygen.c      **** 	 */
3679:keygen.c      **** 	Ft = tmp;
 14522              		.loc 2 3679 5
 14523 0a6a 3B68     		ldr	r3, [r7]
 14524 0a6c C7F88030 		str	r3, [r7, #128]
3680:keygen.c      **** 	Gt = Ft + n;
 14525              		.loc 2 3680 10
 14526 0a70 D7F89C30 		ldr	r3, [r7, #156]
 14527 0a74 9B00     		lsls	r3, r3, #2
 14528              		.loc 2 3680 5
 14529 0a76 D7F88020 		ldr	r2, [r7, #128]
 14530 0a7a 1344     		add	r3, r3, r2
 14531 0a7c FB67     		str	r3, [r7, #124]
3681:keygen.c      **** 	rt3 = align_fpr(tmp, Gt + n);
 14532              		.loc 2 3681 26
 14533 0a7e D7F89C30 		ldr	r3, [r7, #156]
 14534 0a82 9B00     		lsls	r3, r3, #2
 14535 0a84 FA6F     		ldr	r2, [r7, #124]
 14536 0a86 1344     		add	r3, r3, r2
 14537              		.loc 2 3681 8
 14538 0a88 1946     		mov	r1, r3
 14539 0a8a 3868     		ldr	r0, [r7]
 14540 0a8c FFF7FEFF 		bl	align_fpr
 14541 0a90 7866     		str	r0, [r7, #100]
3682:keygen.c      **** 	memmove(rt3, rt1, 2 * n * sizeof *rt1);
 14542              		.loc 2 3682 2
 14543 0a92 D7F89C30 		ldr	r3, [r7, #156]
 14544 0a96 1B01     		lsls	r3, r3, #4
 14545 0a98 1A46     		mov	r2, r3
 14546 0a9a F96E     		ldr	r1, [r7, #108]
 14547 0a9c 786E     		ldr	r0, [r7, #100]
 14548 0a9e FFF7FEFF 		bl	memmove
3683:keygen.c      **** 	rt1 = rt3;
 14549              		.loc 2 3683 6
 14550 0aa2 7B6E     		ldr	r3, [r7, #100]
 14551 0aa4 FB66     		str	r3, [r7, #108]
3684:keygen.c      **** 	rt2 = rt1 + n;
 14552              		.loc 2 3684 12
 14553 0aa6 D7F89C30 		ldr	r3, [r7, #156]
 14554 0aaa DB00     		lsls	r3, r3, #3
 14555              		.loc 2 3684 6
 14556 0aac FA6E     		ldr	r2, [r7, #108]
 14557 0aae 1344     		add	r3, r3, r2
 14558 0ab0 BB66     		str	r3, [r7, #104]
3685:keygen.c      **** 	for (u = 0; u < n; u ++) {
 14559              		.loc 2 3685 9
 14560 0ab2 0023     		movs	r3, #0
 14561 0ab4 C7F8DC30 		str	r3, [r7, #220]
 14562              		.loc 2 3685 2
 14563 0ab8 29E0     		b	.L331
 14564              	.L332:
3686:keygen.c      **** 		Ft[u] = (uint32_t)fpr_rint(rt1[u]);
 14565              		.loc 2 3686 33 discriminator 3
 14566 0aba D7F8DC30 		ldr	r3, [r7, #220]
 14567 0abe DB00     		lsls	r3, r3, #3
 14568 0ac0 FA6E     		ldr	r2, [r7, #108]
 14569 0ac2 1344     		add	r3, r3, r2
 14570              		.loc 2 3686 21 discriminator 3
 14571 0ac4 D3E90023 		ldrd	r2, [r3]
 14572 0ac8 1046     		mov	r0, r2
 14573 0aca 1946     		mov	r1, r3
 14574 0acc FFF7FEFF 		bl	fpr_rint
 14575              		.loc 2 3686 5 discriminator 3
 14576 0ad0 D7F8DC30 		ldr	r3, [r7, #220]
 14577 0ad4 9B00     		lsls	r3, r3, #2
 14578 0ad6 D7F88020 		ldr	r2, [r7, #128]
 14579 0ada 1344     		add	r3, r3, r2
 14580              		.loc 2 3686 11 discriminator 3
 14581 0adc 0246     		mov	r2, r0
 14582              		.loc 2 3686 9 discriminator 3
 14583 0ade 1A60     		str	r2, [r3]
3687:keygen.c      **** 		Gt[u] = (uint32_t)fpr_rint(rt2[u]);
 14584              		.loc 2 3687 33 discriminator 3
 14585 0ae0 D7F8DC30 		ldr	r3, [r7, #220]
 14586 0ae4 DB00     		lsls	r3, r3, #3
 14587 0ae6 BA6E     		ldr	r2, [r7, #104]
 14588 0ae8 1344     		add	r3, r3, r2
 14589              		.loc 2 3687 21 discriminator 3
 14590 0aea D3E90023 		ldrd	r2, [r3]
 14591 0aee 1046     		mov	r0, r2
 14592 0af0 1946     		mov	r1, r3
 14593 0af2 FFF7FEFF 		bl	fpr_rint
 14594              		.loc 2 3687 5 discriminator 3
 14595 0af6 D7F8DC30 		ldr	r3, [r7, #220]
 14596 0afa 9B00     		lsls	r3, r3, #2
 14597 0afc FA6F     		ldr	r2, [r7, #124]
 14598 0afe 1344     		add	r3, r3, r2
 14599              		.loc 2 3687 11 discriminator 3
 14600 0b00 0246     		mov	r2, r0
 14601              		.loc 2 3687 9 discriminator 3
 14602 0b02 1A60     		str	r2, [r3]
3685:keygen.c      **** 	for (u = 0; u < n; u ++) {
 14603              		.loc 2 3685 23 discriminator 3
 14604 0b04 D7F8DC30 		ldr	r3, [r7, #220]
 14605 0b08 0133     		adds	r3, r3, #1
 14606 0b0a C7F8DC30 		str	r3, [r7, #220]
 14607              	.L331:
3685:keygen.c      **** 	for (u = 0; u < n; u ++) {
 14608              		.loc 2 3685 2 discriminator 1
 14609 0b0e D7F8DC20 		ldr	r2, [r7, #220]
 14610 0b12 D7F89C30 		ldr	r3, [r7, #156]
 14611 0b16 9A42     		cmp	r2, r3
 14612 0b18 CFD3     		bcc	.L332
3688:keygen.c      **** 	}
3689:keygen.c      **** 
3690:keygen.c      **** 	return 1;
 14613              		.loc 2 3690 9
 14614 0b1a 0123     		movs	r3, #1
 14615              	.L329:
3691:keygen.c      **** }
 14616              		.loc 2 3691 1
 14617 0b1c 1846     		mov	r0, r3
 14618 0b1e E437     		adds	r7, r7, #228
 14619              	.LCFI269:
 14620              		.cfi_def_cfa_offset 12
 14621 0b20 BD46     		mov	sp, r7
 14622              	.LCFI270:
 14623              		.cfi_def_cfa_register 13
 14624              		@ sp needed
 14625 0b22 90BD     		pop	{r4, r7, pc}
 14626              		.cfi_endproc
 14627              	.LFE61:
 14629              		.section	.text.solve_NTRU_binary_depth0,"ax",%progbits
 14630              		.align	1
 14631              		.syntax unified
 14632              		.thumb
 14633              		.thumb_func
 14634              		.fpu softvfp
 14636              	solve_NTRU_binary_depth0:
 14637              	.LFB62:
3692:keygen.c      **** 
3693:keygen.c      **** /*
3694:keygen.c      ****  * Solving the NTRU equation, top level. Upon entry, the F and G
3695:keygen.c      ****  * from the previous level should be in the tmp[] array.
3696:keygen.c      ****  *
3697:keygen.c      ****  * Returned value: 1 on success, 0 on error.
3698:keygen.c      ****  */
3699:keygen.c      **** static int
3700:keygen.c      **** solve_NTRU_binary_depth0(unsigned logn,
3701:keygen.c      **** 	const int8_t *f, const int8_t *g, uint32_t *tmp)
3702:keygen.c      **** {
 14638              		.loc 2 3702 1
 14639              		.cfi_startproc
 14640              		@ args = 0, pretend = 0, frame = 136
 14641              		@ frame_needed = 1, uses_anonymous_args = 0
 14642 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 14643              	.LCFI271:
 14644              		.cfi_def_cfa_offset 28
 14645              		.cfi_offset 4, -28
 14646              		.cfi_offset 5, -24
 14647              		.cfi_offset 6, -20
 14648              		.cfi_offset 7, -16
 14649              		.cfi_offset 8, -12
 14650              		.cfi_offset 9, -8
 14651              		.cfi_offset 14, -4
 14652 0004 A5B0     		sub	sp, sp, #148
 14653              	.LCFI272:
 14654              		.cfi_def_cfa_offset 176
 14655 0006 02AF     		add	r7, sp, #8
 14656              	.LCFI273:
 14657              		.cfi_def_cfa 7, 168
 14658 0008 7861     		str	r0, [r7, #20]
 14659 000a 3961     		str	r1, [r7, #16]
 14660 000c FA60     		str	r2, [r7, #12]
 14661 000e BB60     		str	r3, [r7, #8]
3703:keygen.c      **** 	size_t n, hn, u;
3704:keygen.c      **** 	uint32_t p, p0i, R2;
3705:keygen.c      **** 	uint32_t *Fp, *Gp, *t1, *t2, *t3, *t4, *t5;
3706:keygen.c      **** 	uint32_t *gm, *igm, *ft, *gt;
3707:keygen.c      **** 	fpr *rt2, *rt3;
3708:keygen.c      **** 
3709:keygen.c      **** 	n = (size_t)1 << logn;
 14662              		.loc 2 3709 4
 14663 0010 0122     		movs	r2, #1
 14664 0012 7B69     		ldr	r3, [r7, #20]
 14665 0014 02FA03F3 		lsl	r3, r2, r3
 14666 0018 C7F88030 		str	r3, [r7, #128]
3710:keygen.c      **** 	hn = n >> 1;
 14667              		.loc 2 3710 5
 14668 001c D7F88030 		ldr	r3, [r7, #128]
 14669 0020 5B08     		lsrs	r3, r3, #1
 14670 0022 FB67     		str	r3, [r7, #124]
3711:keygen.c      **** 
3712:keygen.c      **** 	/*
3713:keygen.c      **** 	 * Equations are:
3714:keygen.c      **** 	 *
3715:keygen.c      **** 	 *   f' = f0^2 - X^2*f1^2
3716:keygen.c      **** 	 *   g' = g0^2 - X^2*g1^2
3717:keygen.c      **** 	 *   F' and G' are a solution to f'G' - g'F' = q (from deeper levels)
3718:keygen.c      **** 	 *   F = F'*(g0 - X*g1)
3719:keygen.c      **** 	 *   G = G'*(f0 - X*f1)
3720:keygen.c      **** 	 *
3721:keygen.c      **** 	 * f0, f1, g0, g1, f', g', F' and G' are all "compressed" to
3722:keygen.c      **** 	 * degree N/2 (their odd-indexed coefficients are all zero).
3723:keygen.c      **** 	 *
3724:keygen.c      **** 	 * Everything should fit in 31-bit integers, hence we can just use
3725:keygen.c      **** 	 * the first small prime p = 2147473409.
3726:keygen.c      **** 	 */
3727:keygen.c      **** 	p = PRIMES[0].p;
 14671              		.loc 2 3727 4
 14672 0024 634B     		ldr	r3, .L367
 14673 0026 BB67     		str	r3, [r7, #120]
3728:keygen.c      **** 	p0i = modp_ninv31(p);
 14674              		.loc 2 3728 8
 14675 0028 B86F     		ldr	r0, [r7, #120]
 14676 002a FFF7FEFF 		bl	modp_ninv31
 14677 002e 7867     		str	r0, [r7, #116]
3729:keygen.c      **** 	R2 = modp_R2(p, p0i);
 14678              		.loc 2 3729 7
 14679 0030 796F     		ldr	r1, [r7, #116]
 14680 0032 B86F     		ldr	r0, [r7, #120]
 14681 0034 FFF7FEFF 		bl	modp_R2
 14682 0038 3867     		str	r0, [r7, #112]
3730:keygen.c      **** 
3731:keygen.c      **** 	Fp = tmp;
 14683              		.loc 2 3731 5
 14684 003a BB68     		ldr	r3, [r7, #8]
 14685 003c FB66     		str	r3, [r7, #108]
3732:keygen.c      **** 	Gp = Fp + hn;
 14686              		.loc 2 3732 10
 14687 003e FB6F     		ldr	r3, [r7, #124]
 14688 0040 9B00     		lsls	r3, r3, #2
 14689              		.loc 2 3732 5
 14690 0042 FA6E     		ldr	r2, [r7, #108]
 14691 0044 1344     		add	r3, r3, r2
 14692 0046 BB66     		str	r3, [r7, #104]
3733:keygen.c      **** 	ft = Gp + hn;
 14693              		.loc 2 3733 10
 14694 0048 FB6F     		ldr	r3, [r7, #124]
 14695 004a 9B00     		lsls	r3, r3, #2
 14696              		.loc 2 3733 5
 14697 004c BA6E     		ldr	r2, [r7, #104]
 14698 004e 1344     		add	r3, r3, r2
 14699 0050 7B66     		str	r3, [r7, #100]
3734:keygen.c      **** 	gt = ft + n;
 14700              		.loc 2 3734 10
 14701 0052 D7F88030 		ldr	r3, [r7, #128]
 14702 0056 9B00     		lsls	r3, r3, #2
 14703              		.loc 2 3734 5
 14704 0058 7A6E     		ldr	r2, [r7, #100]
 14705 005a 1344     		add	r3, r3, r2
 14706 005c 3B66     		str	r3, [r7, #96]
3735:keygen.c      **** 	gm = gt + n;
 14707              		.loc 2 3735 10
 14708 005e D7F88030 		ldr	r3, [r7, #128]
 14709 0062 9B00     		lsls	r3, r3, #2
 14710              		.loc 2 3735 5
 14711 0064 3A6E     		ldr	r2, [r7, #96]
 14712 0066 1344     		add	r3, r3, r2
 14713 0068 FB65     		str	r3, [r7, #92]
3736:keygen.c      **** 	igm = gm + n;
 14714              		.loc 2 3736 11
 14715 006a D7F88030 		ldr	r3, [r7, #128]
 14716 006e 9B00     		lsls	r3, r3, #2
 14717              		.loc 2 3736 6
 14718 0070 FA6D     		ldr	r2, [r7, #92]
 14719 0072 1344     		add	r3, r3, r2
 14720 0074 BB65     		str	r3, [r7, #88]
3737:keygen.c      **** 
3738:keygen.c      **** 	modp_mkgm2(gm, igm, logn, PRIMES[0].g, p, p0i);
 14721              		.loc 2 3738 2
 14722 0076 504A     		ldr	r2, .L367+4
 14723 0078 7B6F     		ldr	r3, [r7, #116]
 14724 007a 0193     		str	r3, [sp, #4]
 14725 007c BB6F     		ldr	r3, [r7, #120]
 14726 007e 0093     		str	r3, [sp]
 14727 0080 1346     		mov	r3, r2
 14728 0082 7A69     		ldr	r2, [r7, #20]
 14729 0084 B96D     		ldr	r1, [r7, #88]
 14730 0086 F86D     		ldr	r0, [r7, #92]
 14731 0088 FFF7FEFF 		bl	modp_mkgm2
3739:keygen.c      **** 
3740:keygen.c      **** 	/*
3741:keygen.c      **** 	 * Convert F' anf G' in NTT representation.
3742:keygen.c      **** 	 */
3743:keygen.c      **** 	for (u = 0; u < hn; u ++) {
 14732              		.loc 2 3743 9
 14733 008c 0023     		movs	r3, #0
 14734 008e C7F88430 		str	r3, [r7, #132]
 14735              		.loc 2 3743 2
 14736 0092 28E0     		b	.L338
 14737              	.L339:
3744:keygen.c      **** 		Fp[u] = modp_set(zint_one_to_plain(Fp + u), p);
 14738              		.loc 2 3744 41 discriminator 3
 14739 0094 D7F88430 		ldr	r3, [r7, #132]
 14740 0098 9B00     		lsls	r3, r3, #2
 14741 009a FA6E     		ldr	r2, [r7, #108]
 14742 009c 1344     		add	r3, r3, r2
 14743              		.loc 2 3744 11 discriminator 3
 14744 009e 1846     		mov	r0, r3
 14745 00a0 FFF7FEFF 		bl	zint_one_to_plain
 14746              		.loc 2 3744 5 discriminator 3
 14747 00a4 D7F88430 		ldr	r3, [r7, #132]
 14748 00a8 9B00     		lsls	r3, r3, #2
 14749 00aa FA6E     		ldr	r2, [r7, #108]
 14750 00ac D618     		adds	r6, r2, r3
 14751              		.loc 2 3744 11 discriminator 3
 14752 00ae B96F     		ldr	r1, [r7, #120]
 14753 00b0 FFF7FEFF 		bl	modp_set
 14754 00b4 0346     		mov	r3, r0
 14755              		.loc 2 3744 9 discriminator 3
 14756 00b6 3360     		str	r3, [r6]
3745:keygen.c      **** 		Gp[u] = modp_set(zint_one_to_plain(Gp + u), p);
 14757              		.loc 2 3745 41 discriminator 3
 14758 00b8 D7F88430 		ldr	r3, [r7, #132]
 14759 00bc 9B00     		lsls	r3, r3, #2
 14760 00be BA6E     		ldr	r2, [r7, #104]
 14761 00c0 1344     		add	r3, r3, r2
 14762              		.loc 2 3745 11 discriminator 3
 14763 00c2 1846     		mov	r0, r3
 14764 00c4 FFF7FEFF 		bl	zint_one_to_plain
 14765              		.loc 2 3745 5 discriminator 3
 14766 00c8 D7F88430 		ldr	r3, [r7, #132]
 14767 00cc 9B00     		lsls	r3, r3, #2
 14768 00ce BA6E     		ldr	r2, [r7, #104]
 14769 00d0 D618     		adds	r6, r2, r3
 14770              		.loc 2 3745 11 discriminator 3
 14771 00d2 B96F     		ldr	r1, [r7, #120]
 14772 00d4 FFF7FEFF 		bl	modp_set
 14773 00d8 0346     		mov	r3, r0
 14774              		.loc 2 3745 9 discriminator 3
 14775 00da 3360     		str	r3, [r6]
3743:keygen.c      **** 		Fp[u] = modp_set(zint_one_to_plain(Fp + u), p);
 14776              		.loc 2 3743 24 discriminator 3
 14777 00dc D7F88430 		ldr	r3, [r7, #132]
 14778 00e0 0133     		adds	r3, r3, #1
 14779 00e2 C7F88430 		str	r3, [r7, #132]
 14780              	.L338:
3743:keygen.c      **** 		Fp[u] = modp_set(zint_one_to_plain(Fp + u), p);
 14781              		.loc 2 3743 2 discriminator 1
 14782 00e6 D7F88420 		ldr	r2, [r7, #132]
 14783 00ea FB6F     		ldr	r3, [r7, #124]
 14784 00ec 9A42     		cmp	r2, r3
 14785 00ee D1D3     		bcc	.L339
3746:keygen.c      **** 	}
3747:keygen.c      **** 	modp_NTT2(Fp, gm, logn - 1, p, p0i);
 14786              		.loc 2 3747 2
 14787 00f0 7B69     		ldr	r3, [r7, #20]
 14788 00f2 5A1E     		subs	r2, r3, #1
 14789 00f4 7B6F     		ldr	r3, [r7, #116]
 14790 00f6 0193     		str	r3, [sp, #4]
 14791 00f8 BB6F     		ldr	r3, [r7, #120]
 14792 00fa 0093     		str	r3, [sp]
 14793 00fc 1346     		mov	r3, r2
 14794 00fe FA6D     		ldr	r2, [r7, #92]
 14795 0100 0121     		movs	r1, #1
 14796 0102 F86E     		ldr	r0, [r7, #108]
 14797 0104 FFF7FEFF 		bl	modp_NTT2_ext
3748:keygen.c      **** 	modp_NTT2(Gp, gm, logn - 1, p, p0i);
 14798              		.loc 2 3748 2
 14799 0108 7B69     		ldr	r3, [r7, #20]
 14800 010a 5A1E     		subs	r2, r3, #1
 14801 010c 7B6F     		ldr	r3, [r7, #116]
 14802 010e 0193     		str	r3, [sp, #4]
 14803 0110 BB6F     		ldr	r3, [r7, #120]
 14804 0112 0093     		str	r3, [sp]
 14805 0114 1346     		mov	r3, r2
 14806 0116 FA6D     		ldr	r2, [r7, #92]
 14807 0118 0121     		movs	r1, #1
 14808 011a B86E     		ldr	r0, [r7, #104]
 14809 011c FFF7FEFF 		bl	modp_NTT2_ext
3749:keygen.c      **** 
3750:keygen.c      **** 	/*
3751:keygen.c      **** 	 * Load f and g and convert them to NTT representation.
3752:keygen.c      **** 	 */
3753:keygen.c      **** 	for (u = 0; u < n; u ++) {
 14810              		.loc 2 3753 9
 14811 0120 0023     		movs	r3, #0
 14812 0122 C7F88430 		str	r3, [r7, #132]
 14813              		.loc 2 3753 2
 14814 0126 26E0     		b	.L340
 14815              	.L341:
3754:keygen.c      **** 		ft[u] = modp_set(f[u], p);
 14816              		.loc 2 3754 21 discriminator 3
 14817 0128 3A69     		ldr	r2, [r7, #16]
 14818 012a D7F88430 		ldr	r3, [r7, #132]
 14819 012e 1344     		add	r3, r3, r2
 14820 0130 93F90030 		ldrsb	r3, [r3]
 14821              		.loc 2 3754 11 discriminator 3
 14822 0134 1846     		mov	r0, r3
 14823              		.loc 2 3754 5 discriminator 3
 14824 0136 D7F88430 		ldr	r3, [r7, #132]
 14825 013a 9B00     		lsls	r3, r3, #2
 14826 013c 7A6E     		ldr	r2, [r7, #100]
 14827 013e D618     		adds	r6, r2, r3
 14828              		.loc 2 3754 11 discriminator 3
 14829 0140 B96F     		ldr	r1, [r7, #120]
 14830 0142 FFF7FEFF 		bl	modp_set
 14831 0146 0346     		mov	r3, r0
 14832              		.loc 2 3754 9 discriminator 3
 14833 0148 3360     		str	r3, [r6]
3755:keygen.c      **** 		gt[u] = modp_set(g[u], p);
 14834              		.loc 2 3755 21 discriminator 3
 14835 014a FA68     		ldr	r2, [r7, #12]
 14836 014c D7F88430 		ldr	r3, [r7, #132]
 14837 0150 1344     		add	r3, r3, r2
 14838 0152 93F90030 		ldrsb	r3, [r3]
 14839              		.loc 2 3755 11 discriminator 3
 14840 0156 1846     		mov	r0, r3
 14841              		.loc 2 3755 5 discriminator 3
 14842 0158 D7F88430 		ldr	r3, [r7, #132]
 14843 015c 9B00     		lsls	r3, r3, #2
 14844 015e 3A6E     		ldr	r2, [r7, #96]
 14845 0160 D618     		adds	r6, r2, r3
 14846              		.loc 2 3755 11 discriminator 3
 14847 0162 B96F     		ldr	r1, [r7, #120]
 14848 0164 FFF7FEFF 		bl	modp_set
 14849 0168 0346     		mov	r3, r0
 14850              		.loc 2 3755 9 discriminator 3
 14851 016a 3360     		str	r3, [r6]
3753:keygen.c      **** 		ft[u] = modp_set(f[u], p);
 14852              		.loc 2 3753 23 discriminator 3
 14853 016c D7F88430 		ldr	r3, [r7, #132]
 14854 0170 0133     		adds	r3, r3, #1
 14855 0172 C7F88430 		str	r3, [r7, #132]
 14856              	.L340:
3753:keygen.c      **** 		ft[u] = modp_set(f[u], p);
 14857              		.loc 2 3753 2 discriminator 1
 14858 0176 D7F88420 		ldr	r2, [r7, #132]
 14859 017a D7F88030 		ldr	r3, [r7, #128]
 14860 017e 9A42     		cmp	r2, r3
 14861 0180 D2D3     		bcc	.L341
3756:keygen.c      **** 	}
3757:keygen.c      **** 	modp_NTT2(ft, gm, logn, p, p0i);
 14862              		.loc 2 3757 2
 14863 0182 7B6F     		ldr	r3, [r7, #116]
 14864 0184 0193     		str	r3, [sp, #4]
 14865 0186 BB6F     		ldr	r3, [r7, #120]
 14866 0188 0093     		str	r3, [sp]
 14867 018a 7B69     		ldr	r3, [r7, #20]
 14868 018c FA6D     		ldr	r2, [r7, #92]
 14869 018e 0121     		movs	r1, #1
 14870 0190 786E     		ldr	r0, [r7, #100]
 14871 0192 FFF7FEFF 		bl	modp_NTT2_ext
3758:keygen.c      **** 	modp_NTT2(gt, gm, logn, p, p0i);
 14872              		.loc 2 3758 2
 14873 0196 7B6F     		ldr	r3, [r7, #116]
 14874 0198 0193     		str	r3, [sp, #4]
 14875 019a BB6F     		ldr	r3, [r7, #120]
 14876 019c 0093     		str	r3, [sp]
 14877 019e 7B69     		ldr	r3, [r7, #20]
 14878 01a0 FA6D     		ldr	r2, [r7, #92]
 14879 01a2 0121     		movs	r1, #1
 14880 01a4 386E     		ldr	r0, [r7, #96]
 14881 01a6 FFF7FEFF 		bl	modp_NTT2_ext
3759:keygen.c      **** 
3760:keygen.c      **** 	/*
3761:keygen.c      **** 	 * Build the unreduced F,G in ft and gt.
3762:keygen.c      **** 	 */
3763:keygen.c      **** 	for (u = 0; u < n; u += 2) {
 14882              		.loc 2 3763 9
 14883 01aa 0023     		movs	r3, #0
 14884 01ac C7F88430 		str	r3, [r7, #132]
 14885              		.loc 2 3763 2
 14886 01b0 77E0     		b	.L342
 14887              	.L368:
 14888 01b2 00BF     		.align	2
 14889              	.L367:
 14890 01b4 01D8FF7F 		.word	2147473409
 14891 01b8 45ADD616 		.word	383167813
 14892              	.L343:
 14893              	.LBB54:
3764:keygen.c      **** 		uint32_t ftA, ftB, gtA, gtB;
3765:keygen.c      **** 		uint32_t mFp, mGp;
3766:keygen.c      **** 
3767:keygen.c      **** 		ftA = ft[u + 0];
 14894              		.loc 2 3767 11 discriminator 3
 14895 01bc D7F88430 		ldr	r3, [r7, #132]
 14896 01c0 9B00     		lsls	r3, r3, #2
 14897 01c2 7A6E     		ldr	r2, [r7, #100]
 14898 01c4 1344     		add	r3, r3, r2
 14899              		.loc 2 3767 7 discriminator 3
 14900 01c6 1B68     		ldr	r3, [r3]
 14901 01c8 FB62     		str	r3, [r7, #44]
3768:keygen.c      **** 		ftB = ft[u + 1];
 14902              		.loc 2 3768 11 discriminator 3
 14903 01ca D7F88430 		ldr	r3, [r7, #132]
 14904 01ce 0133     		adds	r3, r3, #1
 14905 01d0 9B00     		lsls	r3, r3, #2
 14906 01d2 7A6E     		ldr	r2, [r7, #100]
 14907 01d4 1344     		add	r3, r3, r2
 14908              		.loc 2 3768 7 discriminator 3
 14909 01d6 1B68     		ldr	r3, [r3]
 14910 01d8 BB62     		str	r3, [r7, #40]
3769:keygen.c      **** 		gtA = gt[u + 0];
 14911              		.loc 2 3769 11 discriminator 3
 14912 01da D7F88430 		ldr	r3, [r7, #132]
 14913 01de 9B00     		lsls	r3, r3, #2
 14914 01e0 3A6E     		ldr	r2, [r7, #96]
 14915 01e2 1344     		add	r3, r3, r2
 14916              		.loc 2 3769 7 discriminator 3
 14917 01e4 1B68     		ldr	r3, [r3]
 14918 01e6 7B62     		str	r3, [r7, #36]
3770:keygen.c      **** 		gtB = gt[u + 1];
 14919              		.loc 2 3770 11 discriminator 3
 14920 01e8 D7F88430 		ldr	r3, [r7, #132]
 14921 01ec 0133     		adds	r3, r3, #1
 14922 01ee 9B00     		lsls	r3, r3, #2
 14923 01f0 3A6E     		ldr	r2, [r7, #96]
 14924 01f2 1344     		add	r3, r3, r2
 14925              		.loc 2 3770 7 discriminator 3
 14926 01f4 1B68     		ldr	r3, [r3]
 14927 01f6 3B62     		str	r3, [r7, #32]
3771:keygen.c      **** 		mFp = modp_montymul(Fp[u >> 1], R2, p, p0i);
 14928              		.loc 2 3771 28 discriminator 3
 14929 01f8 D7F88430 		ldr	r3, [r7, #132]
 14930 01fc 5B08     		lsrs	r3, r3, #1
 14931              		.loc 2 3771 25 discriminator 3
 14932 01fe 9B00     		lsls	r3, r3, #2
 14933 0200 FA6E     		ldr	r2, [r7, #108]
 14934 0202 1344     		add	r3, r3, r2
 14935              		.loc 2 3771 9 discriminator 3
 14936 0204 1868     		ldr	r0, [r3]
 14937 0206 7B6F     		ldr	r3, [r7, #116]
 14938 0208 BA6F     		ldr	r2, [r7, #120]
 14939 020a 396F     		ldr	r1, [r7, #112]
 14940 020c FFF7FEFF 		bl	modp_montymul
 14941 0210 F861     		str	r0, [r7, #28]
3772:keygen.c      **** 		mGp = modp_montymul(Gp[u >> 1], R2, p, p0i);
 14942              		.loc 2 3772 28 discriminator 3
 14943 0212 D7F88430 		ldr	r3, [r7, #132]
 14944 0216 5B08     		lsrs	r3, r3, #1
 14945              		.loc 2 3772 25 discriminator 3
 14946 0218 9B00     		lsls	r3, r3, #2
 14947 021a BA6E     		ldr	r2, [r7, #104]
 14948 021c 1344     		add	r3, r3, r2
 14949              		.loc 2 3772 9 discriminator 3
 14950 021e 1868     		ldr	r0, [r3]
 14951 0220 7B6F     		ldr	r3, [r7, #116]
 14952 0222 BA6F     		ldr	r2, [r7, #120]
 14953 0224 396F     		ldr	r1, [r7, #112]
 14954 0226 FFF7FEFF 		bl	modp_montymul
 14955 022a B861     		str	r0, [r7, #24]
3773:keygen.c      **** 		ft[u + 0] = modp_montymul(gtB, mFp, p, p0i);
 14956              		.loc 2 3773 5 discriminator 3
 14957 022c D7F88430 		ldr	r3, [r7, #132]
 14958 0230 9B00     		lsls	r3, r3, #2
 14959 0232 7A6E     		ldr	r2, [r7, #100]
 14960 0234 D618     		adds	r6, r2, r3
 14961              		.loc 2 3773 15 discriminator 3
 14962 0236 7B6F     		ldr	r3, [r7, #116]
 14963 0238 BA6F     		ldr	r2, [r7, #120]
 14964 023a F969     		ldr	r1, [r7, #28]
 14965 023c 386A     		ldr	r0, [r7, #32]
 14966 023e FFF7FEFF 		bl	modp_montymul
 14967 0242 0346     		mov	r3, r0
 14968              		.loc 2 3773 13 discriminator 3
 14969 0244 3360     		str	r3, [r6]
3774:keygen.c      **** 		ft[u + 1] = modp_montymul(gtA, mFp, p, p0i);
 14970              		.loc 2 3774 5 discriminator 3
 14971 0246 D7F88430 		ldr	r3, [r7, #132]
 14972 024a 0133     		adds	r3, r3, #1
 14973 024c 9B00     		lsls	r3, r3, #2
 14974 024e 7A6E     		ldr	r2, [r7, #100]
 14975 0250 D618     		adds	r6, r2, r3
 14976              		.loc 2 3774 15 discriminator 3
 14977 0252 7B6F     		ldr	r3, [r7, #116]
 14978 0254 BA6F     		ldr	r2, [r7, #120]
 14979 0256 F969     		ldr	r1, [r7, #28]
 14980 0258 786A     		ldr	r0, [r7, #36]
 14981 025a FFF7FEFF 		bl	modp_montymul
 14982 025e 0346     		mov	r3, r0
 14983              		.loc 2 3774 13 discriminator 3
 14984 0260 3360     		str	r3, [r6]
3775:keygen.c      **** 		gt[u + 0] = modp_montymul(ftB, mGp, p, p0i);
 14985              		.loc 2 3775 5 discriminator 3
 14986 0262 D7F88430 		ldr	r3, [r7, #132]
 14987 0266 9B00     		lsls	r3, r3, #2
 14988 0268 3A6E     		ldr	r2, [r7, #96]
 14989 026a D618     		adds	r6, r2, r3
 14990              		.loc 2 3775 15 discriminator 3
 14991 026c 7B6F     		ldr	r3, [r7, #116]
 14992 026e BA6F     		ldr	r2, [r7, #120]
 14993 0270 B969     		ldr	r1, [r7, #24]
 14994 0272 B86A     		ldr	r0, [r7, #40]
 14995 0274 FFF7FEFF 		bl	modp_montymul
 14996 0278 0346     		mov	r3, r0
 14997              		.loc 2 3775 13 discriminator 3
 14998 027a 3360     		str	r3, [r6]
3776:keygen.c      **** 		gt[u + 1] = modp_montymul(ftA, mGp, p, p0i);
 14999              		.loc 2 3776 5 discriminator 3
 15000 027c D7F88430 		ldr	r3, [r7, #132]
 15001 0280 0133     		adds	r3, r3, #1
 15002 0282 9B00     		lsls	r3, r3, #2
 15003 0284 3A6E     		ldr	r2, [r7, #96]
 15004 0286 D618     		adds	r6, r2, r3
 15005              		.loc 2 3776 15 discriminator 3
 15006 0288 7B6F     		ldr	r3, [r7, #116]
 15007 028a BA6F     		ldr	r2, [r7, #120]
 15008 028c B969     		ldr	r1, [r7, #24]
 15009 028e F86A     		ldr	r0, [r7, #44]
 15010 0290 FFF7FEFF 		bl	modp_montymul
 15011 0294 0346     		mov	r3, r0
 15012              		.loc 2 3776 13 discriminator 3
 15013 0296 3360     		str	r3, [r6]
 15014              	.LBE54:
3763:keygen.c      **** 		uint32_t ftA, ftB, gtA, gtB;
 15015              		.loc 2 3763 23 discriminator 3
 15016 0298 D7F88430 		ldr	r3, [r7, #132]
 15017 029c 0233     		adds	r3, r3, #2
 15018 029e C7F88430 		str	r3, [r7, #132]
 15019              	.L342:
3763:keygen.c      **** 		uint32_t ftA, ftB, gtA, gtB;
 15020              		.loc 2 3763 2 discriminator 1
 15021 02a2 D7F88420 		ldr	r2, [r7, #132]
 15022 02a6 D7F88030 		ldr	r3, [r7, #128]
 15023 02aa 9A42     		cmp	r2, r3
 15024 02ac 86D3     		bcc	.L343
3777:keygen.c      **** 	}
3778:keygen.c      **** 	modp_iNTT2(ft, igm, logn, p, p0i);
 15025              		.loc 2 3778 2
 15026 02ae 7B6F     		ldr	r3, [r7, #116]
 15027 02b0 0193     		str	r3, [sp, #4]
 15028 02b2 BB6F     		ldr	r3, [r7, #120]
 15029 02b4 0093     		str	r3, [sp]
 15030 02b6 7B69     		ldr	r3, [r7, #20]
 15031 02b8 BA6D     		ldr	r2, [r7, #88]
 15032 02ba 0121     		movs	r1, #1
 15033 02bc 786E     		ldr	r0, [r7, #100]
 15034 02be FFF7FEFF 		bl	modp_iNTT2_ext
3779:keygen.c      **** 	modp_iNTT2(gt, igm, logn, p, p0i);
 15035              		.loc 2 3779 2
 15036 02c2 7B6F     		ldr	r3, [r7, #116]
 15037 02c4 0193     		str	r3, [sp, #4]
 15038 02c6 BB6F     		ldr	r3, [r7, #120]
 15039 02c8 0093     		str	r3, [sp]
 15040 02ca 7B69     		ldr	r3, [r7, #20]
 15041 02cc BA6D     		ldr	r2, [r7, #88]
 15042 02ce 0121     		movs	r1, #1
 15043 02d0 386E     		ldr	r0, [r7, #96]
 15044 02d2 FFF7FEFF 		bl	modp_iNTT2_ext
3780:keygen.c      **** 
3781:keygen.c      **** 	Gp = Fp + n;
 15045              		.loc 2 3781 10
 15046 02d6 D7F88030 		ldr	r3, [r7, #128]
 15047 02da 9B00     		lsls	r3, r3, #2
 15048              		.loc 2 3781 5
 15049 02dc FA6E     		ldr	r2, [r7, #108]
 15050 02de 1344     		add	r3, r3, r2
 15051 02e0 BB66     		str	r3, [r7, #104]
3782:keygen.c      **** 	t1 = Gp + n;
 15052              		.loc 2 3782 10
 15053 02e2 D7F88030 		ldr	r3, [r7, #128]
 15054 02e6 9B00     		lsls	r3, r3, #2
 15055              		.loc 2 3782 5
 15056 02e8 BA6E     		ldr	r2, [r7, #104]
 15057 02ea 1344     		add	r3, r3, r2
 15058 02ec 7B65     		str	r3, [r7, #84]
3783:keygen.c      **** 	memmove(Fp, ft, 2 * n * sizeof *ft);
 15059              		.loc 2 3783 2
 15060 02ee D7F88030 		ldr	r3, [r7, #128]
 15061 02f2 DB00     		lsls	r3, r3, #3
 15062 02f4 1A46     		mov	r2, r3
 15063 02f6 796E     		ldr	r1, [r7, #100]
 15064 02f8 F86E     		ldr	r0, [r7, #108]
 15065 02fa FFF7FEFF 		bl	memmove
3784:keygen.c      **** 
3785:keygen.c      **** 	/*
3786:keygen.c      **** 	 * We now need to apply the Babai reduction. At that point,
3787:keygen.c      **** 	 * we have F and G in two n-word arrays.
3788:keygen.c      **** 	 *
3789:keygen.c      **** 	 * We can compute F*adj(f)+G*adj(g) and f*adj(f)+g*adj(g)
3790:keygen.c      **** 	 * modulo p, using the NTT. We still move memory around in
3791:keygen.c      **** 	 * order to save RAM.
3792:keygen.c      **** 	 */
3793:keygen.c      **** 	t2 = t1 + n;
 15066              		.loc 2 3793 10
 15067 02fe D7F88030 		ldr	r3, [r7, #128]
 15068 0302 9B00     		lsls	r3, r3, #2
 15069              		.loc 2 3793 5
 15070 0304 7A6D     		ldr	r2, [r7, #84]
 15071 0306 1344     		add	r3, r3, r2
 15072 0308 3B65     		str	r3, [r7, #80]
3794:keygen.c      **** 	t3 = t2 + n;
 15073              		.loc 2 3794 10
 15074 030a D7F88030 		ldr	r3, [r7, #128]
 15075 030e 9B00     		lsls	r3, r3, #2
 15076              		.loc 2 3794 5
 15077 0310 3A6D     		ldr	r2, [r7, #80]
 15078 0312 1344     		add	r3, r3, r2
 15079 0314 FB64     		str	r3, [r7, #76]
3795:keygen.c      **** 	t4 = t3 + n;
 15080              		.loc 2 3795 10
 15081 0316 D7F88030 		ldr	r3, [r7, #128]
 15082 031a 9B00     		lsls	r3, r3, #2
 15083              		.loc 2 3795 5
 15084 031c FA6C     		ldr	r2, [r7, #76]
 15085 031e 1344     		add	r3, r3, r2
 15086 0320 BB64     		str	r3, [r7, #72]
3796:keygen.c      **** 	t5 = t4 + n;
 15087              		.loc 2 3796 10
 15088 0322 D7F88030 		ldr	r3, [r7, #128]
 15089 0326 9B00     		lsls	r3, r3, #2
 15090              		.loc 2 3796 5
 15091 0328 BA6C     		ldr	r2, [r7, #72]
 15092 032a 1344     		add	r3, r3, r2
 15093 032c 7B64     		str	r3, [r7, #68]
3797:keygen.c      **** 
3798:keygen.c      **** 	/*
3799:keygen.c      **** 	 * Compute the NTT tables in t1 and t2. We do not keep t2
3800:keygen.c      **** 	 * (we'll recompute it later on).
3801:keygen.c      **** 	 */
3802:keygen.c      **** 	modp_mkgm2(t1, t2, logn, PRIMES[0].g, p, p0i);
 15094              		.loc 2 3802 2
 15095 032e 874A     		ldr	r2, .L369
 15096 0330 7B6F     		ldr	r3, [r7, #116]
 15097 0332 0193     		str	r3, [sp, #4]
 15098 0334 BB6F     		ldr	r3, [r7, #120]
 15099 0336 0093     		str	r3, [sp]
 15100 0338 1346     		mov	r3, r2
 15101 033a 7A69     		ldr	r2, [r7, #20]
 15102 033c 396D     		ldr	r1, [r7, #80]
 15103 033e 786D     		ldr	r0, [r7, #84]
 15104 0340 FFF7FEFF 		bl	modp_mkgm2
3803:keygen.c      **** 
3804:keygen.c      **** 	/*
3805:keygen.c      **** 	 * Convert F and G to NTT.
3806:keygen.c      **** 	 */
3807:keygen.c      **** 	modp_NTT2(Fp, t1, logn, p, p0i);
 15105              		.loc 2 3807 2
 15106 0344 7B6F     		ldr	r3, [r7, #116]
 15107 0346 0193     		str	r3, [sp, #4]
 15108 0348 BB6F     		ldr	r3, [r7, #120]
 15109 034a 0093     		str	r3, [sp]
 15110 034c 7B69     		ldr	r3, [r7, #20]
 15111 034e 7A6D     		ldr	r2, [r7, #84]
 15112 0350 0121     		movs	r1, #1
 15113 0352 F86E     		ldr	r0, [r7, #108]
 15114 0354 FFF7FEFF 		bl	modp_NTT2_ext
3808:keygen.c      **** 	modp_NTT2(Gp, t1, logn, p, p0i);
 15115              		.loc 2 3808 2
 15116 0358 7B6F     		ldr	r3, [r7, #116]
 15117 035a 0193     		str	r3, [sp, #4]
 15118 035c BB6F     		ldr	r3, [r7, #120]
 15119 035e 0093     		str	r3, [sp]
 15120 0360 7B69     		ldr	r3, [r7, #20]
 15121 0362 7A6D     		ldr	r2, [r7, #84]
 15122 0364 0121     		movs	r1, #1
 15123 0366 B86E     		ldr	r0, [r7, #104]
 15124 0368 FFF7FEFF 		bl	modp_NTT2_ext
3809:keygen.c      **** 
3810:keygen.c      **** 	/*
3811:keygen.c      **** 	 * Load f and adj(f) in t4 and t5, and convert them to NTT
3812:keygen.c      **** 	 * representation.
3813:keygen.c      **** 	 */
3814:keygen.c      **** 	t4[0] = t5[0] = modp_set(f[0], p);
 15125              		.loc 2 3814 28
 15126 036c 3B69     		ldr	r3, [r7, #16]
 15127 036e 93F90030 		ldrsb	r3, [r3]
 15128              		.loc 2 3814 18
 15129 0372 B96F     		ldr	r1, [r7, #120]
 15130 0374 1846     		mov	r0, r3
 15131 0376 FFF7FEFF 		bl	modp_set
 15132 037a 0246     		mov	r2, r0
 15133              		.loc 2 3814 16
 15134 037c 7B6C     		ldr	r3, [r7, #68]
 15135 037e 1A60     		str	r2, [r3]
 15136              		.loc 2 3814 12
 15137 0380 7B6C     		ldr	r3, [r7, #68]
 15138 0382 1A68     		ldr	r2, [r3]
 15139              		.loc 2 3814 8
 15140 0384 BB6C     		ldr	r3, [r7, #72]
 15141 0386 1A60     		str	r2, [r3]
3815:keygen.c      **** 	for (u = 1; u < n; u ++) {
 15142              		.loc 2 3815 9
 15143 0388 0123     		movs	r3, #1
 15144 038a C7F88430 		str	r3, [r7, #132]
 15145              		.loc 2 3815 2
 15146 038e 29E0     		b	.L344
 15147              	.L345:
3816:keygen.c      **** 		t4[u] = modp_set(f[u], p);
 15148              		.loc 2 3816 21 discriminator 3
 15149 0390 3A69     		ldr	r2, [r7, #16]
 15150 0392 D7F88430 		ldr	r3, [r7, #132]
 15151 0396 1344     		add	r3, r3, r2
 15152 0398 93F90030 		ldrsb	r3, [r3]
 15153              		.loc 2 3816 11 discriminator 3
 15154 039c 1846     		mov	r0, r3
 15155              		.loc 2 3816 5 discriminator 3
 15156 039e D7F88430 		ldr	r3, [r7, #132]
 15157 03a2 9B00     		lsls	r3, r3, #2
 15158 03a4 BA6C     		ldr	r2, [r7, #72]
 15159 03a6 D618     		adds	r6, r2, r3
 15160              		.loc 2 3816 11 discriminator 3
 15161 03a8 B96F     		ldr	r1, [r7, #120]
 15162 03aa FFF7FEFF 		bl	modp_set
 15163 03ae 0346     		mov	r3, r0
 15164              		.loc 2 3816 9 discriminator 3
 15165 03b0 3360     		str	r3, [r6]
3817:keygen.c      **** 		t5[n - u] = modp_set(-f[u], p);
 15166              		.loc 2 3817 26 discriminator 3
 15167 03b2 3A69     		ldr	r2, [r7, #16]
 15168 03b4 D7F88430 		ldr	r3, [r7, #132]
 15169 03b8 1344     		add	r3, r3, r2
 15170 03ba 93F90030 		ldrsb	r3, [r3]
 15171              		.loc 2 3817 24 discriminator 3
 15172 03be 5842     		rsbs	r0, r3, #0
 15173              		.loc 2 3817 8 discriminator 3
 15174 03c0 D7F88020 		ldr	r2, [r7, #128]
 15175 03c4 D7F88430 		ldr	r3, [r7, #132]
 15176 03c8 D31A     		subs	r3, r2, r3
 15177              		.loc 2 3817 5 discriminator 3
 15178 03ca 9B00     		lsls	r3, r3, #2
 15179 03cc 7A6C     		ldr	r2, [r7, #68]
 15180 03ce D618     		adds	r6, r2, r3
 15181              		.loc 2 3817 15 discriminator 3
 15182 03d0 B96F     		ldr	r1, [r7, #120]
 15183 03d2 FFF7FEFF 		bl	modp_set
 15184 03d6 0346     		mov	r3, r0
 15185              		.loc 2 3817 13 discriminator 3
 15186 03d8 3360     		str	r3, [r6]
3815:keygen.c      **** 	for (u = 1; u < n; u ++) {
 15187              		.loc 2 3815 23 discriminator 3
 15188 03da D7F88430 		ldr	r3, [r7, #132]
 15189 03de 0133     		adds	r3, r3, #1
 15190 03e0 C7F88430 		str	r3, [r7, #132]
 15191              	.L344:
3815:keygen.c      **** 	for (u = 1; u < n; u ++) {
 15192              		.loc 2 3815 2 discriminator 1
 15193 03e4 D7F88420 		ldr	r2, [r7, #132]
 15194 03e8 D7F88030 		ldr	r3, [r7, #128]
 15195 03ec 9A42     		cmp	r2, r3
 15196 03ee CFD3     		bcc	.L345
3818:keygen.c      **** 	}
3819:keygen.c      **** 	modp_NTT2(t4, t1, logn, p, p0i);
 15197              		.loc 2 3819 2
 15198 03f0 7B6F     		ldr	r3, [r7, #116]
 15199 03f2 0193     		str	r3, [sp, #4]
 15200 03f4 BB6F     		ldr	r3, [r7, #120]
 15201 03f6 0093     		str	r3, [sp]
 15202 03f8 7B69     		ldr	r3, [r7, #20]
 15203 03fa 7A6D     		ldr	r2, [r7, #84]
 15204 03fc 0121     		movs	r1, #1
 15205 03fe B86C     		ldr	r0, [r7, #72]
 15206 0400 FFF7FEFF 		bl	modp_NTT2_ext
3820:keygen.c      **** 	modp_NTT2(t5, t1, logn, p, p0i);
 15207              		.loc 2 3820 2
 15208 0404 7B6F     		ldr	r3, [r7, #116]
 15209 0406 0193     		str	r3, [sp, #4]
 15210 0408 BB6F     		ldr	r3, [r7, #120]
 15211 040a 0093     		str	r3, [sp]
 15212 040c 7B69     		ldr	r3, [r7, #20]
 15213 040e 7A6D     		ldr	r2, [r7, #84]
 15214 0410 0121     		movs	r1, #1
 15215 0412 786C     		ldr	r0, [r7, #68]
 15216 0414 FFF7FEFF 		bl	modp_NTT2_ext
3821:keygen.c      **** 
3822:keygen.c      **** 	/*
3823:keygen.c      **** 	 * Compute F*adj(f) in t2, and f*adj(f) in t3.
3824:keygen.c      **** 	 */
3825:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15217              		.loc 2 3825 9
 15218 0418 0023     		movs	r3, #0
 15219 041a C7F88430 		str	r3, [r7, #132]
 15220              		.loc 2 3825 2
 15221 041e 34E0     		b	.L346
 15222              	.L347:
 15223              	.LBB55:
3826:keygen.c      **** 		uint32_t w;
3827:keygen.c      **** 
3828:keygen.c      **** 		w = modp_montymul(t5[u], R2, p, p0i);
 15224              		.loc 2 3828 23 discriminator 3
 15225 0420 D7F88430 		ldr	r3, [r7, #132]
 15226 0424 9B00     		lsls	r3, r3, #2
 15227 0426 7A6C     		ldr	r2, [r7, #68]
 15228 0428 1344     		add	r3, r3, r2
 15229              		.loc 2 3828 7 discriminator 3
 15230 042a 1868     		ldr	r0, [r3]
 15231 042c 7B6F     		ldr	r3, [r7, #116]
 15232 042e BA6F     		ldr	r2, [r7, #120]
 15233 0430 396F     		ldr	r1, [r7, #112]
 15234 0432 FFF7FEFF 		bl	modp_montymul
 15235 0436 3863     		str	r0, [r7, #48]
3829:keygen.c      **** 		t2[u] = modp_montymul(w, Fp[u], p, p0i);
 15236              		.loc 2 3829 30 discriminator 3
 15237 0438 D7F88430 		ldr	r3, [r7, #132]
 15238 043c 9B00     		lsls	r3, r3, #2
 15239 043e FA6E     		ldr	r2, [r7, #108]
 15240 0440 1344     		add	r3, r3, r2
 15241              		.loc 2 3829 11 discriminator 3
 15242 0442 1968     		ldr	r1, [r3]
 15243              		.loc 2 3829 5 discriminator 3
 15244 0444 D7F88430 		ldr	r3, [r7, #132]
 15245 0448 9B00     		lsls	r3, r3, #2
 15246 044a 3A6D     		ldr	r2, [r7, #80]
 15247 044c D618     		adds	r6, r2, r3
 15248              		.loc 2 3829 11 discriminator 3
 15249 044e 7B6F     		ldr	r3, [r7, #116]
 15250 0450 BA6F     		ldr	r2, [r7, #120]
 15251 0452 386B     		ldr	r0, [r7, #48]
 15252 0454 FFF7FEFF 		bl	modp_montymul
 15253 0458 0346     		mov	r3, r0
 15254              		.loc 2 3829 9 discriminator 3
 15255 045a 3360     		str	r3, [r6]
3830:keygen.c      **** 		t3[u] = modp_montymul(w, t4[u], p, p0i);
 15256              		.loc 2 3830 30 discriminator 3
 15257 045c D7F88430 		ldr	r3, [r7, #132]
 15258 0460 9B00     		lsls	r3, r3, #2
 15259 0462 BA6C     		ldr	r2, [r7, #72]
 15260 0464 1344     		add	r3, r3, r2
 15261              		.loc 2 3830 11 discriminator 3
 15262 0466 1968     		ldr	r1, [r3]
 15263              		.loc 2 3830 5 discriminator 3
 15264 0468 D7F88430 		ldr	r3, [r7, #132]
 15265 046c 9B00     		lsls	r3, r3, #2
 15266 046e FA6C     		ldr	r2, [r7, #76]
 15267 0470 D618     		adds	r6, r2, r3
 15268              		.loc 2 3830 11 discriminator 3
 15269 0472 7B6F     		ldr	r3, [r7, #116]
 15270 0474 BA6F     		ldr	r2, [r7, #120]
 15271 0476 386B     		ldr	r0, [r7, #48]
 15272 0478 FFF7FEFF 		bl	modp_montymul
 15273 047c 0346     		mov	r3, r0
 15274              		.loc 2 3830 9 discriminator 3
 15275 047e 3360     		str	r3, [r6]
 15276              	.LBE55:
3825:keygen.c      **** 		uint32_t w;
 15277              		.loc 2 3825 23 discriminator 3
 15278 0480 D7F88430 		ldr	r3, [r7, #132]
 15279 0484 0133     		adds	r3, r3, #1
 15280 0486 C7F88430 		str	r3, [r7, #132]
 15281              	.L346:
3825:keygen.c      **** 		uint32_t w;
 15282              		.loc 2 3825 2 discriminator 1
 15283 048a D7F88420 		ldr	r2, [r7, #132]
 15284 048e D7F88030 		ldr	r3, [r7, #128]
 15285 0492 9A42     		cmp	r2, r3
 15286 0494 C4D3     		bcc	.L347
3831:keygen.c      **** 	}
3832:keygen.c      **** 
3833:keygen.c      **** 	/*
3834:keygen.c      **** 	 * Load g and adj(g) in t4 and t5, and convert them to NTT
3835:keygen.c      **** 	 * representation.
3836:keygen.c      **** 	 */
3837:keygen.c      **** 	t4[0] = t5[0] = modp_set(g[0], p);
 15287              		.loc 2 3837 28
 15288 0496 FB68     		ldr	r3, [r7, #12]
 15289 0498 93F90030 		ldrsb	r3, [r3]
 15290              		.loc 2 3837 18
 15291 049c B96F     		ldr	r1, [r7, #120]
 15292 049e 1846     		mov	r0, r3
 15293 04a0 FFF7FEFF 		bl	modp_set
 15294 04a4 0246     		mov	r2, r0
 15295              		.loc 2 3837 16
 15296 04a6 7B6C     		ldr	r3, [r7, #68]
 15297 04a8 1A60     		str	r2, [r3]
 15298              		.loc 2 3837 12
 15299 04aa 7B6C     		ldr	r3, [r7, #68]
 15300 04ac 1A68     		ldr	r2, [r3]
 15301              		.loc 2 3837 8
 15302 04ae BB6C     		ldr	r3, [r7, #72]
 15303 04b0 1A60     		str	r2, [r3]
3838:keygen.c      **** 	for (u = 1; u < n; u ++) {
 15304              		.loc 2 3838 9
 15305 04b2 0123     		movs	r3, #1
 15306 04b4 C7F88430 		str	r3, [r7, #132]
 15307              		.loc 2 3838 2
 15308 04b8 29E0     		b	.L348
 15309              	.L349:
3839:keygen.c      **** 		t4[u] = modp_set(g[u], p);
 15310              		.loc 2 3839 21 discriminator 3
 15311 04ba FA68     		ldr	r2, [r7, #12]
 15312 04bc D7F88430 		ldr	r3, [r7, #132]
 15313 04c0 1344     		add	r3, r3, r2
 15314 04c2 93F90030 		ldrsb	r3, [r3]
 15315              		.loc 2 3839 11 discriminator 3
 15316 04c6 1846     		mov	r0, r3
 15317              		.loc 2 3839 5 discriminator 3
 15318 04c8 D7F88430 		ldr	r3, [r7, #132]
 15319 04cc 9B00     		lsls	r3, r3, #2
 15320 04ce BA6C     		ldr	r2, [r7, #72]
 15321 04d0 D618     		adds	r6, r2, r3
 15322              		.loc 2 3839 11 discriminator 3
 15323 04d2 B96F     		ldr	r1, [r7, #120]
 15324 04d4 FFF7FEFF 		bl	modp_set
 15325 04d8 0346     		mov	r3, r0
 15326              		.loc 2 3839 9 discriminator 3
 15327 04da 3360     		str	r3, [r6]
3840:keygen.c      **** 		t5[n - u] = modp_set(-g[u], p);
 15328              		.loc 2 3840 26 discriminator 3
 15329 04dc FA68     		ldr	r2, [r7, #12]
 15330 04de D7F88430 		ldr	r3, [r7, #132]
 15331 04e2 1344     		add	r3, r3, r2
 15332 04e4 93F90030 		ldrsb	r3, [r3]
 15333              		.loc 2 3840 24 discriminator 3
 15334 04e8 5842     		rsbs	r0, r3, #0
 15335              		.loc 2 3840 8 discriminator 3
 15336 04ea D7F88020 		ldr	r2, [r7, #128]
 15337 04ee D7F88430 		ldr	r3, [r7, #132]
 15338 04f2 D31A     		subs	r3, r2, r3
 15339              		.loc 2 3840 5 discriminator 3
 15340 04f4 9B00     		lsls	r3, r3, #2
 15341 04f6 7A6C     		ldr	r2, [r7, #68]
 15342 04f8 D618     		adds	r6, r2, r3
 15343              		.loc 2 3840 15 discriminator 3
 15344 04fa B96F     		ldr	r1, [r7, #120]
 15345 04fc FFF7FEFF 		bl	modp_set
 15346 0500 0346     		mov	r3, r0
 15347              		.loc 2 3840 13 discriminator 3
 15348 0502 3360     		str	r3, [r6]
3838:keygen.c      **** 	for (u = 1; u < n; u ++) {
 15349              		.loc 2 3838 23 discriminator 3
 15350 0504 D7F88430 		ldr	r3, [r7, #132]
 15351 0508 0133     		adds	r3, r3, #1
 15352 050a C7F88430 		str	r3, [r7, #132]
 15353              	.L348:
3838:keygen.c      **** 	for (u = 1; u < n; u ++) {
 15354              		.loc 2 3838 2 discriminator 1
 15355 050e D7F88420 		ldr	r2, [r7, #132]
 15356 0512 D7F88030 		ldr	r3, [r7, #128]
 15357 0516 9A42     		cmp	r2, r3
 15358 0518 CFD3     		bcc	.L349
3841:keygen.c      **** 	}
3842:keygen.c      **** 	modp_NTT2(t4, t1, logn, p, p0i);
 15359              		.loc 2 3842 2
 15360 051a 7B6F     		ldr	r3, [r7, #116]
 15361 051c 0193     		str	r3, [sp, #4]
 15362 051e BB6F     		ldr	r3, [r7, #120]
 15363 0520 0093     		str	r3, [sp]
 15364 0522 7B69     		ldr	r3, [r7, #20]
 15365 0524 7A6D     		ldr	r2, [r7, #84]
 15366 0526 0121     		movs	r1, #1
 15367 0528 B86C     		ldr	r0, [r7, #72]
 15368 052a FFF7FEFF 		bl	modp_NTT2_ext
3843:keygen.c      **** 	modp_NTT2(t5, t1, logn, p, p0i);
 15369              		.loc 2 3843 2
 15370 052e 7B6F     		ldr	r3, [r7, #116]
 15371 0530 0193     		str	r3, [sp, #4]
 15372 0532 BB6F     		ldr	r3, [r7, #120]
 15373 0534 0093     		str	r3, [sp]
 15374 0536 7B69     		ldr	r3, [r7, #20]
 15375 0538 7A6D     		ldr	r2, [r7, #84]
 15376 053a 0121     		movs	r1, #1
 15377 053c 786C     		ldr	r0, [r7, #68]
 15378 053e FFF7FEFF 		bl	modp_NTT2_ext
3844:keygen.c      **** 
3845:keygen.c      **** 	/*
3846:keygen.c      **** 	 * Add G*adj(g) to t2, and g*adj(g) to t3.
3847:keygen.c      **** 	 */
3848:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15379              		.loc 2 3848 9
 15380 0542 0023     		movs	r3, #0
 15381 0544 C7F88430 		str	r3, [r7, #132]
 15382              		.loc 2 3848 2
 15383 0548 4FE0     		b	.L350
 15384              	.L370:
 15385 054a 00BF     		.align	2
 15386              	.L369:
 15387 054c 45ADD616 		.word	383167813
 15388              	.L351:
 15389              	.LBB56:
3849:keygen.c      **** 		uint32_t w;
3850:keygen.c      **** 
3851:keygen.c      **** 		w = modp_montymul(t5[u], R2, p, p0i);
 15390              		.loc 2 3851 23 discriminator 3
 15391 0550 D7F88430 		ldr	r3, [r7, #132]
 15392 0554 9B00     		lsls	r3, r3, #2
 15393 0556 7A6C     		ldr	r2, [r7, #68]
 15394 0558 1344     		add	r3, r3, r2
 15395              		.loc 2 3851 7 discriminator 3
 15396 055a 1868     		ldr	r0, [r3]
 15397 055c 7B6F     		ldr	r3, [r7, #116]
 15398 055e BA6F     		ldr	r2, [r7, #120]
 15399 0560 396F     		ldr	r1, [r7, #112]
 15400 0562 FFF7FEFF 		bl	modp_montymul
 15401 0566 7863     		str	r0, [r7, #52]
3852:keygen.c      **** 		t2[u] = modp_add(t2[u],
 15402              		.loc 2 3852 22 discriminator 3
 15403 0568 D7F88430 		ldr	r3, [r7, #132]
 15404 056c 9B00     		lsls	r3, r3, #2
 15405 056e 3A6D     		ldr	r2, [r7, #80]
 15406 0570 1344     		add	r3, r3, r2
 15407              		.loc 2 3852 11 discriminator 3
 15408 0572 1B68     		ldr	r3, [r3]
 15409 0574 7B60     		str	r3, [r7, #4]
3853:keygen.c      **** 			modp_montymul(w, Gp[u], p, p0i), p);
 15410              		.loc 2 3853 23 discriminator 3
 15411 0576 D7F88430 		ldr	r3, [r7, #132]
 15412 057a 9B00     		lsls	r3, r3, #2
 15413 057c BA6E     		ldr	r2, [r7, #104]
 15414 057e 1344     		add	r3, r3, r2
3852:keygen.c      **** 		t2[u] = modp_add(t2[u],
 15415              		.loc 2 3852 11 discriminator 3
 15416 0580 1968     		ldr	r1, [r3]
 15417 0582 7B6F     		ldr	r3, [r7, #116]
 15418 0584 BA6F     		ldr	r2, [r7, #120]
 15419 0586 786B     		ldr	r0, [r7, #52]
 15420 0588 FFF7FEFF 		bl	modp_montymul
 15421 058c 0146     		mov	r1, r0
3852:keygen.c      **** 		t2[u] = modp_add(t2[u],
 15422              		.loc 2 3852 5 discriminator 3
 15423 058e D7F88430 		ldr	r3, [r7, #132]
 15424 0592 9B00     		lsls	r3, r3, #2
 15425 0594 3A6D     		ldr	r2, [r7, #80]
 15426 0596 D618     		adds	r6, r2, r3
3852:keygen.c      **** 		t2[u] = modp_add(t2[u],
 15427              		.loc 2 3852 11 discriminator 3
 15428 0598 BA6F     		ldr	r2, [r7, #120]
 15429 059a 7868     		ldr	r0, [r7, #4]
 15430 059c FFF7FEFF 		bl	modp_add
 15431 05a0 0346     		mov	r3, r0
3852:keygen.c      **** 		t2[u] = modp_add(t2[u],
 15432              		.loc 2 3852 9 discriminator 3
 15433 05a2 3360     		str	r3, [r6]
3854:keygen.c      **** 		t3[u] = modp_add(t3[u],
 15434              		.loc 2 3854 22 discriminator 3
 15435 05a4 D7F88430 		ldr	r3, [r7, #132]
 15436 05a8 9B00     		lsls	r3, r3, #2
 15437 05aa FA6C     		ldr	r2, [r7, #76]
 15438 05ac 1344     		add	r3, r3, r2
 15439              		.loc 2 3854 11 discriminator 3
 15440 05ae 1B68     		ldr	r3, [r3]
 15441 05b0 7B60     		str	r3, [r7, #4]
3855:keygen.c      **** 			modp_montymul(w, t4[u], p, p0i), p);
 15442              		.loc 2 3855 23 discriminator 3
 15443 05b2 D7F88430 		ldr	r3, [r7, #132]
 15444 05b6 9B00     		lsls	r3, r3, #2
 15445 05b8 BA6C     		ldr	r2, [r7, #72]
 15446 05ba 1344     		add	r3, r3, r2
3854:keygen.c      **** 		t3[u] = modp_add(t3[u],
 15447              		.loc 2 3854 11 discriminator 3
 15448 05bc 1968     		ldr	r1, [r3]
 15449 05be 7B6F     		ldr	r3, [r7, #116]
 15450 05c0 BA6F     		ldr	r2, [r7, #120]
 15451 05c2 786B     		ldr	r0, [r7, #52]
 15452 05c4 FFF7FEFF 		bl	modp_montymul
 15453 05c8 0146     		mov	r1, r0
3854:keygen.c      **** 		t3[u] = modp_add(t3[u],
 15454              		.loc 2 3854 5 discriminator 3
 15455 05ca D7F88430 		ldr	r3, [r7, #132]
 15456 05ce 9B00     		lsls	r3, r3, #2
 15457 05d0 FA6C     		ldr	r2, [r7, #76]
 15458 05d2 D618     		adds	r6, r2, r3
3854:keygen.c      **** 		t3[u] = modp_add(t3[u],
 15459              		.loc 2 3854 11 discriminator 3
 15460 05d4 BA6F     		ldr	r2, [r7, #120]
 15461 05d6 7868     		ldr	r0, [r7, #4]
 15462 05d8 FFF7FEFF 		bl	modp_add
 15463 05dc 0346     		mov	r3, r0
3854:keygen.c      **** 		t3[u] = modp_add(t3[u],
 15464              		.loc 2 3854 9 discriminator 3
 15465 05de 3360     		str	r3, [r6]
 15466              	.LBE56:
3848:keygen.c      **** 		uint32_t w;
 15467              		.loc 2 3848 23 discriminator 3
 15468 05e0 D7F88430 		ldr	r3, [r7, #132]
 15469 05e4 0133     		adds	r3, r3, #1
 15470 05e6 C7F88430 		str	r3, [r7, #132]
 15471              	.L350:
3848:keygen.c      **** 		uint32_t w;
 15472              		.loc 2 3848 2 discriminator 1
 15473 05ea D7F88420 		ldr	r2, [r7, #132]
 15474 05ee D7F88030 		ldr	r3, [r7, #128]
 15475 05f2 9A42     		cmp	r2, r3
 15476 05f4 ACD3     		bcc	.L351
3856:keygen.c      **** 	}
3857:keygen.c      **** 
3858:keygen.c      **** 	/*
3859:keygen.c      **** 	 * Convert back t2 and t3 to normal representation (normalized
3860:keygen.c      **** 	 * around 0), and then
3861:keygen.c      **** 	 * move them to t1 and t2. We first need to recompute the
3862:keygen.c      **** 	 * inverse table for NTT.
3863:keygen.c      **** 	 */
3864:keygen.c      **** 	modp_mkgm2(t1, t4, logn, PRIMES[0].g, p, p0i);
 15477              		.loc 2 3864 2
 15478 05f6 B04A     		ldr	r2, .L371
 15479 05f8 7B6F     		ldr	r3, [r7, #116]
 15480 05fa 0193     		str	r3, [sp, #4]
 15481 05fc BB6F     		ldr	r3, [r7, #120]
 15482 05fe 0093     		str	r3, [sp]
 15483 0600 1346     		mov	r3, r2
 15484 0602 7A69     		ldr	r2, [r7, #20]
 15485 0604 B96C     		ldr	r1, [r7, #72]
 15486 0606 786D     		ldr	r0, [r7, #84]
 15487 0608 FFF7FEFF 		bl	modp_mkgm2
3865:keygen.c      **** 	modp_iNTT2(t2, t4, logn, p, p0i);
 15488              		.loc 2 3865 2
 15489 060c 7B6F     		ldr	r3, [r7, #116]
 15490 060e 0193     		str	r3, [sp, #4]
 15491 0610 BB6F     		ldr	r3, [r7, #120]
 15492 0612 0093     		str	r3, [sp]
 15493 0614 7B69     		ldr	r3, [r7, #20]
 15494 0616 BA6C     		ldr	r2, [r7, #72]
 15495 0618 0121     		movs	r1, #1
 15496 061a 386D     		ldr	r0, [r7, #80]
 15497 061c FFF7FEFF 		bl	modp_iNTT2_ext
3866:keygen.c      **** 	modp_iNTT2(t3, t4, logn, p, p0i);
 15498              		.loc 2 3866 2
 15499 0620 7B6F     		ldr	r3, [r7, #116]
 15500 0622 0193     		str	r3, [sp, #4]
 15501 0624 BB6F     		ldr	r3, [r7, #120]
 15502 0626 0093     		str	r3, [sp]
 15503 0628 7B69     		ldr	r3, [r7, #20]
 15504 062a BA6C     		ldr	r2, [r7, #72]
 15505 062c 0121     		movs	r1, #1
 15506 062e F86C     		ldr	r0, [r7, #76]
 15507 0630 FFF7FEFF 		bl	modp_iNTT2_ext
3867:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15508              		.loc 2 3867 9
 15509 0634 0023     		movs	r3, #0
 15510 0636 C7F88430 		str	r3, [r7, #132]
 15511              		.loc 2 3867 2
 15512 063a 28E0     		b	.L352
 15513              	.L353:
3868:keygen.c      **** 		t1[u] = (uint32_t)modp_norm(t2[u], p);
 15514              		.loc 2 3868 33 discriminator 3
 15515 063c D7F88430 		ldr	r3, [r7, #132]
 15516 0640 9B00     		lsls	r3, r3, #2
 15517 0642 3A6D     		ldr	r2, [r7, #80]
 15518 0644 1344     		add	r3, r3, r2
 15519              		.loc 2 3868 21 discriminator 3
 15520 0646 1B68     		ldr	r3, [r3]
 15521 0648 B96F     		ldr	r1, [r7, #120]
 15522 064a 1846     		mov	r0, r3
 15523 064c FFF7FEFF 		bl	modp_norm
 15524 0650 0146     		mov	r1, r0
 15525              		.loc 2 3868 5 discriminator 3
 15526 0652 D7F88430 		ldr	r3, [r7, #132]
 15527 0656 9B00     		lsls	r3, r3, #2
 15528 0658 7A6D     		ldr	r2, [r7, #84]
 15529 065a 1344     		add	r3, r3, r2
 15530              		.loc 2 3868 11 discriminator 3
 15531 065c 0A46     		mov	r2, r1
 15532              		.loc 2 3868 9 discriminator 3
 15533 065e 1A60     		str	r2, [r3]
3869:keygen.c      **** 		t2[u] = (uint32_t)modp_norm(t3[u], p);
 15534              		.loc 2 3869 33 discriminator 3
 15535 0660 D7F88430 		ldr	r3, [r7, #132]
 15536 0664 9B00     		lsls	r3, r3, #2
 15537 0666 FA6C     		ldr	r2, [r7, #76]
 15538 0668 1344     		add	r3, r3, r2
 15539              		.loc 2 3869 21 discriminator 3
 15540 066a 1B68     		ldr	r3, [r3]
 15541 066c B96F     		ldr	r1, [r7, #120]
 15542 066e 1846     		mov	r0, r3
 15543 0670 FFF7FEFF 		bl	modp_norm
 15544 0674 0146     		mov	r1, r0
 15545              		.loc 2 3869 5 discriminator 3
 15546 0676 D7F88430 		ldr	r3, [r7, #132]
 15547 067a 9B00     		lsls	r3, r3, #2
 15548 067c 3A6D     		ldr	r2, [r7, #80]
 15549 067e 1344     		add	r3, r3, r2
 15550              		.loc 2 3869 11 discriminator 3
 15551 0680 0A46     		mov	r2, r1
 15552              		.loc 2 3869 9 discriminator 3
 15553 0682 1A60     		str	r2, [r3]
3867:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15554              		.loc 2 3867 23 discriminator 3
 15555 0684 D7F88430 		ldr	r3, [r7, #132]
 15556 0688 0133     		adds	r3, r3, #1
 15557 068a C7F88430 		str	r3, [r7, #132]
 15558              	.L352:
3867:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15559              		.loc 2 3867 2 discriminator 1
 15560 068e D7F88420 		ldr	r2, [r7, #132]
 15561 0692 D7F88030 		ldr	r3, [r7, #128]
 15562 0696 9A42     		cmp	r2, r3
 15563 0698 D0D3     		bcc	.L353
3870:keygen.c      **** 	}
3871:keygen.c      **** 
3872:keygen.c      **** 	/*
3873:keygen.c      **** 	 * At that point, array contents are:
3874:keygen.c      **** 	 *
3875:keygen.c      **** 	 *   F (NTT representation) (Fp)
3876:keygen.c      **** 	 *   G (NTT representation) (Gp)
3877:keygen.c      **** 	 *   F*adj(f)+G*adj(g) (t1)
3878:keygen.c      **** 	 *   f*adj(f)+g*adj(g) (t2)
3879:keygen.c      **** 	 *
3880:keygen.c      **** 	 * We want to divide t1 by t2. The result is not integral; it
3881:keygen.c      **** 	 * must be rounded. We thus need to use the FFT.
3882:keygen.c      **** 	 */
3883:keygen.c      **** 
3884:keygen.c      **** 	/*
3885:keygen.c      **** 	 * Get f*adj(f)+g*adj(g) in FFT representation. Since this
3886:keygen.c      **** 	 * polynomial is auto-adjoint, all its coordinates in FFT
3887:keygen.c      **** 	 * representation are actually real, so we can truncate off
3888:keygen.c      **** 	 * the imaginary parts.
3889:keygen.c      **** 	 */
3890:keygen.c      **** 	rt3 = align_fpr(tmp, t3);
 15564              		.loc 2 3890 8
 15565 069a F96C     		ldr	r1, [r7, #76]
 15566 069c B868     		ldr	r0, [r7, #8]
 15567 069e FFF7FEFF 		bl	align_fpr
 15568 06a2 3864     		str	r0, [r7, #64]
3891:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15569              		.loc 2 3891 9
 15570 06a4 0023     		movs	r3, #0
 15571 06a6 C7F88430 		str	r3, [r7, #132]
 15572              		.loc 2 3891 2
 15573 06aa 1AE0     		b	.L354
 15574              	.L355:
3892:keygen.c      **** 		rt3[u] = fpr_of(((int32_t *)t2)[u]);
 15575              		.loc 2 3892 34 discriminator 3
 15576 06ac D7F88430 		ldr	r3, [r7, #132]
 15577 06b0 9B00     		lsls	r3, r3, #2
 15578 06b2 3A6D     		ldr	r2, [r7, #80]
 15579 06b4 1344     		add	r3, r3, r2
 15580 06b6 1B68     		ldr	r3, [r3]
 15581              		.loc 2 3892 12 discriminator 3
 15582 06b8 DA17     		asrs	r2, r3, #31
 15583 06ba 9846     		mov	r8, r3
 15584 06bc 9146     		mov	r9, r2
 15585              		.loc 2 3892 6 discriminator 3
 15586 06be D7F88430 		ldr	r3, [r7, #132]
 15587 06c2 DB00     		lsls	r3, r3, #3
 15588 06c4 3A6C     		ldr	r2, [r7, #64]
 15589 06c6 D618     		adds	r6, r2, r3
 15590              		.loc 2 3892 12 discriminator 3
 15591 06c8 4046     		mov	r0, r8
 15592 06ca 4946     		mov	r1, r9
 15593 06cc FFF7FEFF 		bl	fpr_of
 15594 06d0 0246     		mov	r2, r0
 15595 06d2 0B46     		mov	r3, r1
 15596              		.loc 2 3892 10 discriminator 3
 15597 06d4 C6E90023 		strd	r2, [r6]
3891:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15598              		.loc 2 3891 23 discriminator 3
 15599 06d8 D7F88430 		ldr	r3, [r7, #132]
 15600 06dc 0133     		adds	r3, r3, #1
 15601 06de C7F88430 		str	r3, [r7, #132]
 15602              	.L354:
3891:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15603              		.loc 2 3891 2 discriminator 1
 15604 06e2 D7F88420 		ldr	r2, [r7, #132]
 15605 06e6 D7F88030 		ldr	r3, [r7, #128]
 15606 06ea 9A42     		cmp	r2, r3
 15607 06ec DED3     		bcc	.L355
3893:keygen.c      **** 	}
3894:keygen.c      **** 	Zf(FFT)(rt3, logn);
 15608              		.loc 2 3894 2
 15609 06ee 7969     		ldr	r1, [r7, #20]
 15610 06f0 386C     		ldr	r0, [r7, #64]
 15611 06f2 FFF7FEFF 		bl	falcon_inner_FFT
3895:keygen.c      **** 	rt2 = align_fpr(tmp, t2);
 15612              		.loc 2 3895 8
 15613 06f6 396D     		ldr	r1, [r7, #80]
 15614 06f8 B868     		ldr	r0, [r7, #8]
 15615 06fa FFF7FEFF 		bl	align_fpr
 15616 06fe F863     		str	r0, [r7, #60]
3896:keygen.c      **** 	memmove(rt2, rt3, hn * sizeof *rt3);
 15617              		.loc 2 3896 2
 15618 0700 FB6F     		ldr	r3, [r7, #124]
 15619 0702 DB00     		lsls	r3, r3, #3
 15620 0704 1A46     		mov	r2, r3
 15621 0706 396C     		ldr	r1, [r7, #64]
 15622 0708 F86B     		ldr	r0, [r7, #60]
 15623 070a FFF7FEFF 		bl	memmove
3897:keygen.c      **** 
3898:keygen.c      **** 	/*
3899:keygen.c      **** 	 * Convert F*adj(f)+G*adj(g) in FFT representation.
3900:keygen.c      **** 	 */
3901:keygen.c      **** 	rt3 = rt2 + hn;
 15624              		.loc 2 3901 12
 15625 070e FB6F     		ldr	r3, [r7, #124]
 15626 0710 DB00     		lsls	r3, r3, #3
 15627              		.loc 2 3901 6
 15628 0712 FA6B     		ldr	r2, [r7, #60]
 15629 0714 1344     		add	r3, r3, r2
 15630 0716 3B64     		str	r3, [r7, #64]
3902:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15631              		.loc 2 3902 9
 15632 0718 0023     		movs	r3, #0
 15633 071a C7F88430 		str	r3, [r7, #132]
 15634              		.loc 2 3902 2
 15635 071e 1AE0     		b	.L356
 15636              	.L357:
3903:keygen.c      **** 		rt3[u] = fpr_of(((int32_t *)t1)[u]);
 15637              		.loc 2 3903 34 discriminator 3
 15638 0720 D7F88430 		ldr	r3, [r7, #132]
 15639 0724 9B00     		lsls	r3, r3, #2
 15640 0726 7A6D     		ldr	r2, [r7, #84]
 15641 0728 1344     		add	r3, r3, r2
 15642 072a 1B68     		ldr	r3, [r3]
 15643              		.loc 2 3903 12 discriminator 3
 15644 072c DA17     		asrs	r2, r3, #31
 15645 072e 1C46     		mov	r4, r3
 15646 0730 1546     		mov	r5, r2
 15647              		.loc 2 3903 6 discriminator 3
 15648 0732 D7F88430 		ldr	r3, [r7, #132]
 15649 0736 DB00     		lsls	r3, r3, #3
 15650 0738 3A6C     		ldr	r2, [r7, #64]
 15651 073a D618     		adds	r6, r2, r3
 15652              		.loc 2 3903 12 discriminator 3
 15653 073c 2046     		mov	r0, r4
 15654 073e 2946     		mov	r1, r5
 15655 0740 FFF7FEFF 		bl	fpr_of
 15656 0744 0246     		mov	r2, r0
 15657 0746 0B46     		mov	r3, r1
 15658              		.loc 2 3903 10 discriminator 3
 15659 0748 C6E90023 		strd	r2, [r6]
3902:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15660              		.loc 2 3902 23 discriminator 3
 15661 074c D7F88430 		ldr	r3, [r7, #132]
 15662 0750 0133     		adds	r3, r3, #1
 15663 0752 C7F88430 		str	r3, [r7, #132]
 15664              	.L356:
3902:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15665              		.loc 2 3902 2 discriminator 1
 15666 0756 D7F88420 		ldr	r2, [r7, #132]
 15667 075a D7F88030 		ldr	r3, [r7, #128]
 15668 075e 9A42     		cmp	r2, r3
 15669 0760 DED3     		bcc	.L357
3904:keygen.c      **** 	}
3905:keygen.c      **** 	Zf(FFT)(rt3, logn);
 15670              		.loc 2 3905 2
 15671 0762 7969     		ldr	r1, [r7, #20]
 15672 0764 386C     		ldr	r0, [r7, #64]
 15673 0766 FFF7FEFF 		bl	falcon_inner_FFT
3906:keygen.c      **** 
3907:keygen.c      **** 	/*
3908:keygen.c      **** 	 * Compute (F*adj(f)+G*adj(g))/(f*adj(f)+g*adj(g)) and get
3909:keygen.c      **** 	 * its rounded normal representation in t1.
3910:keygen.c      **** 	 */
3911:keygen.c      **** 	Zf(poly_div_autoadj_fft)(rt3, rt2, logn);
 15674              		.loc 2 3911 2
 15675 076a 7A69     		ldr	r2, [r7, #20]
 15676 076c F96B     		ldr	r1, [r7, #60]
 15677 076e 386C     		ldr	r0, [r7, #64]
 15678 0770 FFF7FEFF 		bl	falcon_inner_poly_div_autoadj_fft
3912:keygen.c      **** 	Zf(iFFT)(rt3, logn);
 15679              		.loc 2 3912 2
 15680 0774 7969     		ldr	r1, [r7, #20]
 15681 0776 386C     		ldr	r0, [r7, #64]
 15682 0778 FFF7FEFF 		bl	falcon_inner_iFFT
3913:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15683              		.loc 2 3913 9
 15684 077c 0023     		movs	r3, #0
 15685 077e C7F88430 		str	r3, [r7, #132]
 15686              		.loc 2 3913 2
 15687 0782 1CE0     		b	.L358
 15688              	.L359:
3914:keygen.c      **** 		t1[u] = modp_set((int32_t)fpr_rint(rt3[u]), p);
 15689              		.loc 2 3914 41 discriminator 3
 15690 0784 D7F88430 		ldr	r3, [r7, #132]
 15691 0788 DB00     		lsls	r3, r3, #3
 15692 078a 3A6C     		ldr	r2, [r7, #64]
 15693 078c 1344     		add	r3, r3, r2
 15694              		.loc 2 3914 29 discriminator 3
 15695 078e D3E90023 		ldrd	r2, [r3]
 15696 0792 1046     		mov	r0, r2
 15697 0794 1946     		mov	r1, r3
 15698 0796 FFF7FEFF 		bl	fpr_rint
 15699 079a 0246     		mov	r2, r0
 15700 079c 0B46     		mov	r3, r1
 15701              		.loc 2 3914 11 discriminator 3
 15702 079e 1046     		mov	r0, r2
 15703              		.loc 2 3914 5 discriminator 3
 15704 07a0 D7F88430 		ldr	r3, [r7, #132]
 15705 07a4 9B00     		lsls	r3, r3, #2
 15706 07a6 7A6D     		ldr	r2, [r7, #84]
 15707 07a8 D418     		adds	r4, r2, r3
 15708              		.loc 2 3914 11 discriminator 3
 15709 07aa B96F     		ldr	r1, [r7, #120]
 15710 07ac FFF7FEFF 		bl	modp_set
 15711 07b0 0346     		mov	r3, r0
 15712              		.loc 2 3914 9 discriminator 3
 15713 07b2 2360     		str	r3, [r4]
3913:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15714              		.loc 2 3913 23 discriminator 3
 15715 07b4 D7F88430 		ldr	r3, [r7, #132]
 15716 07b8 0133     		adds	r3, r3, #1
 15717 07ba C7F88430 		str	r3, [r7, #132]
 15718              	.L358:
3913:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15719              		.loc 2 3913 2 discriminator 1
 15720 07be D7F88420 		ldr	r2, [r7, #132]
 15721 07c2 D7F88030 		ldr	r3, [r7, #128]
 15722 07c6 9A42     		cmp	r2, r3
 15723 07c8 DCD3     		bcc	.L359
3915:keygen.c      **** 	}
3916:keygen.c      **** 
3917:keygen.c      **** 	/*
3918:keygen.c      **** 	 * RAM contents are now:
3919:keygen.c      **** 	 *
3920:keygen.c      **** 	 *   F (NTT representation) (Fp)
3921:keygen.c      **** 	 *   G (NTT representation) (Gp)
3922:keygen.c      **** 	 *   k (t1)
3923:keygen.c      **** 	 *
3924:keygen.c      **** 	 * We want to compute F-k*f, and G-k*g.
3925:keygen.c      **** 	 */
3926:keygen.c      **** 	t2 = t1 + n;
 15724              		.loc 2 3926 10
 15725 07ca D7F88030 		ldr	r3, [r7, #128]
 15726 07ce 9B00     		lsls	r3, r3, #2
 15727              		.loc 2 3926 5
 15728 07d0 7A6D     		ldr	r2, [r7, #84]
 15729 07d2 1344     		add	r3, r3, r2
 15730 07d4 3B65     		str	r3, [r7, #80]
3927:keygen.c      **** 	t3 = t2 + n;
 15731              		.loc 2 3927 10
 15732 07d6 D7F88030 		ldr	r3, [r7, #128]
 15733 07da 9B00     		lsls	r3, r3, #2
 15734              		.loc 2 3927 5
 15735 07dc 3A6D     		ldr	r2, [r7, #80]
 15736 07de 1344     		add	r3, r3, r2
 15737 07e0 FB64     		str	r3, [r7, #76]
3928:keygen.c      **** 	t4 = t3 + n;
 15738              		.loc 2 3928 10
 15739 07e2 D7F88030 		ldr	r3, [r7, #128]
 15740 07e6 9B00     		lsls	r3, r3, #2
 15741              		.loc 2 3928 5
 15742 07e8 FA6C     		ldr	r2, [r7, #76]
 15743 07ea 1344     		add	r3, r3, r2
 15744 07ec BB64     		str	r3, [r7, #72]
3929:keygen.c      **** 	t5 = t4 + n;
 15745              		.loc 2 3929 10
 15746 07ee D7F88030 		ldr	r3, [r7, #128]
 15747 07f2 9B00     		lsls	r3, r3, #2
 15748              		.loc 2 3929 5
 15749 07f4 BA6C     		ldr	r2, [r7, #72]
 15750 07f6 1344     		add	r3, r3, r2
 15751 07f8 7B64     		str	r3, [r7, #68]
3930:keygen.c      **** 	modp_mkgm2(t2, t3, logn, PRIMES[0].g, p, p0i);
 15752              		.loc 2 3930 2
 15753 07fa 2F4A     		ldr	r2, .L371
 15754 07fc 7B6F     		ldr	r3, [r7, #116]
 15755 07fe 0193     		str	r3, [sp, #4]
 15756 0800 BB6F     		ldr	r3, [r7, #120]
 15757 0802 0093     		str	r3, [sp]
 15758 0804 1346     		mov	r3, r2
 15759 0806 7A69     		ldr	r2, [r7, #20]
 15760 0808 F96C     		ldr	r1, [r7, #76]
 15761 080a 386D     		ldr	r0, [r7, #80]
 15762 080c FFF7FEFF 		bl	modp_mkgm2
3931:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15763              		.loc 2 3931 9
 15764 0810 0023     		movs	r3, #0
 15765 0812 C7F88430 		str	r3, [r7, #132]
 15766              		.loc 2 3931 2
 15767 0816 26E0     		b	.L360
 15768              	.L361:
3932:keygen.c      **** 		t4[u] = modp_set(f[u], p);
 15769              		.loc 2 3932 21 discriminator 3
 15770 0818 3A69     		ldr	r2, [r7, #16]
 15771 081a D7F88430 		ldr	r3, [r7, #132]
 15772 081e 1344     		add	r3, r3, r2
 15773 0820 93F90030 		ldrsb	r3, [r3]
 15774              		.loc 2 3932 11 discriminator 3
 15775 0824 1846     		mov	r0, r3
 15776              		.loc 2 3932 5 discriminator 3
 15777 0826 D7F88430 		ldr	r3, [r7, #132]
 15778 082a 9B00     		lsls	r3, r3, #2
 15779 082c BA6C     		ldr	r2, [r7, #72]
 15780 082e D418     		adds	r4, r2, r3
 15781              		.loc 2 3932 11 discriminator 3
 15782 0830 B96F     		ldr	r1, [r7, #120]
 15783 0832 FFF7FEFF 		bl	modp_set
 15784 0836 0346     		mov	r3, r0
 15785              		.loc 2 3932 9 discriminator 3
 15786 0838 2360     		str	r3, [r4]
3933:keygen.c      **** 		t5[u] = modp_set(g[u], p);
 15787              		.loc 2 3933 21 discriminator 3
 15788 083a FA68     		ldr	r2, [r7, #12]
 15789 083c D7F88430 		ldr	r3, [r7, #132]
 15790 0840 1344     		add	r3, r3, r2
 15791 0842 93F90030 		ldrsb	r3, [r3]
 15792              		.loc 2 3933 11 discriminator 3
 15793 0846 1846     		mov	r0, r3
 15794              		.loc 2 3933 5 discriminator 3
 15795 0848 D7F88430 		ldr	r3, [r7, #132]
 15796 084c 9B00     		lsls	r3, r3, #2
 15797 084e 7A6C     		ldr	r2, [r7, #68]
 15798 0850 D418     		adds	r4, r2, r3
 15799              		.loc 2 3933 11 discriminator 3
 15800 0852 B96F     		ldr	r1, [r7, #120]
 15801 0854 FFF7FEFF 		bl	modp_set
 15802 0858 0346     		mov	r3, r0
 15803              		.loc 2 3933 9 discriminator 3
 15804 085a 2360     		str	r3, [r4]
3931:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15805              		.loc 2 3931 23 discriminator 3
 15806 085c D7F88430 		ldr	r3, [r7, #132]
 15807 0860 0133     		adds	r3, r3, #1
 15808 0862 C7F88430 		str	r3, [r7, #132]
 15809              	.L360:
3931:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15810              		.loc 2 3931 2 discriminator 1
 15811 0866 D7F88420 		ldr	r2, [r7, #132]
 15812 086a D7F88030 		ldr	r3, [r7, #128]
 15813 086e 9A42     		cmp	r2, r3
 15814 0870 D2D3     		bcc	.L361
3934:keygen.c      **** 	}
3935:keygen.c      **** 	modp_NTT2(t1, t2, logn, p, p0i);
 15815              		.loc 2 3935 2
 15816 0872 7B6F     		ldr	r3, [r7, #116]
 15817 0874 0193     		str	r3, [sp, #4]
 15818 0876 BB6F     		ldr	r3, [r7, #120]
 15819 0878 0093     		str	r3, [sp]
 15820 087a 7B69     		ldr	r3, [r7, #20]
 15821 087c 3A6D     		ldr	r2, [r7, #80]
 15822 087e 0121     		movs	r1, #1
 15823 0880 786D     		ldr	r0, [r7, #84]
 15824 0882 FFF7FEFF 		bl	modp_NTT2_ext
3936:keygen.c      **** 	modp_NTT2(t4, t2, logn, p, p0i);
 15825              		.loc 2 3936 2
 15826 0886 7B6F     		ldr	r3, [r7, #116]
 15827 0888 0193     		str	r3, [sp, #4]
 15828 088a BB6F     		ldr	r3, [r7, #120]
 15829 088c 0093     		str	r3, [sp]
 15830 088e 7B69     		ldr	r3, [r7, #20]
 15831 0890 3A6D     		ldr	r2, [r7, #80]
 15832 0892 0121     		movs	r1, #1
 15833 0894 B86C     		ldr	r0, [r7, #72]
 15834 0896 FFF7FEFF 		bl	modp_NTT2_ext
3937:keygen.c      **** 	modp_NTT2(t5, t2, logn, p, p0i);
 15835              		.loc 2 3937 2
 15836 089a 7B6F     		ldr	r3, [r7, #116]
 15837 089c 0193     		str	r3, [sp, #4]
 15838 089e BB6F     		ldr	r3, [r7, #120]
 15839 08a0 0093     		str	r3, [sp]
 15840 08a2 7B69     		ldr	r3, [r7, #20]
 15841 08a4 3A6D     		ldr	r2, [r7, #80]
 15842 08a6 0121     		movs	r1, #1
 15843 08a8 786C     		ldr	r0, [r7, #68]
 15844 08aa FFF7FEFF 		bl	modp_NTT2_ext
3938:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15845              		.loc 2 3938 9
 15846 08ae 0023     		movs	r3, #0
 15847 08b0 C7F88430 		str	r3, [r7, #132]
 15848              		.loc 2 3938 2
 15849 08b4 4DE0     		b	.L362
 15850              	.L372:
 15851 08b6 00BF     		.align	2
 15852              	.L371:
 15853 08b8 45ADD616 		.word	383167813
 15854              	.L363:
 15855              	.LBB57:
3939:keygen.c      **** 		uint32_t kw;
3940:keygen.c      **** 
3941:keygen.c      **** 		kw = modp_montymul(t1[u], R2, p, p0i);
 15856              		.loc 2 3941 24 discriminator 3
 15857 08bc D7F88430 		ldr	r3, [r7, #132]
 15858 08c0 9B00     		lsls	r3, r3, #2
 15859 08c2 7A6D     		ldr	r2, [r7, #84]
 15860 08c4 1344     		add	r3, r3, r2
 15861              		.loc 2 3941 8 discriminator 3
 15862 08c6 1868     		ldr	r0, [r3]
 15863 08c8 7B6F     		ldr	r3, [r7, #116]
 15864 08ca BA6F     		ldr	r2, [r7, #120]
 15865 08cc 396F     		ldr	r1, [r7, #112]
 15866 08ce FFF7FEFF 		bl	modp_montymul
 15867 08d2 B863     		str	r0, [r7, #56]
3942:keygen.c      **** 		Fp[u] = modp_sub(Fp[u],
 15868              		.loc 2 3942 22 discriminator 3
 15869 08d4 D7F88430 		ldr	r3, [r7, #132]
 15870 08d8 9B00     		lsls	r3, r3, #2
 15871 08da FA6E     		ldr	r2, [r7, #108]
 15872 08dc 1344     		add	r3, r3, r2
 15873              		.loc 2 3942 11 discriminator 3
 15874 08de 1D68     		ldr	r5, [r3]
3943:keygen.c      **** 			modp_montymul(kw, t4[u], p, p0i), p);
 15875              		.loc 2 3943 24 discriminator 3
 15876 08e0 D7F88430 		ldr	r3, [r7, #132]
 15877 08e4 9B00     		lsls	r3, r3, #2
 15878 08e6 BA6C     		ldr	r2, [r7, #72]
 15879 08e8 1344     		add	r3, r3, r2
3942:keygen.c      **** 		Fp[u] = modp_sub(Fp[u],
 15880              		.loc 2 3942 11 discriminator 3
 15881 08ea 1968     		ldr	r1, [r3]
 15882 08ec 7B6F     		ldr	r3, [r7, #116]
 15883 08ee BA6F     		ldr	r2, [r7, #120]
 15884 08f0 B86B     		ldr	r0, [r7, #56]
 15885 08f2 FFF7FEFF 		bl	modp_montymul
 15886 08f6 0146     		mov	r1, r0
3942:keygen.c      **** 		Fp[u] = modp_sub(Fp[u],
 15887              		.loc 2 3942 5 discriminator 3
 15888 08f8 D7F88430 		ldr	r3, [r7, #132]
 15889 08fc 9B00     		lsls	r3, r3, #2
 15890 08fe FA6E     		ldr	r2, [r7, #108]
 15891 0900 D418     		adds	r4, r2, r3
3942:keygen.c      **** 		Fp[u] = modp_sub(Fp[u],
 15892              		.loc 2 3942 11 discriminator 3
 15893 0902 BA6F     		ldr	r2, [r7, #120]
 15894 0904 2846     		mov	r0, r5
 15895 0906 FFF7FEFF 		bl	modp_sub
 15896 090a 0346     		mov	r3, r0
3942:keygen.c      **** 		Fp[u] = modp_sub(Fp[u],
 15897              		.loc 2 3942 9 discriminator 3
 15898 090c 2360     		str	r3, [r4]
3944:keygen.c      **** 		Gp[u] = modp_sub(Gp[u],
 15899              		.loc 2 3944 22 discriminator 3
 15900 090e D7F88430 		ldr	r3, [r7, #132]
 15901 0912 9B00     		lsls	r3, r3, #2
 15902 0914 BA6E     		ldr	r2, [r7, #104]
 15903 0916 1344     		add	r3, r3, r2
 15904              		.loc 2 3944 11 discriminator 3
 15905 0918 1D68     		ldr	r5, [r3]
3945:keygen.c      **** 			modp_montymul(kw, t5[u], p, p0i), p);
 15906              		.loc 2 3945 24 discriminator 3
 15907 091a D7F88430 		ldr	r3, [r7, #132]
 15908 091e 9B00     		lsls	r3, r3, #2
 15909 0920 7A6C     		ldr	r2, [r7, #68]
 15910 0922 1344     		add	r3, r3, r2
3944:keygen.c      **** 		Gp[u] = modp_sub(Gp[u],
 15911              		.loc 2 3944 11 discriminator 3
 15912 0924 1968     		ldr	r1, [r3]
 15913 0926 7B6F     		ldr	r3, [r7, #116]
 15914 0928 BA6F     		ldr	r2, [r7, #120]
 15915 092a B86B     		ldr	r0, [r7, #56]
 15916 092c FFF7FEFF 		bl	modp_montymul
 15917 0930 0146     		mov	r1, r0
3944:keygen.c      **** 		Gp[u] = modp_sub(Gp[u],
 15918              		.loc 2 3944 5 discriminator 3
 15919 0932 D7F88430 		ldr	r3, [r7, #132]
 15920 0936 9B00     		lsls	r3, r3, #2
 15921 0938 BA6E     		ldr	r2, [r7, #104]
 15922 093a D418     		adds	r4, r2, r3
3944:keygen.c      **** 		Gp[u] = modp_sub(Gp[u],
 15923              		.loc 2 3944 11 discriminator 3
 15924 093c BA6F     		ldr	r2, [r7, #120]
 15925 093e 2846     		mov	r0, r5
 15926 0940 FFF7FEFF 		bl	modp_sub
 15927 0944 0346     		mov	r3, r0
3944:keygen.c      **** 		Gp[u] = modp_sub(Gp[u],
 15928              		.loc 2 3944 9 discriminator 3
 15929 0946 2360     		str	r3, [r4]
 15930              	.LBE57:
3938:keygen.c      **** 		uint32_t kw;
 15931              		.loc 2 3938 23 discriminator 3
 15932 0948 D7F88430 		ldr	r3, [r7, #132]
 15933 094c 0133     		adds	r3, r3, #1
 15934 094e C7F88430 		str	r3, [r7, #132]
 15935              	.L362:
3938:keygen.c      **** 		uint32_t kw;
 15936              		.loc 2 3938 2 discriminator 1
 15937 0952 D7F88420 		ldr	r2, [r7, #132]
 15938 0956 D7F88030 		ldr	r3, [r7, #128]
 15939 095a 9A42     		cmp	r2, r3
 15940 095c AED3     		bcc	.L363
3946:keygen.c      **** 	}
3947:keygen.c      **** 	modp_iNTT2(Fp, t3, logn, p, p0i);
 15941              		.loc 2 3947 2
 15942 095e 7B6F     		ldr	r3, [r7, #116]
 15943 0960 0193     		str	r3, [sp, #4]
 15944 0962 BB6F     		ldr	r3, [r7, #120]
 15945 0964 0093     		str	r3, [sp]
 15946 0966 7B69     		ldr	r3, [r7, #20]
 15947 0968 FA6C     		ldr	r2, [r7, #76]
 15948 096a 0121     		movs	r1, #1
 15949 096c F86E     		ldr	r0, [r7, #108]
 15950 096e FFF7FEFF 		bl	modp_iNTT2_ext
3948:keygen.c      **** 	modp_iNTT2(Gp, t3, logn, p, p0i);
 15951              		.loc 2 3948 2
 15952 0972 7B6F     		ldr	r3, [r7, #116]
 15953 0974 0193     		str	r3, [sp, #4]
 15954 0976 BB6F     		ldr	r3, [r7, #120]
 15955 0978 0093     		str	r3, [sp]
 15956 097a 7B69     		ldr	r3, [r7, #20]
 15957 097c FA6C     		ldr	r2, [r7, #76]
 15958 097e 0121     		movs	r1, #1
 15959 0980 B86E     		ldr	r0, [r7, #104]
 15960 0982 FFF7FEFF 		bl	modp_iNTT2_ext
3949:keygen.c      **** 	for (u = 0; u < n; u ++) {
 15961              		.loc 2 3949 9
 15962 0986 0023     		movs	r3, #0
 15963 0988 C7F88430 		str	r3, [r7, #132]
 15964              		.loc 2 3949 2
 15965 098c 28E0     		b	.L364
 15966              	.L365:
3950:keygen.c      **** 		Fp[u] = (uint32_t)modp_norm(Fp[u], p);
 15967              		.loc 2 3950 33 discriminator 3
 15968 098e D7F88430 		ldr	r3, [r7, #132]
 15969 0992 9B00     		lsls	r3, r3, #2
 15970 0994 FA6E     		ldr	r2, [r7, #108]
 15971 0996 1344     		add	r3, r3, r2
 15972              		.loc 2 3950 21 discriminator 3
 15973 0998 1B68     		ldr	r3, [r3]
 15974 099a B96F     		ldr	r1, [r7, #120]
 15975 099c 1846     		mov	r0, r3
 15976 099e FFF7FEFF 		bl	modp_norm
 15977 09a2 0146     		mov	r1, r0
 15978              		.loc 2 3950 5 discriminator 3
 15979 09a4 D7F88430 		ldr	r3, [r7, #132]
 15980 09a8 9B00     		lsls	r3, r3, #2
 15981 09aa FA6E     		ldr	r2, [r7, #108]
 15982 09ac 1344     		add	r3, r3, r2
 15983              		.loc 2 3950 11 discriminator 3
 15984 09ae 0A46     		mov	r2, r1
 15985              		.loc 2 3950 9 discriminator 3
 15986 09b0 1A60     		str	r2, [r3]
3951:keygen.c      **** 		Gp[u] = (uint32_t)modp_norm(Gp[u], p);
 15987              		.loc 2 3951 33 discriminator 3
 15988 09b2 D7F88430 		ldr	r3, [r7, #132]
 15989 09b6 9B00     		lsls	r3, r3, #2
 15990 09b8 BA6E     		ldr	r2, [r7, #104]
 15991 09ba 1344     		add	r3, r3, r2
 15992              		.loc 2 3951 21 discriminator 3
 15993 09bc 1B68     		ldr	r3, [r3]
 15994 09be B96F     		ldr	r1, [r7, #120]
 15995 09c0 1846     		mov	r0, r3
 15996 09c2 FFF7FEFF 		bl	modp_norm
 15997 09c6 0146     		mov	r1, r0
 15998              		.loc 2 3951 5 discriminator 3
 15999 09c8 D7F88430 		ldr	r3, [r7, #132]
 16000 09cc 9B00     		lsls	r3, r3, #2
 16001 09ce BA6E     		ldr	r2, [r7, #104]
 16002 09d0 1344     		add	r3, r3, r2
 16003              		.loc 2 3951 11 discriminator 3
 16004 09d2 0A46     		mov	r2, r1
 16005              		.loc 2 3951 9 discriminator 3
 16006 09d4 1A60     		str	r2, [r3]
3949:keygen.c      **** 	for (u = 0; u < n; u ++) {
 16007              		.loc 2 3949 23 discriminator 3
 16008 09d6 D7F88430 		ldr	r3, [r7, #132]
 16009 09da 0133     		adds	r3, r3, #1
 16010 09dc C7F88430 		str	r3, [r7, #132]
 16011              	.L364:
3949:keygen.c      **** 	for (u = 0; u < n; u ++) {
 16012              		.loc 2 3949 2 discriminator 1
 16013 09e0 D7F88420 		ldr	r2, [r7, #132]
 16014 09e4 D7F88030 		ldr	r3, [r7, #128]
 16015 09e8 9A42     		cmp	r2, r3
 16016 09ea D0D3     		bcc	.L365
3952:keygen.c      **** 	}
3953:keygen.c      **** 
3954:keygen.c      **** 	return 1;
 16017              		.loc 2 3954 9
 16018 09ec 0123     		movs	r3, #1
3955:keygen.c      **** }
 16019              		.loc 2 3955 1
 16020 09ee 1846     		mov	r0, r3
 16021 09f0 8C37     		adds	r7, r7, #140
 16022              	.LCFI274:
 16023              		.cfi_def_cfa_offset 28
 16024 09f2 BD46     		mov	sp, r7
 16025              	.LCFI275:
 16026              		.cfi_def_cfa_register 13
 16027              		@ sp needed
 16028 09f4 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 16029              		.cfi_endproc
 16030              	.LFE62:
 16032              		.section	.text.solve_NTRU,"ax",%progbits
 16033              		.align	1
 16034              		.syntax unified
 16035              		.thumb
 16036              		.thumb_func
 16037              		.fpu softvfp
 16039              	solve_NTRU:
 16040              	.LFB63:
3956:keygen.c      **** 
3957:keygen.c      **** /*
3958:keygen.c      ****  * Solve the NTRU equation. Returned value is 1 on success, 0 on error.
3959:keygen.c      ****  * G can be NULL, in which case that value is computed but not returned.
3960:keygen.c      ****  * If any of the coefficients of F and G exceeds lim (in absolute value),
3961:keygen.c      ****  * then 0 is returned.
3962:keygen.c      ****  */
3963:keygen.c      **** static int
3964:keygen.c      **** solve_NTRU(unsigned logn, int8_t *F, int8_t *G,
3965:keygen.c      **** 	const int8_t *f, const int8_t *g, int lim, uint32_t *tmp)
3966:keygen.c      **** {
 16041              		.loc 2 3966 1
 16042              		.cfi_startproc
 16043              		@ args = 12, pretend = 0, frame = 72
 16044              		@ frame_needed = 1, uses_anonymous_args = 0
 16045 0000 90B5     		push	{r4, r7, lr}
 16046              	.LCFI276:
 16047              		.cfi_def_cfa_offset 12
 16048              		.cfi_offset 4, -12
 16049              		.cfi_offset 7, -8
 16050              		.cfi_offset 14, -4
 16051 0002 95B0     		sub	sp, sp, #84
 16052              	.LCFI277:
 16053              		.cfi_def_cfa_offset 96
 16054 0004 02AF     		add	r7, sp, #8
 16055              	.LCFI278:
 16056              		.cfi_def_cfa 7, 88
 16057 0006 F860     		str	r0, [r7, #12]
 16058 0008 B960     		str	r1, [r7, #8]
 16059 000a 7A60     		str	r2, [r7, #4]
 16060 000c 3B60     		str	r3, [r7]
3967:keygen.c      **** 	size_t n, u;
3968:keygen.c      **** 	uint32_t *ft, *gt, *Ft, *Gt, *gm;
3969:keygen.c      **** 	uint32_t p, p0i, r;
3970:keygen.c      **** 	const small_prime *primes;
3971:keygen.c      **** 
3972:keygen.c      **** 	n = MKN(logn);
 16061              		.loc 2 3972 4
 16062 000e 0122     		movs	r2, #1
 16063 0010 FB68     		ldr	r3, [r7, #12]
 16064 0012 02FA03F3 		lsl	r3, r2, r3
 16065 0016 BB63     		str	r3, [r7, #56]
3973:keygen.c      **** 
3974:keygen.c      **** 	if (!solve_NTRU_deepest(logn, f, g, tmp)) {
 16066              		.loc 2 3974 7
 16067 0018 3B6E     		ldr	r3, [r7, #96]
 16068 001a BA6D     		ldr	r2, [r7, #88]
 16069 001c 3968     		ldr	r1, [r7]
 16070 001e F868     		ldr	r0, [r7, #12]
 16071 0020 FFF7FEFF 		bl	solve_NTRU_deepest
 16072 0024 0346     		mov	r3, r0
 16073              		.loc 2 3974 5
 16074 0026 002B     		cmp	r3, #0
 16075 0028 01D1     		bne	.L374
3975:keygen.c      **** 		return 0;
 16076              		.loc 2 3975 10
 16077 002a 0023     		movs	r3, #0
 16078 002c 42E1     		b	.L375
 16079              	.L374:
3976:keygen.c      **** 	}
3977:keygen.c      **** 
3978:keygen.c      **** 	/*
3979:keygen.c      **** 	 * For logn <= 2, we need to use solve_NTRU_intermediate()
3980:keygen.c      **** 	 * directly, because coefficients are a bit too large and
3981:keygen.c      **** 	 * do not fit the hypotheses in solve_NTRU_binary_depth0().
3982:keygen.c      **** 	 */
3983:keygen.c      **** 	if (logn <= 2) {
 16080              		.loc 2 3983 5
 16081 002e FB68     		ldr	r3, [r7, #12]
 16082 0030 022B     		cmp	r3, #2
 16083 0032 15D8     		bhi	.L376
 16084              	.LBB58:
3984:keygen.c      **** 		unsigned depth;
3985:keygen.c      **** 
3986:keygen.c      **** 		depth = logn;
 16085              		.loc 2 3986 9
 16086 0034 FB68     		ldr	r3, [r7, #12]
 16087 0036 3B64     		str	r3, [r7, #64]
3987:keygen.c      **** 		while (depth -- > 0) {
 16088              		.loc 2 3987 9
 16089 0038 0CE0     		b	.L377
 16090              	.L378:
3988:keygen.c      **** 			if (!solve_NTRU_intermediate(logn, f, g, depth, tmp)) {
 16091              		.loc 2 3988 9
 16092 003a 3B6E     		ldr	r3, [r7, #96]
 16093 003c 0093     		str	r3, [sp]
 16094 003e 3B6C     		ldr	r3, [r7, #64]
 16095 0040 BA6D     		ldr	r2, [r7, #88]
 16096 0042 3968     		ldr	r1, [r7]
 16097 0044 F868     		ldr	r0, [r7, #12]
 16098 0046 FFF7FEFF 		bl	solve_NTRU_intermediate
 16099 004a 0346     		mov	r3, r0
 16100              		.loc 2 3988 7
 16101 004c 002B     		cmp	r3, #0
 16102 004e 01D1     		bne	.L377
3989:keygen.c      **** 				return 0;
 16103              		.loc 2 3989 12
 16104 0050 0023     		movs	r3, #0
 16105 0052 2FE1     		b	.L375
 16106              	.L377:
3987:keygen.c      **** 		while (depth -- > 0) {
 16107              		.loc 2 3987 16
 16108 0054 3B6C     		ldr	r3, [r7, #64]
 16109 0056 5A1E     		subs	r2, r3, #1
 16110 0058 3A64     		str	r2, [r7, #64]
3987:keygen.c      **** 		while (depth -- > 0) {
 16111              		.loc 2 3987 9
 16112 005a 002B     		cmp	r3, #0
 16113 005c EDD1     		bne	.L378
 16114 005e 2AE0     		b	.L379
 16115              	.L376:
 16116              	.LBE58:
 16117              	.LBB59:
3990:keygen.c      **** 			}
3991:keygen.c      **** 		}
3992:keygen.c      **** 	} else {
3993:keygen.c      **** 		unsigned depth;
3994:keygen.c      **** 
3995:keygen.c      **** 		depth = logn;
 16118              		.loc 2 3995 9
 16119 0060 FB68     		ldr	r3, [r7, #12]
 16120 0062 FB63     		str	r3, [r7, #60]
3996:keygen.c      **** 		while (depth -- > 2) {
 16121              		.loc 2 3996 9
 16122 0064 0CE0     		b	.L380
 16123              	.L381:
3997:keygen.c      **** 			if (!solve_NTRU_intermediate(logn, f, g, depth, tmp)) {
 16124              		.loc 2 3997 9
 16125 0066 3B6E     		ldr	r3, [r7, #96]
 16126 0068 0093     		str	r3, [sp]
 16127 006a FB6B     		ldr	r3, [r7, #60]
 16128 006c BA6D     		ldr	r2, [r7, #88]
 16129 006e 3968     		ldr	r1, [r7]
 16130 0070 F868     		ldr	r0, [r7, #12]
 16131 0072 FFF7FEFF 		bl	solve_NTRU_intermediate
 16132 0076 0346     		mov	r3, r0
 16133              		.loc 2 3997 7
 16134 0078 002B     		cmp	r3, #0
 16135 007a 01D1     		bne	.L380
3998:keygen.c      **** 				return 0;
 16136              		.loc 2 3998 12
 16137 007c 0023     		movs	r3, #0
 16138 007e 19E1     		b	.L375
 16139              	.L380:
3996:keygen.c      **** 		while (depth -- > 2) {
 16140              		.loc 2 3996 16
 16141 0080 FB6B     		ldr	r3, [r7, #60]
 16142 0082 5A1E     		subs	r2, r3, #1
 16143 0084 FA63     		str	r2, [r7, #60]
3996:keygen.c      **** 		while (depth -- > 2) {
 16144              		.loc 2 3996 9
 16145 0086 022B     		cmp	r3, #2
 16146 0088 EDD8     		bhi	.L381
3999:keygen.c      **** 			}
4000:keygen.c      **** 		}
4001:keygen.c      **** 		if (!solve_NTRU_binary_depth1(logn, f, g, tmp)) {
 16147              		.loc 2 4001 8
 16148 008a 3B6E     		ldr	r3, [r7, #96]
 16149 008c BA6D     		ldr	r2, [r7, #88]
 16150 008e 3968     		ldr	r1, [r7]
 16151 0090 F868     		ldr	r0, [r7, #12]
 16152 0092 FFF7FEFF 		bl	solve_NTRU_binary_depth1
 16153 0096 0346     		mov	r3, r0
 16154              		.loc 2 4001 6
 16155 0098 002B     		cmp	r3, #0
 16156 009a 01D1     		bne	.L382
4002:keygen.c      **** 			return 0;
 16157              		.loc 2 4002 11
 16158 009c 0023     		movs	r3, #0
 16159 009e 09E1     		b	.L375
 16160              	.L382:
4003:keygen.c      **** 		}
4004:keygen.c      **** 		if (!solve_NTRU_binary_depth0(logn, f, g, tmp)) {
 16161              		.loc 2 4004 8
 16162 00a0 3B6E     		ldr	r3, [r7, #96]
 16163 00a2 BA6D     		ldr	r2, [r7, #88]
 16164 00a4 3968     		ldr	r1, [r7]
 16165 00a6 F868     		ldr	r0, [r7, #12]
 16166 00a8 FFF7FEFF 		bl	solve_NTRU_binary_depth0
 16167 00ac 0346     		mov	r3, r0
 16168              		.loc 2 4004 6
 16169 00ae 002B     		cmp	r3, #0
 16170 00b0 01D1     		bne	.L379
4005:keygen.c      **** 			return 0;
 16171              		.loc 2 4005 11
 16172 00b2 0023     		movs	r3, #0
 16173 00b4 FEE0     		b	.L375
 16174              	.L379:
 16175              	.LBE59:
4006:keygen.c      **** 		}
4007:keygen.c      **** 	}
4008:keygen.c      **** 
4009:keygen.c      **** 	/*
4010:keygen.c      **** 	 * If no buffer has been provided for G, use a temporary one.
4011:keygen.c      **** 	 */
4012:keygen.c      **** 	if (G == NULL) {
 16176              		.loc 2 4012 5
 16177 00b6 7B68     		ldr	r3, [r7, #4]
 16178 00b8 002B     		cmp	r3, #0
 16179 00ba 04D1     		bne	.L383
4013:keygen.c      **** 		G = (int8_t *)(tmp + 2 * n);
 16180              		.loc 2 4013 22
 16181 00bc BB6B     		ldr	r3, [r7, #56]
 16182 00be DB00     		lsls	r3, r3, #3
 16183              		.loc 2 4013 5
 16184 00c0 3A6E     		ldr	r2, [r7, #96]
 16185 00c2 1344     		add	r3, r3, r2
 16186 00c4 7B60     		str	r3, [r7, #4]
 16187              	.L383:
4014:keygen.c      **** 	}
4015:keygen.c      **** 
4016:keygen.c      **** 	/*
4017:keygen.c      **** 	 * Final F and G are in fk->tmp, one word per coefficient
4018:keygen.c      **** 	 * (signed value over 31 bits).
4019:keygen.c      **** 	 */
4020:keygen.c      **** 	if (!poly_big_to_small(F, tmp, lim, logn)
 16188              		.loc 2 4020 7
 16189 00c6 FB68     		ldr	r3, [r7, #12]
 16190 00c8 FA6D     		ldr	r2, [r7, #92]
 16191 00ca 396E     		ldr	r1, [r7, #96]
 16192 00cc B868     		ldr	r0, [r7, #8]
 16193 00ce FFF7FEFF 		bl	poly_big_to_small
 16194 00d2 0346     		mov	r3, r0
 16195              		.loc 2 4020 5
 16196 00d4 002B     		cmp	r3, #0
 16197 00d6 0BD0     		beq	.L384
4021:keygen.c      **** 		|| !poly_big_to_small(G, tmp + n, lim, logn))
 16198              		.loc 2 4021 32
 16199 00d8 BB6B     		ldr	r3, [r7, #56]
 16200 00da 9B00     		lsls	r3, r3, #2
 16201 00dc 3A6E     		ldr	r2, [r7, #96]
 16202 00de D118     		adds	r1, r2, r3
 16203              		.loc 2 4021 7
 16204 00e0 FB68     		ldr	r3, [r7, #12]
 16205 00e2 FA6D     		ldr	r2, [r7, #92]
 16206 00e4 7868     		ldr	r0, [r7, #4]
 16207 00e6 FFF7FEFF 		bl	poly_big_to_small
 16208 00ea 0346     		mov	r3, r0
 16209              		.loc 2 4021 3
 16210 00ec 002B     		cmp	r3, #0
 16211 00ee 01D1     		bne	.L385
 16212              	.L384:
4022:keygen.c      **** 	{
4023:keygen.c      **** 		return 0;
 16213              		.loc 2 4023 10
 16214 00f0 0023     		movs	r3, #0
 16215 00f2 DFE0     		b	.L375
 16216              	.L385:
4024:keygen.c      **** 	}
4025:keygen.c      **** 
4026:keygen.c      **** 	/*
4027:keygen.c      **** 	 * Verify that the NTRU equation is fulfilled. Since all elements
4028:keygen.c      **** 	 * have short lengths, verifying modulo a small prime p works, and
4029:keygen.c      **** 	 * allows using the NTT.
4030:keygen.c      **** 	 *
4031:keygen.c      **** 	 * We put Gt[] first in tmp[], and process it first, so that it does
4032:keygen.c      **** 	 * not overlap with G[] in case we allocated it ourselves.
4033:keygen.c      **** 	 */
4034:keygen.c      **** 	Gt = tmp;
 16217              		.loc 2 4034 5
 16218 00f4 3B6E     		ldr	r3, [r7, #96]
 16219 00f6 7B63     		str	r3, [r7, #52]
4035:keygen.c      **** 	ft = Gt + n;
 16220              		.loc 2 4035 10
 16221 00f8 BB6B     		ldr	r3, [r7, #56]
 16222 00fa 9B00     		lsls	r3, r3, #2
 16223              		.loc 2 4035 5
 16224 00fc 7A6B     		ldr	r2, [r7, #52]
 16225 00fe 1344     		add	r3, r3, r2
 16226 0100 3B63     		str	r3, [r7, #48]
4036:keygen.c      **** 	gt = ft + n;
 16227              		.loc 2 4036 10
 16228 0102 BB6B     		ldr	r3, [r7, #56]
 16229 0104 9B00     		lsls	r3, r3, #2
 16230              		.loc 2 4036 5
 16231 0106 3A6B     		ldr	r2, [r7, #48]
 16232 0108 1344     		add	r3, r3, r2
 16233 010a FB62     		str	r3, [r7, #44]
4037:keygen.c      **** 	Ft = gt + n;
 16234              		.loc 2 4037 10
 16235 010c BB6B     		ldr	r3, [r7, #56]
 16236 010e 9B00     		lsls	r3, r3, #2
 16237              		.loc 2 4037 5
 16238 0110 FA6A     		ldr	r2, [r7, #44]
 16239 0112 1344     		add	r3, r3, r2
 16240 0114 BB62     		str	r3, [r7, #40]
4038:keygen.c      **** 	gm = Ft + n;
 16241              		.loc 2 4038 10
 16242 0116 BB6B     		ldr	r3, [r7, #56]
 16243 0118 9B00     		lsls	r3, r3, #2
 16244              		.loc 2 4038 5
 16245 011a BA6A     		ldr	r2, [r7, #40]
 16246 011c 1344     		add	r3, r3, r2
 16247 011e 7B62     		str	r3, [r7, #36]
4039:keygen.c      **** 
4040:keygen.c      **** 	primes = PRIMES;
 16248              		.loc 2 4040 9
 16249 0120 664B     		ldr	r3, .L393
 16250 0122 3B62     		str	r3, [r7, #32]
4041:keygen.c      **** 	p = primes[0].p;
 16251              		.loc 2 4041 4
 16252 0124 3B6A     		ldr	r3, [r7, #32]
 16253 0126 1B68     		ldr	r3, [r3]
 16254 0128 FB61     		str	r3, [r7, #28]
4042:keygen.c      **** 	p0i = modp_ninv31(p);
 16255              		.loc 2 4042 8
 16256 012a F869     		ldr	r0, [r7, #28]
 16257 012c FFF7FEFF 		bl	modp_ninv31
 16258 0130 B861     		str	r0, [r7, #24]
4043:keygen.c      **** 	modp_mkgm2(gm, tmp, logn, primes[0].g, p, p0i);
 16259              		.loc 2 4043 2
 16260 0132 3B6A     		ldr	r3, [r7, #32]
 16261 0134 5A68     		ldr	r2, [r3, #4]
 16262 0136 BB69     		ldr	r3, [r7, #24]
 16263 0138 0193     		str	r3, [sp, #4]
 16264 013a FB69     		ldr	r3, [r7, #28]
 16265 013c 0093     		str	r3, [sp]
 16266 013e 1346     		mov	r3, r2
 16267 0140 FA68     		ldr	r2, [r7, #12]
 16268 0142 396E     		ldr	r1, [r7, #96]
 16269 0144 786A     		ldr	r0, [r7, #36]
 16270 0146 FFF7FEFF 		bl	modp_mkgm2
4044:keygen.c      **** 	for (u = 0; u < n; u ++) {
 16271              		.loc 2 4044 9
 16272 014a 0023     		movs	r3, #0
 16273 014c 7B64     		str	r3, [r7, #68]
 16274              		.loc 2 4044 2
 16275 014e 11E0     		b	.L386
 16276              	.L387:
4045:keygen.c      **** 		Gt[u] = modp_set(G[u], p);
 16277              		.loc 2 4045 21 discriminator 3
 16278 0150 7A68     		ldr	r2, [r7, #4]
 16279 0152 7B6C     		ldr	r3, [r7, #68]
 16280 0154 1344     		add	r3, r3, r2
 16281 0156 93F90030 		ldrsb	r3, [r3]
 16282              		.loc 2 4045 11 discriminator 3
 16283 015a 1846     		mov	r0, r3
 16284              		.loc 2 4045 5 discriminator 3
 16285 015c 7B6C     		ldr	r3, [r7, #68]
 16286 015e 9B00     		lsls	r3, r3, #2
 16287 0160 7A6B     		ldr	r2, [r7, #52]
 16288 0162 D418     		adds	r4, r2, r3
 16289              		.loc 2 4045 11 discriminator 3
 16290 0164 F969     		ldr	r1, [r7, #28]
 16291 0166 FFF7FEFF 		bl	modp_set
 16292 016a 0346     		mov	r3, r0
 16293              		.loc 2 4045 9 discriminator 3
 16294 016c 2360     		str	r3, [r4]
4044:keygen.c      **** 	for (u = 0; u < n; u ++) {
 16295              		.loc 2 4044 23 discriminator 3
 16296 016e 7B6C     		ldr	r3, [r7, #68]
 16297 0170 0133     		adds	r3, r3, #1
 16298 0172 7B64     		str	r3, [r7, #68]
 16299              	.L386:
4044:keygen.c      **** 	for (u = 0; u < n; u ++) {
 16300              		.loc 2 4044 2 discriminator 1
 16301 0174 7A6C     		ldr	r2, [r7, #68]
 16302 0176 BB6B     		ldr	r3, [r7, #56]
 16303 0178 9A42     		cmp	r2, r3
 16304 017a E9D3     		bcc	.L387
4046:keygen.c      **** 	}
4047:keygen.c      **** 	for (u = 0; u < n; u ++) {
 16305              		.loc 2 4047 9
 16306 017c 0023     		movs	r3, #0
 16307 017e 7B64     		str	r3, [r7, #68]
 16308              		.loc 2 4047 2
 16309 0180 2FE0     		b	.L388
 16310              	.L389:
4048:keygen.c      **** 		ft[u] = modp_set(f[u], p);
 16311              		.loc 2 4048 21 discriminator 3
 16312 0182 3A68     		ldr	r2, [r7]
 16313 0184 7B6C     		ldr	r3, [r7, #68]
 16314 0186 1344     		add	r3, r3, r2
 16315 0188 93F90030 		ldrsb	r3, [r3]
 16316              		.loc 2 4048 11 discriminator 3
 16317 018c 1846     		mov	r0, r3
 16318              		.loc 2 4048 5 discriminator 3
 16319 018e 7B6C     		ldr	r3, [r7, #68]
 16320 0190 9B00     		lsls	r3, r3, #2
 16321 0192 3A6B     		ldr	r2, [r7, #48]
 16322 0194 D418     		adds	r4, r2, r3
 16323              		.loc 2 4048 11 discriminator 3
 16324 0196 F969     		ldr	r1, [r7, #28]
 16325 0198 FFF7FEFF 		bl	modp_set
 16326 019c 0346     		mov	r3, r0
 16327              		.loc 2 4048 9 discriminator 3
 16328 019e 2360     		str	r3, [r4]
4049:keygen.c      **** 		gt[u] = modp_set(g[u], p);
 16329              		.loc 2 4049 21 discriminator 3
 16330 01a0 BA6D     		ldr	r2, [r7, #88]
 16331 01a2 7B6C     		ldr	r3, [r7, #68]
 16332 01a4 1344     		add	r3, r3, r2
 16333 01a6 93F90030 		ldrsb	r3, [r3]
 16334              		.loc 2 4049 11 discriminator 3
 16335 01aa 1846     		mov	r0, r3
 16336              		.loc 2 4049 5 discriminator 3
 16337 01ac 7B6C     		ldr	r3, [r7, #68]
 16338 01ae 9B00     		lsls	r3, r3, #2
 16339 01b0 FA6A     		ldr	r2, [r7, #44]
 16340 01b2 D418     		adds	r4, r2, r3
 16341              		.loc 2 4049 11 discriminator 3
 16342 01b4 F969     		ldr	r1, [r7, #28]
 16343 01b6 FFF7FEFF 		bl	modp_set
 16344 01ba 0346     		mov	r3, r0
 16345              		.loc 2 4049 9 discriminator 3
 16346 01bc 2360     		str	r3, [r4]
4050:keygen.c      **** 		Ft[u] = modp_set(F[u], p);
 16347              		.loc 2 4050 21 discriminator 3
 16348 01be BA68     		ldr	r2, [r7, #8]
 16349 01c0 7B6C     		ldr	r3, [r7, #68]
 16350 01c2 1344     		add	r3, r3, r2
 16351 01c4 93F90030 		ldrsb	r3, [r3]
 16352              		.loc 2 4050 11 discriminator 3
 16353 01c8 1846     		mov	r0, r3
 16354              		.loc 2 4050 5 discriminator 3
 16355 01ca 7B6C     		ldr	r3, [r7, #68]
 16356 01cc 9B00     		lsls	r3, r3, #2
 16357 01ce BA6A     		ldr	r2, [r7, #40]
 16358 01d0 D418     		adds	r4, r2, r3
 16359              		.loc 2 4050 11 discriminator 3
 16360 01d2 F969     		ldr	r1, [r7, #28]
 16361 01d4 FFF7FEFF 		bl	modp_set
 16362 01d8 0346     		mov	r3, r0
 16363              		.loc 2 4050 9 discriminator 3
 16364 01da 2360     		str	r3, [r4]
4047:keygen.c      **** 		ft[u] = modp_set(f[u], p);
 16365              		.loc 2 4047 23 discriminator 3
 16366 01dc 7B6C     		ldr	r3, [r7, #68]
 16367 01de 0133     		adds	r3, r3, #1
 16368 01e0 7B64     		str	r3, [r7, #68]
 16369              	.L388:
4047:keygen.c      **** 		ft[u] = modp_set(f[u], p);
 16370              		.loc 2 4047 2 discriminator 1
 16371 01e2 7A6C     		ldr	r2, [r7, #68]
 16372 01e4 BB6B     		ldr	r3, [r7, #56]
 16373 01e6 9A42     		cmp	r2, r3
 16374 01e8 CBD3     		bcc	.L389
4051:keygen.c      **** 	}
4052:keygen.c      **** 	modp_NTT2(ft, gm, logn, p, p0i);
 16375              		.loc 2 4052 2
 16376 01ea BB69     		ldr	r3, [r7, #24]
 16377 01ec 0193     		str	r3, [sp, #4]
 16378 01ee FB69     		ldr	r3, [r7, #28]
 16379 01f0 0093     		str	r3, [sp]
 16380 01f2 FB68     		ldr	r3, [r7, #12]
 16381 01f4 7A6A     		ldr	r2, [r7, #36]
 16382 01f6 0121     		movs	r1, #1
 16383 01f8 386B     		ldr	r0, [r7, #48]
 16384 01fa FFF7FEFF 		bl	modp_NTT2_ext
4053:keygen.c      **** 	modp_NTT2(gt, gm, logn, p, p0i);
 16385              		.loc 2 4053 2
 16386 01fe BB69     		ldr	r3, [r7, #24]
 16387 0200 0193     		str	r3, [sp, #4]
 16388 0202 FB69     		ldr	r3, [r7, #28]
 16389 0204 0093     		str	r3, [sp]
 16390 0206 FB68     		ldr	r3, [r7, #12]
 16391 0208 7A6A     		ldr	r2, [r7, #36]
 16392 020a 0121     		movs	r1, #1
 16393 020c F86A     		ldr	r0, [r7, #44]
 16394 020e FFF7FEFF 		bl	modp_NTT2_ext
4054:keygen.c      **** 	modp_NTT2(Ft, gm, logn, p, p0i);
 16395              		.loc 2 4054 2
 16396 0212 BB69     		ldr	r3, [r7, #24]
 16397 0214 0193     		str	r3, [sp, #4]
 16398 0216 FB69     		ldr	r3, [r7, #28]
 16399 0218 0093     		str	r3, [sp]
 16400 021a FB68     		ldr	r3, [r7, #12]
 16401 021c 7A6A     		ldr	r2, [r7, #36]
 16402 021e 0121     		movs	r1, #1
 16403 0220 B86A     		ldr	r0, [r7, #40]
 16404 0222 FFF7FEFF 		bl	modp_NTT2_ext
4055:keygen.c      **** 	modp_NTT2(Gt, gm, logn, p, p0i);
 16405              		.loc 2 4055 2
 16406 0226 BB69     		ldr	r3, [r7, #24]
 16407 0228 0193     		str	r3, [sp, #4]
 16408 022a FB69     		ldr	r3, [r7, #28]
 16409 022c 0093     		str	r3, [sp]
 16410 022e FB68     		ldr	r3, [r7, #12]
 16411 0230 7A6A     		ldr	r2, [r7, #36]
 16412 0232 0121     		movs	r1, #1
 16413 0234 786B     		ldr	r0, [r7, #52]
 16414 0236 FFF7FEFF 		bl	modp_NTT2_ext
4056:keygen.c      **** 	r = modp_montymul(12289, 1, p, p0i);
 16415              		.loc 2 4056 6
 16416 023a BB69     		ldr	r3, [r7, #24]
 16417 023c FA69     		ldr	r2, [r7, #28]
 16418 023e 0121     		movs	r1, #1
 16419 0240 43F20100 		movw	r0, #12289
 16420 0244 FFF7FEFF 		bl	modp_montymul
 16421 0248 7861     		str	r0, [r7, #20]
4057:keygen.c      **** 	for (u = 0; u < n; u ++) {
 16422              		.loc 2 4057 9
 16423 024a 0023     		movs	r3, #0
 16424 024c 7B64     		str	r3, [r7, #68]
 16425              		.loc 2 4057 2
 16426 024e 2CE0     		b	.L390
 16427              	.L392:
 16428              	.LBB60:
4058:keygen.c      **** 		uint32_t z;
4059:keygen.c      **** 
4060:keygen.c      **** 		z = modp_sub(modp_montymul(ft[u], Gt[u], p, p0i),
 16429              		.loc 2 4060 32
 16430 0250 7B6C     		ldr	r3, [r7, #68]
 16431 0252 9B00     		lsls	r3, r3, #2
 16432 0254 3A6B     		ldr	r2, [r7, #48]
 16433 0256 1344     		add	r3, r3, r2
 16434              		.loc 2 4060 7
 16435 0258 1868     		ldr	r0, [r3]
 16436              		.loc 2 4060 39
 16437 025a 7B6C     		ldr	r3, [r7, #68]
 16438 025c 9B00     		lsls	r3, r3, #2
 16439 025e 7A6B     		ldr	r2, [r7, #52]
 16440 0260 1344     		add	r3, r3, r2
 16441              		.loc 2 4060 7
 16442 0262 1968     		ldr	r1, [r3]
 16443 0264 BB69     		ldr	r3, [r7, #24]
 16444 0266 FA69     		ldr	r2, [r7, #28]
 16445 0268 FFF7FEFF 		bl	modp_montymul
 16446 026c 0446     		mov	r4, r0
4061:keygen.c      **** 			modp_montymul(gt[u], Ft[u], p, p0i), p);
 16447              		.loc 2 4061 20
 16448 026e 7B6C     		ldr	r3, [r7, #68]
 16449 0270 9B00     		lsls	r3, r3, #2
 16450 0272 FA6A     		ldr	r2, [r7, #44]
 16451 0274 1344     		add	r3, r3, r2
4060:keygen.c      **** 			modp_montymul(gt[u], Ft[u], p, p0i), p);
 16452              		.loc 2 4060 7
 16453 0276 1868     		ldr	r0, [r3]
 16454              		.loc 2 4061 27
 16455 0278 7B6C     		ldr	r3, [r7, #68]
 16456 027a 9B00     		lsls	r3, r3, #2
 16457 027c BA6A     		ldr	r2, [r7, #40]
 16458 027e 1344     		add	r3, r3, r2
4060:keygen.c      **** 			modp_montymul(gt[u], Ft[u], p, p0i), p);
 16459              		.loc 2 4060 7
 16460 0280 1968     		ldr	r1, [r3]
 16461 0282 BB69     		ldr	r3, [r7, #24]
 16462 0284 FA69     		ldr	r2, [r7, #28]
 16463 0286 FFF7FEFF 		bl	modp_montymul
 16464 028a 0346     		mov	r3, r0
 16465 028c FA69     		ldr	r2, [r7, #28]
 16466 028e 1946     		mov	r1, r3
 16467 0290 2046     		mov	r0, r4
 16468 0292 FFF7FEFF 		bl	modp_sub
 16469 0296 3861     		str	r0, [r7, #16]
4062:keygen.c      **** 		if (z != r) {
 16470              		.loc 2 4062 6
 16471 0298 3A69     		ldr	r2, [r7, #16]
 16472 029a 7B69     		ldr	r3, [r7, #20]
 16473 029c 9A42     		cmp	r2, r3
 16474 029e 01D0     		beq	.L391
4063:keygen.c      **** 			return 0;
 16475              		.loc 2 4063 11
 16476 02a0 0023     		movs	r3, #0
 16477 02a2 07E0     		b	.L375
 16478              	.L391:
 16479              	.LBE60:
4057:keygen.c      **** 		uint32_t z;
 16480              		.loc 2 4057 23 discriminator 2
 16481 02a4 7B6C     		ldr	r3, [r7, #68]
 16482 02a6 0133     		adds	r3, r3, #1
 16483 02a8 7B64     		str	r3, [r7, #68]
 16484              	.L390:
4057:keygen.c      **** 		uint32_t z;
 16485              		.loc 2 4057 2 discriminator 1
 16486 02aa 7A6C     		ldr	r2, [r7, #68]
 16487 02ac BB6B     		ldr	r3, [r7, #56]
 16488 02ae 9A42     		cmp	r2, r3
 16489 02b0 CED3     		bcc	.L392
4064:keygen.c      **** 		}
4065:keygen.c      **** 	}
4066:keygen.c      **** 
4067:keygen.c      **** 	return 1;
 16490              		.loc 2 4067 9
 16491 02b2 0123     		movs	r3, #1
 16492              	.L375:
4068:keygen.c      **** }
 16493              		.loc 2 4068 1
 16494 02b4 1846     		mov	r0, r3
 16495 02b6 4C37     		adds	r7, r7, #76
 16496              	.LCFI279:
 16497              		.cfi_def_cfa_offset 12
 16498 02b8 BD46     		mov	sp, r7
 16499              	.LCFI280:
 16500              		.cfi_def_cfa_register 13
 16501              		@ sp needed
 16502 02ba 90BD     		pop	{r4, r7, pc}
 16503              	.L394:
 16504              		.align	2
 16505              	.L393:
 16506 02bc 40010000 		.word	PRIMES
 16507              		.cfi_endproc
 16508              	.LFE63:
 16510              		.section	.text.poly_small_mkgauss,"ax",%progbits
 16511              		.align	1
 16512              		.syntax unified
 16513              		.thumb
 16514              		.thumb_func
 16515              		.fpu softvfp
 16517              	poly_small_mkgauss:
 16518              	.LFB64:
4069:keygen.c      **** 
4070:keygen.c      **** /*
4071:keygen.c      ****  * Generate a random polynomial with a Gaussian distribution. This function
4072:keygen.c      ****  * also makes sure that the resultant of the polynomial with phi is odd.
4073:keygen.c      ****  */
4074:keygen.c      **** static void
4075:keygen.c      **** poly_small_mkgauss(RNG_CONTEXT *rng, int8_t *f, unsigned logn)
4076:keygen.c      **** {
 16519              		.loc 2 4076 1
 16520              		.cfi_startproc
 16521              		@ args = 0, pretend = 0, frame = 32
 16522              		@ frame_needed = 1, uses_anonymous_args = 0
 16523 0000 80B5     		push	{r7, lr}
 16524              	.LCFI281:
 16525              		.cfi_def_cfa_offset 8
 16526              		.cfi_offset 7, -8
 16527              		.cfi_offset 14, -4
 16528 0002 88B0     		sub	sp, sp, #32
 16529              	.LCFI282:
 16530              		.cfi_def_cfa_offset 40
 16531 0004 00AF     		add	r7, sp, #0
 16532              	.LCFI283:
 16533              		.cfi_def_cfa_register 7
 16534 0006 F860     		str	r0, [r7, #12]
 16535 0008 B960     		str	r1, [r7, #8]
 16536 000a 7A60     		str	r2, [r7, #4]
4077:keygen.c      **** 	size_t n, u;
4078:keygen.c      **** 	unsigned mod2;
4079:keygen.c      **** 
4080:keygen.c      **** 	n = MKN(logn);
 16537              		.loc 2 4080 4
 16538 000c 0122     		movs	r2, #1
 16539 000e 7B68     		ldr	r3, [r7, #4]
 16540 0010 02FA03F3 		lsl	r3, r2, r3
 16541 0014 7B61     		str	r3, [r7, #20]
4081:keygen.c      **** 	mod2 = 0;
 16542              		.loc 2 4081 7
 16543 0016 0023     		movs	r3, #0
 16544 0018 BB61     		str	r3, [r7, #24]
4082:keygen.c      **** 	for (u = 0; u < n; u ++) {
 16545              		.loc 2 4082 9
 16546 001a 0023     		movs	r3, #0
 16547 001c FB61     		str	r3, [r7, #28]
 16548              		.loc 2 4082 2
 16549 001e 28E0     		b	.L396
 16550              	.L402:
 16551              	.LBB61:
4083:keygen.c      **** 		int s;
4084:keygen.c      **** 
4085:keygen.c      **** 	restart:
 16552              		.loc 2 4085 2
 16553 0020 00BF     		nop
 16554              	.L397:
4086:keygen.c      **** 		s = mkgauss(rng, logn);
 16555              		.loc 2 4086 7
 16556 0022 7968     		ldr	r1, [r7, #4]
 16557 0024 F868     		ldr	r0, [r7, #12]
 16558 0026 FFF7FEFF 		bl	mkgauss
 16559 002a 3861     		str	r0, [r7, #16]
4087:keygen.c      **** 
4088:keygen.c      **** 		/*
4089:keygen.c      **** 		 * We need the coefficient to fit within -127..+127;
4090:keygen.c      **** 		 * realistically, this is always the case except for
4091:keygen.c      **** 		 * the very low degrees (N = 2 or 4), for which there
4092:keygen.c      **** 		 * is no real security anyway.
4093:keygen.c      **** 		 */
4094:keygen.c      **** 		if (s < -127 || s > 127) {
 16560              		.loc 2 4094 6
 16561 002c 3B69     		ldr	r3, [r7, #16]
 16562 002e 13F17F0F 		cmn	r3, #127
 16563 0032 F6DB     		blt	.L397
 16564              		.loc 2 4094 16 discriminator 1
 16565 0034 3B69     		ldr	r3, [r7, #16]
 16566 0036 7F2B     		cmp	r3, #127
 16567 0038 00DD     		ble	.L399
4095:keygen.c      **** 			goto restart;
 16568              		.loc 2 4095 4
 16569 003a F2E7     		b	.L397
 16570              	.L399:
4096:keygen.c      **** 		}
4097:keygen.c      **** 
4098:keygen.c      **** 		/*
4099:keygen.c      **** 		 * We need the sum of all coefficients to be 1; otherwise,
4100:keygen.c      **** 		 * the resultant of the polynomial with X^N+1 will be even,
4101:keygen.c      **** 		 * and the binary GCD will fail.
4102:keygen.c      **** 		 */
4103:keygen.c      **** 		if (u == n - 1) {
 16571              		.loc 2 4103 14
 16572 003c 7B69     		ldr	r3, [r7, #20]
 16573 003e 013B     		subs	r3, r3, #1
 16574              		.loc 2 4103 6
 16575 0040 FA69     		ldr	r2, [r7, #28]
 16576 0042 9A42     		cmp	r2, r3
 16577 0044 06D1     		bne	.L400
4104:keygen.c      **** 			if ((mod2 ^ (unsigned)(s & 1)) == 0) {
 16578              		.loc 2 4104 29
 16579 0046 3B69     		ldr	r3, [r7, #16]
 16580              		.loc 2 4104 16
 16581 0048 03F00103 		and	r3, r3, #1
 16582              		.loc 2 4104 7
 16583 004c BA69     		ldr	r2, [r7, #24]
 16584 004e 9A42     		cmp	r2, r3
 16585 0050 06D1     		bne	.L401
4105:keygen.c      **** 				goto restart;
 16586              		.loc 2 4105 5
 16587 0052 E6E7     		b	.L397
 16588              	.L400:
4106:keygen.c      **** 			}
4107:keygen.c      **** 		} else {
4108:keygen.c      **** 			mod2 ^= (unsigned)(s & 1);
 16589              		.loc 2 4108 25
 16590 0054 3B69     		ldr	r3, [r7, #16]
 16591              		.loc 2 4108 12
 16592 0056 03F00103 		and	r3, r3, #1
 16593              		.loc 2 4108 9
 16594 005a BA69     		ldr	r2, [r7, #24]
 16595 005c 5340     		eors	r3, r3, r2
 16596 005e BB61     		str	r3, [r7, #24]
 16597              	.L401:
4109:keygen.c      **** 		}
4110:keygen.c      **** 		f[u] = (int8_t)s;
 16598              		.loc 2 4110 4 discriminator 2
 16599 0060 BA68     		ldr	r2, [r7, #8]
 16600 0062 FB69     		ldr	r3, [r7, #28]
 16601 0064 1344     		add	r3, r3, r2
 16602              		.loc 2 4110 10 discriminator 2
 16603 0066 3A69     		ldr	r2, [r7, #16]
 16604 0068 52B2     		sxtb	r2, r2
 16605              		.loc 2 4110 8 discriminator 2
 16606 006a 1A70     		strb	r2, [r3]
 16607              	.LBE61:
4082:keygen.c      **** 		int s;
 16608              		.loc 2 4082 23 discriminator 2
 16609 006c FB69     		ldr	r3, [r7, #28]
 16610 006e 0133     		adds	r3, r3, #1
 16611 0070 FB61     		str	r3, [r7, #28]
 16612              	.L396:
4082:keygen.c      **** 		int s;
 16613              		.loc 2 4082 2 discriminator 1
 16614 0072 FA69     		ldr	r2, [r7, #28]
 16615 0074 7B69     		ldr	r3, [r7, #20]
 16616 0076 9A42     		cmp	r2, r3
 16617 0078 D2D3     		bcc	.L402
4111:keygen.c      **** 	}
4112:keygen.c      **** }
 16618              		.loc 2 4112 1
 16619 007a 00BF     		nop
 16620 007c 00BF     		nop
 16621 007e 2037     		adds	r7, r7, #32
 16622              	.LCFI284:
 16623              		.cfi_def_cfa_offset 8
 16624 0080 BD46     		mov	sp, r7
 16625              	.LCFI285:
 16626              		.cfi_def_cfa_register 13
 16627              		@ sp needed
 16628 0082 80BD     		pop	{r7, pc}
 16629              		.cfi_endproc
 16630              	.LFE64:
 16632              		.section	.text.falcon_inner_keygen,"ax",%progbits
 16633              		.align	1
 16634              		.global	falcon_inner_keygen
 16635              		.syntax unified
 16636              		.thumb
 16637              		.thumb_func
 16638              		.fpu softvfp
 16640              	falcon_inner_keygen:
 16641              	.LFB65:
4113:keygen.c      **** 
4114:keygen.c      **** /* see falcon.h */
4115:keygen.c      **** void
4116:keygen.c      **** Zf(keygen)(inner_shake256_context *rng,
4117:keygen.c      **** 	int8_t *f, int8_t *g, int8_t *F, int8_t *G, uint16_t *h,
4118:keygen.c      **** 	unsigned logn, uint8_t *tmp)
4119:keygen.c      **** {
 16642              		.loc 2 4119 1
 16643              		.cfi_startproc
 16644              		@ args = 16, pretend = 0, frame = 80
 16645              		@ frame_needed = 1, uses_anonymous_args = 0
 16646 0000 80B5     		push	{r7, lr}
 16647              	.LCFI286:
 16648              		.cfi_def_cfa_offset 8
 16649              		.cfi_offset 7, -8
 16650              		.cfi_offset 14, -4
 16651 0002 98B0     		sub	sp, sp, #96
 16652              	.LCFI287:
 16653              		.cfi_def_cfa_offset 104
 16654 0004 04AF     		add	r7, sp, #16
 16655              	.LCFI288:
 16656              		.cfi_def_cfa 7, 88
 16657 0006 F860     		str	r0, [r7, #12]
 16658 0008 B960     		str	r1, [r7, #8]
 16659 000a 7A60     		str	r2, [r7, #4]
 16660 000c 3B60     		str	r3, [r7]
4120:keygen.c      **** 	/*
4121:keygen.c      **** 	 * Algorithm is the following:
4122:keygen.c      **** 	 *
4123:keygen.c      **** 	 *  - Generate f and g with the Gaussian distribution.
4124:keygen.c      **** 	 *
4125:keygen.c      **** 	 *  - If either Res(f,phi) or Res(g,phi) is even, try again.
4126:keygen.c      **** 	 *
4127:keygen.c      **** 	 *  - If ||(f,g)|| is too large, try again.
4128:keygen.c      **** 	 *
4129:keygen.c      **** 	 *  - If ||B~_{f,g}|| is too large, try again.
4130:keygen.c      **** 	 *
4131:keygen.c      **** 	 *  - If f is not invertible mod phi mod q, try again.
4132:keygen.c      **** 	 *
4133:keygen.c      **** 	 *  - Compute h = g/f mod phi mod q.
4134:keygen.c      **** 	 *
4135:keygen.c      **** 	 *  - Solve the NTRU equation fG - gF = q; if the solving fails,
4136:keygen.c      **** 	 *    try again. Usual failure condition is when Res(f,phi)
4137:keygen.c      **** 	 *    and Res(g,phi) are not prime to each other.
4138:keygen.c      **** 	 */
4139:keygen.c      **** 	size_t n, u;
4140:keygen.c      **** 	uint16_t *h2, *tmp2;
4141:keygen.c      **** 	RNG_CONTEXT *rc;
4142:keygen.c      **** 
4143:keygen.c      **** 	n = MKN(logn);
 16661              		.loc 2 4143 4
 16662 000e 0122     		movs	r2, #1
 16663 0010 3B6E     		ldr	r3, [r7, #96]
 16664 0012 02FA03F3 		lsl	r3, r2, r3
 16665 0016 3B63     		str	r3, [r7, #48]
4144:keygen.c      **** 	rc = rng;
 16666              		.loc 2 4144 5
 16667 0018 FB68     		ldr	r3, [r7, #12]
 16668 001a FB62     		str	r3, [r7, #44]
 16669              	.L420:
 16670              	.LBB62:
4145:keygen.c      **** 
4146:keygen.c      **** 	/*
4147:keygen.c      **** 	 * We need to generate f and g randomly, until we find values
4148:keygen.c      **** 	 * such that the norm of (g,-f), and of the orthogonalized
4149:keygen.c      **** 	 * vector, are satisfying. The orthogonalized vector is:
4150:keygen.c      **** 	 *   (q*adj(f)/(f*adj(f)+g*adj(g)), q*adj(g)/(f*adj(f)+g*adj(g)))
4151:keygen.c      **** 	 * (it is actually the (N+1)-th row of the Gram-Schmidt basis).
4152:keygen.c      **** 	 *
4153:keygen.c      **** 	 * In the binary case, coefficients of f and g are generated
4154:keygen.c      **** 	 * independently of each other, with a discrete Gaussian
4155:keygen.c      **** 	 * distribution of standard deviation 1.17*sqrt(q/(2*N)). Then,
4156:keygen.c      **** 	 * the two vectors have expected norm 1.17*sqrt(q), which is
4157:keygen.c      **** 	 * also our acceptance bound: we require both vectors to be no
4158:keygen.c      **** 	 * larger than that (this will be satisfied about 1/4th of the
4159:keygen.c      **** 	 * time, thus we expect sampling new (f,g) about 4 times for that
4160:keygen.c      **** 	 * step).
4161:keygen.c      **** 	 *
4162:keygen.c      **** 	 * We require that Res(f,phi) and Res(g,phi) are both odd (the
4163:keygen.c      **** 	 * NTRU equation solver requires it).
4164:keygen.c      **** 	 */
4165:keygen.c      **** 	for (;;) {
4166:keygen.c      **** 		fpr *rt1, *rt2, *rt3;
4167:keygen.c      **** 		fpr bnorm;
4168:keygen.c      **** 		uint32_t normf, normg, norm;
4169:keygen.c      **** 		int lim;
4170:keygen.c      **** 
4171:keygen.c      **** 		/*
4172:keygen.c      **** 		 * The poly_small_mkgauss() function makes sure
4173:keygen.c      **** 		 * that the sum of coefficients is 1 modulo 2
4174:keygen.c      **** 		 * (i.e. the resultant of the polynomial with phi
4175:keygen.c      **** 		 * will be odd).
4176:keygen.c      **** 		 */
4177:keygen.c      **** 		poly_small_mkgauss(rc, f, logn);
 16671              		.loc 2 4177 3
 16672 001c 3A6E     		ldr	r2, [r7, #96]
 16673 001e B968     		ldr	r1, [r7, #8]
 16674 0020 F86A     		ldr	r0, [r7, #44]
 16675 0022 FFF7FEFF 		bl	poly_small_mkgauss
4178:keygen.c      **** 		poly_small_mkgauss(rc, g, logn);
 16676              		.loc 2 4178 3
 16677 0026 3A6E     		ldr	r2, [r7, #96]
 16678 0028 7968     		ldr	r1, [r7, #4]
 16679 002a F86A     		ldr	r0, [r7, #44]
 16680 002c FFF7FEFF 		bl	poly_small_mkgauss
4179:keygen.c      **** 
4180:keygen.c      **** 		/*
4181:keygen.c      **** 		 * Verify that all coefficients are within the bounds
4182:keygen.c      **** 		 * defined in max_fg_bits. This is the case with
4183:keygen.c      **** 		 * overwhelming probability; this guarantees that the
4184:keygen.c      **** 		 * key will be encodable with FALCON_COMP_TRIM.
4185:keygen.c      **** 		 */
4186:keygen.c      **** 		lim = 1 << (Zf(max_fg_bits)[logn] - 1);
 16681              		.loc 2 4186 30
 16682 0030 974A     		ldr	r2, .L426+16
 16683 0032 3B6E     		ldr	r3, [r7, #96]
 16684 0034 1344     		add	r3, r3, r2
 16685 0036 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 16686              		.loc 2 4186 37
 16687 0038 013B     		subs	r3, r3, #1
 16688              		.loc 2 4186 7
 16689 003a 0122     		movs	r2, #1
 16690 003c 02FA03F3 		lsl	r3, r2, r3
 16691 0040 7B63     		str	r3, [r7, #52]
4187:keygen.c      **** 		for (u = 0; u < n; u ++) {
 16692              		.loc 2 4187 10
 16693 0042 0023     		movs	r3, #0
 16694 0044 FB64     		str	r3, [r7, #76]
 16695              		.loc 2 4187 3
 16696 0046 2CE0     		b	.L404
 16697              	.L408:
4188:keygen.c      **** 			/*
4189:keygen.c      **** 			 * We can use non-CT tests since on any failure
4190:keygen.c      **** 			 * we will discard f and g.
4191:keygen.c      **** 			 */
4192:keygen.c      **** 			if (f[u] >= lim || f[u] <= -lim
 16698              		.loc 2 4192 9
 16699 0048 BA68     		ldr	r2, [r7, #8]
 16700 004a FB6C     		ldr	r3, [r7, #76]
 16701 004c 1344     		add	r3, r3, r2
 16702 004e 93F90030 		ldrsb	r3, [r3]
 16703 0052 1A46     		mov	r2, r3
 16704              		.loc 2 4192 7
 16705 0054 7B6B     		ldr	r3, [r7, #52]
 16706 0056 9342     		cmp	r3, r2
 16707 0058 1CDD     		ble	.L405
 16708              		.loc 2 4192 24 discriminator 1
 16709 005a BA68     		ldr	r2, [r7, #8]
 16710 005c FB6C     		ldr	r3, [r7, #76]
 16711 005e 1344     		add	r3, r3, r2
 16712 0060 93F90030 		ldrsb	r3, [r3]
 16713 0064 1A46     		mov	r2, r3
 16714              		.loc 2 4192 31 discriminator 1
 16715 0066 7B6B     		ldr	r3, [r7, #52]
 16716 0068 5B42     		rsbs	r3, r3, #0
 16717              		.loc 2 4192 20 discriminator 1
 16718 006a 9A42     		cmp	r2, r3
 16719 006c 12DD     		ble	.L405
4193:keygen.c      **** 				|| g[u] >= lim || g[u] <= -lim)
 16720              		.loc 2 4193 9
 16721 006e 7A68     		ldr	r2, [r7, #4]
 16722 0070 FB6C     		ldr	r3, [r7, #76]
 16723 0072 1344     		add	r3, r3, r2
 16724 0074 93F90030 		ldrsb	r3, [r3]
 16725 0078 1A46     		mov	r2, r3
 16726              		.loc 2 4193 5
 16727 007a 7B6B     		ldr	r3, [r7, #52]
 16728 007c 9342     		cmp	r3, r2
 16729 007e 09DD     		ble	.L405
 16730              		.loc 2 4193 24 discriminator 1
 16731 0080 7A68     		ldr	r2, [r7, #4]
 16732 0082 FB6C     		ldr	r3, [r7, #76]
 16733 0084 1344     		add	r3, r3, r2
 16734 0086 93F90030 		ldrsb	r3, [r3]
 16735 008a 1A46     		mov	r2, r3
 16736              		.loc 2 4193 31 discriminator 1
 16737 008c 7B6B     		ldr	r3, [r7, #52]
 16738 008e 5B42     		rsbs	r3, r3, #0
 16739              		.loc 2 4193 20 discriminator 1
 16740 0090 9A42     		cmp	r2, r3
 16741 0092 03DC     		bgt	.L406
 16742              	.L405:
4194:keygen.c      **** 			{
4195:keygen.c      **** 				lim = -1;
 16743              		.loc 2 4195 9
 16744 0094 4FF0FF33 		mov	r3, #-1
 16745 0098 7B63     		str	r3, [r7, #52]
4196:keygen.c      **** 				break;
 16746              		.loc 2 4196 5
 16747 009a 06E0     		b	.L407
 16748              	.L406:
4187:keygen.c      **** 			/*
 16749              		.loc 2 4187 24 discriminator 2
 16750 009c FB6C     		ldr	r3, [r7, #76]
 16751 009e 0133     		adds	r3, r3, #1
 16752 00a0 FB64     		str	r3, [r7, #76]
 16753              	.L404:
4187:keygen.c      **** 			/*
 16754              		.loc 2 4187 3 discriminator 1
 16755 00a2 FA6C     		ldr	r2, [r7, #76]
 16756 00a4 3B6B     		ldr	r3, [r7, #48]
 16757 00a6 9A42     		cmp	r2, r3
 16758 00a8 CED3     		bcc	.L408
 16759              	.L407:
4197:keygen.c      **** 			}
4198:keygen.c      **** 		}
4199:keygen.c      **** 		if (lim < 0) {
 16760              		.loc 2 4199 6
 16761 00aa 7B6B     		ldr	r3, [r7, #52]
 16762 00ac 002B     		cmp	r3, #0
 16763 00ae C0F2D980 		blt	.L421
4200:keygen.c      **** 			continue;
4201:keygen.c      **** 		}
4202:keygen.c      **** 
4203:keygen.c      **** 		/*
4204:keygen.c      **** 		 * Bound is 1.17*sqrt(q). We compute the squared
4205:keygen.c      **** 		 * norms. With q = 12289, the squared bound is:
4206:keygen.c      **** 		 *   (1.17^2)* 12289 = 16822.4121
4207:keygen.c      **** 		 * Since f and g are integral, the squared norm
4208:keygen.c      **** 		 * of (g,-f) is an integer.
4209:keygen.c      **** 		 */
4210:keygen.c      **** 		normf = poly_small_sqnorm(f, logn);
 16764              		.loc 2 4210 11
 16765 00b2 396E     		ldr	r1, [r7, #96]
 16766 00b4 B868     		ldr	r0, [r7, #8]
 16767 00b6 FFF7FEFF 		bl	poly_small_sqnorm
 16768 00ba B862     		str	r0, [r7, #40]
4211:keygen.c      **** 		normg = poly_small_sqnorm(g, logn);
 16769              		.loc 2 4211 11
 16770 00bc 396E     		ldr	r1, [r7, #96]
 16771 00be 7868     		ldr	r0, [r7, #4]
 16772 00c0 FFF7FEFF 		bl	poly_small_sqnorm
 16773 00c4 7862     		str	r0, [r7, #36]
4212:keygen.c      **** 		norm = (normf + normg) | -((normf | normg) >> 31);
 16774              		.loc 2 4212 17
 16775 00c6 BA6A     		ldr	r2, [r7, #40]
 16776 00c8 7B6A     		ldr	r3, [r7, #36]
 16777 00ca 1344     		add	r3, r3, r2
 16778              		.loc 2 4212 37
 16779 00cc B96A     		ldr	r1, [r7, #40]
 16780 00ce 7A6A     		ldr	r2, [r7, #36]
 16781 00d0 0A43     		orrs	r2, r2, r1
 16782              		.loc 2 4212 28
 16783 00d2 D217     		asrs	r2, r2, #31
 16784              		.loc 2 4212 8
 16785 00d4 1343     		orrs	r3, r3, r2
 16786 00d6 3B62     		str	r3, [r7, #32]
4213:keygen.c      **** 		if (norm >= 16823) {
 16787              		.loc 2 4213 6
 16788 00d8 3B6A     		ldr	r3, [r7, #32]
 16789 00da 44F2B612 		movw	r2, #16822
 16790 00de 9342     		cmp	r3, r2
 16791 00e0 00F2C280 		bhi	.L422
4214:keygen.c      **** 			continue;
4215:keygen.c      **** 		}
4216:keygen.c      **** 
4217:keygen.c      **** 		/*
4218:keygen.c      **** 		 * We compute the orthogonalized vector norm.
4219:keygen.c      **** 		 */
4220:keygen.c      **** 		rt1 = (fpr *)tmp;
 16792              		.loc 2 4220 7
 16793 00e4 7B6E     		ldr	r3, [r7, #100]
 16794 00e6 FB61     		str	r3, [r7, #28]
4221:keygen.c      **** 		rt2 = rt1 + n;
 16795              		.loc 2 4221 13
 16796 00e8 3B6B     		ldr	r3, [r7, #48]
 16797 00ea DB00     		lsls	r3, r3, #3
 16798              		.loc 2 4221 7
 16799 00ec FA69     		ldr	r2, [r7, #28]
 16800 00ee 1344     		add	r3, r3, r2
 16801 00f0 BB61     		str	r3, [r7, #24]
4222:keygen.c      **** 		rt3 = rt2 + n;
 16802              		.loc 2 4222 13
 16803 00f2 3B6B     		ldr	r3, [r7, #48]
 16804 00f4 DB00     		lsls	r3, r3, #3
 16805              		.loc 2 4222 7
 16806 00f6 BA69     		ldr	r2, [r7, #24]
 16807 00f8 1344     		add	r3, r3, r2
 16808 00fa 7B61     		str	r3, [r7, #20]
4223:keygen.c      **** 		poly_small_to_fp(rt1, f, logn);
 16809              		.loc 2 4223 3
 16810 00fc 3A6E     		ldr	r2, [r7, #96]
 16811 00fe B968     		ldr	r1, [r7, #8]
 16812 0100 F869     		ldr	r0, [r7, #28]
 16813 0102 FFF7FEFF 		bl	poly_small_to_fp
4224:keygen.c      **** 		poly_small_to_fp(rt2, g, logn);
 16814              		.loc 2 4224 3
 16815 0106 3A6E     		ldr	r2, [r7, #96]
 16816 0108 7968     		ldr	r1, [r7, #4]
 16817 010a B869     		ldr	r0, [r7, #24]
 16818 010c FFF7FEFF 		bl	poly_small_to_fp
4225:keygen.c      **** 		Zf(FFT)(rt1, logn);
 16819              		.loc 2 4225 3
 16820 0110 396E     		ldr	r1, [r7, #96]
 16821 0112 F869     		ldr	r0, [r7, #28]
 16822 0114 FFF7FEFF 		bl	falcon_inner_FFT
4226:keygen.c      **** 		Zf(FFT)(rt2, logn);
 16823              		.loc 2 4226 3
 16824 0118 396E     		ldr	r1, [r7, #96]
 16825 011a B869     		ldr	r0, [r7, #24]
 16826 011c FFF7FEFF 		bl	falcon_inner_FFT
4227:keygen.c      **** 		Zf(poly_invnorm2_fft)(rt3, rt1, rt2, logn);
 16827              		.loc 2 4227 3
 16828 0120 3B6E     		ldr	r3, [r7, #96]
 16829 0122 BA69     		ldr	r2, [r7, #24]
 16830 0124 F969     		ldr	r1, [r7, #28]
 16831 0126 7869     		ldr	r0, [r7, #20]
 16832 0128 FFF7FEFF 		bl	falcon_inner_poly_invnorm2_fft
4228:keygen.c      **** 		Zf(poly_adj_fft)(rt1, logn);
 16833              		.loc 2 4228 3
 16834 012c 396E     		ldr	r1, [r7, #96]
 16835 012e F869     		ldr	r0, [r7, #28]
 16836 0130 FFF7FEFF 		bl	falcon_inner_poly_adj_fft
4229:keygen.c      **** 		Zf(poly_adj_fft)(rt2, logn);
 16837              		.loc 2 4229 3
 16838 0134 396E     		ldr	r1, [r7, #96]
 16839 0136 B869     		ldr	r0, [r7, #24]
 16840 0138 FFF7FEFF 		bl	falcon_inner_poly_adj_fft
4230:keygen.c      **** 		Zf(poly_mulconst)(rt1, fpr_q, logn);
 16841              		.loc 2 4230 3
 16842 013c 50A3     		adr	r3, .L426
 16843 013e D3E90023 		ldrd	r2, [r3]
 16844 0142 396E     		ldr	r1, [r7, #96]
 16845 0144 0091     		str	r1, [sp]
 16846 0146 F869     		ldr	r0, [r7, #28]
 16847 0148 FFF7FEFF 		bl	falcon_inner_poly_mulconst
4231:keygen.c      **** 		Zf(poly_mulconst)(rt2, fpr_q, logn);
 16848              		.loc 2 4231 3
 16849 014c 4CA3     		adr	r3, .L426
 16850 014e D3E90023 		ldrd	r2, [r3]
 16851 0152 396E     		ldr	r1, [r7, #96]
 16852 0154 0091     		str	r1, [sp]
 16853 0156 B869     		ldr	r0, [r7, #24]
 16854 0158 FFF7FEFF 		bl	falcon_inner_poly_mulconst
4232:keygen.c      **** 		Zf(poly_mul_autoadj_fft)(rt1, rt3, logn);
 16855              		.loc 2 4232 3
 16856 015c 3A6E     		ldr	r2, [r7, #96]
 16857 015e 7969     		ldr	r1, [r7, #20]
 16858 0160 F869     		ldr	r0, [r7, #28]
 16859 0162 FFF7FEFF 		bl	falcon_inner_poly_mul_autoadj_fft
4233:keygen.c      **** 		Zf(poly_mul_autoadj_fft)(rt2, rt3, logn);
 16860              		.loc 2 4233 3
 16861 0166 3A6E     		ldr	r2, [r7, #96]
 16862 0168 7969     		ldr	r1, [r7, #20]
 16863 016a B869     		ldr	r0, [r7, #24]
 16864 016c FFF7FEFF 		bl	falcon_inner_poly_mul_autoadj_fft
4234:keygen.c      **** 		Zf(iFFT)(rt1, logn);
 16865              		.loc 2 4234 3
 16866 0170 396E     		ldr	r1, [r7, #96]
 16867 0172 F869     		ldr	r0, [r7, #28]
 16868 0174 FFF7FEFF 		bl	falcon_inner_iFFT
4235:keygen.c      **** 		Zf(iFFT)(rt2, logn);
 16869              		.loc 2 4235 3
 16870 0178 396E     		ldr	r1, [r7, #96]
 16871 017a B869     		ldr	r0, [r7, #24]
 16872 017c FFF7FEFF 		bl	falcon_inner_iFFT
4236:keygen.c      **** 		bnorm = fpr_zero;
 16873              		.loc 2 4236 9
 16874 0180 4FF00002 		mov	r2, #0
 16875 0184 4FF00003 		mov	r3, #0
 16876 0188 C7E90E23 		strd	r2, [r7, #56]
4237:keygen.c      **** 		for (u = 0; u < n; u ++) {
 16877              		.loc 2 4237 10
 16878 018c 0023     		movs	r3, #0
 16879 018e FB64     		str	r3, [r7, #76]
 16880              		.loc 2 4237 3
 16881 0190 26E0     		b	.L412
 16882              	.L413:
4238:keygen.c      **** 			bnorm = fpr_add(bnorm, fpr_sqr(rt1[u]));
 16883              		.loc 2 4238 38 discriminator 3
 16884 0192 FB6C     		ldr	r3, [r7, #76]
 16885 0194 DB00     		lsls	r3, r3, #3
 16886 0196 FA69     		ldr	r2, [r7, #28]
 16887 0198 1344     		add	r3, r3, r2
 16888              		.loc 2 4238 12 discriminator 3
 16889 019a D3E90023 		ldrd	r2, [r3]
 16890 019e 1046     		mov	r0, r2
 16891 01a0 1946     		mov	r1, r3
 16892 01a2 FFF7FEFF 		bl	fpr_sqr
 16893 01a6 0246     		mov	r2, r0
 16894 01a8 0B46     		mov	r3, r1
 16895 01aa D7E90E01 		ldrd	r0, [r7, #56]
 16896 01ae FFF7FEFF 		bl	falcon_inner_fpr_add
 16897 01b2 C7E90E01 		strd	r0, [r7, #56]
4239:keygen.c      **** 			bnorm = fpr_add(bnorm, fpr_sqr(rt2[u]));
 16898              		.loc 2 4239 38 discriminator 3
 16899 01b6 FB6C     		ldr	r3, [r7, #76]
 16900 01b8 DB00     		lsls	r3, r3, #3
 16901 01ba BA69     		ldr	r2, [r7, #24]
 16902 01bc 1344     		add	r3, r3, r2
 16903              		.loc 2 4239 12 discriminator 3
 16904 01be D3E90023 		ldrd	r2, [r3]
 16905 01c2 1046     		mov	r0, r2
 16906 01c4 1946     		mov	r1, r3
 16907 01c6 FFF7FEFF 		bl	fpr_sqr
 16908 01ca 0246     		mov	r2, r0
 16909 01cc 0B46     		mov	r3, r1
 16910 01ce D7E90E01 		ldrd	r0, [r7, #56]
 16911 01d2 FFF7FEFF 		bl	falcon_inner_fpr_add
 16912 01d6 C7E90E01 		strd	r0, [r7, #56]
4237:keygen.c      **** 		for (u = 0; u < n; u ++) {
 16913              		.loc 2 4237 24 discriminator 3
 16914 01da FB6C     		ldr	r3, [r7, #76]
 16915 01dc 0133     		adds	r3, r3, #1
 16916 01de FB64     		str	r3, [r7, #76]
 16917              	.L412:
4237:keygen.c      **** 		for (u = 0; u < n; u ++) {
 16918              		.loc 2 4237 3 discriminator 1
 16919 01e0 FA6C     		ldr	r2, [r7, #76]
 16920 01e2 3B6B     		ldr	r3, [r7, #48]
 16921 01e4 9A42     		cmp	r2, r3
 16922 01e6 D4D3     		bcc	.L413
4240:keygen.c      **** 		}
4241:keygen.c      **** 		if (!fpr_lt(bnorm, fpr_bnorm_max)) {
 16923              		.loc 2 4241 8
 16924 01e8 27A3     		adr	r3, .L426+8
 16925 01ea D3E90023 		ldrd	r2, [r3]
 16926 01ee D7E90E01 		ldrd	r0, [r7, #56]
 16927 01f2 FFF7FEFF 		bl	fpr_lt
 16928 01f6 0346     		mov	r3, r0
 16929              		.loc 2 4241 6
 16930 01f8 002B     		cmp	r3, #0
 16931 01fa 37D0     		beq	.L423
4242:keygen.c      **** 			continue;
4243:keygen.c      **** 		}
4244:keygen.c      **** 
4245:keygen.c      **** 		/*
4246:keygen.c      **** 		 * Compute public key h = g/f mod X^N+1 mod q. If this
4247:keygen.c      **** 		 * fails, we must restart.
4248:keygen.c      **** 		 */
4249:keygen.c      **** 		if (h == NULL) {
 16932              		.loc 2 4249 6
 16933 01fc FB6D     		ldr	r3, [r7, #92]
 16934 01fe 002B     		cmp	r3, #0
 16935 0200 07D1     		bne	.L415
4250:keygen.c      **** 			h2 = (uint16_t *)tmp;
 16936              		.loc 2 4250 7
 16937 0202 7B6E     		ldr	r3, [r7, #100]
 16938 0204 BB64     		str	r3, [r7, #72]
4251:keygen.c      **** 			tmp2 = h2 + n;
 16939              		.loc 2 4251 14
 16940 0206 3B6B     		ldr	r3, [r7, #48]
 16941 0208 5B00     		lsls	r3, r3, #1
 16942              		.loc 2 4251 9
 16943 020a BA6C     		ldr	r2, [r7, #72]
 16944 020c 1344     		add	r3, r3, r2
 16945 020e 7B64     		str	r3, [r7, #68]
 16946 0210 03E0     		b	.L416
 16947              	.L415:
4252:keygen.c      **** 		} else {
4253:keygen.c      **** 			h2 = h;
 16948              		.loc 2 4253 7
 16949 0212 FB6D     		ldr	r3, [r7, #92]
 16950 0214 BB64     		str	r3, [r7, #72]
4254:keygen.c      **** 			tmp2 = (uint16_t *)tmp;
 16951              		.loc 2 4254 9
 16952 0216 7B6E     		ldr	r3, [r7, #100]
 16953 0218 7B64     		str	r3, [r7, #68]
 16954              	.L416:
4255:keygen.c      **** 		}
4256:keygen.c      **** 		if (!Zf(compute_public)(h2, f, g, logn, (uint8_t *)tmp2)) {
 16955              		.loc 2 4256 8
 16956 021a 7B6C     		ldr	r3, [r7, #68]
 16957 021c 0093     		str	r3, [sp]
 16958 021e 3B6E     		ldr	r3, [r7, #96]
 16959 0220 7A68     		ldr	r2, [r7, #4]
 16960 0222 B968     		ldr	r1, [r7, #8]
 16961 0224 B86C     		ldr	r0, [r7, #72]
 16962 0226 FFF7FEFF 		bl	falcon_inner_compute_public
 16963 022a 0346     		mov	r3, r0
 16964              		.loc 2 4256 6
 16965 022c 002B     		cmp	r3, #0
 16966 022e 1FD0     		beq	.L424
4257:keygen.c      **** 			continue;
4258:keygen.c      **** 		}
4259:keygen.c      **** 
4260:keygen.c      **** 		/*
4261:keygen.c      **** 		 * Solve the NTRU equation to get F and G.
4262:keygen.c      **** 		 */
4263:keygen.c      **** 		lim = (1 << (Zf(max_FG_bits)[logn] - 1)) - 1;
 16967              		.loc 2 4263 31
 16968 0230 184A     		ldr	r2, .L426+20
 16969 0232 3B6E     		ldr	r3, [r7, #96]
 16970 0234 1344     		add	r3, r3, r2
 16971 0236 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 16972              		.loc 2 4263 38
 16973 0238 013B     		subs	r3, r3, #1
 16974              		.loc 2 4263 12
 16975 023a 0122     		movs	r2, #1
 16976 023c 02FA03F3 		lsl	r3, r2, r3
 16977              		.loc 2 4263 7
 16978 0240 013B     		subs	r3, r3, #1
 16979 0242 7B63     		str	r3, [r7, #52]
4264:keygen.c      **** 		if (!solve_NTRU(logn, F, G, f, g, lim, (uint32_t *)tmp)) {
 16980              		.loc 2 4264 8
 16981 0244 7B6E     		ldr	r3, [r7, #100]
 16982 0246 0293     		str	r3, [sp, #8]
 16983 0248 7B6B     		ldr	r3, [r7, #52]
 16984 024a 0193     		str	r3, [sp, #4]
 16985 024c 7B68     		ldr	r3, [r7, #4]
 16986 024e 0093     		str	r3, [sp]
 16987 0250 BB68     		ldr	r3, [r7, #8]
 16988 0252 BA6D     		ldr	r2, [r7, #88]
 16989 0254 3968     		ldr	r1, [r7]
 16990 0256 386E     		ldr	r0, [r7, #96]
 16991 0258 FFF7FEFF 		bl	solve_NTRU
 16992 025c 0346     		mov	r3, r0
 16993              		.loc 2 4264 6
 16994 025e 002B     		cmp	r3, #0
 16995 0260 08D1     		bne	.L425
4265:keygen.c      **** 			continue;
 16996              		.loc 2 4265 4
 16997 0262 06E0     		b	.L410
 16998              	.L421:
4200:keygen.c      **** 		}
 16999              		.loc 2 4200 4
 17000 0264 00BF     		nop
 17001 0266 D9E6     		b	.L420
 17002              	.L422:
4214:keygen.c      **** 		}
 17003              		.loc 2 4214 4
 17004 0268 00BF     		nop
 17005 026a D7E6     		b	.L420
 17006              	.L423:
4242:keygen.c      **** 		}
 17007              		.loc 2 4242 4
 17008 026c 00BF     		nop
 17009 026e D5E6     		b	.L420
 17010              	.L424:
4257:keygen.c      **** 		}
 17011              		.loc 2 4257 4
 17012 0270 00BF     		nop
 17013              	.L410:
 17014              	.LBE62:
4165:keygen.c      **** 		fpr *rt1, *rt2, *rt3;
 17015              		.loc 2 4165 11
 17016 0272 D3E6     		b	.L420
 17017              	.L425:
 17018              	.LBB63:
4266:keygen.c      **** 		}
4267:keygen.c      **** 
4268:keygen.c      **** 		/*
4269:keygen.c      **** 		 * Key pair is generated.
4270:keygen.c      **** 		 */
4271:keygen.c      **** 		break;
 17019              		.loc 2 4271 3
 17020 0274 00BF     		nop
 17021              	.LBE63:
4272:keygen.c      **** 	}
4273:keygen.c      **** }
 17022              		.loc 2 4273 1
 17023 0276 00BF     		nop
 17024 0278 5037     		adds	r7, r7, #80
 17025              	.LCFI289:
 17026              		.cfi_def_cfa_offset 8
 17027 027a BD46     		mov	sp, r7
 17028              	.LCFI290:
 17029              		.cfi_def_cfa_register 13
 17030              		@ sp needed
 17031 027c 80BD     		pop	{r7, pc}
 17032              	.L427:
 17033 027e 00BF     		.align	3
 17034              	.L426:
 17035 0280 00000000 		.word	0
 17036 0284 8000C840 		.word	1086849152
 17037 0288 ACADD85F 		.word	1608035756
 17038 028c 9A6DD040 		.word	1087401370
 17039 0290 00000000 		.word	falcon_inner_max_fg_bits
 17040 0294 00000000 		.word	falcon_inner_max_FG_bits
 17041              		.cfi_endproc
 17042              	.LFE65:
 17044              		.text
 17045              	.Letext0:
 17046              		.file 3 "c:\\users\\user\\chipwhisperer5_64\\cw\\home\\portable\\armgcc\\gcc-arm-none-eabi-10-2020
 17047              		.file 4 "c:\\users\\user\\chipwhisperer5_64\\cw\\home\\portable\\armgcc\\gcc-arm-none-eabi-10-2020
 17048              		.file 5 "c:\\users\\user\\chipwhisperer5_64\\cw\\home\\portable\\armgcc\\gcc-arm-none-eabi-10-2020
 17049              		.file 6 "inner.h"
DEFINED SYMBOLS
                            *ABS*:00000000 keygen.c
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:16     .text.fpr_ursh:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:23     .text.fpr_ursh:00000000 fpr_ursh
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:127    .text.fpr_ulsh:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:133    .text.fpr_ulsh:00000000 fpr_ulsh
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:236    .text.fpr_of:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:242    .text.fpr_of:00000000 fpr_of
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:281    .rodata:00000000 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:284    .rodata:00000000 fpr_q
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:290    .rodata:00000008 fpr_inverse_of_q
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:296    .rodata:00000010 fpr_inv_2sqrsigma0
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:302    .rodata:00000018 fpr_inv_sigma
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:328    .rodata:00000070 fpr_sigma_min
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:354    .rodata:000000c8 fpr_log2
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:360    .rodata:000000d0 fpr_inv_log2
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:366    .rodata:000000d8 fpr_bnorm_max
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:372    .rodata:000000e0 fpr_zero
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:377    .rodata:000000e8 fpr_one
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:383    .rodata:000000f0 fpr_two
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:389    .rodata:000000f8 fpr_onehalf
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:395    .rodata:00000100 fpr_invsqrt2
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:401    .rodata:00000108 fpr_invsqrt8
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:407    .rodata:00000110 fpr_ptwo31
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:413    .rodata:00000118 fpr_ptwo31m1
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:419    .rodata:00000120 fpr_mtwo31m1
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:425    .rodata:00000128 fpr_ptwo63m1
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:431    .rodata:00000130 fpr_mtwo63m1
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:437    .rodata:00000138 fpr_ptwo63
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:441    .text.fpr_rint:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:447    .text.fpr_rint:00000000 fpr_rint
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:659    .text.fpr_sqr:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:665    .text.fpr_sqr:00000000 fpr_sqr
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:704    .text.fpr_lt:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:710    .text.fpr_lt:00000000 fpr_lt
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:811    .rodata:00000140 PRIMES
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2379   .text.modp_set:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2385   .text.modp_set:00000000 modp_set
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2439   .text.modp_norm:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2445   .text.modp_norm:00000000 modp_norm
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2500   .text.modp_ninv31:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2506   .text.modp_ninv31:00000000 modp_ninv31
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2591   .text.modp_R:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2597   .text.modp_R:00000000 modp_R
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2636   .text.modp_add:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2642   .text.modp_add:00000000 modp_add
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2701   .text.modp_sub:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2707   .text.modp_sub:00000000 modp_sub
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2763   .text.modp_montymul:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2769   .text.modp_montymul:00000000 modp_montymul
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2927   .text.modp_R2:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:2933   .text.modp_R2:00000000 modp_R2
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:3027   .text.modp_Rx:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:3033   .text.modp_Rx:00000000 modp_Rx
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:3123   .text.modp_div:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:3129   .text.modp_div:00000000 modp_div
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:3237   .rodata:000019b8 REV10
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4263   .text.modp_mkgm2:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4269   .text.modp_mkgm2:00000000 modp_mkgm2
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4422   .text.modp_mkgm2:000000e0 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4427   .text.modp_NTT2_ext:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4433   .text.modp_NTT2_ext:00000000 modp_NTT2_ext
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4626   .text.modp_iNTT2_ext:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4632   .text.modp_iNTT2_ext:00000000 modp_iNTT2_ext
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4869   .text.modp_poly_rec_res:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4875   .text.modp_poly_rec_res:00000000 modp_poly_rec_res
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4973   .text.zint_sub:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:4979   .text.zint_sub:00000000 zint_sub
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5091   .text.zint_mul_small:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5097   .text.zint_mul_small:00000000 zint_mul_small
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5228   .text.zint_mod_small_unsigned:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5234   .text.zint_mod_small_unsigned:00000000 zint_mod_small_unsigned
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5324   .text.zint_mod_small_signed:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5330   .text.zint_mod_small_signed:00000000 zint_mod_small_signed
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5405   .text.zint_add_mul_small:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5411   .text.zint_add_mul_small:00000000 zint_add_mul_small
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5573   .text.zint_norm_zero:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5579   .text.zint_norm_zero:00000000 zint_norm_zero
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5701   .text.zint_rebuild_CRT:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5707   .text.zint_rebuild_CRT:00000000 zint_rebuild_CRT
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5909   .text.zint_negate:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:5915   .text.zint_negate:00000000 zint_negate
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:6011   .text.zint_co_reduce:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:6017   .text.zint_co_reduce:00000000 zint_co_reduce
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:6319   .text.zint_finish_mod:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:6325   .text.zint_finish_mod:00000000 zint_finish_mod
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:6483   .text.zint_co_reduce_mod:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:6489   .text.zint_co_reduce_mod:00000000 zint_co_reduce_mod
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:6908   .text.zint_bezout:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:6914   .text.zint_bezout:00000000 zint_bezout
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8114   .text.zint_add_scaled_mul_small:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8120   .text.zint_add_scaled_mul_small:00000000 zint_add_scaled_mul_small
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8336   .text.zint_sub_scaled:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8342   .text.zint_sub_scaled:00000000 zint_sub_scaled
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8496   .text.zint_one_to_plain:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8502   .text.zint_one_to_plain:00000000 zint_one_to_plain
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8555   .text.poly_big_to_fp:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8561   .text.poly_big_to_fp:00000000 poly_big_to_fp
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8771   .text.poly_big_to_fp:00000138 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8777   .text.poly_big_to_small:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8783   .text.poly_big_to_small:00000000 poly_big_to_small
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8879   .text.poly_sub_scaled:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:8885   .text.poly_sub_scaled:00000000 poly_sub_scaled
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9026   .text.poly_sub_scaled_ntt:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9032   .text.poly_sub_scaled_ntt:00000000 poly_sub_scaled_ntt
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9404   .text.poly_sub_scaled_ntt:00000240 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9409   .text.get_rng_u64:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9415   .text.get_rng_u64:00000000 get_rng_u64
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9611   .rodata:000021b8 gauss_1024_12289
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9667   .text.mkgauss:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9673   .text.mkgauss:00000000 mkgauss
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9864   .text.mkgauss:00000128 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9874   .rodata:00002290 MAX_BL_SMALL
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9889   .rodata:000022bc MAX_BL_LARGE
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9903   .rodata:000022e4 BITLENGTH
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9927   .text.poly_small_sqnorm:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:9933   .text.poly_small_sqnorm:00000000 poly_small_sqnorm
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10027  .text.align_fpr:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10033  .text.align_fpr:00000000 align_fpr
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10101  .text.align_u32:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10107  .text.align_u32:00000000 align_u32
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10175  .text.poly_small_to_fp:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10181  .text.poly_small_to_fp:00000000 poly_small_to_fp
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10263  .text.make_fg_step:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10269  .text.make_fg_step:00000000 make_fg_step
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10634  .text.make_fg_step:00000270 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:10639  .text.make_fg_step:00000278 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11125  .text.make_fg:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11131  .text.make_fg:00000000 make_fg
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11360  .text.make_fg:00000144 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11365  .text.solve_NTRU_deepest:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11371  .text.solve_NTRU_deepest:00000000 solve_NTRU_deepest
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11513  .text.solve_NTRU_deepest:000000c8 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11519  .text.solve_NTRU_intermediate:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11525  .text.solve_NTRU_intermediate:00000000 solve_NTRU_intermediate
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11897  .text.solve_NTRU_intermediate:0000039c $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:11903  .text.solve_NTRU_intermediate:000003a8 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:12896  .text.solve_NTRU_intermediate:00000c88 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:12905  .text.solve_NTRU_intermediate:00000ca4 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:13264  .text.solve_NTRU_intermediate:00000fa4 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:13269  .text.solve_NTRU_binary_depth1:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:13275  .text.solve_NTRU_binary_depth1:00000000 solve_NTRU_binary_depth1
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:13648  .text.solve_NTRU_binary_depth1:0000030c $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:13653  .text.solve_NTRU_binary_depth1:00000318 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:14457  .text.solve_NTRU_binary_depth1:000009d4 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:14462  .text.solve_NTRU_binary_depth1:000009e0 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:14630  .text.solve_NTRU_binary_depth0:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:14636  .text.solve_NTRU_binary_depth0:00000000 solve_NTRU_binary_depth0
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:14890  .text.solve_NTRU_binary_depth0:000001b4 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:14895  .text.solve_NTRU_binary_depth0:000001bc $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:15387  .text.solve_NTRU_binary_depth0:0000054c $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:15391  .text.solve_NTRU_binary_depth0:00000550 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:15853  .text.solve_NTRU_binary_depth0:000008b8 $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:15857  .text.solve_NTRU_binary_depth0:000008bc $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:16033  .text.solve_NTRU:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:16039  .text.solve_NTRU:00000000 solve_NTRU
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:16506  .text.solve_NTRU:000002bc $d
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:16511  .text.poly_small_mkgauss:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:16517  .text.poly_small_mkgauss:00000000 poly_small_mkgauss
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:16633  .text.falcon_inner_keygen:00000000 $t
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:16640  .text.falcon_inner_keygen:00000000 falcon_inner_keygen
C:\Users\user\AppData\Local\Temp\ccAlabcF.s:17035  .text.falcon_inner_keygen:00000280 $d

UNDEFINED SYMBOLS
falcon_inner_fpr_scaled
falcon_inner_fpr_mul
memcpy
memset
falcon_inner_fpr_add
falcon_inner_i_shake256_extract
memmove
falcon_inner_FFT
falcon_inner_poly_invnorm2_fft
falcon_inner_poly_adj_fft
falcon_inner_poly_mul_fft
falcon_inner_poly_add
falcon_inner_poly_mul_autoadj_fft
falcon_inner_iFFT
falcon_inner_poly_add_muladj_fft
falcon_inner_poly_sub
falcon_inner_poly_div_autoadj_fft
falcon_inner_poly_mulconst
falcon_inner_compute_public
falcon_inner_max_fg_bits
falcon_inner_max_FG_bits
